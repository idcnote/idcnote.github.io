<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Java 5.0 多线程编程实践_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="Java5增加了新的类库并发集java.util.concurrent，该类库为并发程序提供了丰富的API多线程编程在Java 5中更加容易，灵活。本文通过一个网络服务器模型，来" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Java 5.0 多线程编程实践</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>Java5增加了新的类库并发集java.util.concurrent，该类库为并发程序提供了丰富的API多线程编程在Java 5中更加容易，灵活。本文通过一个网络服务器模型，来</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>Java5增加了新的类库并发集java.util.concurrent，该类库为并发程序提供了丰富的API多线程编程在Java 5中更加容易，灵活。本文通过一个网络服务器模型，来实践Java5的多线程编程，该模型中使用了Java5中的线程池，阻塞队列，可重入锁等，还实践了Callable， Future等接口，并使用了Java 5的另外一个新特性泛型。<br /><br /><strong>　　简介</strong><br /><br />　　本文将实现一个网络服务器模型，一旦有客户端连接到该服务器，则启动一个新线程为该连接服务，服务内容为往客户端输送一些字符信息。一个典型的网络服务器模型如下：<br /><br /><strong>　　1. 建立监听端口。</strong><br /><br />　　2. 发现有新连接，接受连接，启动线程，执行服务线程。 3. 服务完毕，关闭线程。<br /><br />　　这个模型在大部分情况下运行良好，但是需要频繁的处理用户请求而每次请求需要的服务又是简短的时候，系统会将大量的时间花费在线程的创建销毁。Java 5的线程池克服了这些缺点。通过对重用线程来执行多个任务，避免了频繁线程的创建与销毁开销，使得服务器的性能方面得到很大提高。因此，本文的网络服务器模型将如下：<br /><br />　　1. 建立监听端口，创建线程池。<br /><br />　　2. 发现有新连接，使用线程池来执行服务任务。<br /><br />　　3. 服务完毕，释放线程到线程池。<br /><br />　　下面详细介绍如何使用Java 5的concurrent包提供的API来实现该服务器。<br /><br />　　初始化<br /><br />　　初始化包括创建线程池以及初始化监听端口。创建线程池可以通过调用java.util.concurrent.Executors类里的静态方法newChahedThreadPool或是newFixedThreadPool来创建，也可以通过新建一个java.util.concurrent.ThreadPoolExecutor实例来执行任务。这里我们采用newFixedThreadPool方法来建立线程池。<br /><br />ExecutorService pool = Executors.newFixedThreadPool(10);<br /><br />　　表示新建了一个线程池，线程池里面有10个线程为任务队列服务。<br /><br />　　使用ServerSocket对象来初始化监听端口。<br /><br />private static final int PORT = 19527;<br />serverListenSocket = new ServerSocket(PORT);<br />serverListenSocket.setReuseAddress(true);<br />serverListenSocket.setReuseAddress(true);<br /><br />　　服务新连接<br /><br />　　当有新连接建立时，accept返回时，将服务任务提交给线程池执行。<br /><br />while(true){<br />　Socket socket = serverListenSocket.accept();<br />　pool.execute(new ServiceThread(socket));<br />}<br /><br />　　这里使用线程池对象来执行线程，减少了每次线程创建和销毁的开销。任务执行完毕，线程释放到线程池。<br /><br />　　服务任务<br /><br />　　服务线程ServiceThread维护一个count来记录服务线程被调用的次数。每当服务任务被调用一次时，count的值自增1，因此ServiceThread提供一个increaseCount和getCount的方法，分别将count值自增1和取得该count值。由于可能多个线程存在竞争，同时访问count，因此需要加锁机制，在Java 5之前，我们只能使用synchronized来锁定。Java 5中引入了性能更加粒度更细的重入锁ReentrantLock。我们使用ReentrantLock保证代码线程安全。下面是具体代码：<br /><br /><code><font face="新宋体">private static ReentrantLock lock = new ReentrantLock ();<br />private static int count = 0;<br />private int getCount(){<br />　int ret = 0;<br />　try{<br />　　lock.lock();<br />　　ret = count;<br />　}finally{<br />　　lock.unlock();<br />　}<br />　return ret;<br />}<br />private void increaseCount(){<br />　try{<br />　　lock.lock();<br />　　++count;<br />　}finally{<br />　　lock.unlock();<br />　}<br />}<br /><br />　　服务线程在开始给客户端打印一个欢迎信息，<br /><br />increaseCount();<br />int curCount = getCount();<br />helloString = &quot;hello, id = &quot; + curCount+&quot;\r\n&quot;;<br />dos = new DataOutputStream(connectedSocket.getOutputStream());<br />dos.write(helloString.getBytes());<br /><br />　　然后使用ExecutorService的submit方法提交一个Callable的任务，返回一个Future接口的引用。这种做法对费时的任务非常有效，submit任务之后可以继续执行下面的代码，然后在适当的位置可以使用Future的get方法来获取结果，如果这时候该方法已经执行完毕，则无需等待即可获得结果，如果还在执行，则等待到运行完毕。<br /><br />ExecutorService executor = Executors.newSingleThreadExecutor();<br />Future <string>future = executor.submit(new TimeConsumingTask());<br />dos.write(&quot;let&#39;s do soemthing other&quot;.getBytes());<br />String result = future.get();<br />dos.write(result.getBytes());<br /><br />　　其中TimeConsumingTask实现了Callable接口<br /><br />class TimeConsumingTask implements Callable <string>{<br />　public String call() throws Exception {<br />　　System.out.println(&quot;It&#39;s a time-consuming task, you&#39;d better retrieve your result in the furture&quot;);<br />　　return &quot;ok, here&#39;s the result: It takes me lots of time to produce this result&quot;;<br />　}<br />}<br /><br />　　这里使用了Java 5的另外一个新特性泛型，声明TimeConsumingTask的时候使用了String做为类型参数。必须实现Callable接口的call函数，其作用类似与Runnable中的run函数，在call函数里写入要执行的代码，其返回值类型等同于在类声明中传入的类型值。在这段程序中，我们提交了一个Callable的任务，然后程序不会堵塞，而是继续执行dos.write(&quot;let&#39;s do soemthing other&quot;.getBytes());当程序执行到String result = future.get()时如果call函数已经执行完毕，则取得返回值，如果还在执行，则等待其执行完毕。</string></string></font></code></p>
<p><code>服务器端的完整实现</code></p>
<p><code>　　服务器端的完整实现代码如下：</code></p>
<p><code>package com.andrew;</code></p>
<p><code>import java.io.DataOutputStream;<br />import java.io.IOException;<br />import java.io.Serializable;<br />import java.net.ServerSocket;<br />import java.net.Socket;<br />import java.util.concurrent.ArrayBlockingQueue;<br />import java.util.concurrent.BlockingQueue;<br />import java.util.concurrent.Callable;<br />import java.util.concurrent.ExecutionException;<br />import java.util.concurrent.ExecutorService;<br />import java.util.concurrent.Executors;<br />import java.util.concurrent.Future;<br />import java.util.concurrent.RejectedExecutionHandler;<br />import java.util.concurrent.ThreadPoolExecutor;<br />import java.util.concurrent.TimeUnit;<br />import java.util.concurrent.locks.ReentrantLock;</code></p>
<p><code>public class Server {<br />　private static int produceTaskSleepTime = 100;<br />　private static int consumeTaskSleepTime = 1200;<br />　private static int produceTaskMaxNumber = 100;<br />　private static final int CORE_POOL_SIZE = 2;<br />　private static final int MAX_POOL_SIZE = 100;<br />　private static final int KEEPALIVE_TIME = 3;<br />　private static final int QUEUE_CAPACITY = (CORE_POOL_SIZE + MAX_POOL_SIZE) / 2;<br />　private static final TimeUnit TIME_UNIT = TimeUnit.SECONDS;<br />　private static final String HOST = &quot;127.0.0.1&quot;;<br />　private static final int PORT = 19527;<br />　private BlockingQueueworkQueue = new ArrayBlockingQueue(QUEUE_CAPACITY);<br />　//private ThreadPoolExecutor serverThreadPool = null;<br />　private ExecutorService pool = null;<br />　private RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.DiscardOldestPolicy();<br />　private ServerSocket serverListenSocket = null;<br />　private int times = 5;<br />　public void start() {<br />　　// You can also init thread pool in this way.<br />　　/*serverThreadPool = new ThreadPoolExecutor(CORE_POOL_SIZE,<br />　　MAX_POOL_SIZE, KEEPALIVE_TIME, TIME_UNIT, workQueue,<br />　　rejectedExecutionHandler);*/<br />　　pool = Executors.newFixedThreadPool(10);<br />　　try {<br />　　　serverListenSocket = new ServerSocket(PORT);<br />　　　serverListenSocket.setReuseAddress(true);</code></p>
<p><code>　　　System.out.println(&quot;I&#39;m listening&quot;);<br />　　　while (times-- &gt;0) {<br />　　　　Socket socket = serverListenSocket.accept();<br />　　　　String welcomeString = &quot;hello&quot;;<br />　　　　//serverThreadPool.execute(new ServiceThread(socket, welcomeString));<br />　　　　pool.execute(new ServiceThread(socket));<br />　　　}<br />　　} catch (IOException e) {<br />　　　// TODO Auto-generated catch block<br />　　　e.printStackTrace();<br />　　}<br />　　cleanup();<br />　}</code></p>
<p><code>　public void cleanup() {<br />　　if (null != serverListenSocket) {<br />　　　try {<br />　　　　serverListenSocket.close();<br />　　　} catch (IOException e) {<br />　　　　// TODO Auto-generated catch block<br />　　　　e.printStackTrace();<br />　　　}<br />　　}<br />　　//serverThreadPool.shutdown();<br />　　pool.shutdown();<br />　}</code></p>
<p><code>　public static void main(String args[]) {<br />　　Server server = new Server();<br />　　server.start();<br />　}<br />}</code></p>
<p><code>class ServiceThread implements Runnable, Serializable {<br />　private static final long serialVersionUID = 0;<br />　private Socket connectedSocket = null;<br />　private String helloString = null;<br />　private static int count = 0;<br />　private static ReentrantLock lock = new ReentrantLock();</code></p>
<p><code>　ServiceThread(Socket socket) {<br />　　connectedSocket = socket;<br />　}</code></p>
<p><code>　public void run() {<br />　　increaseCount();<br />　　int curCount = getCount();<br />　　helloString = &quot;hello, id = &quot; + curCount + &quot;\r\n&quot;;</code></p>
<p><code>　　ExecutorService executor = Executors.newSingleThreadExecutor();<br />　　Futurefuture = executor.submit(new TimeConsumingTask());</code></p>
<p><code>　　DataOutputStream dos = null;<br />　　try {<br />　　　dos = new DataOutputStream(connectedSocket.getOutputStream());<br />　　　dos.write(helloString.getBytes());<br />　　　try {<br />　　　　dos.write(&quot;let&#39;s do soemthing other.\r\n&quot;.getBytes());<br />　　　　String result = future.get();<br />　　　　dos.write(result.getBytes());<br />　　　} catch (InterruptedException e) {<br />　　　　e.printStackTrace();<br />　　　} catch (ExecutionException e) {<br />　　　　e.printStackTrace();<br />　　　}<br />　　} catch (IOException e) {<br />　　　// TODO Auto-generated catch block<br />　　　e.printStackTrace();<br />　　} finally {<br />　　　if (null != connectedSocket) {<br />　　　　try {<br />　　　　　connectedSocket.close();<br />　　　　} catch (IOException e) {<br />　　　　　// TODO Auto-generated catch block<br />　　　　　e.printStackTrace();<br />　　　　}<br />　　　}<br />　　　if (null != dos) {<br />　　　　try {<br />　　　　　dos.close();<br />　　　　} catch (IOException e) {<br />　　　　　// TODO Auto-generated catch block<br />　　　　　e.printStackTrace();<br />　　　　}<br />　　　}<br />　　　executor.shutdown();<br />　　}<br />　}</code></p>
<p><code>　private int getCount() {<br />　　int ret = 0;<br />　　try {<br />　　　lock.lock();<br />　　　ret = count;<br />　　} finally {<br />　　　lock.unlock();<br />　　}<br />　　return ret;<br />　}</code></p>
<p><code>　private void increaseCount() {<br />　　try {<br />　　　lock.lock();<br />　　　++count;<br />　　} finally {<br />　　　lock.unlock();<br />　　}<br />　}<br />}</code></p>
<p><code>class TimeConsumingTask implements Callable{<br />　public String call() throws Exception {<br />　　System.out.println(&quot;It&#39;s a time-consuming task, you&#39;d better retrieve your result in the furture&quot;);<br />　　return &quot;ok, here&#39;s the result: It takes me lots of time to produce this result&quot;;<br />　}</code></p>
<p><code>} </code></p>
<p><code>　　运行程序</code></p>
<p><code>　　运行服务端，客户端只需使用telnet 127.0.0.1 19527 即可看到信息</code></p>
<div class="c" id="weste_pagead_4"><script type="text/javascript">BAIDU_CLB_fillSlot("160927");</script></div></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/111.html'>[红]PHP程序调用java类的两种方法</a><a>下一篇</a><a href='/java/biji/113.html'>用J2ME编写手机短消息发送程序</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>