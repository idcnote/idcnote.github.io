<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>java反射机制详细介绍_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="一、什么是JAVA的反射机制（推荐：java视频教程）Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的cla" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">java反射机制详细介绍</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>一、什么是JAVA的反射机制（推荐：java视频教程）Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的cla</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>一、什么是JAVA的反射机制（推荐：java视频教程）</p><p>Java反射是Java被视为动态（或准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括其modifiers（诸如public, static 等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。</p><p>Java反射机制容许程序在运行时加载、探知、使用编译期间完全未知的classes。</p><p>换言之，Java可以加载一个运行时才得知名称的class，获得其完整结构。</p><p>二、JDK中提供的Reflection API</p><p>Java反射相关的API在包java.lang.reflect中，JDK 1.6.0的reflect包如下图：</p><p><img src="/d/file/p/20221028/1574833145600729.jpg" title="1574833145600729.jpg" alt="1.jpg"/></p><table width="808"><tbody><tr class="firstRow"><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Member接口</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">该接口可以获取有关类成员（域或者方法）后者构造函数的信息。</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">AccessibleObject类 </td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">该类是域(field)对象、方法(method)对象、构造函数(constructor)对象的基础类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Array类</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">该类提供动态地生成和访问JAVA数组的方法。</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Constructor类</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">提供一个类的构造函数的信息以及访问类的构造函数的接口。   </td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Field类</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">提供一个类的域的信息以及访问类的域的接口。  </td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Method类</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">提供一个类的方法的信息以及访问类的方法的接口。</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Modifier类</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">提供了 static 方法和常量，对类和成员访问修饰符进行解码。</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="104">Proxy类 </td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="703">提供动态地生成代理类和类实例的静态方法。</td></tr></tbody></table><p>三、JAVA反射机制提供了什么功能</p><p>Java反射机制提供如下功能：</p><p>在运行时判断任意一个对象所属的类</p><p>在运行时构造任意一个类的对象</p><p>在运行时判段任意一个类所具有的成员变量和方法</p><p>在运行时调用任一个对象的方法</p><p>在运行时创建新类对象</p><p>在使用Java的反射功能时，基本首先都要获取类的Class对象，再通过Class对象获取其他的对象。</p><p>这里首先定义用于测试的类:</p><pre class="brush:js;toolbar:false">class Type{
    public int pubIntField;
    public String pubStringField;
    private int prvIntField;
     
    public Type(){
        Log(&quot;Default Constructor&quot;);
    }
     
    Type(int arg1, String arg2){
        pubIntField = arg1;
        pubStringField = arg2;
         
        Log(&quot;Constructor with parameters&quot;);
    }
     
    public void setIntField(int val) {
        this.prvIntField = val;
    }
    public int getIntField() {
        return prvIntField;
    }
     
    private void Log(String msg){
        System.out.println(&quot;Type:&quot; + msg);
    }
}
 
class ExtendType extends Type{
    public int pubIntExtendField;
    public String pubStringExtendField;
    private int prvIntExtendField;
     
    public ExtendType(){
        Log(&quot;Default Constructor&quot;);
    }   
     
    ExtendType(int arg1, String arg2){      
        pubIntExtendField = arg1;
        pubStringExtendField = arg2;
         
        Log(&quot;Constructor with parameters&quot;);
    }
     
    public void setIntExtendField(int field7) {
        this.prvIntExtendField = field7;
    }
    public int getIntExtendField() {
        return prvIntExtendField;
    }
     
    private void Log(String msg){
        System.out.println(&quot;ExtendType:&quot; + msg);
    }
}</pre><p> 1、获取类的Class对象</p><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。获取类的Class对象有多种方式：</p><p>调用getClass：</p><pre class="brush:js;toolbar:false">Boolean var1 = true;
Class&lt;?&gt; classType2 = var1.getClass();
System.out.println(classType2);</pre><blockquote><p>输出：class java.lang.Boolean</p></blockquote><p>运用.class 语法：</p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType4 = Boolean.class;
System.out.println(classType4);</pre><blockquote><p>输出：class java.lang.Boolean</p></blockquote><p>运用static method Class.forName()：</p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType5 = Class.forName(&quot;java.lang.Boolean&quot;);
System.out.println(classType5);</pre><blockquote><p>输出：class java.lang.Boolean</p></blockquote><p>运用primitive wrapper classes的TYPE 语法：</p><p>这里返回的是原生类型，和Boolean.class返回的不同</p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType3 = Boolean.TYPE;
System.out.println(classType3);</pre><blockquote><p>输出：boolean</p></blockquote><p>2、获取类的Fields</p><p>可以通过反射机制得到某个类的某个属性，然后改变对应于这个类的某个实例的该属性值。JAVA 的Class&lt;T&gt;类提供了几个方法获取类的属性。</p><table width="808"><tbody><tr class="firstRow"><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="251">public Field getField(String name)</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="556">返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段 </td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="251">public Field[] getFields()</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="556">返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="251">public Field getDeclaredField(String name)</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="556">返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段</td></tr><tr><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="251">public Field[] getDeclaredFields()</td><td valign="top" style="word-break: break-all; border-color: rgb(221, 221, 221);" width="556">返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段</td></tr></tbody></table><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType = ExtendType.class;
             
// 使用getFields获取属性
Field[] fields = classType.getFields();
for (Field f : fields)
{
    System.out.println(f);
}
 
System.out.println();
             
// 使用getDeclaredFields获取属性
fields = classType.getDeclaredFields();
for (Field f : fields)
{
    System.out.println(f);
}</pre><p>输出：</p><blockquote><p>public int com.quincy.ExtendType.pubIntExtendField</p><p>public java.lang.String com.quincy.ExtendType.pubStringExtendField</p><p>public int com.quincy.Type.pubIntField</p><p>public java.lang.String com.quincy.Type.pubStringField</p><p>public int com.quincy.ExtendType.pubIntExtendField</p><p>public java.lang.String com.quincy.ExtendType.pubStringExtendField</p><p>private int com.quincy.ExtendType.prvIntExtendField</p></blockquote><p>可见getFields和getDeclaredFields区别：</p><p>getFields返回的是申明为public的属性，包括父类中定义，</p><p>getDeclaredFields返回的是指定类定义的所有定义的属性，不包括父类的。</p><p>3、获取类的Method</p><p>通过反射机制得到某个类的某个方法，然后调用对应于这个类的某个实例的该方法</p><p>Class&lt;T&gt;类提供了几个方法获取类的方法。</p><pre class="brush:js;toolbar:false">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</pre><p>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法</p><pre class="brush:js;toolbar:false">public Method[] getMethods()</pre><p>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法 </p><pre class="brush:js;toolbar:false">public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</pre><p>返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法</p><pre class="brush:js;toolbar:false">public Method[] getDeclaredMethods()</pre><p>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</p><pre class="brush:js;toolbar:false">// 使用getMethods获取函数 
Class&lt;?&gt; classType = ExtendType.class;
Method[] methods = classType.getMethods();
for (Method m : methods)
{
    System.out.println(m);
}
 
System.out.println();
 
// 使用getDeclaredMethods获取函数 
methods = classType.getDeclaredMethods();
for (Method m : methods)
{
    System.out.println(m);
}</pre><p>输出：</p><blockquote><p>public void com.quincy.ExtendType.setIntExtendField(int)</p><p>public int com.quincy.ExtendType.getIntExtendField()</p><p>public void com.quincy.Type.setIntField(int)</p><p>public int com.quincy.Type.getIntField()</p><p>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</p><p>public final void java.lang.Object.wait() throws java.lang.InterruptedException</p><p>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</p><p>public boolean java.lang.Object.equals(java.lang.Object)</p><p>public java.lang.String java.lang.Object.toString()</p><p>public native int java.lang.Object.hashCode()</p><p>public final native java.lang.Class java.lang.Object.getClass()</p><p>public final native void java.lang.Object.notify()</p><p>public final native void java.lang.Object.notifyAll()</p><p>private void com.quincy.ExtendType.Log(java.lang.String)</p><p>public void com.quincy.ExtendType.setIntExtendField(int)</p><p>public int com.quincy.ExtendType.getIntExtendField()</p></blockquote><p>4、获取类的Constructor</p><p>通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例 </p><p>Class&lt;T&gt;类提供了几个方法获取类的构造器。</p><pre class="brush:js;toolbar:false">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</pre><p>返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法</p><pre class="brush:js;toolbar:false">public Constructor&lt;?&gt;[] getConstructors()</pre><p>返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法  </p><pre class="brush:js;toolbar:false">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</pre><p>返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法</p><pre class="brush:js;toolbar:false">public Constructor&lt;?&gt;[] getDeclaredConstructors()</pre><p>返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。它们是公共、保护、默认（包）访问和私有构造方法</p><pre class="brush:js;toolbar:false">// 使用getConstructors获取构造器  
Constructor&lt;?&gt;[] constructors = classType.getConstructors();
for (Constructor&lt;?&gt; m : constructors)
{
    System.out.println(m);
}
             
System.out.println();
             
// 使用getDeclaredConstructors获取构造器   
constructors = classType.getDeclaredConstructors();
for (Constructor&lt;?&gt; m : constructors)
{
    System.out.println(m);
}
 
输出：
public com.quincy.ExtendType()
 
public com.quincy.ExtendType()
com.quincy.ExtendType(int,java.lang.String)</pre><p>5、新建类的实例</p><p>通过反射机制创建新类的实例，有几种方法可以创建</p><p>调用无自变量ctor：</p><p>1、调用类的Class对象的newInstance方法，该方法会调用对象的默认构造器，如果没有默认构造器，会调用失败.</p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType = ExtendType.class;
Object inst = classType.newInstance();
System.out.println(inst);</pre><p>输出：</p><blockquote><p>Type:Default Constructor</p><p>ExtendType:Default Constructor</p><p>com.quincy.ExtendType@d80be3</p></blockquote><p>2、调用默认Constructor对象的newInstance方法<br/></p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType = ExtendType.class;
Constructor&lt;?&gt; constructor1 = classType.getConstructor();
Object inst = constructor1.newInstance();
System.out.println(inst);</pre><p>输出：</p><blockquote><p>Type:Default Constructor</p><p>ExtendType:Default Constructor</p><p>com.quincy.ExtendType@1006d75</p></blockquote><p>调用带参数ctor：</p><p>3、调用带参数Constructor对象的newInstance方法</p><pre class="brush:js;toolbar:false">Constructor&lt;?&gt; constructor2 =
classType.getDeclaredConstructor(int.class, String.class);
Object inst = constructor2.newInstance(1, &quot;123&quot;);
System.out.println(inst);</pre><p>输出：</p><blockquote><p>Type:Default Constructor</p><p>ExtendType:Constructor with parameters</p><p>com.quincy.ExtendType@15e83f9</p></blockquote><p>6、调用类的函数<br/></p><p>通过反射获取类Method对象，调用Field的Invoke方法调用函数。</p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType = ExtendType.class;
Object inst = classType.newInstance();
Method logMethod = classType.&lt;strong&gt;getDeclaredMethod&lt;/strong&gt;(&quot;Log&quot;, String.class);
logMethod.invoke(inst, &quot;test&quot;);
 
输出：
Type:Default Constructor
ExtendType:Default Constructor
&lt;font color=&quot;#ff0000&quot;&gt;Class com.quincy.ClassT can not access a member of class com.quincy.ExtendType with modifiers &quot;private&quot;&lt;/font&gt;
 
&lt;font color=&quot;#ff0000&quot;&gt;上面失败是由于没有权限调用private函数，这里需要设置Accessible为true;&lt;/font&gt;
Class&lt;?&gt; classType = ExtendType.class;
Object inst = classType.newInstance();
Method logMethod = classType.getDeclaredMethod(&quot;Log&quot;, String.class);
&lt;font color=&quot;#ff0000&quot;&gt;logMethod.setAccessible(true);&lt;/font&gt;
logMethod.invoke(inst, &quot;test&quot;);</pre><p>7、设置/获取类的属性值</p><p>通过反射获取类的Field对象，调用Field方法设置或获取值</p><pre class="brush:js;toolbar:false">Class&lt;?&gt; classType = ExtendType.class;
Object inst = classType.newInstance();
Field intField = classType.getField(&quot;pubIntExtendField&quot;);
intField.&lt;strong&gt;setInt&lt;/strong&gt;(inst, 100);
    int value = intField.&lt;strong&gt;getInt&lt;/strong&gt;(inst);</pre><p>四、动态创建代理类</p><p>代理模式：代理模式的作用=为其他对象提供一种代理以控制对这个对象的访问。</p><p>代理模式的角色：</p><p>抽象角色：声明真实对象和代理对象的共同接口</p><p>代理角色：代理角色内部包含有真实对象的引用，从而可以操作真实对象。</p><p>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p><p>动态代理：</p><p>java.lang.reflect.Proxy：    </p><p>Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类</p><p>InvocationHandler：    </p><p>是代理实例的调用处理程序 实现的接口，每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。</p><p>动态Proxy是这样的一种类:</p><p>它是在运行生成的类，在生成时你必须提供一组Interface给它，然后该class就宣称它实现了这些interface。你可以把该class的实例当作这些interface中的任何一个来用。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p><p>在使用动态代理类时，我们必须实现InvocationHandler接口</p><p>步骤：</p><p>1、定义抽象角色</p><pre class="brush:js;toolbar:false">public interface Subject {
public void Request();
}</pre><p>2、定义真实角色</p><pre class="brush:js;toolbar:false">public class RealSubject implements Subject {
@Override
public void Request() {
// TODO Auto-generated method stub
System.out.println(&quot;RealSubject&quot;);
}
}</pre><p>3、定义代理角色</p><pre class="brush:js;toolbar:false">public class DynamicSubject implements InvocationHandler {
private Object sub;
public DynamicSubject(Object obj){
this.sub = obj;
}
@Override
public Object invoke(Object proxy, Method method, Object[] args)
throws Throwable {
// TODO Auto-generated method stub
System.out.println(&quot;Method:&quot;+ method + &quot;,Args:&quot; + args);
method.invoke(sub, args);
return null;
}
}</pre><p>4、通过Proxy.newProxyInstance构建代理对象</p><pre class="brush:js;toolbar:false">RealSubject realSub = new RealSubject();
InvocationHandler handler = new DynamicSubject(realSub);
Class&lt;?&gt; classType = handler.getClass();
Subject sub = (Subject)Proxy.newProxyInstance(classType.getClassLoader(),
realSub.getClass().getInterfaces(), handler);
System.out.println(sub.getClass());</pre><p>5、通过调用代理对象的方法去调用真实角色的方法。</p><pre class="brush:js;toolbar:false">sub.Request();</pre><p>输出：</p><p>class $Proxy0 新建的代理对象，它实现指定的接口</p><pre class="brush:js;toolbar:false">Method:public abstract void DynamicProxy.Subject.Request(),Args:null</pre><p>RealSubject 调用的真实对象的方法</p><p>更多java知识请关注java基础教程栏目。</p>
                                                                                                        
                                                </div>
                                                <!-- .entry-wrapper --></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/636.html'>java学习之switch语句与循环语句</a><a>下一篇</a><a href='/java/biji/638.html'>java中如何判断map集合中是否存在key</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>