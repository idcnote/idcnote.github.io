<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Java各个集合（Collection）的特性和用途_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="这篇文章总结了所有的Java集合（Collection）。主要介绍各个集合的特性和用途，以及在不同的集合类型之间转换的方式。" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Java各个集合（Collection）的特性和用途</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章总结了所有的Java集合（Collection）。主要介绍各个集合的特性和用途，以及在不同的集合类型之间转换的方式。</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章总结了所有的Java集合（Collection）。主要介绍各个集合的特性和用途，以及在不同的集合类型之间转换的方式。</p>
<h2>Arrays</h2>
<p>Array是Java特有的数组。在你知道所要处理数据元素个数的情况下非常好用。java.util.Arrays 包含了许多处理数据的实用方法：</p>
<ul>
	<li>Arrays.asList：可以从 Array 转换成 List。可以作为其他集合类型构造器的参数。</li>
	<li>Arrays.binarySearch：在一个已排序的或者其中一段中快速查找。</li>
	<li>Arrays.copyOf：如果你想扩大数组容量又不想改变它的内容的时候可以使用这个方法。</li>
	<li>Arrays.copyOfRange：可以复制整个数组或其中的一部分。</li>
	<li>Arrays.deepEquals、Arrays.deepHashCode：Arrays.equals/hashCode的高级版本，支持子数组的操作。</li>
	<li>Arrays.equals：如果你想要比较两个数组是否相等，应该调用这个方法而不是数组对象中的 equals方法（数组对象中没有重写equals()方法，所以这个方法之比较引用而不比较内容）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 equals() 方法&mdash;&mdash;所以这个方法在比较了对象的类型之后是直接传值进去比较的。</li>
	<li>Arrays.fill：用一个给定的值填充整个数组或其中的一部分。</li>
	<li>Arrays.hashCode：用来根据数组的内容计算其哈希值（数组对象的hashCode()不可用）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 Arrays.hashcode方法&mdash;&mdash;只是传值进去，不是对象。</li>
	<li>Arrays.sort：对整个数组或者数组的一部分进行排序。也可以使用此方法用给定的比较器对对象数组进行排序。</li>
	<li>Arrays.toString：打印数组的内容。</li>
</ul>
<p>如果想要复制整个数组或其中一部分到另一个数组，可以调用 System.arraycopy方法。此方法从源数组中指定的位置复制指定个数的元素到目标数组里。这无疑是一个简便的方法。</p>
<p>最后，所有的集合都可以用T[] Collection.toArray( T[] a ) 这个方法复制到数组中。通常会用这样的方式调用：</p>
<pre>
return coll.toArray( new T[ coll.size() ] );
</pre>
<p>这个方法会分配足够大的数组来储存所有的集合，这样 toArray 在返回值时就不必再分配空间了。</p>
<h2>单线程集合</h2>
<p>这一部分介绍的是不支持多线程的集合。这些集合都在java.util包里。其中一些在Java 1.o的时候就有了（现在已经弃用），其中大多数在Java 1.4中重新发布。枚举集合在Java 1.5中重新发布，并且从这个版本之后所有的集合都支持泛型。PriorityQueue也在Java 1.5中加入。非线程安全的集合架构的最后一个版本是ArrayDeque ，也在Java 1.6中重新发布了。</p>
<h3>List</h3>
<ul>
	<li>ArrayList：最有用的List集合实现。由一个整形数字或数组存储了集合的大小（数组中第一个没有使用的元素）。像所有的List集合一样，ArrayList可以在必要的时候扩展它的大小。ArrayList访问元素的时间开销固定。在尾部添加元素成本低（为常数复杂度），而在头部添加元素成本很高（线性复杂度）。这是由ArrayList的实现原理&mdash;&mdash;所有的元素的从角标为0开始一个接着一个排列造成的。也就是说，从要插入的元素位置往后，每个元素都要向后移动一个位置。CPU缓存友好的集合是基于数组的。（其实也不是很友好，因为有时数组会包含对象，这样存储的只是指向实际对象的指针）。</li>
	<li>LinkedList：Deque实现：每一个节点都保存着上一个节点和下一个节点的指针。这就意味着数据的存取和更新具有线性复杂度（这也是一个最佳化的实现，每次操作都不会遍历数组一半以上，操作成本最高的元素就是数组中间的那个）。如果想写出高效的LinkedList代码可以使用 ListIterators 。如果你想用一个Queue/Deque实现的话（你只需读取第一个和最后一个元素就行了）&mdash;&mdash;考虑用ArrayDeque代替。</li>
	<li>Vector：一个带有线程同步方法的ArrayList版本。现在直接用ArrayList代替了。</li>
</ul>
<h3>Queues/deques</h3>
<ul>
	<li>ArrayDeque：Deque是基于有首尾指针的数组（环形缓冲区）实现的。和LinkedList不同，这个类没有实现List接口。因此，如果没有首尾元素的话就不能取出任何元素。这个类比LinkedList要好一些，因为它产生的垃圾数量较少（在扩展的时候旧的数组会被丢弃）。</li>
	<li>Stack：一种后进先出的队列。不要在生产代码中使用，使用别的Deque来代替（ArrayDeque比较好）。</li>
	<li>PriorityQueue：一个基于优先级的队列。使用自然顺序或者制定的比较器来排序。他的主要属性&mdash;&mdash;poll/peek/remove/element会返回一个队列的最小值。不仅如此，PriorityQueue还实现了Iterable接口，队列迭代时不进行排序（或者其他顺序）。在需要排序的集合中，使用这个队列会比TreeSet等其他队列要方便。</li>
</ul>
<h3>Maps</h3>
<ul>
	<li>HashMap：最常用的Map实现。只是将一个键和值相对应，并没有其他的功能。对于复杂的hashCode method，get/put方法有固定的复杂度。</li>
	<li>EnumMap：枚举类型作为键值的Map。因为键的数量相对固定，所以在内部用一个数组储存对应值。通常来说，效率要高于HashMap。</li>
	<li>HashTable：旧HashMap的同步版本，新的代码中也使用了HashMap。</li>
	<li>IdentityHashMap：这是一个特殊的Map版本，它违背了一般Map的规则：它使用 &ldquo;==&rdquo; 来比较引用而不是调用Object.equals来判断相等。这个特性使得此集合在遍历图表的算法中非常实用&mdash;&mdash;可以方便地在IdentityHashMap中存储处理过的节点以及相关的数据。</li>
	<li>LinkedHashMap ：HashMap和LinkedList的结合，所有元素的插入顺序存储在LinkedList中。这就是为什么迭代LinkedHashMap的条目（entry）、键和值的时候总是遵循插入的顺序。在JDK中，这是每元素消耗内存最大的集合。</li>
	<li>TreeMap：一种基于已排序且带导向信息Map的红黑树。每次插入都会按照自然顺序或者给定的比较器排序。这个Map需要实现equals方法和Comparable/Comparator。compareTo需要前后一致。这个类实现了一个NavigableMap接口：可以带有与键数量不同的入口，可以得到键的上一个或者下一个入口，可以得到另一Map某一范围的键（大致和SQL的BETWEEN运算符相同），以及其他的一些方法。</li>
	<li>WeakHashMap：这种Map通常用在数据缓存中。它将键存储在WeakReference中，就是说，如果没有强引用指向键对象的话，这些键就可以被垃圾回收线程回收。值被保存在强引用中。因此，你要确保没有引用从值指向键或者将值也保存在弱引用中m.put(key, new WeakReference(value))。</li>
</ul>
<h3>Sets</h3>
<ul>
	<li>HashSet：一个基于HashMap的Set实现。其中，所有的值为&ldquo;假值&rdquo;（同一个Object对象具备和HashMap同样的性能。基于这个特性，这个数据结构会消耗更多不必要的内存。</li>
	<li>EnumSet：值为枚举类型的Set。Java的每一个enum都映射成一个不同的int。这就允许使用BitSet&mdash;&mdash;一个类似的集合结构，其中每一比特都映射成不同的enum。EnumSet有两种实现，RegularEnumSet&mdash;&mdash;由一个单独的long存储（能够存储64个枚举值，99.9%的情况下是够用的），JumboEnumSet&mdash;&mdash;由long[]存储。</li>
	<li>BitSet：一个比特Set。需要时常考虑用BitSet处理一组密集的整数Set（比如从一个预先知道的数字开始的id集合）。这个类用 long[]来存储bit。</li>
	<li>LinkedHashMap：与HashSet一样，这个类基于LinkedHashMap实现。这是唯一一个保持了插入顺序的Set。</li>
	<li>TreeSet：与HashSet类似。这个类是基于一个TreeMap实例的。这是在单线程部分唯一一个排序的Set。</li>
</ul>
<h2>java.util.Collections</h2>
<p>就像有专门的java.util.Arrays来处理数组，Java中对集合也有java.util.Collections来处理。</p>
<p>第一组方法主要返回集合的各种数据：</p>
<ul>
	<li>Collections.checkedCollection / checkedList / checkedMap / checkedSet / checkedSortedMap / checkedSortedSet：检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个ClassCastException异常。这个功能可以防止在运行的时候出错。//fixme</li>
	<li>Collections.emptyList / emptyMap / emptySet ：返回一个固定的空集合，不能添加任何元素。</li>
	<li>Collections.singleton / singletonList / singletonMap：返回一个只有一个入口的 set/list/map 集合。</li>
	<li>Collections.synchronizedCollection / synchronizedList / synchronizedMap / synchronizedSet / synchronizedSortedMap / synchronizedSortedSet：获得集合的线程安全版本（多线程操作时开销低但不高效，而且不支持类似put或update这样的复合操作）</li>
	<li>Collections.unmodifiableCollection / unmodifiableList / unmodifiableMap / unmodifiableSet / unmodifiableSortedMap / unmodifiableSortedSet：返回一个不可变的集合。当一个不可变对象中包含集合的时候，可以使用此方法。</li>
</ul>
<p>第二组方法中，其中有一些方法因为某些原因没有加入到集合中：</p>
<ul>
	<li>Collections.addAll：添加一些元素或者一个数组的内容到集合中。</li>
	<li>Collections.binarySearch：和数组的Arrays.binarySearch功能相同。</li>
	<li>Collections.disjoint：检查两个集合是不是没有相同的元素。</li>
	<li>Collections.fill：用一个指定的值代替集合中的所有元素。</li>
	<li>Collections.frequency：集合中有多少元素是和给定元素相同的。</li>
	<li>Collections.indexOfSubList / lastIndexOfSubList：和String.indexOf(String) / lastIndexOf(String)方法类似&mdash;&mdash;找出给定的List中第一个出现或者最后一个出现的子表。</li>
	<li>Collections.max / min：找出基于自然顺序或者比较器排序的集合中，最大的或者最小的元素。</li>
	<li>Collections.replaceAll：将集合中的某一元素替换成另一个元素。</li>
	<li>Collections.reverse：颠倒排列元素在集合中的顺序。如果你要在排序之后使用这个方法的话，在列表排序时，最好使用Collections.reverseOrder比较器。</li>
	<li>Collections.rotate：根据给定的距离旋转元素。</li>
	<li>Collections.shuffle：随机排放List集合中的节点，可以给定你自己的生成器&mdash;&mdash;例如 java.util.Random / java.util.ThreadLocalRandom or java.security.SecureRandom。</li>
	<li>Collections.sort：将集合按照自然顺序或者给定的顺序排序。</li>
	<li>Collections.swap：交换集合中两个元素的位置（多数开发者都是自己实现这个操作的）。</li>
</ul>
<h2>并发集合</h2>
<p>这一部分将介绍java.util.concurrent包中线程安全的集合。这些集合的主要属性是一个不可分割的必须执行的方法。因为并发的操作，例如add或update或者check再update，都有一次以上的调用，必须同步。因为第一步从集合中组合操作查询到的信息在开始第二步操作时可能变为无效数据。</p>
<p>多数的并发集合是在Java 1.5引入的。ConcurrentSkipListMap / ConcurrentSkipListSet 和 LinkedBlockingDeque是在Java 1.6新加入的。Java 1.7加入了最后的 ConcurrentLinkedDeque 和 LinkedTransferQueue</p>
<h3>Lists</h3>
<ul>
	<li>CopyOnWriteArrayList：list的实现每一次更新都会产生一个新的隐含数组副本，所以这个操作成本很高。通常用在遍历操作比更新操作多的集合，比如listeners/observers集合。</li>
</ul>
<h3>Queues/deques</h3>
<ul>
	<li>ArrayBlockingQueue：基于数组实现的一个有界阻塞队，大小不能重新定义。所以当你试图向一个满的队列添加元素的时候，就会受到阻塞，直到另一个方法从队列中取出元素。</li>
	<li>ConcurrentLinkedDeque / ConcurrentLinkedQueue：基于链表实现的无界队列，添加元素不会堵塞。但是这就要求这个集合的消费者工作速度至少要和生产这一样快，不然内存就会耗尽。严重依赖于CAS(compare-and-set)操作。</li>
	<li>DelayQueue：无界的保存Delayed元素的集合。元素只有在延时已经过期的时候才能被取出。队列的第一个元素延期最小（包含负值&mdash;&mdash;延时已经过期）。当你要实现一个延期任务的队列的时候使用（不要自己手动实现&mdash;&mdash;使用ScheduledThreadPoolExecutor）。</li>
	<li>LinkedBlockingDeque / LinkedBlockingQueue：可选择有界或者无界基于链表的实现。在队列为空或者满的情况下使用ReentrantLock-s。</li>
	<li>LinkedTransferQueue：基于链表的无界队列。除了通常的队列操作，它还有一系列的transfer方法，可以让生产者直接给等待的消费者传递信息，这样就不用将元素存储到队列中了。这是一个基于CAS操作的无锁集合。</li>
	<li>PriorityBlockingQueue：PriorityQueue的无界的版本。</li>
	<li>SynchronousQueue：一个有界队列，其中没有任何内存容量。这就意味着任何插入操作必须等到响应的取出操作才能执行，反之亦反。如果不需要Queue接口的话，通过Exchanger类也能完成响应的功能。</li>
</ul>
<h3>Maps</h3>
<ul>
	<li>ConcurrentHashMap：get操作全并发访问，put操作可配置并发操作的哈希表。并发的级别可以通过构造函数中concurrencyLevel参数设置（默认级别16）。该参数会在Map内部划分一些分区。在put操作的时候只有只有更新的分区是锁住的。这种Map不是代替HashMap的线程安全版本&mdash;&mdash;任何 get-then-put的操作都需要在外部进行同步。</li>
	<li>ConcurrentSkipListMap：基于跳跃列表（Skip List）的ConcurrentNavigableMap实现。本质上这种集合可以当做一种TreeMap的线程安全版本来使用。</li>
</ul>
<h3>Sets</h3>
<ul>
	<li>ConcurrentSkipListSet：使用 ConcurrentSkipListMap来存储的线程安全的Set。</li>
	<li>CopyOnWriteArraySet：使用CopyOnWriteArrayList来存储的线程安全的Set。</li>
</ul>
<h2>总结</h2>
<table border="1" width="600">
	<tbody>
		<tr>
			<td>&nbsp;</td>
			<td>单线程</td>
			<td>并发</td>
		</tr>
		<tr>
			<td>Lists</td>
			<td>
			<ul>
				<li>ArrayList&mdash;&mdash;基于泛型数组</li>
				<li>LinkedList&mdash;&mdash;不推荐使用</li>
				<li>Vector&mdash;&mdash;已废弃（deprecated）</li>
			</ul></td>
			<td>
			<ul>
				<li>CopyOnWriteArrayList&mdash;&mdash;几乎不更新，常用来遍历</li>
			</ul></td>
		</tr>
		<tr>
			<td>Queues / deques</td>
			<td>
			<ul>
				<li>ArrayDeque&mdash;&mdash;基于泛型数组</li>
				<li>Stack&mdash;&mdash;已废弃（deprecated）</li>
				<li>PriorityQueue&mdash;&mdash;读取操作的内容已排序</li>
			</ul></td>
			<td>
			<ul>
				<li>ArrayBlockingQueue&mdash;&mdash;带边界的阻塞式队列</li>
				<li>ConcurrentLinkedDeque / ConcurrentLinkedQueue&mdash;&mdash;无边界的链表队列（CAS）</li>
				<li>DelayQueue&mdash;&mdash;元素带有延迟的队列</li>
				<li>LinkedBlockingDeque / LinkedBlockingQueue&mdash;&mdash;链表队列（带锁），可设定是否带边界</li>
				<li>LinkedTransferQueue&mdash;&mdash;可将元素`transfer`进行w/o存储</li>
				<li>PriorityBlockingQueue&mdash;&mdash;并发PriorityQueue</li>
				<li>SynchronousQueue&mdash;&mdash;使用Queue接口进行Exchanger</li>
			</ul></td>
		</tr>
		<tr>
			<td>Maps</td>
			<td>
			<ul>
				<li>HashMap&mdash;&mdash;通用Map</li>
				<li>EnumMap&mdash;&mdash;键使用enum</li>
				<li>Hashtable&mdash;&mdash;已废弃（deprecated）</li>
				<li>IdentityHashMap&mdash;&mdash;键使用==进行比较</li>
				<li>LinkedHashMap&mdash;&mdash;保持插入顺序</li>
				<li>TreeMap&mdash;&mdash;键已排序</li>
				<li>WeakHashMap&mdash;&mdash;适用于缓存（cache）</li>
			</ul></td>
			<td>
			<ul>
				<li>ConcurrentHashMap&mdash;&mdash;通用并发Map</li>
				<li>ConcurrentSkipListMap&mdash;&mdash;已排序的并发Map</li>
			</ul></td>
		</tr>
		<tr>
			<td>Sets</td>
			<td>
			<ul>
				<li>HashSet&mdash;&mdash;通用set</li>
				<li>EnumSet&mdash;&mdash;enum Set</li>
				<li>BitSet&mdash;&mdash;比特或密集的整数Set</li>
				<li>LinkedHashSet&mdash;&mdash;保持插入顺序</li>
				<li>TreeSet&mdash;&mdash;排序Set</li>
			</ul></td>
			<td>
			<ul>
				<li>ConcurrentSkipListSet&mdash;&mdash;排序并发Set</li>
				<li>CopyOnWriteArraySet&mdash;&mdash;几乎不更新，通常只做遍历</li>
			</ul></td>
		</tr>
	</tbody>
</table></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/55.html'>Android APP实现清除本地缓存数据的代码</a><a>下一篇</a><a href='/java/biji/57.html'>50道Java多线程面试题</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>