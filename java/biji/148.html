<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Hibernate的原理与配置快速入门_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="也许你听说过Hibernate的大名，但可能一直不了解它，也许你一直渴望使用它进行开发，那么本文正是你所需要的！在本文中，我向大家重点介绍Hibernate的核心API调用库，并" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Hibernate的原理与配置快速入门</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>也许你听说过Hibernate的大名，但可能一直不了解它，也许你一直渴望使用它进行开发，那么本文正是你所需要的！在本文中，我向大家重点介绍Hibernate的核心API调用库，并</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>　　也许你听说过Hibernate的大名，但可能一直不了解它，也许你一直渴望使用它进行开发，那么本文正是你所需要的！在本文中，我向大家重点介绍Hibernate的核心API调用库，并讲解一下它的基本配置。<br /><br />　　看完本文后，我相信你对什么是ORM（对像/关系映射）以及它的优点会有一个深刻的认识，我们先通过一个简单的例子开始来展现它的威力。<br /><br />　　正如一些传统的经典计算机文章大都会通过一个&ldquo;hello,world&rdquo;的例子开始讲解一样，我们也不例外，我们也将从一个相对简单的例子来阐述Hibernate的开发方法，但如果要真正阐述Hibernate的一些重要思想，仅仅靠在屏幕上打印一些字符是远远不够的，在我们的示例程序中，我们将创建一些对象，并将其保存在数据库中，然后对它们进行更新和查询。</p>
<p>&nbsp;</p>
<table align="center" border="1" bordercolor="#ffcc00" cellspacing="4" width="90%">
	<tbody>
		<tr>
			<td width="35%"><font color="#0000ff">&ldquo;Hello World&rdquo;</font></td>
			<td width="65%">&ldquo;Hello world&rdquo;示例程序让您对Hibernate有一个简单的认识<strong>。</strong></td>
		</tr>
		<tr>
			<td><font color="#0000ff">理解Hibernate的架构</font></td>
			<td>介绍Hibernate接口的主要功能。</td>
		</tr>
		<tr>
			<td><font color="#0000ff">核心接口</font></td>
			<td>Hibernate有5个核心接口，通过这几个接口开发人员可以存储和获得持久对象，并且能够进行事务控制</td>
		</tr>
		<tr>
			<td><font color="#0000ff">一个重要的术语：Type</font></td>
			<td>Type是Hibernate发明者发明的一个术语，它在整个构架中是一个非常基础、有着强大功能的元素，一个Type对象能将一个Java类型映射到数据库中一个表的字段中去。</td>
		</tr>
		<tr>
			<td><font color="#0000ff">策略接口</font></td>
			<td>Hibernate与某些其它开源软件不同的还有一点――高度的可扩展性，这通过它的内置策略机制来实现。</td>
		</tr>
		<tr>
			<td><font color="#0000ff">基础配置</font></td>
			<td>Hibernate可以配置成可在任何Java环境中运行，一般说来，它通常被用在2－3层的C/S模式的项目中，并被部署在服务端。</td>
		</tr>
		<tr>
			<td height="36"><font color="#0000ff">创建一个SessionFactory对象</font></td>
			<td>要创建一个SessionFactory对象，必须在Hibernate初始化时创建一个Configuration类的实例，并将已写好的映射文件交由它处理。</td>
		</tr>
	</tbody>
</table>
<p><span class="f14">　　<strong>&ldquo;Hello World&rdquo;</strong><br /><br />　　Hibernate应用程序定义了一些持久类，并且定义了这些类与数据库表格的映射关系。在我们这个&ldquo;Hello world&rdquo;示例程序中包含了一个类和一个映射文件。让我们看看这个简单的持久类包含有一些什么？映射文件是怎样定义的？另外，我们该怎样用Hibernate来操作这个持久类。<br /><br />　　我们这个简单示例程序的目的是将一些持久类存储在数据库中，然后从数据库取出来，并将其信息正文显示给用户。其中Message正是一个简单的持久类：，它包含我们要显示的信息，其源代码如下：<br /><br />　　列表1　Message.Java　一个简单的持久类</span></p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>package hello;<br />public class Message {<br />　private Long id;<br />　private String text;<br />　private Message nextMessage;<br />　private Message() {}<br />　public Message(String text) {<br />　　this.text = text;<br />　}<br />　public Long getId() {<br />　　return id;<br />　}<br />　private void setId(Long id) {<br />　　this.id = id;<br />　}<br />　public String getText() {<br />　　return text;<br />　}<br />　public void setText(String text) {<br />　　this.text = text;<br />　}<br />　public Message getNextMessage() {<br />　　return nextMessage;<br />　}<br />　public void setNextMessage(Message nextMessage) {<br />　　this.nextMessage = nextMessage;<br />　}<br />}</td>
		</tr>
	</tbody>
</table>
<p><br />　　Message类有三个属性：Message的id 、消息正文、以及一个指向下一条消息的指针。其中id属性让我们的应用程序能够唯一的识别这条消息，通常它等同于数据库中的主键，如果多个Message类的实例对象拥有相同的id，那它们代表数据库某个表的同一个记录。在这里我们选择了长整型作为我们的id值，但这不是必需的。Hibernate允许我们使用任意的类型来作为对象的id值，在后面我们会对此作详细描述。<br /><br />　　你可能注意到Message类的代码类似于JavaBean的代码风格，并且它有一个没有参数的构造函数，在我们以后的代码中我将继续使用这种风格来编写持久类的代码。<br /><br />　　Hibernate会自动管理Message类的实例，并通过内部机制使其持久化，但实际上Message对象并没有实现任何关于Hibernate的类或接口，因此我们也可以将它作为一个普通的Java类来使用：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>Message message = new Message(&quot;Hello World&quot;);<br />System.out.println( message.getText() );</td>
		</tr>
	</tbody>
</table>
<p><br />　　以上这段代码正是我们所期望的结果：它打印&ldquo;hello world&rdquo;到屏幕上。但这并不是我们的最终目标；实际上Hibernate与诸如EJB容器这样的环境在持久层实现的方式上有很大的不同。我们的持久类(Message类)可以用在与容器无关的环境中，不像EJB必须要有EJB容器才能执行。为了能更清楚地表现这点，以下代码将我们的一个新消息保存到数据库中去：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>Session session = getSessionFactory().openSession();<br />Transaction tx = session.beginTransaction();<br />Message message = new Message(&quot;Hello World&quot;);<br />session.save(message);<br />tx.commit();<br />session.close();</td>
		</tr>
	</tbody>
</table>
<p><br />　　以上这段代码调用了Hibernate的Session和Transaction接口（关于getSessionFactory()方法我们将会马上提到）。它相当于我们执行了以下SQL语句：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>insert into MESSAGES (MESSAGE_ID, MESSAGE_TEXT, NEXT_MESSAGE_ID)<br />values (1, &#39;Hello World&#39;, null)</td>
		</tr>
	</tbody>
</table>
<p><br />　　在以上的SQL语句中，MESSAGE_ID字段到底被初始化成了什么值呢？由于我们并没有在先前的代码中为message对象的id属性赋与初始值，那它是否为null呢？实际上Hibernate对id属性作了特殊处理：由于它是一个对象的唯一标识，因此当我们进行save()调用时，Hibernate会为它自动赋予一个唯一的值（我们将在后面内容中讲述它是如何生成这个值的）。<br /><br />　　我们假设你已经在数据库中创建了一个名为MESSAGE的表，那么既然前面这段代码让我们将Message对象存入了数据库中，那么现在我们就要将它们一一取出来。下面这段代码将按照字母顺序，将数据库中的所有Message对象取出来，并将它们的消息正文打印到屏幕上：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>Session newSession = getSessionFactory().openSession();<br />Transaction newTransaction = newSession.beginTransaction();<br />List messages =newSession.find(&quot;from Message as m order by m.text asc&quot;);<br />System.out.println( messages.size() + &quot; message(s) found:&quot; );<br />for ( Iterator iter = messages.iterator(); iter.hasNext(); ) {<br />　Message message = (Message) iter.next();<br />　System.out.println( message.getText() );<br />}<br />newTransaction.commit();<br />newSession.close();</td>
		</tr>
	</tbody>
</table>
<p><br />　　在以上这段代码中，你可能被find()方法的这个参数困扰着：&quot;from Message as m order by m.text asc&quot;，其实它是Hibernate自己定义的查询语言，全称叫Hibernate Query Language(HQL)。通俗地讲HQL与SQL的关系差不多就是方言与普通话之间的关系，咋一看，你会觉得它有点类似于SQL语句。其实在find()调用时，Hibernate会将这段HQL语言翻译成如下的SQL语句：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>select m.MESSAGE_ID, m.MESSAGE_TEXT, m.NEXT_MESSAGE_ID<br />from MESSAGES m<br />order by m.MESSAGE_TEXT asc</td>
		</tr>
	</tbody>
</table>
<p><br />　　以下就是运行结果：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>1 message(s) found:<br />Hello World</td>
		</tr>
	</tbody>
</table>
<p><br />　　如果你以前没有ORM（对象－关系映射）的开发经验，那你可能想在代码的某个地方去寻找这段SQL语句，但在Hibernate中你可能会失望：它根本不存在！所有就SQL语句都是Hibernate动态生成的。<br /><br />　　也许你会觉得还缺点什么，对！仅凭以上代码Hibernate是无法将我们的Message类持久化的。我们还需要一些更多的信息，这就是映射定义表！这个表在Hibernate中是以XML格式来体现的，它定义了Message类的属性是怎样与数据库中的MESSAGES表的字段进行一一对应的，列表2是这个示例程序的映射配置文件清单：<br /><br />　　列表2：示例程序的对象－关系映射表<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>＜?xml version=&quot;1.0&quot;?＞<br />＜!DOCTYPE hibernate-mapping PUBLIC<br />&quot;-//Hibernate/Hibernate Mapping DTD//EN&quot;<br />&quot;http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd&quot;＞<br />＜hibernate-mapping＞<br />＜class name=&quot;hello.Message&quot; table=&quot;MESSAGES&quot;＞<br />　＜id name=&quot;id&quot; column=&quot;MESSAGE_ID&quot;＞<br />　　＜generator class=&quot;increment&quot;/＞<br />　＜/id＞<br />　＜property name=&quot;text&quot; column=&quot;MESSAGE_TEXT&quot;/＞<br />　＜many-to-one name=&quot;nextMessage&quot; cascade=&quot;all&quot; column=&quot;NEXT_MESSAGE_ID&quot;/＞<br />＜/class＞<br />＜/hibernate-mapping＞</td>
		</tr>
	</tbody>
</table>
<p><br />　　以上这个文档告诉Hibernate怎样将Message类映射到MESSAGES表中，其中Message类的id属性与表的MESSAGE_ID字段对应，text属性与表的MESSAGE_TEXT字段对应，nextMessage属性是一个多对一的关系，它与表中的NEXT_MESSAGE_ID相对应。<br /><br />　　相对于有些开源项目来说，Hibernate的配置文件其实是很容易理解的。你可以轻松地修改与维护它。只要你定义好了持久类与数据库中表字段的对应关系就行了，Hibernate会自动帮你生成SQL语句来对Message对象进行插入、更新、删除、查找工作，你可以不写一句SQL语句，甚至不需要懂得SQL语言！<br /><br />　　现在让我们做一个新的试验，我们先取出第一个Message对象，然后修改它的消息正文，最后我们再生成一个新的Message对象，并将它作为第一个Message对象的下一条消息，其代码如下：<br /><br />　　列表3　更新一条消息<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>Session session = getSessionFactory().openSession();<br />Transaction tx = session.beginTransaction();<br />// 1 is the generated id of the first message<br />Message message =(Message) session.load( Message.class, new Long(1) );<br />message.setText(&quot;Greetings Earthling&quot;);<br />Message nextMessage = new Message(&quot;Take me to your leader (please)&quot;);<br />message.setNextMessage( nextMessage );<br />tx.commit();<br />session.close();</td>
		</tr>
	</tbody>
</table>
<p><br />　　以上这段代码在调用时，Hibernate内部自动生成如下的SQL语句：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>select m.MESSAGE_ID, m.MESSAGE_TEXT, m.NEXT_MESSAGE_ID<br />from MESSAGES m<br />where m.MESSAGE_ID = 1<br /><br />insert into MESSAGES (MESSAGE_ID, MESSAGE_TEXT, NEXT_MESSAGE_ID)<br />values (2, &#39;Take me to your leader (please)&#39;, null)<br /><br />update MESSAGES<br />set MESSAGE_TEXT = &#39;Greetings Earthling&#39;, NEXT_MESSAGE_ID = 2<br />where MESSAGE_ID = 1</td>
		</tr>
	</tbody>
</table>
<p><br />　　当第一个Message对象的text属性和nextMessage被程序修改时，请注意Hibernate是如何检测到这种变化，并如何在数据库中自动对它更新的。这实际上是Hibernate的一个很有价值的特色，我们把它称为&ldquo;自动脏数据检测&rdquo;，Hibernate的这个特色使得当我们修改一个持久对象的属性后，不必显式地通知Hibernate去将它在数据库中进行更新。同样的，当第一个Message对象调用setNextMessage()方法将第二个Message对象作为它的下一条消息的引用时，第二条消息会无需调用save()方法，便可以自动地保存在数据库中。这种特色被称为&ldquo;级联保存&rdquo;，它也免去了我们显式地对第二个Message对象调用save()方法之苦。<br /><br />　　如果我们再运行先前的那段将数据库中所有的Message对象都打印出来的代码，那它的运行结果如下：<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td>2 message(s) found:<br />Greetings Earthling<br />Take me to your leader (please)</td>
		</tr>
	</tbody>
</table>
<p><br />　　&ldquo;Hello world&rdquo;示例程序现在介绍完毕。我们总算对Hibernate有了一个简单的认识，下面我们将回过头来，对Hibernate的主要API调用作一下简要的介绍：</p>
<p>&nbsp;</p>
<p><span class="f14">　　<strong>理解Hibernate的架构</strong><br /><br />　　当你想用Hibernate开发自己的基于持久层的应用时，第一件事情应当是熟悉它的编程接口。Hibernate的API接口设计得尽量简洁明了，以方便开发人员。然而实际上由于ORM的复杂性，它的API一般都不可能设计得很简单。但是别担心，你没有必要一下子了解所有的Hibernate的API接口。下面这张图描述了Hibernate在应用层和持久层中的一些重要的接口类：</span></p>
<p align="center"><span class="f14"><img alt="\" border="undefined" onload="javascript:resizepic(this)" onmousewheel="return bbimg(this)" src="/Files/UpFiles/2004/10/27/2004102709050032701.jpg" /></span></p>
<p><span class="f14">　　在上图中，我们将应用层放在了持久层的上部，实际上在传统的项目中，应用层充当着持久层的一个客户端角色。但对于一些简单的项目来说，应用层和持久层并没有区分得那么清楚，这也没什么，在这种情况下你可以将应用层和持久层合并成了一层。<br /><br />　　在上图中，Hibernate的接口大致可以分为以下几种类型：<br /><br />　　&middot; 一些被用户的应用程序调用的，用来完成基本的创建、读取、更新、删除操作以及查询操作的接口。这些接口是Hibernate实现用户程序的商业逻辑的主要接口，它们包括Session、Transaction和Query。<br /><br />　　&middot; Hibernate用来读取诸如映射表这类配置文件的接口，典型的代表有Configuration类。<br /><br />　　&middot; 回调(Callback)接口。它允许应用程序能对一些事件的发生作出相应的操作，例如Interceptor、Lifecycle和Validatable都是这一类接口。<br /><br />　　&middot; 一些可以用来扩展Hibernate的映射机制的接口，例如UserType、CompositeUserType和IdentifierGenerator。这些接口可由用户程序来实现（如果有必要）。<br /><br />　　Hibernate使用了J2EE架构中的如下技术：JDBC、JTA、JNDI。其中JDBC是一个支持关系数据库操作的一个基础层；它与JNDI和JTA一起结合，使得Hibernate可以方便地集成到J2EE应用服务器中去。<br /><br />　　在这里，我们不会详细地去讨论Hibernate API接口中的所有方法，我们只简要讲一下每个主要接口的功能，如果你想了解得更多的话，你可以在Hibernate的源码包中的net.sf.hibernate子包中去查看这些接口的源代码。下面我们依次讲一下所有的主要接口：<br /><br />　　<strong>核心接口</strong><br /><br />　　以下5个核心接口几乎在任何实际开发中都会用到。通过这些接口，你不仅可以存储和获得持久对象，并且能够进行事务控制。<br /><br />　　Session接口<br /><br />　　Session接口对于Hibernate 开发人员来说是一个最重要的接口。然而在Hibernate中，实例化的Session是一个轻量级的类，创建和销毁它都不会占用很多资源。这在实际项目中确实很重要，因为在客户程序中，可能会不断地创建以及销毁Session对象，如果Session的开销太大，会给系统带来不良影响。但值得注意的是Session对象是非线程安全的，因此在你的设计中，最好是一个线程只创建一个Session对象。<br /><br />　　在Hibernate的设计者的头脑中，他们将session看作介于数据连接与事务管理一种中间接口。我们可以将session想象成一个持久对象的缓冲区，Hibernate能检测到这些持久对象的改变，并及时刷新数据库。我们有时也称Session是一个持久层管理器，因为它包含这一些持久层相关的操作，诸如存储持久对象至数据库，以及从数据库从获得它们。请注意，Hibernate 的session不同于JSP应用中的HttpSession。当我们使用session这个术语时，我们指的是Hibernate中的session，而我们以后会将HttpSesion对象称为用户session。<br /><br />　　SessionFactory 接口<br /><br />　　这里用到了一个设计模式――工厂模式，用户程序从工厂类SessionFactory中取得Session的实例。<br /><br />　　令你感到奇怪的是SessionFactory并不是轻量级的！实际上它的设计者的意图是让它能在整个应用中共享。典型地来说，一个项目通常只需要一个SessionFactory就够了，但是当你的项目要操作多个数据库时，那你必须为每个数据库指定一个SessionFactory。<br />SessionFactory在Hibernate中实际起到了一个缓冲区的作用，它缓冲了Hibernate自动生成的SQL语句和一些其它的映射数据，还缓冲了一些将来有可能重复利用的数据。<br /><br />　　Configuration 接口<br /><br />　　Configuration接口的作用是对Hibernate进行配置，以及对它进行启动。在Hibernate的启动过程中，Configuration类的实例首先定位映射文档的位置，读取这些配置，然后创建一个SessionFactory对象。<br /><br />　　虽然Configuration接口在整个Hibernate项目中只扮演着一个很小的角色，但它是启动hibernate时你所遇到的每一个对象。<br /><br />　　Transaction 接口<br /><br />　　Transaction接口是一个可选的API，你可以选择不使用这个接口，取而代之的是Hibernate的设计者自己写的底层事务处理代码。 Transaction接口是对实际事务实现的一个抽象，这些实现包括JDBC的事务、JTA中的UserTransaction、甚至可以是CORBA事务。之所以这样设计是能让开发者能够使用一个统一事务的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移值。<br /><br />　　Query和Criteria接口<br /><br />　　Query接口让你方便地对数据库及持久对象进行查询，它可以有两种表达方式：HQL语言或本地数据库的SQL语句。Query经常被用来绑定查询参数、限制查询记录数量，并最终执行查询操作。<br /><br />　　Criteria接口与Query接口非常类似，它允许你创建并执行面向对象的标准化查询。<br /><br />　　值得注意的是Query接口也是轻量级的，它不能在Session之外使用。<br /><br />　　Callback 接口<br /><br />　　当一些有用的事件发生时――例如持久对象的载入、存储、删除时，Callback接口会通知Hibernate去接收一个通知消息。一般而言，Callback接口在用户程序中并不是必须的，但你要在你的项目中创建审计日志时，你可能会用到它。</span></p>
<p>&nbsp;</p>
<p><span class="f14">　　<strong>一个重要的术语：Type</strong><br /><br />　　Hibernate的设计者们发明了一个术语：Type，它在整个构架中是一个非常基础、有着强大功能的元素。一个Type对象能将一个Java类型映射到数据库中一个表的字段中去（实际上，它可以映射到表的多个字段中去）。持久类的所有属性都对应一个type。这种设计思想使用Hibernate有着高度的灵活性和扩展性。<br /><br />　　Hibernate内置很多type类型，几乎包括所有的Java基本类型，例如Java.util.Currency、Java.util.calendar、byte[]和Java.io.Serializable。<br /><br />　　不仅如此，Hibernate还支持用户自定义的type，通过实现接口UserType和接口CompositeUserType，你可以加入自己的type。你可以利用这种特色让你的项目中使用自定义的诸如Address、Name这样的type，这样你就可以获得更大的便利，让你的代码更优雅。自定义type在Hibernate中是一项核心特色，它的设计者鼓励你多多使用它来创建一个灵活、优雅的项目！<br /><br />　　<strong>策略接口</strong><br /><br />　　Hibernate与某些其它开源软件不同的还有一点――高度的可扩展性，这通过它的内置策略机制来实现。当你感觉到Hibernate的某些功能不足，或者有某些缺陷时，你可以开发一个自己的策略来替换它，而你所要做的仅仅只是继承它的某个策略接口，然后实现你的新策略就可以了，以下是它的策略接口：<br /><br />　　&middot; 主键的生成 (IdentifierGenerator 接口)<br /><br />　　&middot; 本地SQL语言支持 (Dialect 抽象类)<br /><br />　　&middot; 缓冲机制 (Cache 和CacheProvider 接口)<br /><br />　　&middot; JDBC 连接管理 (ConnectionProvider接口)<br /><br />　　&middot; 事务管理 (TransactionFactory, Transaction, 和 TransactionManagerLookup 接口)<br /><br />　　&middot; ORM 策略 (ClassPersister 接口)<br /><br />　　&middot; 属性访问策略 (PropertyAccessor 接口)<br /><br />　　&middot; 代理对象的创建 (ProxyFactory接口)<br /><br />　　Hibernate为以上所列的机制分别创建了一个缺省的实现，因此如果你只是要增强它的某个策略的功能的话，只需简单地继承这个类就可以了，没有必要从头开始写代码。<br /><br />　　以上就是Hibernate的一些核心接口，但当我们真正开始用它进行开发时，你的脑海里可能总会有一个疑问：我是通过什么方式，并从哪里取得Session的呢？以下我们就解答这个问题。<br /><br />　　<strong>基础配置</strong><br /><br />　　现在回顾一下我们先前的内容：我们写出了一个示例程序，并简要地讲解了Hibernate的一些核心类。但要真正使你的项目运行起来，还有一件事必须要做：配置。Hibernate可以配置成可在任何Java环境中运行，一般说来，它通常被用在2－3层的C/S模式的项目中，并被部署在服务端。在这种项目中，Web浏览器、或Java GUI程序充当者客户端。尽管我们的焦点主要是集中在多层web应用，但实际上在一些基于命令行的应用中也可以使用Hibernate。并且，对Hibernate的配置在不同的环境下都会不同，Hibernate运行在两种环境下：可管理环境和不可管理环境<br /><br />　　&middot; 可管理环境――这种环境可管理如下资源：池资源管理，诸如数据库连接池和，还有事务管理、安全定义。一些典型的J2EE服务器（JBoss、Weblogic、WebSphere）已经实现了这些。<br /><br />　　&middot; 不可管理环境――只是提供了一些基本的功能，诸如像Jetty或Tomcat这样的servlet容器环境。一个普通的Java桌面应用或命令行程序也可以认为是处于这种环境下。这种环境不能提供自动事务处理、资源管理或安全管理，这些都必须由应用程序自己来定义。<br /><br />　　Hibernate的设计者们将这两种环境设计了一个统一的抽象界面，因此对于开发者来说只有一种环境：可管理环境。如果实际项目是建立在诸如Tomcat这类不可管理的环境中时，那Hibernate将会使用它自己的事务处理代码和JDBC连接池，使其变为一个可管理环境。<br />对于可管理的环境而言，Hibernate会将自己集成在这种环境中。对于开发者而言，你所要做的工作非常简单：只需从一个Configuration类中创建一个SessionFactory类就可以了。</span></p>
<p>&nbsp;</p>
<p><span class="f14">　　<strong>创建一个SessionFactory对象</strong><br /><br />　　为了能创建一个SessionFactory对象，你必须在Hibernate初始化时创建一个Configuration类的实例，并将已写好的映射文件交由它处理。这样，Configuration对象就可以创建一个SessionFactory对象，当SessionFactory对象创建成功后，Configuration对象就没有用了，你可以简单地抛弃它。如下是示例代码：</span></p>&nbsp;
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td><span class="f14">Configuration cfg = new Configuration();<br />cfg.addResource(&quot;hello/Message.hbm.xml&quot;);<br />cfg.setProperties( System.getProperties() );<br />SessionFactory sessions = cfg.buildSessionFactory(); </span></td>
		</tr>
	</tbody>
</table><br /><span class="f14">　　在以上代码中，Message.hb.xml这个映射文件的位置比较特殊，它与当前的classpath相关。例如classpath包含当前目录，那在上述代码中的Message.hbm.xml映射文件就可以保存在当前目录下的hello目录中。<br /><br />　　作为一种约定，Hibernate的映射文件默认以.htm.xml作为其扩展名。另一个约定是坚持为每一个持久类写一个配置文件，想一想如果你将所有持久类的映射写入一个单独的配置文件中的话，那这个配置文件肯定非常庞大，不易维护。但这里又出现了一个新问题：如果为每个类写一个配置文件的话，这么多的配置文件应该存放在哪里呢？<br /><br />　　Hibernate推荐你将每个映射文件保存在与持久类相同的目录下，并且与持久类同名。例如我们第一个示例程序中的Message持久类放在hello目录下，那你必须在这个目录下存放名为Message.hbm.xml的映射文件。这样一个持久类都有自己的一个映射文件，避免了出现像struts项目中的&ldquo;struts-config.xml地狱&rdquo;的情况。如果你不遵循这种规定，那你必须手动地用addResource()方法将一个个的映射文件载入；但你如果遵循这种规定，那你可以方便地用addClass()方法同时将持久类和它的映射文件载入，以下是体现这种便利性的示例代码：</span><br />&nbsp;
<table align="center" bgcolor="#e6e4dd" border="1" bordercolor="#ffcc66" width="90%">
	<tbody>
		<tr>
			<td><span class="f14">SessionFactory sessions = new Configuration()<br />.addClass(org.hibernate.auction.model.Item.class)<br />.addClass(org.hibernate.auction.model.Category.class)<br />.addClass(org.hibernate.auction.model.Bid.class)<br />.setProperties( System.getProperties() )<br />.buildSessionFactory(); </span></td>
		</tr>
	</tbody>
</table><br /><span class="f14">　　当然，Hibernate的映射文件还有很多其它的配置选项，比如数据库连接的设定，或是能够改变Hibernate运行时行为的一些设定。所有的设置可能是非常庞杂的，足以让你喘不过气来，但是不必担心，因为Hibernate为绝大多数值都设定了一个合理缺省值，你只需要修改这些配置文件中的极小一部分值。<br /><br />　　你可以通过以下几种方式来修改Hibernate的系统配置参数：<br /><br />　　&middot; 将一个Java.util.Properties实例作为参数传给Configuration类的setProperties()方法。<br /><br />　　&middot; 在Hibernate启动时用Java &ndash;Dproperty=value的方式设置值。<br /><br />　　&middot; 在classpath可以找到的路径下创建一个名为hibernate.properties的配置文件。<br /><br />　　&middot; 在classpath可以找到的路径下创建一个名为hibernate.cfg.xml的文件，并在其＜property＞标签中定义属性值。<br /><br />　　以上就是对Hibernate的一个大致介绍，如果你想知道得更多，那本文还是远远不够的，我将陆续推出更多关于Hibernate的资料。但有一点是毫无疑问的：它的确是一个非常优秀的持久层解决方案！</span></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/147.html'>Java使用全屏幕模式</a><a>下一篇</a><a href='/java/biji/149.html'>高效编写JAVA代码的30条建议</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>