<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>在Java应用程序中访问USB设备详解_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="Java 平台一直都以其平台无关性自豪。虽然这种无关性有许多好处，但是它也使得编写与硬件交互的 Java 应用程序的过程变得相当复杂。在本文中，研究科学" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">在Java应用程序中访问USB设备详解</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>Java 平台一直都以其平台无关性自豪。虽然这种无关性有许多好处，但是它也使得编写与硬件交互的 Java 应用程序的过程变得相当复杂。在本文中，研究科学</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>Java 平台一直都以其平台无关性自豪。虽然这种无关性有许多好处，但是它也使得编写与硬件交互的 Java 应用程序的过程变得相当复杂。在本文中，研究科学家蒋清野讨论了两个项目，它们通过提供使Java 应用程序可以使用 USB 设备的 API 而使这个过程变得更容易。虽然这两个项目仍然处于萌芽状态，但是它们都显示了良好的前景，并已经成为一些实用应用程序的基础。</p>
<p>通用串行总线(Universal Serial Bus USB)规范的第一个版本发表于 1996年 1月。因为它的低成本、高数据传输率、使用容易和灵活性，USB 在计算机行业里获得了广泛接受。今天，许多周边设备和装置都是通过 USB 接口连接到计算机上的。目前，大多数一般用途的操作系统都提供了对 USB 设备的支持，并且用 C 或者 C++ 可以相对容易地开发访问这些外设的应用程序。不过，Java 编程语言在设计上对硬件访问提供的支持很少，所以编写与 USB 设备交互的应用程序是相当困难的。</p>
<p>IBM 的 Dan Streetman 最早开始了在 Java 语言中提供对 USB 设备的访问的努力。2001年，他的项目通过 Java 规范请求(Java Specification Request，JSR)过程被接受为 Java 语言的候选扩展标准。这个项目现在称为 JSR-80 并且指定了官方包 javax.usb。同时，在 2000年 6月，Mojo Jojo 和 David Brownell 在 SourceForge 开始了 jUSB 项目。这两个项目都开发出了 Linux 开发人员可以使用的包，尽管它们都还很不完善。这两个项目也都开始试图向其他操作系统上的 Java 应用程序提供对 USB 设备的访问，尽管它们都还没有开发出可以使用的包(参阅 参考资料 中有关本文中讨论的这两个项目及其他项目的资料)。</p>
<p>在本文中，将对 jUSB 和 JSR-80 项目作一个简要介绍，不过，我们首先要看一下 USB 协议的具体细节，这样您就可以理解这两个项目是如何与 USB 设备交互的。我们还将提供代码片段以展示如何用这两个项目的 API 访问 USB 设备。</p>
<p>USB 介绍</p>
<p>1994年，一个由四个行业伙伴(Compaq、Intel、Microsoft 和 NEC)组成的联盟开始制定 USB 协议。该协议最初的目的是将 PC 与电话相连并提供容易扩展和重新配置的 I/O 接口。1996年 1月，发表了 USB 规范的第一个版本，1998年 9月发表了后续版本(版本 1.1)。这个规范允许 127台设备同时连接到一起，总的通信带宽限制为 12 Mbps。后来，又有三个成员(Hewlett-Packard、Lucent 和 Philips)加入了这个联盟。2000年 4月，发表了 USB 规范的 2.0版本，它支持高达 480 Mbps 的传输率。今天，USB 在高速(视频、图像、储存)和全速(音频、宽带、麦克风)数据传输应用中起了关键作用。它还使各种低速设备(键盘、鼠标、游戏外设、虚拟现实外设)连接到 PC 上。</p>
<p>USB 协议有严格的层次结构。在所有 USB 系统中，只有一个主设备，到主计算机的的 USB 接口称为主控器(host controller)。主控器有两个标准??开放主控器接口(Compaq 的 Open Host Controller Interface，OHCI)和通用主控器接口(Intel 的 Universal Host Controller Interface，UHCI)。这两个标准提供了同样的能力，并可用于所有的 USB 设备，UHCI 的硬件实现更简单一些，但是需要更复杂的设备驱动程序(因而 CPU 的负荷更大一些)。</p>
<p>USB 物理互连是分层的星形拓朴，最多有七层。一个 hub 是每个星形的中心，USB 主机被认为是 root hub。每一段连线都是 hub 与 USB 设备的点对点连接，后者可以是为系统提供更多附加点的另一个 hub，也可以是一个提供功能的某种设备。主机使用主/从协议与 USB 设备通信。这种方式解决了包冲突的问题，但是同时也阻止了附加的设备彼此建立直接通信。</p>
<p>所有传输的数据都是由主控器发起的。数据从主机流向设备称为下行(downstream)或者输出(out)传输，数据从设备流向主机称为上 行(upstream)或者输入(in)传输。数据传输发生在主机和 USB 设备上特定的端点(endpoint) 之间，主机与端点之间的数据链接称为管道(pipe)。 一个给定的 USB 设备可以有许多个端点，主机与设备之间数据管道的数量与该设备上端点的数量相同。一个管道可以是单向或者是双向的，一个管道中的数据流与所有其他管道中的数据流无关。</p>
<p>USB 网络中的通信可以使用下面四种数据传输类型中的任意一种：<br /><br /><u>控制传输</u>： 这些是一些短的数据包，用于设备控制和配置，特别是在设备附加到主机上时。<br /><br /><u>批量传输</u>： 这些是数量相对大的数据包。像扫描仪或者 SCSI 适配器这样的设备使用这种传输类型。<br /><br /><u>中断传输</u>： 这些是定期轮询的数据包。主控器会以特定的间隔自动发出一个中断。<br /><br /><u>等时传输</u>： 这些是实时的数据流，它们对带宽的要求高于可靠性要求。音频和视频设备一般使用这种传输类型。<br /><br />像串行端口一样，计算机上每一个 USB 端口都由 USB 控制器指定了一个惟一的标识数字(端口 ID)。当 USB 设备附加到 USB 端口上时，就将这个 惟一端口 ID 分配给这台设备，并且 USB 控制器会读取设备描述符。设备描述符包括适用于该设备的全局信息、以及设备的配置信息。配置定义了一台 USB 设备的功能和 I/O 行为。一台 USB 设备可以有一个或者多个配置，这由它们相应的配置描述符所描述。每一个配置都有一个或者多个接口，它可以视为一个物理通信渠道 ；每一个接口有零个或者多个端点，它可以是数据提供者或者数据消费者，或者同时具有这两种身份。接口由接口描述符描述，端点由端点描述符描述。并且一台 USB 设备可能还有字符串描述符以提供像厂商名、设备名或者序列号这样的附加信息。<br /><br />正如您所看到的，像 USB 这样的协议为使用 Java 这种强调平台和硬件无关性的语言的开发人员提出了挑战。现在让我们看两个试图解决这个问题的项目。<br /><br /><strong>jUSB API</strong><br /><br />jUSB 项目是由 Mojo Jojo 和 David Brownell 于 2000年 6月创立的。其目标是提供一组免费的、在 Linux 平台上访问 USB 设备的 Java API。这个 API 是按照 Lesser GPL (LGPL)条款发表的，这意味着您可以在专有和免费软件项目中使用它。这个 API 提供了对多个物理 USB 设备的多线程访问，并支持本机和远程设备。具有多个接口的设备可以同时被多个应用程序(或者设备驱动程序)所访问，其中每一个应用程序(或者设备驱动程序)都占据一个不同的接口。该 API 支持控制传输、批量传输和中断传输，不支持等时传输，因为等时传输用于媒体数据(如音频和视频)，JMF API 已经在其他标准设备驱动程序上对此提供了很好的支持(参阅 参考资料)。当前，该 API 可以在具有 Linux 2.4 核心或者以前的 2.2.18 核心的 GNU/Linux 版本上工作。因此可支持大多数最新的版本，例如，该 API 可以在没有任何补丁或者升级的 Red Hat 7.2 和 9.0 上工作。<br /><br />jUSB API 包括以下包：<br /><br />1.usb.core: 这个包是 jUSB API 的核心部分。它使得 Java 应用程序可以从 USB 主机访问 USB 设备。<br /><br />2.usb.linux: 这个包包含 usb.core.Host 对象的 Linux 实现、bootstrapping 支持和其他可以提升 Linux USB 支持的类。这个实现通过虚拟 USB 文件系统(usbdevfs)访问 USB 设备。<br /><br />3.usb.windows: 这个包包含 usb.core.Host 对象的 Windows 实现、bootstrapping 支持和其他可以提升 Windows USB 支持的类。这个实现仍然处于非常初级的阶段。<br /><br />4.usb.remote: 这个包是 usb.core API 的远程版本。它包括一个 RMI proxy 和一个 daemon 应用程序，它让 Java 应用程序可以访问远程计算机上的 USB 设备。<br /><br />5.usb.util: 这个包提供了一些有用的实用程序，可以将 firmware下载到 USB 设备上、将 USB 系统的内容转储到 XML 中、以及将只有 bulk I/O 的 USB 设备工具转换成一个套接字(socket)。<br /><br />6.usb.devices: 这个可选包收集了用 jUSB API 访问不同 USB 设备的 Java 代码，包括柯达数码相机和 Rio 500 MP3 播放器。这些 API 经过特别编写以简化访问特定 USB 设备的过程，并且不能用于访问其他设备。这些 API 是在 usb.core API 之上构建的，它们可以工作在所有支持 jUSB 的操作系统上。<br /><br />7.usb.view: 这个可选包提供了基于 Swing 的 USB 树简单浏览器。它是一个展示 jUSB API 应用的很好的示例程序。<br /><br />尽管 usb.core.Host 对象的实现对于不同的操作系统是不同的，但是 Java 程序员只需要理解 usb.core 包就可以用 jUSB API 开始应用程序的开发。表 1 列出了 usb.core 的接口和类，Java 程序员应该熟悉它们：<br /><br />表 1. jUSB 中的接口和类<br />&nbsp;</p>
<p>&nbsp;</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="WIDTH: 539px; HEIGHT: 345px" width="539">
	<tbody>
		<tr>
			<td>接口/类</td>
			<td>说明</td>
		</tr>
		<tr>
			<td>Bus</td>
			<td>将一组 USB 设备连接到 Host 上</td>
		</tr>
		<tr>
			<td>Host</td>
			<td>表示具有一个或者多个 Bus 的 USB 控制器</td>
		</tr>
		<tr>
			<td>Configuration</td>
			<td>提供对设备所支持的 USB 配置的访问，以及对与该配置关联的接口的访问</td>
		</tr>
		<tr>
			<td>Descriptor</td>
			<td>具有 USB 类型的描述符的实体的基类</td>
		</tr>
		<tr>
			<td>Device</td>
			<td>提供对 USB 设备的访问</td>
		</tr>
		<tr>
			<td>DeviceDescriptor</td>
			<td>提供对 USB 设备描述符的访问</td>
		</tr>
		<tr>
			<td>EndPoint</td>
			<td>提供对 USB 端点描述符的访问、在给定设备配置中构造设备数据输入或者输出</td>
		</tr>
		<tr>
			<td>HostFactory</td>
			<td>包含 bootstrapping 方法</td>
		</tr>
		<tr>
			<td>Hub</td>
			<td>提供对 USB hub 描述符以及一些 hub 操作的访问</td>
		</tr>
		<tr>
			<td>Interface</td>
			<td>描述一组端点，并与一个特定设备配置相关联</td>
		</tr>
		<tr>
			<td>PortIdentifier</td>
			<td>为 USB 设备提供稳定的字符串标识符，以便在操作和故障诊断时使</td>
		</tr>
	</tbody>
</table>
<p>用 jUSB API 访问一台 USB 设备的正常过程如下：<br /><br />1.通过从 HostFactory 得到 USB Host 进行 Bootstrap。<br /><br />2.从 Host 访问 USB Bus，然后从这个 Bus 访问 USB root hub(即 USB Device)。<br /><br />3.得到 hub 上可用的 USB 端口数量，遍历所有端口以找到正确的 Device。<br /><br />4.访问附加到特定端口上的 USB Device。可以用一台 Device 的 PortIdentifier 直接从 Host 访问它，也可以通过从 root hub 开始遍历 USB Bus 找到它。<br /><br />5.用 ControlMessage 与该 Device 直接交互，或者从该 Device 的当前 Configuration 中要求一个 Interface，并与该 Interface 上可用的 Endpoint 进行 I/O 。<br /><br />清单 1 展示了如何用 jUSB API 获得 USB 系统中的内容。这个程序编写为只是查看 root hub 上可用的 USB 设备，但是很容易将它改为遍历整个 USB 树。这里的逻辑对应于上述步骤 1 到步骤 4。<br /><br />清单 1. 用 jUSB API 获得 USB 系统的内容<br />&nbsp;</p>
<p>&nbsp;</p>
<p><code><font face="新宋体">import usb.core.*;<br /><br />public class ListUSB<br /><br />{<br /><br />　public static void main(String[] args)<br /><br />　{<br /><br />try<br /><br />{<br /><br />　// Bootstrap by getting the USB Host from the HostFactory.<br /><br />　Host host = HostFactory.getHost();<br /><br />　// Obtain a list of the USB buses available on the Host.<br /><br />　Bus[] bus = host.getBusses();<br /><br />　int total_bus = bus.length;<br /><br />　// Traverse through all the USB buses.<br /><br />　for (int i=0; i<total_bus; i=""><br />　{<br /><br />// Access the root hub on the USB bus and obtain the<br /><br />// number of USB ports available on the root hub.<br /><br />Device root = bus[i].getRootHub();<br /><br />int total_port = root.getNumPorts();<br /><br />// Traverse through all the USB ports available on the<br /><br />// root hub. It should be mentioned that the numbering<br /><br />// starts from 1, not 0.<br /><br />for (int j=1; j&lt;=total_port; j++)<br /><br />{<br /><br />　// Obtain the Device connected to the port.<br /><br />　Device device = root.getChild(j);<br /><br />　if (device != null)<br /><br />　{<br /><br />// USB device available, do something here.<br /><br />　}<br /><br />}<br /><br />　}<br /><br />} catch (Exception e)<br /><br />{<br /><br />　System.out.println(e.getMessage());<br /><br />}<br /><br />　}</total_bus;></font></code></p>
<p>清单 2 展示了在应用程序成功地找到了 Device 的条件下，如何与 Interface 和 EndPoint 进行批量 I/O。 这个代码段也可以修改为执行控制或者中断 I/O。它对应于上述步骤 5。<br /><br />清单 2. 用 jUSB API 执行批量 I/O<br />&nbsp;</p>
<p><code><font face="新宋体">if (device != null)<br /><br />{<br /><br />　// Obtain the current Configuration of the device and the number of<br /><br />　// Interfaces available under the current Configuration.<br /><br />　Configuration config = device.getConfiguration();<br /><br />　int total_interface = config.getNumInterfaces();<br /><br />　// Traverse through the Interfaces<br /><br />　for (int k=0; k<total_interface; k=""><br />　{<br /><br />// Access the currently Interface and obtain the number of<br /><br />// endpoints available on the Interface.<br /><br />Interface itf = config.getInterface(k, 0);<br /><br />int total_ep = itf.getNumEndpoints();<br /><br />// Traverse through all the endpoints.<br /><br />for (int l=0; l<total_ep; l=""><br />{<br /><br />　// Access the endpoint, and obtain its I/O type.<br /><br />　Endpoint ep = itf.getEndpoint(l);<br /><br />　String io_type = ep.getType();<br /><br />　boolean input = ep.isInput();<br /><br />　// If the endpoint is an input endpoint, obtain its<br /><br />　// InputStream and read in data.<br /><br />　if (input)<br /><br />　{<br /><br />InputStream in;<br /><br />in = ep.getInputStream();<br /><br />// Read in data here<br /><br />in.close();<br /><br />　}<br /><br />　// If the Endpoint is and output Endpoint, obtain its<br /><br />　// OutputStream and write out data.<br /><br />　else<br /><br />　{<br /><br />OutputStream out;<br /><br />out = ep.getOutputStream();<br /><br />// Write out data here.<br /><br />out.close();<br /><br />　}<br /><br />}<br /><br />　}<br /><br />}</total_ep;></total_interface;></font></code></p>
<p><br />jUSB 项目在 2000年 6月到 2001年 2月期间非常活跃。该 API 的最新的版本 0.4.4发表于 2001年 2月 14日。从那以后只提出了很少的改进，原因可能是 IBM 小组成功地成为了 Java 语言的候选扩展标准。不过，基于 jUSB 已经开发出一些第三方应用程序，包括 JPhoto 项目(这是一个用 jUSB 连接到数码照相机的应用程序)和 jSyncManager 项目(这是一个用 jUSB 与使用 Palm 操作系统的 PDA 同步的应用程序)。</p>
<p><strong>JSR-80 API (javax.usb)</strong><br /><br />正如前面提到的，JSR-80 项目是由 IBM 的 Dan Streetman 于 1999年创立的。2001年，这个项目通过 Java 规范请求(JSR)过程被接受为 Java 语言的候选扩展标准。这个项目现在称为 JSR-80 并且被正式分派了 Java 包 javax.usb。这个项目使用 Common Public License 的许可证形式，并通过 Java Community Process 进行开发。这个项目的目标是为 Java 平台开发一个 USB 接口，可以从任何 Java 应用程序中完全访问 USB 系统。JSR-80 API 支持 USB 规范所定义的全部四种传输类型。目前，该 API 的 Linux 实现可以在支持 2.4 核心的大多数最新 GNU/Linux 版本上工作，如 Red Hat 7.2 和 9.0。<br /><br />JSR-80 项目包括三个包：javax-usb (javax.usb API)、javax-usb-ri (操作系统无关的基准实现的公共部分)以及 javax-usb-ri-linux (Linux 平台的基准实现，它将公共基准实现链接到 Linux USB 堆栈)。所有这三个部分都是构成 Linux 平台上 java.usb API 完整功能所必需的。在该项目的电子邮件列表中可以看到有人正在致力于将这个 API 移植到其他操作系统上(主要是 Microsoft Windows)，但是还没有可以工作的版本发表。<br /><br />尽管 JSR-80 API 的操作系统无关的实现在不同的操作系统上是不同的，但是 Java 程序员只需要理解 javax.usb 包就可以开始开发应用程序了。表 2 列出了 javax.usb 中的接口和类， Java 程序员应该熟悉它们：<br /><br />表 2. JSR-80 API 中的接口和类<br />&nbsp;</p>
<p>&nbsp;</p>
<table border="1" cellpadding="1" cellspacing="1" width="100%">
	<tbody>
		<tr>
			<td>接口/类</td>
			<td>说明</td>
		</tr>
		<tr>
			<td>UsbConfiguration</td>
			<td>表示 USB 设备的配置</td>
		</tr>
		<tr>
			<td>UsbConfigurationDescriptor</td>
			<td>USB 配置描述符的接口</td>
		</tr>
		<tr>
			<td>UsbDevice USB</td>
			<td>设备的接口</td>
		</tr>
		<tr>
			<td>UsbDeviceDescriptor USB</td>
			<td>设备描述符的接口</td>
		</tr>
		<tr>
			<td>UsbEndpoint USB</td>
			<td>端点的接口</td>
		</tr>
		<tr>
			<td>UsbEndpointDescriptor USB</td>
			<td>端点描述符的接口</td>
		</tr>
		<tr>
			<td>UsbHub</td>
			<td>USB hub 的接口</td>
		</tr>
		<tr>
			<td>UsbInterface</td>
			<td>USB 接口的接口</td>
		</tr>
		<tr>
			<td>UsbInterfaceDescriptor</td>
			<td>USB 接口描述符的接口</td>
		</tr>
		<tr>
			<td>UsbPipe USB</td>
			<td>管道的接口</td>
		</tr>
		<tr>
			<td>UsbPort USB</td>
			<td>端口的接口</td>
		</tr>
		<tr>
			<td>UsbServices</td>
			<td>javax.usb实现的接口</td>
		</tr>
		<tr>
			<td>UsbHostManager</td>
			<td>javax.usb 的入口点</td>
		</tr>
	</tbody>
</table>
<p><br /><br />用 JSR-80 API 访问 USB 设备的正常过程如下：<br /><br />1.通过从 UsbHostManager 得到相应的 UsbServices 进行 Bootstrap。<br /><br />2.通过 UsbServices 访问 root hub。在应用程序中 root hub 就是一个 UsbHub。<br /><br />3.获得连接到 root hub 的 UsbDevices 清单。遍历所有低级 hub 以找到正确的 UsbDevice。<br /><br />4.用控制消息(UsbControlIrp)与 UsbDevice 直接交互，或者从 UsbDevice 的相应 UsbConfiguration 中要求一个 UsbInterface 并与该 UsbInterface 上可用的 UsbEndpoint 进行 I/O。<br /><br />5.如果一个 UsbEndpoint 用于进行 I/O，那么打开与它关联的 UsbPipe。通过这个 UsbPipe 可以同步或者异步提交上行数</p>
<p>据(从 USB 设备到主计算机)和下行数据(从主计算机到 USB 设备)。<br /><br />6.当应用程序不再需要访问该 UsbDevice 时，关闭这个 UsbPipe 并释放相应的 UsbInterface。<br /><br />在清单 3 中，我们用 JSR-80 API 获得 USB 系统的内容。这个程序递归地遍历 USB 系统上的所有 USB hub 并找出连接到主机计算机上的所有 USB 设备。这段代码对应于上述步骤 1 到步骤 3。<br /><br />清单 3. 用 JSR-80 API 获得 USB 系统的内容</p>
<p><code><font face="新宋体">import javax.usb.*;<br /><br />import java.util.List;<br /><br />public class TraverseUSB<br /><br />{<br /><br />　public static void main(String argv[])<br /><br />　{<br /><br />try<br /><br />{<br /><br />　// Access the system USB services, and access to the root<br /><br />　// hub. Then traverse through the root hub.<br /><br />　UsbServices services = UsbHostManager.getUsbServices();<br /><br />　UsbHub rootHub = services.getRootUsbHub();<br /><br />　traverse(rootHub);<br /><br />} catch (Exception e) {}<br /><br />　}<br /><br />　public static void traverse(UsbDevice device)<br /><br />　{<br /><br />if (device.isUsbHub())<br /><br />{<br /><br />　// This is a USB Hub, traverse through the hub.<br /><br />　List attachedDevices = ((UsbHub) device).getAttachedUsbDevices();<br /><br />　for (int i=0; i<attacheddevices.size(); i=""><br />　{<br /><br />traverse((UsbDevice) attachedDevices.get(i));<br /><br />　}<br /><br />}<br /><br />else<br /><br />{<br /><br />　// This is a USB function, not a hub.<br /><br />　// Do something.<br /><br />}<br /><br />　}<br /><br />}</attacheddevices.size();></font></code></p>
<p><br /><br />清单 4 展示了在应用程序成功地找到 Device 后，如何与 Interface 和 EndPoint 进行 I/O。这段代码还可以修改为进行所有四种数据传输类型的 I/O。它对应于上述步骤 4 到步骤 6。<br /><br />清单 4. 用 JSR-80 API 进行 I/O<br />&nbsp;</p>
<p><code><font face="新宋体">public static void testIO(UsbDevice device)<br /><br />{<br /><br />　try<br /><br />　{<br /><br />// Access to the active configuration of the USB device, obtain<br /><br />// all the interfaces available in that configuration.<br /><br />UsbConfiguration config = device.getActiveUsbConfiguration();<br /><br />List totalInterfaces = config.getUsbInterfaces();<br /><br />// Traverse through all the interfaces, and access the endpoints<br /><br />// available to that interface for I/O.<br /><br />for (int i=0; i<totalinterfaces.size(); i=""><br />{<br /><br />　UsbInterface interf = (UsbInterface) totalInterfaces.get(i);<br /><br />　interf.claim();<br /><br />　List totalEndpoints = interf.getUsbEndpoints();<br /><br />　for (int j=0; j<totalendpoints.size(); j=""><br />　{<br /><br />// Access the particular endpoint, determine the direction<br /><br />// of its data flow, and type of data transfer, and open the<br /><br />// data pipe for I/O.<br /><br />UsbEndpoint ep = (UsbEndpoint) totalEndpoints.get(i);<br /><br />int direction = ep.getDirection();<br /><br />int type = ep.getType();<br /><br />UsbPipe pipe = ep.getUsbPipe();<br /><br />pipe.open();<br /><br />// Perform I/O through the USB pipe here.<br /><br />pipe.close();<br /><br />　}<br /><br />　interf.release();<br /><br />}<br /><br />　} catch (Exception e) {}<br /><br />}</totalendpoints.size();></totalinterfaces.size();></font></code></p>
<p>JSR-80 项目从一开始就非常活跃。2003年 2月发表了 javax.usb API、RI 和 RI 的 0.10.0 版本。看起来这一版本会提交给 JSR-80 委员会做最终批准。预计正式成为 Java 语言的扩展标准后，其他操作系统上的实现会很快出现。Linux 开发者团体看来对 JSR-80 项目的兴趣比 jUSB 项目更大，使用 Linux 平台的 javax.usb API 的项目数量在不断地增加。<br /><br /><strong>结束语</strong><br /><br />　<br /><br />jUSB API 和 JSR-80 API 都为应用程序提供了从运行 Linux 操作系统的计算机中访问 USB 设备的能力。JSR-80 API 提供了比 jUSB API 更多的功能，很有可能成为 Java 语言的扩展标准。目前，只有 Linux 开发人员可以利用 jUSB 和 JSR-80 API 的功能。不过，有人正在积极地将这两种 API 移植到其他操作系统上。Java 开发人员应该在不久就可以在其他操作系统上访问 USB 设备。从现在起就熟悉这些 API，当这些项目可以在多个平台上发挥作用时，您就可以在自己的应用程序中加入 USB 功能了。</p>
<div class="c" id="weste_pagead_4"><script type="text/javascript">BAIDU_CLB_fillSlot("160927");</script></div></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/106.html'>Java如何处理ARP报文的收发</a><a>下一篇</a><a href='/java/biji/108.html'>常用数据库JDBC连接写法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>