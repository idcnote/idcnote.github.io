<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>审查Java代码的十一种常见错误_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="代码审查是消灭Bug最重要的方法之一，这些审查在大多数时候都特别奏效。由于代码审查本身所针对的对象，就是俯瞰整个代码在测试过程中的问题和Bug。" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">审查Java代码的十一种常见错误</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>代码审查是消灭Bug最重要的方法之一，这些审查在大多数时候都特别奏效。由于代码审查本身所针对的对象，就是俯瞰整个代码在测试过程中的问题和Bug。</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>&nbsp;&nbsp;&nbsp; 代码审查是消灭Bug最重要的方法之一，这些审查在大多数时候都特别奏效。由于代码审查本身所针对的对象，就是俯瞰整个代码在测试过程中的问题和Bug。并且，代码审查对消除一些特别细节的错误大有裨益，尤其是那些能够容易在阅读代码的时候发现的错误，这些错误往往不容易通过机器上的测试识别出来。本文就常见的Java代码中容易出现的问题提出一些建设性建议，以便您在审查代码的过程中注意到这些常见的细节性错误。</p>
<p>　　通常给别人的工作挑错要比找自己的错容易些。别样视角的存在也解释了为什么作者需要编辑，而运动员需要教练的原因。不仅不应当拒绝别人的批评，我们应该欢迎别人来发现并指出我们的编程工作中的不足之处，我们会受益匪浅的。</p>
<p>　&nbsp; 正规的代码审查(code inspection)是提高代码质量的最强大的技术之一，代码审查&mdash;由同事们寻找代码中的错误&mdash;所发现的错误与在测试中所发现的错误不同，因此两者的关系是互补的，而非竞争的。</p>
<p>　　如果审查者能够有意识地寻找特定的错误，而不是靠漫无目的的浏览代码来发现错误，那么代码审查的效果会事半功倍。在这篇文章中，我列出了11个Java编程中常见的错误。你可以把这些错误添加到你的代码审查的检查列表(checklist)中，这样在经过代码审查后，你可以确信你的代码中不再存在这类错误了。</p>
<p><strong>　　一、常见错误1# ：多次拷贝字符串</strong></p>
<p>　　测试所不能发现的一个错误是生成不可变(immutable)对象的多份拷贝。不可变对象是不可改变的，因此不需要拷贝它。最常用的不可变对象是String。</p>
<p>　　如果你必须改变一个String对象的内容，你应该使用StringBuffer。下面的代码会正常工作：</p>
<p>String s = new String (&quot;Text here&quot;);</p>
<p>　　但是，这段代码性能差，而且没有必要这么复杂。你还可以用以下的方式来重写上面的代码：</p>
<pre>
String temp = &quot;Text here&quot;;
String s = new String (temp);</pre>
<p>　　但是这段代码包含额外的String，并非完全必要。更好的代码为：</p>
<p>String s = &quot;Text here&quot;;</p>
<p><strong>　　二、常见错误2#： 没有克隆(clone)返回的对象</strong></p>
<p>　　封装(encapsulation)是面向对象编程的重要概念。不幸的是，Java为不小心打破封装提供了方便&mdash;&mdash;Java允许返回私有数据的引用(reference)。下面的代码揭示了这一点：</p>
<p>import java.awt.Dimension;<br />/***Example class.The x and y values should never*be negative.*/<br />public class Example{<br />　 private Dimension d = new Dimension (0, 0);<br />　 public Example (){ }</p>
<p>　 /*** Set height and width. Both height and width must be nonnegative * or an exception is thrown.*/<br />　 public synchronized void setValues (int height,int width) throws IllegalArgumentException{<br />　　 if (height &lt; 0 || width &lt; 0)<br />　　　 throw new IllegalArgumentException();<br />　　　 d.height = height;<br />　　&nbsp;&nbsp;&nbsp; d.width = width;<br />　 }</p>
<p>　 public synchronized Dimension getValues(){<br />　　 // Ooops! Breaks encapsulation<br />　　 return d;<br />　 }<br />}</p>
<p>　　Example类保证了它所存储的height和width值永远非负数，试图使用setValues()方法来设置负值会触发异常。不幸的是，由于getValues()返回d的引用，而不是d的拷贝，你可以编写如下的破坏性代码：</p>
<p>Example ex = new Example();<br />Dimension d = ex.getValues();<br />d.height = -5;<br />d.width = -10;</p>
<p>　　现在，Example对象拥有负值了！如果getValues() 的调用者永远也不设置返回的Dimension对象的width 和height值，那么仅凭测试是不可能检测到这类的错误。</p>
<p>　　不幸的是，随着时间的推移，客户代码可能会改变返回的Dimension对象的值，这个时候，追寻错误的根源是件枯燥且费时的事情，尤其是在多线程环境中。</p>
<p>　　更好的方式是让getValues()返回拷贝：</p>
<p>public synchronized Dimension getValues(){<br />return new Dimension (d.x, d.y);<br />}</p>
<p>　　现在，Example对象的内部状态就安全了。调用者可以根据需要改变它所得到的拷贝的状态，但是要修改Example对象的内部状态，必须通过setValues()才可以。</p>
<p><strong>　　三、常见错误3#：不必要的克隆</strong></p>
<p>　　我们现在知道了get方法应该返回内部数据对象的拷贝，而不是引用。但是，事情没有绝对：</p>
<p>/*** Example class.The value should never * be negative.*/<br />public class Example{<br />　 private Integer i = new Integer (0);<br />　 public Example (){ }</p>
<p>　 /*** Set x. x must be nonnegative* or an exception will be thrown*/<br />　 public synchronized void setValues (int x) throws IllegalArgumentException{<br />　　 if (x &lt; 0)<br />　　　 throw new IllegalArgumentException();<br />　　　 i = new Integer (x);<br />　 }</p>
<p>　 public synchronized Integer getValue(){<br />　　 // We can&rsquo;t clone Integers so we makea copy this way.<br />　　 return new Integer (i.intValue());<br />　 }<br />}</p>
<p>　　这段代码是安全的，但是就象在错误1#那样，又作了多余的工作。Integer对象，就象String对象那样，一旦被创建就是不可变的。因此，返回内部Integer对象，而不是它的拷贝，也是安全的。</p>
<p>　　方法getValue()应该被写为：</p>
<p>public synchronized Integer getValue(){<br />// &rsquo;i&rsquo; is immutable, so it is safe to return it instead of a copy.<br />return i;<br />}</p>
<p>　　Java程序比C++程序包含更多的不可变对象。JDK 所提供的若干不可变类包括：</p>
<p>　　&middot;Boolean<br />　　 &middot;Byte<br />　　 &middot;Character<br />　　 &middot;Class<br />　　 &middot;Double<br />　　 &middot;Float<br />　　 &middot;Integer<br />　　 &middot;Long<br />　　 &middot;Short<br />　　 &middot;String<br />　　 &middot;大部分的Exception的子类</p>
<p><strong>&nbsp;&nbsp;&nbsp; 四、常见错误4# ：自编代码来拷贝数组</strong></p>
<p>　　Java允许你克隆数组，但是开发者通常会错误地编写如下的代码，问题在于如下的循环用三行做的事情，如果采用Object的clone方法用一行就可以完成：</p>
<p>public class Example{<br />　 private int[] copy;<br />　 /*** Save a copy of &rsquo;data&rsquo;. &rsquo;data&rsquo; cannot be null.*/<br />　 public void saveCopy (int[] data){<br />　　 copy = new int[data.length];<br />　　 for (int i = 0; i &lt; copy.length; ++i)<br />　　　 copy[i] = data[i];<br />　 }<br />}</p>
<p>　　这段代码是正确的，但却不必要地复杂。saveCopy()的一个更好的实现是：</p>
<p>void saveCopy (int[] data){<br />　 try{<br />　　 copy = (int[])data.clone();<br />　 }catch (CloneNotSupportedException e){<br />　　 // Can&rsquo;t get here.<br />　 }<br />}</p>
<p>　　如果你经常克隆数组，编写如下的一个工具方法会是个好主意：</p>
<p>&nbsp;</p>
<p>static int[] cloneArray (int[] data){<br />　 try{<br />　　 return(int[])data.clone();<br />　 }catch(CloneNotSupportedException e){<br />　　 // Can&rsquo;t get here.<br />　 }<br />}</p>
<p>　　这样的话，我们的saveCopy看起来就更简洁了：</p>
<p>void saveCopy (int[] data){<br />　 copy = cloneArray ( data);<br />}</p>
<p><strong>　　五、常见错误5#：拷贝错误的数据</strong></p>
<p>　　有时候程序员知道必须返回一个拷贝，但是却不小心拷贝了错误的数据。由于仅仅做了部分的数据拷贝工作，下面的代码与程序员的意图有偏差：</p>
<p>import java.awt.Dimension;<br />/*** Example class. The height and width values should never * be<br />negative. */<br />public class Example{<br />　 static final public int TOTAL_VALUES = 10;<br />　 private Dimension[] d = new Dimension[TOTAL_VALUES];<br />　 public Example (){ }</p>
<p>　 /*** Set height and width. Both height and width must be nonnegative * or an exception will be thrown. */<br />　 public synchronized void setValues (int index, int height, int width) throws IllegalArgumentException{<br />　　 if (height &lt; 0 || width &lt; 0)<br />　　　 throw new IllegalArgumentException();<br />　　　 if (d[index] == null)<br />　　　　 d[index] = new Dimension();<br />　　　　 d[index].height = height;<br />　　　　 d[index].width = width;<br />　 }<br />　 public synchronized Dimension[] getValues()<br />　　 throws CloneNotSupportedException{<br />　　　 return (Dimension[])d.clone();<br />　 }<br />}</p>
<p>　　这儿的问题在于getValues()方法仅仅克隆了数组，而没有克隆数组中包含的Dimension对象，因此，虽然调用者无法改变内部的数组使其元素指向不同的Dimension对象，但是调用者却可以改变内部的数组元素(也就是Dimension对象)的内容。方法getValues()的更好版本为：</p>
<p>public synchronized Dimension[] getValues() throws CloneNotSupportedException{<br />　 Dimension[] copy = (Dimension[])d.clone();<br />　 for (int i = 0; i &lt; copy.length; ++i){<br />　　 // NOTE: Dimension isn&rsquo;t cloneable.<br />　　 if (d != null)<br />　　　 copy[i] = new Dimension (d[i].height, d[i].width);<br />　 }<br />　 return copy;<br />}</p>
<p>　　在克隆原子类型数据的多维数组的时候，也会犯类似的错误。原子类型包括int,float等。简单的克隆int型的一维数组是正确的，如下所示：</p>
<p>public void store (int[] data) throws CloneNotSupportedException{<br />　 this.data = (int[])data.clone();<br />　 // OK<br />}</p>
<p>　　拷贝int型的二维数组更复杂些。Java没有int型的二维数组，因此一个int型的二维数组实际上是一个这样的一维数组：它的类型为int[]。简单的克隆int[][]型的数组会犯与上面例子中getValues()方法第一版本同样的错误，因此应该避免这么做。下面的例子演示了在克隆int型二维数组时错误的和正确的做法：</p>
<p>public void wrongStore (int[][] data) throws CloneNotSupportedException{<br />　 this.data = (int[][])data.clone(); // Not OK!<br />}<br />public void rightStore (int[][] data){<br />　 // OK!<br />　 this.data = (int[][])data.clone();<br />　 for (int i = 0; i &lt; data.length; ++i){<br />　　 if (data != null)<br />　　　 this.data[i] = (int[])data[i].clone();<br />　 }<br />}</p>
<p><br /><strong>　　 六、常见错误6#：检查new 操作的结果是否为null</strong></p>
<p>　　Java编程新手有时候会检查new操作的结果是否为null。可能的检查代码为：</p>
<p>Integer i = new Integer (400);<br />if (i == null)<br />throw new NullPointerException();</p>
<p>　　检查当然没什么错误，但却不必要，if和throw这两行代码完全是浪费，他们的唯一功用是让整个程序更臃肿，运行更慢。</p>
<p>　　C/C++程序员在开始写java程序的时候常常会这么做，这是由于检查C中malloc()的返回结果是必要的，不这样做就可能产生错误。检查C++中new操作的结果可能是一个好的编程行为，这依赖于异常是否被使能(许多编译器允许异常被禁止，在这种情况下new操作失败就会返回null)。在java 中，new 操作不允许返回null，如果真的返回null，很可能是虚拟机崩溃了，这时候即便检查返回结果也无济于事。</p>
<p>&nbsp;</p>
<p><strong>&nbsp;&nbsp;&nbsp; 七、常见错误7#：用== 替代.equals</strong></p>
<p>　　在Java中，有两种方式检查两个数据是否相等：通过使用==操作符，或者使用所有对象都实现的.equals方法。原子类型(int, flosat, char 等)不是对象，因此他们只能使用==操作符，如下所示：</p>
<p>int x = 4;<br />int y = 5;<br />if (x == y)<br />&nbsp;&nbsp; System.out.println (&quot;Hi&quot;);<br />// This &rsquo;if&rsquo; test won&rsquo;t compile.<br />if (x.equals (y))<br />&nbsp;&nbsp; System.out.println (&quot;Hi&quot;);</p>
<p>　　对象更复杂些，==操作符检查两个引用是否指向同一个对象，而equals方法则实现更专门的相等性检查。</p>
<p>　　更显得混乱的是由java.lang.Object 所提供的缺省的equals方法的实现使用==来简单的判断被比较的两个对象是否为同一个。</p>
<p>　　许多类覆盖了缺省的equals方法以便更有用些，比如String类，它的equals方法检查两个String对象是否包含同样的字符串，而Integer的equals方法检查所包含的int值是否相等。</p>
<p>　　大部分时候，在检查两个对象是否相等的时候你应该使用equals方法，而对于原子类型的数据，你用该使用==操作符。</p>
<p><strong>　　八、常见错误8#： 混淆原子操作和非原子操作</strong></p>
<p>　　Java保证读和写32位数或者更小的值是原子操作，也就是说可以在一步完成，因而不可能被打断，因此这样的读和写不需要同步。以下的代码是线程安全(thread safe)的：</p>
<p>public class Example{<br />　 private int value; // More code here...<br />　 public void set (int x){<br />　　 // NOTE: No synchronized keyword<br />　　 this.value = x;<br />　 }<br />}</p>
<p>　　不过，这个保证仅限于读和写，下面的代码不是线程安全的：</p>
<p>public void increment (){<br />　 // This is effectively two or three instructions:<br />　 // 1) Read current setting of &rsquo;value&rsquo;.<br />　 // 2) Increment that setting.<br />　 // 3) Write the new setting back.<br />　 ++this.value;<br />}</p>
<p>　　在测试的时候，你可能不会捕获到这个错误。首先，测试与线程有关的错误是很难的，而且很耗时间。其次，在有些机器上，这些代码可能会被翻译成一条指令，因此工作正常，只有当在其它的虚拟机上测试的时候这个错误才可能显现。因此最好在开始的时候就正确地同步代码：</p>
<p>public synchronized void increment (){<br />　 ++this.value;<br />}</p>
<p><strong>　　九、常见错误9#：在catch 块中作清除工作</strong></p>
<p>　　一段在catch块中作清除工作的代码如下所示：</p>
<p>OutputStream os = null;<br />try{<br />　 os = new OutputStream ();<br />　 // Do something with os here.<br />　 os.close();<br />}catch (Exception e){<br />　 if (os != null)<br />　 os.close();<br />}</p>
<p>　　尽管这段代码在几个方面都是有问题的，但是在测试中很容易漏掉这个错误。下面列出了这段代码所存在的三个问题：</p>
<p>　　1．语句os.close()在两处出现，多此一举，而且会带来维护方面的麻烦。</p>
<p>　　2．上面的代码仅仅处理了Exception，而没有涉及到Error。但是当try块运行出现了Error，流也应该被关闭。</p>
<p>　　3．close()可能会抛出异常。</p>
<p>　　上面代码的一个更优版本为：</p>
<p>OutputStream os = null;<br />try{<br />　 os = new OutputStream ();<br />　 // Do something with os here.<br />}finally{<br />　 if (os != null)<br />　　 os.close();<br />}</p>
<p>　　这个版本消除了上面所提到的两个问题：代码不再重复，Error也可以被正确处理了。但是没有好的方法来处理第三个问题，也许最好的方法是把close()语句单独放在一个try/catch块中。</p>
<p><strong>　　十、常见错误10#： 增加不必要的catch 块</strong></p>
<p>　　一些开发者听到try/catch块这个名字后，就会想当然的以为所有的try块必须要有与之匹配的catch块。</p>
<p>　　C++程序员尤其是会这样想，因为在C++中不存在finally块的概念，而且try块存在的唯一理由只不过是为了与catch块相配对。</p>
<p>　　增加不必要的catch块的代码就象下面的样子，捕获到的异常又立即被抛出：</p>
<p>try{<br />　 // Nifty code here<br />}catch(Exception e){<br />　 throw e;<br />}finally{<br />　 // Cleanup code here<br />}</p>
<p>　　不必要的catch块被删除后，上面的代码就缩短为：</p>
<p>try{<br />　 // Nifty code here<br />}finally{<br />　 // Cleanup code here<br />}</p>
<p>　　常见错误11#；没有正确实现equals，hashCode，或者clone 等方法</p>
<p>　　方法equals，hashCode，和clone 由java.lang.Object提供的缺省实现是正确的。不幸地是，这些缺省实现在大部分时候毫无用处，因此许多类覆盖其中的若干个方法以提供更有用的功能。但是，问题又来了，当继承一个覆盖了若干个这些方法的父类的时候，子类通常也需要覆盖这些方法。在进行代码审查时，应该确保如果父类实现了equals，hashCode，或者clone等方法，那么子类也必须正确。正确的实现equals，hashCode，和clone需要一些技巧。</p>
<p><strong>　　小结</strong></p>
<p>　　我在代码审查的时候至少遇到过一次这些错误，我自己也犯过其中的几个错误。好消息是只要你知道你在找什么错误，那么代码审查就很容易管理，错误也很容易被发现和修改。即便你找不到时间来进行正规的代码审查，以自审的方式把这些错误从你的代码中根除会大大节省你的调试时间。花时间在代码审查上是值得的。</p></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/96.html'>Eclipse五岁了：Java程序员的Eclipse情结</a><a>下一篇</a><a href='/java/biji/100.html'>在无线J2ME设备上实现超文本传输协议</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>