<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>什么是java线程同步_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="线程同步多线程之间调用同一对象时，为了运行的安全和准确性，需要对该对象进行同步，确保每一个线程用到的时候该对象的结果都是正确的，该对象的状态都是合理的，这部分涉及到同步、" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">什么是java线程同步</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>线程同步多线程之间调用同一对象时，为了运行的安全和准确性，需要对该对象进行同步，确保每一个线程用到的时候该对象的结果都是正确的，该对象的状态都是合理的，这部分涉及到同步、</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><span style="font-size: 18px;"><strong>线程同步</strong></span></p>
<p>多线程之间调用同一对象时，为了运行的安全和准确性，需要对该对象进行同步，确保每一个线程用到的时候该对象的结果都是正确的，该对象的状态都是合理的，这部分涉及到同步、线程锁等知识点。这部分的只是就涉及到了synchronized、同步锁（Lock）的概念。</p>
<p><strong>synchronized</strong></p>
<p>synchronized关键词可以修饰对象、方法，通常用法如下：</p>
<pre class="brush:php;toolbar:false">
//同步代码块
synchronized（Object object）{
...
}
//或者
//同步方法
public synchronized void test(){
...
}</pre>
<p>其中有一个同步监视器的概念，比如上面同步代码块的object对象以及同步方法的this对象就会同步监视，多个线程同时调用一个同步的代码块或者方法时，在任何时刻只能够一个线程能够获得该同步监视的对象锁，执行完代码之后才会释放该锁，在此期间其他调用的线程只能等待该锁被释放后才能调用。</p>
<p>上文中提到的SellRunnable类中的sell方法也用到了synchronized，上文中代码执行太快，所以感知不到，如果修改一下就能明白有没有synchronized的区别了。</p>
<pre class="brush:php;toolbar:false">
public class ThreadTest {
    public static void main(String[] args) {
        SellRunnable sellRunnable = new SellRunnable();
        Thread thread1 = new Thread(sellRunnable, &quot;1&quot;);
        Thread thread2 = new Thread(sellRunnable, &quot;2&quot;);
        Thread thread3 = new Thread(sellRunnable, &quot;3&quot;);
        thread2.start();
        thread1.start();
        thread3.start();
    }
}
class SellRunnable implements Runnable {
    //有十张票
    int index = 10;
    public void sell() {
        if (index &gt;= 1) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            index--;
            System.out.println(&quot;售货窗口：&quot; + Thread.currentThread().getName() + 
            &quot; 卖出了一张票,剩余：
            &quot; + index);
        } else {
            System.out.println(&quot;售货窗口：&quot; + Thread.currentThread().getName() + &quot; 买票时没票了&quot;);
        }
    }
    @Override
    public void run() {
        while (index &gt; 0) {
            System.out.println(&quot;售货窗口：&quot; + Thread.currentThread().getName() + &quot; 开始买票&quot;);
            sell();
        }
    }
}
//执行结果：
售货窗口：1 开始买票
售货窗口：2 开始买票
售货窗口：3 开始买票
售货窗口：2  卖出了一张票,剩余：9
售货窗口：2 开始买票
售货窗口：1  卖出了一张票,剩余：9
售货窗口：1 开始买票
售货窗口：3  卖出了一张票,剩余：8
售货窗口：3 开始买票
售货窗口：1  卖出了一张票,剩余：6
售货窗口：1 开始买票
售货窗口：2  卖出了一张票,剩余：6
售货窗口：2 开始买票
售货窗口：3  卖出了一张票,剩余：5
售货窗口：3 开始买票
售货窗口：1  卖出了一张票,剩余：4
售货窗口：1 开始买票
售货窗口：2  卖出了一张票,剩余：3
售货窗口：3  卖出了一张票,剩余：2
售货窗口：3 开始买票
售货窗口：2 开始买票
售货窗口：3  卖出了一张票,剩余：1
售货窗口：2  卖出了一张票,剩余：0
售货窗口：1  卖出了一张票,剩余：1
Process finished with exit code 0  //可以看到，票数减少是错误的
//sell方法添加synchronized修饰符后 执行结果：
public synchronized void sell() {
        if (index &gt;= 1) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            index--;
            System.out.println(&quot;售货窗口：&quot; + Thread.currentThread().getName() + 
            &quot; 卖出了一张票,剩余：
            &quot; + index);
        } else {
            System.out.println(&quot;售货窗口：&quot; + Thread.currentThread().getName() + &quot; 买票时没票了&quot;);
        }
    }
售货窗口：2 开始买票
售货窗口：3 开始买票
售货窗口：1 开始买票
售货窗口：2  卖出了一张票,剩余：9
售货窗口：2 开始买票
售货窗口：1  卖出了一张票,剩余：8
售货窗口：1 开始买票
售货窗口：3  卖出了一张票,剩余：7
售货窗口：3 开始买票
售货窗口：1  卖出了一张票,剩余：6
售货窗口：1 开始买票
售货窗口：2  卖出了一张票,剩余：5
售货窗口：2 开始买票
售货窗口：1  卖出了一张票,剩余：4
售货窗口：1 开始买票
售货窗口：1  卖出了一张票,剩余：3
售货窗口：1 开始买票
售货窗口：3  卖出了一张票,剩余：2
售货窗口：3 开始买票
售货窗口：1  卖出了一张票,剩余：1
售货窗口：1 开始买票
售货窗口：1  卖出了一张票,剩余：0
售货窗口：2 买票时没票了
售货窗口：3 买票时没票了
Process finished with exit code 0  // 可以看到，票数是正常减少的</pre>
<p>以上对于sell方法进行同步之后，在某一瞬间，只会有一个线程调用该方法，所以里面判断index的时候得到的结果就是正确的结果。</p>
<p>以上同步的时候，是以降低运行效率的方式来保证线程安全的，为此，不要对线程使用类中没必要的方法、对象进行同步标识，只对有竞争的资源或者代码进行同步标识。</p>
<p>同步标识后，有以下几点可以释放该锁：</p>
<p>代码块、方法执行完毕（正常完毕、return或break、抛出异常）</p>
<p>调用了wait方法，使得当前线程暂停。</p>
<p>当线程执行到同步代码块时，sleep、yield方法不会释放该同步锁，挂起方法suspend也不会（线程操作过程中尽量避免使用suspend、resume来操作线程状态，容易导致死锁。）</p>
<p><span style="font-size: 18px;"><strong>同步锁Lock</strong></span></p>
<p>上文中提到的synchronized是java中的一个关键词，也提到了在sleep的时候、进行IO操作的时候该线程不会释放线程锁，其他线程就需要一直等待，这样有时会降低执行的效率，所以就需要一个可以在线程阻塞时可以释放线程锁的替代方案，Lock就是为了解决这个问题出现的。</p>
<p>Lock是一个java中的类，在java.util.concurrent.locks包中，具体的代码如下：</p>
<pre class="brush:php;toolbar:false">
public interface Lock {
    void lock();//加锁
    void lockInterruptibly() throws InterruptedException;//加锁
    boolean tryLock();//加锁
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;//加锁
    void unlock();//释放锁
    Condition newCondition();//线程协作中用到
}</pre>
<p>Lock接口的一个实现子类为ReentrantLock，在java.util.concurrent.locks包下，ReentrantLock的源代码如下：</p>
<pre class="brush:php;toolbar:false">
public class ReentrantLock implements Lock, Serializable {
    private static final long serialVersionUID = 7373984872572414699L;
    private final ReentrantLock.Sync sync;
    public ReentrantLock() {
        this.sync = new ReentrantLock.NonfairSync();
    }
    public ReentrantLock(boolean var1) {//是否创建公平锁
        this.sync = (ReentrantLock.Sync)(var1?new ReentrantLock.FairSync():new  ReentrantLock.
        NonfairSync());
    }
    public void lock() {
        this.sync.lock();
    }
    public void lockInterruptibly() throws InterruptedException {
        this.sync.acquireInterruptibly(1);
    }
    public boolean tryLock() {
        return this.sync.nonfairTryAcquire(1);
    }
    public boolean tryLock(long var1, TimeUnit var3) throws InterruptedException {
        return this.sync.tryAcquireNanos(1, var3.toNanos(var1));
    }
    public void unlock() {
        this.sync.release(1);
    }
    public Condition newCondition() {
        return this.sync.newCondition();
    }
    public int getHoldCount() {//当前线程持有该锁的数量
        return this.sync.getHoldCount();
    }
    public boolean isHeldByCurrentThread() {//该锁是否被当前线程持有
        return this.sync.isHeldExclusively();
    }
    public boolean isLocked() {//是否被其他线程持有该锁
        return this.sync.isLocked();
    }
    public final boolean isFair() {//是否是公平锁
        return this.sync instanceof ReentrantLock.FairSync;
    }
    protected Thread getOwner() {//当前锁的持有线程
        return this.sync.getOwner();
    }
    public final boolean hasQueuedThreads() {//是否有线程在等待该锁
        return this.sync.hasQueuedThreads();
    }
    public final boolean hasQueuedThread(Thread var1) {//目标线程是否在等待该锁
        return this.sync.isQueued(var1);
    }
    public final int getQueueLength() {//等待该锁线程的数量
        return this.sync.getQueueLength();
    }
    protected Collection&lt;Thread&gt; getQueuedThreads() {//获取所有等待该锁的线程集合
        return this.sync.getQueuedThreads();
    }
    ...
    
}</pre>
<p><span style="font-size: 18px;"><strong>Lock的使用方法</strong></span></p>
<p>lock</p>
<p>lock() 用来获取锁，如果该锁被其他线程占用，则进入等待。</p>
<pre class="brush:php;toolbar:false">
public class LockTest {
    public static void main(String[] args) {
        com.test.java.SellRunnable sellRunnable = new com.test.java.SellRunnable();
        Thread thread1 = new Thread(sellRunnable, &quot;1号窗口&quot;);
        Thread thread2 = new Thread(sellRunnable, &quot;2号窗口&quot;);
        Thread thread3 = new Thread(sellRunnable, &quot;3号窗口&quot;);
        thread1.start();
        thread2.start();
        thread3.start();
    }
}</pre>
<pre class="brush:php;toolbar:false">
public class SellRunnable implements Runnable {
    //有十张票
    int index = 10;
    Lock lock = new ReentrantLock();
    public void sell() {
        try {
            lock.lock();
            System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
            &quot;获取了票源+++++&quot;);
            if (index &gt;= 1) {
                index--;
                System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                &quot;卖出了一张票,剩余：
                &quot; + index);
            } else {
                System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                &quot;买票时没票了000&quot;);
            }
        } finally {
            lock.unlock();
        }
    }
    @Override
    public void run() {
        while (index &gt; 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            sell();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：9
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：8
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：7
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：6
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：5
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：4
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：3
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：2
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：1
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：0
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口买票时没票了000
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口买票时没票了000
Process finished with exit code 0  //每一个窗口都随机获取票源、然后卖出票</pre>
<p>tryLock</p>
<p>tryLock()尝试获取锁，如果获取成功返回true，如果失败，则返回false，不会进入等待状态。</p>
<pre class="brush:php;toolbar:false">
public class SellRunnable implements Runnable {
    //有十张票
    int index = 10;
    Lock lock = new ReentrantLock();
    public void sell() {
        if (lock.tryLock()) {
            try {
                System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                &quot;获取了票源+++++&quot;);
                if (index &gt;= 1) {
                    index--;
                    System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                    &quot;卖出了一张票,剩余：&quot; + index);
                } else {
                    System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                    &quot;买票时没票了000&quot;);
                }
            } finally {
                lock.unlock();
            }
        } else {
           System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName()+&quot;没有获取票源！！！&quot;);
        }
    }
    @Override
    public void run() {
        while (index &gt; 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            sell();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
售货柜台：1号窗口获取了票源+++++
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口没有获取票源！！！
售货柜台：1号窗口卖出了一张票,剩余：9
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：8
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：7
售货柜台：1号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：6
售货柜台：1号窗口获取了票源+++++
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口卖出了一张票,剩余：5
售货柜台：2号窗口获取了票源+++++
售货柜台：1号窗口没有获取票源！！！
售货柜台：2号窗口卖出了一张票,剩余：4
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口获取了票源+++++
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口卖出了一张票,剩余：3
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：2
售货柜台：2号窗口获取了票源+++++
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口卖出了一张票,剩余：1
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：0
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口没有获取票源！！！
Process finished with exit code 0//没有获取到货源的票口，就直接没有等待，进入下次买票</pre>
<p>tryLock(long time, TimeUnit unit)</p>
<p>tryLock(long time, TimeUnit unit)可以设置拿不到锁的时候等待一段时间。//第一个参数时常长，第二个参数时间单位</p>
<pre class="brush:php;toolbar:false">
public class SellRunnable implements Runnable {
    //有十张票
    int index = 10;
    Lock lock = new ReentrantLock();
    public void sell() {
        try {
            if (lock.tryLock(1000, TimeUnit.MILLISECONDS)) {
                try {
                    System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                    &quot;获取了票源+++++&quot;);
                    if (index &gt;= 1) {
                        index--;
                        System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName()
                         +&quot;卖出了一张票,剩余：&quot; + index);
                    } else {
                        System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().
                        getName()  + &quot;买票时没票了000&quot;);
                    }
                    try {
                        Thread.sleep(2000);//人为加入买票时间
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println(&quot;售货柜台：&quot; + Thread.currentThread().getName() + 
                &quot;没有获取票源！！！&quot;);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    @Override
    public void run() {
        while (index &gt; 0) {
            try {
                Thread.sleep(500);//要不执行太快，看不出效果
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            sell();
        }
    }
}</pre>
<p>执行结果：</p>
<pre class="brush:php;toolbar:false">
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：9
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：8
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口没有获取票源！！！
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：7
售货柜台：1号窗口没有获取票源！！！
售货柜台：2号窗口没有获取票源！！！
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：6
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：5
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口没有获取票源！！！
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：4
售货柜台：1号窗口没有获取票源！！！
售货柜台：2号窗口没有获取票源！！！
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：3
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：2
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口没有获取票源！！！
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：1
售货柜台：1号窗口没有获取票源！！！
售货柜台：2号窗口没有获取票源！！！
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：0
售货柜台：2号窗口没有获取票源！！！
售货柜台：3号窗口没有获取票源！！！
Process finished with exit code 0 //当买票时间大约等待时间时，则没有获取票源的窗口不买票，进入下个买票机会</pre>
<p>将买票时间缩短：</p>
<pre class="brush:php;toolbar:false">
try {
    Thread.sleep(500);//人为加入买票时间
} catch (InterruptedException e) {
    e.printStackTrace();
}</pre>
<p>执行结果：</p>
<pre class="brush:php;toolbar:false">
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：9
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：8
售货柜台：3号窗口没有获取票源！！！
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：7
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：6
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：5
售货柜台：3号窗口没有获取票源！！！
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：4
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：3
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：2
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：1
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：0
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口买票时没票了000
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口买票时没票了000
Process finished with exit code 0 //等待时间内获取到票源了，也就卖出票了</pre>
<p>lockInterruptibly</p>
<p>lockInterruptibly()通过该方法获取锁时，如果该锁正在被其他线程持有，则进入等待状态，但是这个等待过程是可以被中断的，通过调用Thread对象的interrupt方法就可中断等待，中断时抛出异常InterruptedException，需要捕获或者声明抛出。</p>
<pre class="brush:php;toolbar:false">
public class ThreadTest {
    public static void main(String[] args) {
        SellRunnable sellRunnable = new SellRunnable();
        Thread thread1 = new Thread(sellRunnable, &quot;1号窗口&quot;);
        Thread thread2 = new Thread(sellRunnable, &quot;2号窗口&quot;);
        Thread thread3 = new Thread(sellRunnable, &quot;3号窗口&quot;);
        thread1.start();
        try {
            Thread.sleep(500);//确保窗口1号先获取锁
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread2.start();
        thread3.start();
        try {
            Thread.sleep(2000);//等待两秒后，打断窗口2、3的等待
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread2.interrupt();
        thread3.interrupt();
    }
}
SellRunnable中等待时间加长：
try {
    Thread.sleep(5000);//人为加入买票时间
} catch (InterruptedException e) {
    e.printStackTrace();
}</pre>
<p>执行结果：</p>
<pre class="brush:php;toolbar:false">
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：9
售货柜台：3号窗口被打断了      //这个地方被打断了
售货柜台：2号窗口被打断了      //这个地方被打断了
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：8
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：7
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：6
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：5
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：4
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：3
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口卖出了一张票,剩余：2
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口卖出了一张票,剩余：1
售货柜台：1号窗口获取了票源+++++
售货柜台：1号窗口卖出了一张票,剩余：0
售货柜台：2号窗口获取了票源+++++
售货柜台：2号窗口买票时没票了000
售货柜台：3号窗口获取了票源+++++
售货柜台：3号窗口买票时没票了000
Process finished with exit code 0</pre>
<p><span style="font-size: 18px;"><strong>synchronized和Lock对比</strong></span></p>
<p>通过以上代码，可以看出Lock和synchronized的几点关联和区别：</p>
<p>两者都是可重入锁</p>
<p>可重入锁是指当一个线程获得对象锁之后，该线程可以再次获取该对象的锁而不被阻塞。比如同一个类中有多个方法（或一个方法递归调用）被synchronized修饰或者被Lock加持后，同一个线程在调用这两个方法时都可以获取该对象的锁而不被阻塞。</p>
<p>不可重入锁的示例：</p>
<pre class="brush:php;toolbar:false">
public class Lock{
    private boolean isLocked = false;
    public void lock(){
        while(isLocked){    
            wait();
        }
        isLocked = true;
    }
    public void unlock(){
        isLocked = false;
        notify();
    }
}
//使用方法：
public class Test{
    Lock lock = new Lock();
    public void test1(){
        lock.lock();
        test2();
        lock.unlock();
    }
    public void test2(){
        lock.lock();
        ...
        lock.unlock();
    }
}</pre>
<p>Test类在调用test1方法的时候，执行完lock.lock()后调用test2的时候，就会一直等待，变成死锁。</p>
<p>可重入锁设计原理：</p>
<pre class="brush:php;toolbar:false">
public class Lock{
    private boolean isLocked = false;
    private Thread lockedThread = null;
    int lockedCount = 0;
    public void lock(){
        Thread thread = Thread.currentThread();
        while(isLocked &amp;&amp; thread != lockedThread){    
            wait();
        }
        isLocked = true;
        lockedCount++;
        lockedThread = thread;
    }
    public void unlock(){
        Thread thread = Thread.currentThread();
        if(thread == lockedThread){    
            lockedCount--;
            if(lockedCount == 0){
                isLocked = false;
                lockedThread = null;
                notify();
            }
        }
    }
}</pre>
<p>这样调用Test类的test1方法后，test2方法也能顺利被执行。</p>
<p>synchronized在实现上也基本上是采用记数器的方式来实现可重入的。</p>
<p>Lock是可中断锁，synchronized不可中断。</p>
<p>当一个线程B执行被锁的对象的代码时，发现线程A已经持有该锁，那么线程B就会进入等待，但是synchronized就无法中断该等待过程，而Lock就可以通过lockInterruptibly方法抛出异常从而中断等待，去处理别的事情。</p>
<p>Lock可创建公平锁，synchronized是非公平锁。</p>
<p>公平锁的意思是按照请求的顺序来获取锁，不平公锁就无法保证线程获取锁的先后次序。</p>
<p>Lock可以知道是否获取到锁，synchronized不可以。</p>
<p>synchronized在发生异常或者运行完毕，会自动释放线程占有的锁。而Lock需要主动释放锁，否则会锁死；</p>
<p>synchronized在阻塞时，别的线程无法获取锁，Lock可以（这也是lock设计的一个目的）。</p>
<p><span style="font-size: 18px;"><strong>读写锁</strong></span></p>
<p>多个线程对同一个文件进行写操作时，会发生冲突所以需要加锁，但是对同一个文件进行读操作的时候，使用上面的方法会造成效率的降低，所以基于这种情况，产生了ReadWriteLock这个接口：</p>
<pre class="brush:php;toolbar:false">
public interface ReadWriteLock {
    /**
     * Returns the lock used for reading.
     *
     * @return the lock used for reading.
     */
    Lock readLock();//读的锁
 
    /**
     * Returns the lock used for writing.
     *
     * @return the lock used for writing.
     */
    Lock writeLock();//写的锁
}</pre>
<p>这个接口的实现类是ReentrantReadWriteLock，其源代码如下：</p>
<pre class="brush:php;toolbar:false">
public class ReentrantReadWriteLock implements ReadWriteLock, Serializable {
    private static final long serialVersionUID = -6992448646407690164L;
    private final ReentrantReadWriteLock.ReadLock readerLock;
    private final ReentrantReadWriteLock.WriteLock writerLock;
    ...
    public ReentrantReadWriteLock.WriteLock writeLock() {//获取write lock
        return this.writerLock;
    }
    public ReentrantReadWriteLock.ReadLock readLock() {//获取read lock
        return this.readerLock;
    }
    ...
}</pre>
<p>使用方法和Lock一样，使用到write时调用writeLock()方法获取lock进行加锁，使用到read时调用readLock()方法进行加锁，需要注意的知识点如下：</p>
<p>线程A占用写锁，线程B在申请写、读的时候需要等待。</p>
<p>线程A占用读锁，线程B在申请写操作时，需要等待。</p>
<p>线程A占用读锁，线程B获取读操作时可以获取到。</p>
<p><span style="font-size: 18px;"><strong>总结</strong></span></p>
<p>如果需要效率提升，则建议使用Lock，如果效率要求不高，则synchronized满足使用条件，业务逻辑写起来也简单，不需要手动释放锁。</p><!-- .entry-wrapper --></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/1307.html'>java中什么是异常？</a><a>下一篇</a><a href='/java/biji/1309.html'>java函数有哪些？</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>