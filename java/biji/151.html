<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>100行Java代码构建一个线程池_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="在现代的操作系统中，有一个很重要的概念――线程，几乎所有目前流行的操作系统都支持线程，线程来源于操作系统中进程的概念，进程有自己的虚拟地址空间以及正文段" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">100行Java代码构建一个线程池</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>在现代的操作系统中，有一个很重要的概念――线程，几乎所有目前流行的操作系统都支持线程，线程来源于操作系统中进程的概念，进程有自己的虚拟地址空间以及正文段</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>&nbsp;&nbsp;&nbsp; 在现代的操作系统中，有一个很重要的概念――线程，几乎所有目前流行的操作系统都支持线程，线程来源于操作系统中进程的概念，进程有自己的虚拟地址空间以及正文段、数据段及堆栈，而且各自占有不同的系统资源（例如文件、环境变量等等）。与此不同，线程不能单独存在，它依附于进程，只能由进程派生。如果一个进程派生出了两个线程，那这两个线程共享此进程的全局变量和代码段，但每个线程各拥有各自的堆栈，因此它们拥有各自的局部变量，线程在UNIX系统中还被进一步分为用户级线程（由进程自已来管理）和系统级线程（由操作系统的调度程序来管理）。</p>
<p>　　既然有了进程，为什么还要提出线程的概念呢？因为与创建一个新的进程相比，创建一个线程将会耗费小得多的系统资源，对于一些小型的应用，可能感觉不到这点，但对于那些并发进程数特别多的应用，使用线程会比使用进程获得更好的性能，从而降低操作系统的负担。另外，线程共享创建它的进程的全局变量，因此线程间的通讯编程会更将简单，完全可以抛弃传统的进程间通讯的IPC编程，而采用共享全局变量来进行线程间通讯。</p>
<p>　　有了上面这个概念，我们下面就进入正题，来看一下线程池究竟是怎么一回事？其实线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。可能你也许会问：为什么要搞得这么麻烦，如果每当客户端有新的请求时，我就创建一个新的线程不就完了？这也许是个不错的方法，因为它能使得你编写代码相对容易一些，但你却忽略了一个重要的问题――性能！就拿我所在的单位来说，我的单位是一个省级数据大集中的银行网络中心，高峰期每秒的客户端请求并发数超过100，如果为每个客户端请求创建一个新线程的话，那耗费的CPU时间和内存将是惊人的，如果采用一个拥有200个线程的线程池，那将会节约大量的的系统资源，使得更多的CPU时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁。</p>
<p>　　既然一切都明白了，那我们就开始着手实现一个真正的线程池吧，线程编程可以有多种语言来实现，例如C、C＋＋、java等等，但不同的操作系统提供不同的线程API接口，为了让你能更明白线程池的原理而避免陷入烦琐的API调用之中，我采用了JAVA语言来实现它，由于JAVA语言是一种跨平台的语言，因此你不必为使用不同的操作系统而无法编译运行本程序而苦恼，只要你安装了JDK1.2以上的版本，都能正确地编译运行本程序。另外JAVA语言本身就内置了线程对象，而且JAVA语言是完全面像对象的，因此能够让你更清晰地了解线程池的原理，如果你注意看一下本文的标题，你会发现整个示例程序的代码只有大约100行。</p>
<p>　　本示例程序由三个类构成，第一个是TestThreadPool类，它是一个测试程序，用来模拟客户端的请求，当你运行它时，系统首先会显示线程池的初始化信息，然后提示你从键盘上输入字符串，并按下回车键，这时你会发现屏幕上显示信息，告诉你某个线程正在处理你的请求，如果你快速地输入一行行字符串，那么你会发现线程池中不断有线程被唤醒，来处理你的请求，在本例中，我创建了一个拥有10个线程的线程池，如果线程池中没有可用线程了，系统会提示你相应的警告信息，但如果你稍等片刻，那你会发现屏幕上会陆陆续续提示有线程进入了睡眠状态，这时你又可以发送新的请求了。</p>
<p>　　第二个类是ThreadPoolManager类，顾名思义，它是一个用于管理线程池的类，它的主要职责是初始化线程池，并为客户端的请求分配不同的线程来进行处理，如果线程池满了，它会对你发出警告信息。</p>
<p>　　最后一个类是SimpleThread类，它是Thread类的一个子类，它才真正对客户端的请求进行处理，SimpleThread在示例程序初始化时都处于睡眠状态，但如果它接受到了ThreadPoolManager类发过来的调度信息，则会将自己唤醒，并对请求进行处理。</p>
<p>&nbsp;&nbsp;&nbsp; 首先我们来看一下TestThreadPool类的源码：</p>
<p>//TestThreadPool.java<br />1 import java.io.*;<br />2<br />3<br />4 public class TestThreadPool<br />5 {<br />6 public static void main(String[] args)<br />7 {<br />8 try{<br />9 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<br />10 String s;<br />11 ThreadPoolManager manager = new ThreadPoolManager(10);<br />12 while((s = br.readLine()) != null)<br />13 {<br />14 manager.process(s);<br />15 }<br />16 }catch(IOException e){}<br />17 }<br />18 }</p>
<p>　　由于此测试程序用到了输入输入类，因此第1行导入了JAVA的基本IO处理包，在第11行中，我们创建了一个名为manager的类，它给ThreadPoolManager类的构造函数传递了一个值为10的参数，告诉ThreadPoolManager类：我要一个有10个线程的池，给我创建一个吧！第12行至15行是一个无限循环，它用来等待用户的键入，并将键入的字符串保存在s变量中，并调用ThreadPoolManager类的process方法来将这个请求进行处理。</p>
<p>　　下面我们再进一步跟踪到ThreadPoolManager类中去，以下是它的源代码：</p>
<p>//ThreadPoolManager.java<br />1 import java.util.*;<br />2<br />3<br />4 class ThreadPoolManager<br />5 {<br />6<br />7 private int maxThread;<br />8 public Vector vector;<br />9 public void setMaxThread(int threadCount)<br />10 {<br />11 maxThread = threadCount;<br />12 }<br />13<br />14 public ThreadPoolManager(int threadCount)<br />15 {<br />16 setMaxThread(threadCount);<br />17 System.out.println(&quot;Starting thread pool...&quot;);<br />18 vector = new Vector();<br />19 for(int i = 1; i &lt;= 10; i++)<br />20 {<br />21 SimpleThread thread = new SimpleThread(i);<br />22 vector.addElement(thread);<br />23 thread.start();<br />24 }<br />25 }<br />26<br />27 public void process(String argument)<br />28 {<br />29 int i;<br />30 for(i = 0; i &lt; vector.size(); i++)<br />31 {<br />32 SimpleThread currentThread = (SimpleThread)vector.elementAt(i);<br />33 if(!currentThread.isRunning())<br />34 {<br />35 System.out.println(&quot;Thread &quot;+ (i+1) +&quot; is processing:&quot; +<br />argument);<br />36 currentThread.setArgument(argument);<br />37 currentThread.setRunning(true);<br />38 return;<br />39 }<br />40 }<br />41 if(i == vector.size())<br />42 {<br />43 System.out.println(&quot;pool is full, try in another time.&quot;);<br />44 }<br />45 }<br />46 }//end of class ThreadPoolManager</p>
<p>　　我们先关注一下这个类的构造函数，然后再看它的process()方法。第16－24行是它的构造函数，首先它给ThreadPoolManager类的成员变量maxThread赋值，maxThread表示用于控制线程池中最大线程的数量。第18行初始化一个数组vector，它用来存放所有的SimpleThread类，这时候就充分体现了JAVA语言的优越性与艺术性：如果你用C语言的话，至少要写100行以上的代码来完成vector的功能，而且C语言数组只能容纳类型统一的基本数据类型，无法容纳对象。好了，闲话少说，第19－24行的循环完成这样一个功能：先创建一个新的SimpleThread类，然后将它放入vector中去，最后用thread.start()来启动这个线程，为什么要用start()方法来启动线程呢？因为这是JAVA语言中所规定的，如果你不用的话，那这些线程将永远得不到激活，从而导致本示例程序根本无法运行。</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 下面我们再来看一下process()方法，第30－40行的循环依次从vector数组中选取SimpleThread线程，并检查它是否处于激活状态（所谓激活状态是指此线程是否正在处理客户端的请求），如果处于激活状态的话，那继续查找vector数组的下一项，如果vector数组中所有的线程都处于激活状态的话，那它会打印出一条信息，提示用户稍候再试。相反如果找到了一个睡眠线程的话，那第35－38行会对此进行处理，它先告诉客户端是哪一个线程来处理这个请求，然后将客户端的请求，即字符串argument转发给SimpleThread类的setArgument()方法进行处理，并调用SimpleThread类的setRunning()方法来唤醒当前线程，来对客户端请求进行处理。</p>
<p>　　可能你还对setRunning()方法是怎样唤醒线程的有些不明白，那我们现在就进入最后一个类：SimpleThread类，它的源代码如下：</p>
<p>//SimpleThread.java<br />1 class SimpleThread extends Thread<br />2 {<br />3 private boolean runningFlag;<br />4 private String argument;<br />5 public boolean isRunning()<br />6 {<br />7 return runningFlag;<br />8 }<br />9 public synchronized void setRunning(boolean flag)<br />10 {<br />11 runningFlag = flag;<br />12 if(flag)<br />13 this.notify();<br />14 }<br />15<br />16 public String getArgument()<br />17 {<br />18 return this.argument;<br />19 }<br />20 public void setArgument(String string)<br />21 {<br />22 argument = string;<br />23 }<br />24<br />25 public SimpleThread(int threadNumber)<br />26 {<br />27 runningFlag = false;<br />28 System.out.println(&quot;thread &quot; + threadNumber + &quot;started.&quot;);<br />29 }<br />30<br />31 public synchronized void run()<br />32 {<br />33 try{<br />34 while(true)<br />35 {<br />36 if(!runningFlag)<br />37 {<br />38 this.wait();<br />39 }<br />40 else<br />41 {<br />42 System.out.println(&quot;processing &quot; + getArgument() + &quot;... done.&quot;);<br />43 sleep(5000);<br />44 System.out.println(&quot;Thread is sleeping...&quot;);<br />45 setRunning(false);<br />46 }<br />47 }<br />48 } catch(InterruptedException e){<br />49 System.out.println(&quot;Interrupt&quot;);<br />50 }<br />51 }//end of run()<br />52 }//end of class SimpleThread</p>
<p>　　如果你对JAVA的线程编程有些不太明白的话，那我先在这里简单地讲解一下，JAVA有一个名为Thread的类，如果你要创建一个线程，则必须要从Thread类中继承，并且还要实现Thread类的run()接口，要激活一个线程，必须调用它的start()方法，start()方法会自动调用run()接口，因此用户必须在run()接口中写入自己的应用处理逻辑。那么我们怎么来控制线程的睡眠与唤醒呢？其实很简单，JAVA语言为所有的对象都内置了wait()和notify()方法，当一个线程调用wait()方法时，则线程进入睡眠状态，就像停在了当前代码上了，也不会继续执行它以下的代码了，当调用notify()方法时，则会从调用wait()方法的那行代码继续执行以下的代码，这个过程有点像编译器中的断点调试的概念。以本程序为例，第38行调用了wait()方法，则这个线程就像凝固了一样停在了38行上了，如果我们在第13行进行一个notify()调用的话，那线程会从第38行上唤醒，继续从第39行开始执行以下的代码了。</p>
<p>　　通过以上的讲述，我们现在就不难理解SimpleThread类了，第9－14行通过设置一个标志runningFlag激活当前线程，第25－29行是SimpleThread类的构造函数，它用来告诉客户端启动的是第几号进程。第31－50行则是我实现的run()接口，它实际上是一个无限循环，在循环中首先判断一下标志runningFlag，如果没有runningFlag为false的话，那线程处理睡眠状态，否则第42－45行会进行真正的处理：先打印用户键入的字符串，然后睡眠5秒钟，为什么要睡眠5秒钟呢？如果你不加上这句代码的话，由于计算机处理速度远远超过你的键盘输入速度，因此你看到的总是第1号线程来处理你的请求，从而达不到演示效果。最后第45行调用setRunning()方法又将线程置于睡眠状态，等待新请求的到来。</p>
<p>　　最后还有一点要注意的是，如果你在一个方法中调用了wait()和notify()函数，那你一定要将此方法置为同步的，即synchronized，否则在编译时会报错，并得到一个莫名其妙的消息：&ldquo;current thread not owner&rdquo;（当前线程不是拥有者）。</p>
<p>　　至此为止，我们完整地实现了一个线程池，当然，这个线程池只是简单地将客户端输入的字符串打印到了屏幕上，而没有做任何处理，对于一个真正的企业级运用，本例还是远远不够的，例如错误处理、线程的动态调整、性能优化、临界区的处理、客户端报文的定义等等都是值得考虑的问题，但本文的目的仅仅只是让你了解线程池的概念以及它的简单实现，如果你想成为这方面的高手，本文是远远不够的，你应该参考一些更多的资料来深入地了解它。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/150.html'>Java中关于XML的API惊鸿一瞥_</a><a>下一篇</a><a href='/java/biji/152.html'>利用JBuilder2005开发Web应用程序</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>