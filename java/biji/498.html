<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>java———面向对象详细介绍（二）_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="11、子类访问父类和方法覆写子类不能直接访问父类的私有成员；但是子类可以调用父类中的非私有方法来间接访问父类的私有成员。Person类中有私有字段name,Student继承Personne" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">java———面向对象详细介绍（二）</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>11、子类访问父类和方法覆写子类不能直接访问父类的私有成员；但是子类可以调用父类中的非私有方法来间接访问父类的私有成员。Person类中有私有字段name,Student继承Personne</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>11、子类访问父类和方法覆写</strong></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(20, 25, 30); font-family: &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, Helvetica, &quot;Helvetica Neue&quot;, å¾®è½¯é›…é»‘, Tahoma, Arial, sans-serif; font-size: 14px;">子类不能直接访问父类的私有成员；</span></p>
<p>但是子类可以调用父类中的非私有方法来间接访问父类的私有成员。</p>
<p>Person类中有私有字段name,Student继承Person</p>
<p>new Sudent().name; &times;</p>
<p>new Student().getName(); &radic;</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p>
<p>子类拓展父类（子类是父类的一种特殊情况）</p>
<p>主要是以父类为基础，然后添加属于自己的字段和方法。</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p>
<p>方法覆写产生原因：</p>
<p>当父类中某个方法不适合于子类时,子类出现父类一模一样的方法.</p>
<p>判断必杀技:子类方法前加上@Override能编译通过,表明是方法的覆写。</p>
<p>调用被覆盖的父类方法：使用super.方法名(实参);</p>
<p>方法覆写时应遵循的原则(一同两小一大)：</p>
<p>(一同):</p>
<p>方法签名必须相同;</p>
<p>(两小):</p>
<p>子类方法的返回值类型比父类方法的返回值类型更小或相等</p>
<p>子类方法声明抛出的异常应比父类方法申明抛出的异常更小或相等;</p>
<p>(一大):子类方法的访问权限应比父类方法更大或相等;</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p>
<p>子类需要覆写父类方法。</p>
<p>当父类的某个方法不适合于子类本身的特征行为时就当覆写父类中应当改变的方法。</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>12、super关键字和调用父类构造方法</strong></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(20, 25, 30); font-family: &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, Helvetica, &quot;Helvetica Neue&quot;, å¾®è½¯é›…é»‘, Tahoma, Arial, sans-serif; font-size: 14px;">表示父类对象的默认引用</span></p>
<p>如果子类要调用父类被覆盖的实例方法，可用super作为调用者调用父类被覆盖的实例方法。</p>
<p>使用super调用父类方法</p>
<p>使用super调用父类的构造方法</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p>
<p><strong>调用构造方法</strong></p>
<p>本类中调用另一个重载构造方法用this(参数列表)</p>
<p>子类构造方法调用父类构造方法用super(参数列表)</p>
<p><strong>子类调用父类的构造方法时：</strong></p>
<p>super必须放在第一句</p>
<p>Java在执行子类的构造方法前会先调用父类无参的构造方法，其目的是为了对继承自父类的成员做初始化操作。</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 14px;">子类在创建对象的时候，默认调用父类的无参构造方法，要是子类构造方法中显示指定调用父类其他构造方法，就调用指定的父类构造方法，取消调用父类无参构造方法。</span></p>
<pre class="brush:php;toolbar:false">
Eg：
 
package reviewDemo;
 
 
 
class A{
 
   String name;
 
   A(){
 
      System.out.println(&quot;父类默认隐式的构造方法！&quot;);
 
   }
 
  
 
   A(String name){
 
      System.out.println(&quot;父类显式的构造方法！&quot;);
 
   }
 
}
 
 
 
class B extends A{
 
  
 
   B(){
 
      super(null);
 
      System.out.println(&quot;子类默认隐式的构造方法！&quot;);
 
   }
 
}
 
 
 
public class Demo10 {
 
   public static void main(String[] args) {
 
      new B();
 
   }
 
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>13、面向对象之多态</strong></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);">&nbsp;</p>
<p>多态:指同一个实体同时具有多种形式</p>
<p>好比,你去面馆吃面,说我要吃面,那么;老板给我牛肉面,鸡蛋面等都可以,</p>
<p>这就是说&quot;面&quot;有多种形态,也就是说实体有多种形态;</p>
<p>编译时的类型由声明该变量时使用的类型决定,运行时的类型由实际赋给变量的对象决定。</p>
<p>如果编译时类型和运行时类型不同，就出现多态。</p>
<p>Eg：</p>
<p>前提:<code>Student extends Person:</code></p>
<p><code>Person p = new Person()</code>;</p>
<p><code>Student s = new Student()</code>;</p>
<p><code>Person p = new Student()</code>;//多态</p>
<p>引用关系:父类变量指向子类实例对象</p>
<p><strong>实现多态的机制:</strong></p>
<p>父类的引用变量可以指向子类的实例对象,而程序调用的方法在运行期才动态绑定，就是引用变量所指向的真正实例对象的方法,也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</p>
<p><strong>多态的作用</strong>：</p>
<p>把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</p>
<p>只修改方法的实现，不必修改方法的声明</p>
<p><strong>继承是多态产生的前提条件</strong>;</p>
<p>分类:</p>
<p>编译时多态：方法重载</p>
<p>运行时多态：方法覆写</p>
<pre class="brush:php;toolbar:false">
Eg：
 
package test;
 
 
 
class Dog{
 
   void eat(){
 
      System.out.println(&quot;一般的狗吃一般的狗粮！&quot;);
 
   }
 
}
 
 
 
class HashDog extends Dog{
 
   void eat(){
 
      System.out.println(&quot;哈士奇吃哈士奇的狗粮！&quot;);
 
   }
 
}
 
 
 
class ZangAoDog extends Dog{
 
   void eat(){
 
      System.out.println(&quot;藏獒吃藏獒的狗粮！&quot;);
 
   }
 
}
 
 
 
//定义一个动物园喂的方法
 
class Zoo{
 
  
 
   void feed(Dog d){
 
      d.eat();
 
   }
 
  
 
}
 
 
 
public class Demo11 {
 
   public static void main(String[] args) {
 
     
 
      Dog hd = new HashDog();
 
     
 
      Dog zd = new ZangAoDog();
 
     
 
      Zoo z = new Zoo();
 
      z.feed(hd);
 
      z.feed(zd);
 
   }
 
}</pre>
<p>输出：</p>
<p>哈士奇吃哈士奇的狗粮！</p>
<p>藏獒吃藏獒的狗粮！</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>14、引用变量类型转换</strong></p>
<p>向上转型（子类&rarr;父类）：(自动完成)</p>
<p>父类名称 父类对象 = 子类实例 ;</p>
<p>向下转型（父类&rarr;子类）：(强制完成)</p>
<p>子类名称 子类对象 = （子类名称）父类实例 ;</p>
<p>对象名 instanceof 类</p>
<p>判断指定的变量名此时引用的真正类型是不是当前给出的类或子类；</p>
<p>我的总结：对象的类型和类必须有继承关系</p>
<pre class="brush:php;toolbar:false">
Eg：
class A extends B{}
 
B b = new A();
If(b instanceof A){  ...
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 24px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 32px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>2、面向对象（2）</strong></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>1、基本数据类型的包装类</strong></p>
<p>引言：Java提倡的万物皆对象，但是数据类型的划分出现了基本数据类型和引用数据类型，那么我们怎么能把基本数据类型称为对象呢？</p>
<p><img alt="20180902114356567.png" src="/d/file/p/20221028/1566524393848000.png" title="1566524393848000.png" /></p>
<p>除了Integer和Character定义的名称和对应的基本类型差异大，其他六种都是将首字母大写就可以了。</p>
<p>Integer,Byte,Float,Double,Short,Long都是Number类的子类。(Number类后面讲)；</p>
<p>Character和Boolean都是Object直接子类；</p>
<p>8个类都是final修饰的(不可被继承)。</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>2、基本数据类型和包装类相互转换</strong></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(20, 25, 30); font-family: &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, Helvetica, &quot;Helvetica Neue&quot;, å¾®è½¯é›…é»‘, Tahoma, Arial, sans-serif; font-size: 14px;">把基本数据类型 &rarr; 包装类：</span></p>
<p>通过对应包装类的构造方法实现</p>
<p>除了Character外，其他包装类都可以传入一个字符串参数构建包装类对象。</p>
<p>包装类 &rarr; 基本数据类型</p>
<p>包装类的实例方法xxxValue(); // xxx表示包装类对应的基本数据类型</p>
<pre class="brush:php;toolbar:false">
Eg：
 
boolean bool = false;
 
Boolean b2 = new Boolean(bool);
 
Integer i = new Integer(3);
 
int i2 = i.intValue();
 
Boolean b1 = new Boolean(&quot;TRue&quot;);//true
 
boolean b2 = b1.booleanValue();
 
Float f = new Float(&quot;3.14&quot;);//3.14
 
Integer i2 = new Integer(&quot;123s&quot;);//NumberFormatException</pre>
<p>备注：</p>
<p>自动装箱&amp;自动拆箱</p>
<p>jdk1.5开始出现的特性：</p>
<p>自动装箱：可把一个基本类型变量直接赋给对应的包装类对象或则Object对象</p>
<p>自动拆箱：允许把 包装类对象直接赋给对应的基本数据类型</p>
<pre class="brush:php;toolbar:false">
Eg：
 
Integer i = 3;//装箱
 
int i2 = i;//拆箱
 
Object flag = new Boolean(false);
 
if(flag instanceof Boolean){
 
        Boolean b = (Boolean)flag;
 
        boolean b2 = b;
 
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>3、基本类型和String之间的转换</strong></p>
<p>String &rarr; 基本类型，除了Character外所有的包装类提供parseXxx(String s)静态方法，用于把一个特定的字符串转换成基本类型变量；</p>
<p>基本类型 &rarr; String，String 类有静态方法valueOf()，用于将基本类型的变量转换成String类型。</p>
<pre class="brush:php;toolbar:false">
String str = &quot;17&quot;;
int i = Integer.parseInt(str);//String  --&gt; 基本类型
String s1 = String.valueOf(i);//基本类型 --&gt; String</pre>
<p><span style="font-size: 24px;"><strong>4、Object类</strong></span></p>
<p>所有类的公共父类，一旦一个类没有显示地继承一个类则其直接父类一定是Object。</p>
<p>一切数据类型都可用Object接收</p>
<p>class OOXX extends Object{}等价于class ooXX {}</p>
<p>&nbsp;</p>
<p>常见方法</p>
<p><code>public boolean equals(Object obj)</code>：对象比较</p>
<p><code>public int hashCode()</code>：取得该对象的Hash码</p>
<p><code>public String toString()</code>：对象描述</p>
<p>Object类的 toString()方法：&ldquo;对象的描述&rdquo;</p>
<p>建议所有类都覆写此方法</p>
<p>直接打印输出对象时，会调用该对象的toString()方法。//可以不写出来</p>
<p>打印对象的时候,实际调用的对象实际指向的类的自我描述；</p>
<p>全限定类名+@+十六进制的hashCode值，等价于</p>
<p>全限定类名+@+IntegertoHexString(该对象.hashCode)</p>
<p>&nbsp;</p>
<p>equals也是判断是否指向同一个对象</p>
<p>没有实际意义，有必要可以重写</p>
<p><code>public boolean equals(Object obj) {}</code></p>
<p>String 覆写了 Object的equals方法：只比较字符的序列是否相同</p>
<p>==用于判断两个变量是否相等</p>
<p>&nbsp;</p>
<p>基本类型：</p>
<p>引用类型：必须指向同一个对象，才true</p>
<p>只能比较有父子或平级关系的两个对象</p>
<p>new String(&quot;1&quot;) == new String(&quot;1&quot;); ？</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>5、代码块</strong></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="color: rgb(20, 25, 30); font-family: &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, Helvetica, &quot;Helvetica Neue&quot;, å¾®è½¯é›…é»‘, Tahoma, Arial, sans-serif; font-size: 14px;">代码块指的是使用&quot;{}&quot;括起来的一段代码，根据代码块存在的位置可以分为4种:</span></p>
<p>普通代码块;</p>
<p>构造代码块;</p>
<p>静态代码块;</p>
<p>同步代码块(线程同步的时候讲解)。</p>
<p>代码块里变量的作用域：</p>
<p>只在自己所在区域(前后的{})内有效；</p>
<p>&nbsp;</p>
<p>普通代码块：</p>
<p>普通代码块就是直接定义在方法或语句中定义的代码块：</p>
<p>public void show(){</p>
<p>普通代码块</p>
<p>}</p>
<p>构造代码块：</p>
<p>直接写在类中的代码块:</p>
<p>优先于构造方法执行，每次实例化对象之前都会执行构造代码块。</p>
<pre class="brush:php;toolbar:false">
Eg：
 
public class Demo {
 
    {
 
               System.out.println(&quot;我是构造代码块&quot;);
 
    }
 
    public Demo(){
 
                System.out.println(&quot;我是构造方法&quot;);
 
    }
 
    public static void main(String[] args) {
 
               Demo d1  = new Demo();
 
               Demo d2  = new Demo();
 
    }
 
}</pre>
<p>静态代码块</p>
<p>使用static 修饰的构造代码块:</p>
<p>优先于主方法执行，优先于构造代码块执行，不管有创建多少对象，静态代码块只执行一次，可用于给静态变量赋值；</p>
<pre class="brush:php;toolbar:false">
Eg：
 
package reviewDemo;
 
/**
 * 测试各代码块的优先级
 * 优先级顺序：静态代码块 　＞　构造代码块　＞　普通代码块
 * 备注：无论创建几个对象，静态代码块只执行一次！
 */
 
 
 
public class Demo13 {
 
   Demo13(){
 
      System.out.println(&quot;我是构造方法！&quot;);
 
   }
 
   {
 
      System.out.println(&quot;我是构造代码块！&quot;);//实例化对象的时候才会去调用！
 
   }
 
   static{
 
      System.out.println(&quot;我是静态代码块！&quot;);
 
   }
 
  
 
   public static void main(String[] args) {
 
      new Demo13();
 
      new Demo13();//再次创建对象，证明无论创建几次对象，静态代码块都只执行一次
 
      System.out.println(&quot;我是普通代码块！&quot;);
 
   }
 
}</pre>
<p>输出：</p>
<p>我是静态代码块！</p>
<p>我是构造代码块！</p>
<p>我是构造方法！</p>
<p>我是构造代码块！</p>
<p>我是构造方法！</p>
<p>我是普通代码块！</p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>6、构造方法的私有化</strong></p>
<p>有的时候我们为了避免外界创建某类的实例，就将某类的构造方法私有化，即将它的构造方法用private修饰：</p>
<p>外界如何用到？</p>
<p>提供get方法！不提供的话外界就没法创建对象！（对反射无效）</p>
<pre class="brush:php;toolbar:false">
Eg：package reviewDemo;
 
 
class Stu{
 
   //将构造方法私有化
 
   private Stu(){
 
     
 
   }
 
}
 
 
 
public class Demo15 {
 
   public static void main(String[] args) {
 
      Stu s = new Stu();
 
   }
 
}</pre>
<p>Singleton模式(单例模式) 饿汉式和懒汉式</p>
<p>目的：整个应用中有且只有一个实例，所有指向该类型实例的引用都指向这个实例。</p>
<p>好比一个国家就只有一个皇帝(XXX)，此时每个人叫的&ldquo;皇帝&rdquo;都是指叫的XXX本人;</p>
<p>常见单例模式类型：</p>
<p>饿汉式单例：直接将对象定义出来</p>
<p>懒汉式单例：只给出变量，并不将其初始化；</p>
<p>我的总结：</p>
<p>饿汉式，static修饰，随着类的加载而加载，会损耗性能，但是方法相对简单</p>
<p>懒汉式 第一次用的时候相对较慢，因为需要加载！线程，不安全！</p>
<pre class="brush:php;toolbar:false">
 
package reviewDemo;
 
//单例模式
 
 
 
//饿汉式,直接把对象构造出来
 
class SingleDemo{
 
   private static SingleDemo s1 = new SingleDemo();
 
   private SingleDemo(){
 
      //提供私有化的构造方法，那么外界就不能构造对象了！
 
   }
 
  
 
   public static SingleDemo getS1() {
 
      return s1;
 
   }
 
}
 
 
 
//懒汉式，先定义，但是不创建对象
 
class SingleDemo2{
 
   private static SingleDemo2 s3 ;
 
  
 
   private SingleDemo2(){
 
      //提供私有化的构造方法，那么外界就不能构造对象了！
 
   }
 
  
 
   public static SingleDemo2 getS3() {//这是一个方法，返回值为创建的对象！
 
      if(s3 == null){
 
         s3 = new SingleDemo2();
 
      }//和饿汉式的区别，此时才来创建对象！
 
      return s3;
 
   }
 
}
 
 
 
public class Demo14 {
 
   public static void main(String[] args) {
 
      SingleDemo s1 = SingleDemo.getS1();
 
      SingleDemo s2 = SingleDemo.getS1();
 
     
 
      SingleDemo2 s3 = SingleDemo2.getS3();
 
      SingleDemo2 s4 = SingleDemo2.getS3();
 
     
 
      System.out.println(s1 == s2);
 
      System.out.println(s3 == s4);
 
     
 
   }
 
}
 
 
 
输出：true true
 
 
 
备注：枚举更加安全些
 
package reviewDemo;
 
 
 
enum Stu{
 
   jake;
 
   //将构造方法私有化起来，反射也不能创建对象，安全
 
   private Stu(){
 
     
 
   }
 
}
 
 
 
public class Demo15 {
 
   public static void main(String[] args) {
 
   }
 
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>8、final 关键字</strong></p>
<p>final可以修饰类,方法,变量。</p>
<p>final修饰类不可以被继承，但是可以继承其他类。</p>
<p>final修饰的方法不可以被覆写,但可以覆写父类方法。</p>
<p>final修饰的变量称为常量，这些变量只能赋值一次。</p>
<p>内部类在局部时，只可以访问被final修饰的局部变量。</p>
<p>final修饰的引用类型变量,表示该变量的引用不能变,而不是该变量的值不能变;</p>
<pre class="brush:php;toolbar:false">
Eg：
 
package reviewDemo;
 
 
 
final class Name{
 
}
 
 
 
class NewName extends Name{//ERROR，报错，因为Name有final修饰
 
}
 
 
 
public class Demo15 {
 
   public static void main(String[] args) {
 
   }
 
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>9、抽象类</strong></p>
<p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的行为方式，那么这些方法都有具体的方法体。</p>
<p>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。</p>
<p>抽象方法的定义：通过abstract关键字来修饰的类称为抽象类；</p>
<p>总结：抽象类用private修饰，里面可以有用private修饰的方法（没有方法体），强制子类进行覆写；</p>
<p>可以理解为：具有某些公共方法的一个总结类。</p>
<p>可以定义被abstract修饰的抽象方法</p>
<p>抽象方法只有返回类型和方法签名，没有方法体。</p>
<p>备注：</p>
<p>抽象类可以含有普通方法</p>
<p>抽象类不能创建实例对象（不能new）</p>
<p>需要子类覆盖掉所有的抽象方法后才可以创建子类对象，否则子类也必须作为抽象类</p>
<p>列举常见的几个抽象类：</p>
<p>流的四个基本父类</p>
<p>InputStream，OutputStream，Reader，Writer</p>
<p>我的总结：</p>
<p>抽象类是类的一种特殊情况:据有类的一切特点,但是不能实例化;一般的都得带有抽象方法。</p>
<p>抽象类不可以实例化，有时看到的近似实例化是多态机制的体现，并不是真正的实例化。</p>
<pre class="brush:php;toolbar:false">
Eg：
 
Socket s = new Socket();
 
OutputStream os = s.getOutputStream();
 
左边是OutputStream类型变量的声明，右边是获取抽象类OutputStream的一个实例对象！
 
 
package testDemo2;
 
 
 
abstract class Person{
 
}
 
 
 
class Student extends Person{
 
}
 
 
public class Demo2 {
 
   public static void main(String[] args) {
 
      Person p = new Student();//体现的是多态，父类声明实例化子类对象。而不是抽象类实例化
 
   }
 
}</pre>
<p><strong>abstract方法</strong></p>
<p>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是功能声明相同，但功能主体不同。</p>
<p>那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</p>
<p>abstract [非private访问修饰符] 返回值类型 方法名称(参数列表);</p>
<p>抽象方法要存放在抽象类中。</p>
<p>抽象方法也可以存在于接口中</p>
<pre class="brush:php;toolbar:false">
Eg：
 
package reviewDemo;
 
 
 
abstract class Person3{
 
   abstract void show();
 
   abstract void inof();
 
   void turn(){
 
   }
 
}
 
 
 
class NewP extends Person3{
 
   @Override
 
   void show() {
 
   }
 
 
 
   @Override
 
   void inof() {
 
   }
 
   //不覆写的话会报错
 
}
 
 
 
public class Demo15 {
 
   public static void main(String[] args) {
 
      //new Person3();报错！因为抽象类不可以实例化
 
   }
 
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><strong>10、抽象类的体现-模板模式</strong></p>
<p>抽象类是多个具体子类抽象出来的父类,具有高层次的抽象性;以该抽象类作为子类的模板可以避免子类设计的随意性;</p>
<p>抽象类的体现主要就是模板模式设计,抽象类作为多个子类的通用模板,子类在抽象类的基础上进行拓展,但是子类在总体上大致保留抽象类的行为方式;</p>
<p>编写一个抽象父类,该父类提供了多个子类的通用方法,并把一个或多个抽象方法留给子类去实现,这就是模板设计模式;</p>
<p>模板模式应用的简单规则:</p>
<p>1.抽象父类可以只定义需要使用的某些方法,其余留给子类去实现;</p>
<p>2.父类提供的方法只是定义了一个通用算法,其实现必须依赖子类的辅助;</p>
<p>我的总结：</p>
<p>如果父类的方法不想被子类覆写，那么可以在前面加上final关键字修饰。</p>
<pre class="brush:php;toolbar:false">
Eg：
 
package reviewDemo;
 
//模板模式
 
 
 
//抽象类中包含很多的抽象方法，子类必须去覆写！
 
abstract class Method{
 
   abstract double mul();//返回值类型如果是void的话，下面报错，因为没有返回值，无法引用！
 
   abstract double divid();
 
   void show(){
 
      System.out.println(&quot;面积是：&quot;+mul());//周长
 
      System.out.println(&quot;面积是：&quot;+divid());//面积
 
   }
 
}
 
 
 
class Square extends Method{
 
   double d;
 
  
 
   public Square(double d) {
 
      super();
 
      this.d = d;
 
   }
 
 
 
   @Override
 
   double mul() {
 
      return d * d;
 
   }
 
 
 
   @Override
 
   double divid() {
 
      return 4 * d;
 
   }
 
}
 
 
 
class Cirle extends Method{
 
   double r;
 
  
 
   public Cirle(double r) {
 
      super();
 
      this.r = r;
 
   }
 
 
 
   @Override
 
   double mul() {
 
      return 2 * 3.14 * r;
 
   }
 
 
 
   @Override
 
   double divid() {
 
      return 3.14 * r * r;
 
   }
 
}
 
 
 
public class Demo16 {
 
   public static void main(String[] args) {
 
      Square s = new Square(5);
 
      s.show();
 
      Cirle c = new Cirle(4);
 
      c.show();
 
   }
 
}</pre>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 14px;">以上是本次整理的关于java面向对象的详细讲解，后续会为大家继续整理。</span></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 14px;">文中若有明显错误请指正，谢谢！</span></p>
<p style="box-sizing: border-box; outline: 0px; margin: 8px 0px 16px 0cm; padding: 0px; font-size: 22px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; color: rgb(79, 79, 79); line-height: 30px; overflow-wrap: break-word; white-space: normal; background-color: rgb(255, 255, 255);"><span style="font-size: 14px;">更多JAVA相关问题请访问PHP中文网：JAVA视频教程</span></p><!-- .entry-wrapper --></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/497.html'>代码讲解java的单例模式</a><a>下一篇</a><a href='/java/biji/499.html'>awt是什么</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>