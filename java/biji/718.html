<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>详解java中的transient关键字_java教程_IDC笔记</title>
    <meta name="keywords" content=",java教程" />
    <meta name="description" content="相信很多人都是直到自己碰到才会关心这个关键字，记得博主第一次碰到transient关键字是在阅读JDK源码的时候。在学习java的过程中transient关键字少见的原因其实离不开它的作" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/start/184.html">第一个Java程序</a></li><li><a href="/java/start/185.html">如何运行Java程序</a></li><li><a href="/java/start/186.html">Java标识符与关键字</a></li><li><a href="/java/start/187.html">Java注释</a></li><li><a href="/java/start/188.html">Java常量</a></li><li><a href="/java/start/189.html">Java基本数据类型</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java运算符和表达式			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/operators/190.html">Java运算符和表达式</a></li><li><a href="/java/operators/191.html">Java算数运算符实例讲解</a></li><li><a href="/java/operators/192.html">Java关系运算符实例讲解</a></li><li><a href="/java/operators/193.html">Java逻辑运算符实例讲解</a></li><li><a href="/java/operators/194.html">Java位运算符实例讲解</a></li><li><a href="/java/operators/195.html">Java赋值运算符实例讲解</a></li><li><a href="/java/operators/196.html">Java条件运算符实例讲解</a></li><li><a href="/java/operators/197.html">Java instanceof运算符实例讲解</a></li><li><a href="/java/operators/198.html">Java运算符的优先级和结合性</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java流程控制			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/control/200.html">Java if条件分支语句</a></li><li><a href="/java/control/199.html">Java语句</a></li><li><a href="/java/control/201.html">Java switch开关语句</a></li><li><a href="/java/control/203.html">Java while循环语句</a></li><li><a href="/java/control/202.html">Java for循环语句</a></li><li><a href="/java/control/205.html">Java break语句</a></li><li><a href="/java/control/204.html">Java do-while循环语句</a></li><li><a href="/java/control/206.html">Java continue语句</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/java/objects/209.html">Java方法</a></li><li><a href="/java/objects/208.html">Java成员变量</a></li><li><a href="/java/objects/207.html">Java类</a></li><li><a href="/java/objects/211.html">Java创建对象</a></li><li><a href="/java/objects/210.html">Java类的构造方法</a></li><li><a href="/java/objects/213.html">Java对象的引用和实体</a></li><li><a href="/java/objects/212.html">Java使用对象</a></li><li><a href="/java/objects/216.html">Java实例变量和类变量</a></li><li><a href="/java/objects/215.html">Java参数传值</a></li><li><a href="/java/objects/214.html">Java类与程序的基本结构</a></li><li><a href="/java/objects/217.html">Java实例方法和类方法</a></li><li><a href="/java/objects/218.html">Java方法重载</a></li><li><a href="/java/objects/222.html">Java访问权限</a></li><li><a href="/java/objects/221.html">Java import语句</a></li><li><a href="/java/objects/220.html">Java包</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java子类与继承			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java接口与实现			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java内部类与异常类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Java常用实用类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 		</ul>
	</li>
		<li>
	    <a href="/java/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>JAVA笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">详解java中的transient关键字</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>相信很多人都是直到自己碰到才会关心这个关键字，记得博主第一次碰到transient关键字是在阅读JDK源码的时候。在学习java的过程中transient关键字少见的原因其实离不开它的作</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p style="text-align: center;">相信很多人都是直到自己碰到才会关心这个关键字，记得博主第一次碰到transient关键字是在阅读JDK源码的时候。在学习java的过程中transient关键字少见的原因其实离不开它的作用：transient关键字的主要作用就是让某些被transient关键字修饰的成员属性变量不被序列化。实际上也正是因此，在学习过程中很少用得上序列化操作，一般都是在实际开发中！至于序列化，相信有很多小白童鞋一直迷迷糊糊或者没有具体的概念，这都不是事，下面博主会很清楚的让你记住啥是序列化，保证你这辈子忘不了（貌似有点夸张，有点装b，感觉要被打）</p>
<p><strong>1、何谓序列化？</strong></p>
<p>说起序列化，随之而来的另一个概念就是反序列化，小白童鞋不要慌，记住了序列化就相当于记住了反序列化，因为反序列化就是序列化反过来，所以博主建议只记住序列化概念即可，省的搞晕自己。</p>
<p><strong>（推荐视频：</strong><strong>java视频教程</strong><strong>） </strong></p>
<p>专业术语定义的序列化：</p>
<blockquote>
<p>Java提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。</p></blockquote>
<p>序列化： 字节 &mdash;&mdash;&gt; 对象</p>
<p>其实，我总结的就是上面的结论，如果不理解，直接参照专业术语的定义，理解之后就记住我的话就行了，记不住，请打死我</p>
<p>图理解序列化：</p>
<p><img alt="1.jpg" src="/d/file/p/20221028/1574755122440086.jpg" title="1574755122440086.jpg" /></p>
<p><strong>2、为何要序列化？</strong></p>
<p>从上一节提到序列化的概念，知道概念之后，我们就必须要知道 为何要序列化了。</p>
<p>讲为何要序列化原因之前，博主我举个栗子：</p>
<p>就像你去街上买菜，一般操作都是用塑料袋给包装起来，直到回家要做菜的时候就把菜给拿出来。而这一系列操作就像极了序列化和反序列化！</p>
<p>Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象 可以被写到数据库或文件中，也可用于 网络传输，一般当我们使用 缓存cache（内存空间不够有可能会本地存储到硬盘）或 远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</p>
<p>在开发过程中要使用transient关键字修饰的栗子：</p>
<p>如果一个用户有一些密码等信息，为了安全起见，不希望在网络操作中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
<p><strong>在开发过程中不需要transient关键字修饰的栗子：</strong></p>
<p>1、类中的字段值可以根据其它字段推导出来。</p>
<p>2、看具体业务需求，哪些字段不想被序列化；</p>
<p>不知道各位有木有想过为什么要不被序列化呢？其实主要是为了节省存储空间。优化程序！</p>
<p>PS：记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p>
<p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，就像买菜一样，用塑料袋包裹最后还是为了方便安全到家再去掉塑料袋，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p>
<p><strong>3、序列化与transient的使用</strong></p>
<p>1、需要做序列化的对象的类，必须实现序列化接口：Java.lang.Serializable 接口（一个标志接口，没有任何抽象方法），Java 中大多数类都实现了该接口，比如：String，Integer类等，不实现此接口的类将不会使任何状态序列化或反序列化，会抛NotSerializableException异常 。</p>
<p>2、底层会判断，如果当前对象是 Serializable 的实例，才允许做序列化，Java对象 instanceof Serializable 来判断。</p>
<p>3、在 Java 中使用对象流ObjectOutputStream来完成序列化以及ObjectInputStream流反序列化　　　</p>
<p>==ObjectOutputStream:通过 writeObject()方法做序列化操作==　</p>
<p>==ObjectInputStream:通过 readObject() 方法做反序列化操作==</p>
<p><strong>4、该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</strong></p>
<p><img alt="2.jpg" src="/d/file/p/20221028/1574755174794740.jpg" title="1574755174794740.jpg" /></p>
<p>由于字节嘛所以肯定要涉及流的操作，也就是对象流也叫序列化流ObjectOutputstream，下面进行多种情况分析序列化的操作代码！</p>
<p>在这里，我真的强烈建议看宜春博客的读者朋友，请试着去敲，切记一眼带过或者复制过去运行就完事了，特别是小白童鞋，相信我！你一定会有不一样的收获。！</p>
<p>3.1、没有实现Serializable接口进行序列化情况</p>
<pre class="brush:php;toolbar:false">
package TransientTest;
import java.io.*;

class UserInfo { //================================注意这里没有实现Serializable接口
    private String name;
    private transient String password;

    public UserInfo(String name, String psw) {
        this.name = name;
        this.password = psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
            &quot;name=&#39;&quot; + name + &#39;&#39;&#39; +
            &quot;, password=&#39;&quot; + password + &#39;&#39;&#39; +
            &#39;}&#39;;
    }
}

public class TransientDemo {
    public static void main(String[] args) {

        UserInfo userInfo = new UserInfo(&quot;老王&quot;, &quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot; + userInfo);

        try {
            ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;));
            output.writeObject(new UserInfo(&quot;老王&quot;, &quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
<p>运行结果</p>
<p><img alt="3.jpg" src="/d/file/p/20221028/1574755240873865.jpg" title="1574755240873865.jpg" /></p>
<p id="实现serializable接口序列化情况" style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">3.2、实现Serializable接口序列化情况</p>
<p>当我们加上实现Serializable接口再运行会发现，项目中出现的userinfo.txt文件内容是这样的:</p>
<p><img alt="4.jpg" src="/d/file/p/20221028/1574755253283266.jpg" title="1574755253283266.jpg" /></p>
<p>其实这都不是重点，重点是序列化操作成功了！</p>
<p id="普通序列化情况" style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">3.3、普通序列化情况</p>
<pre class="brush:php;toolbar:false">
package TransientTest;
import java.io.*;

class UserInfo implements Serializable { //第一步实现Serializable接口
    private String name;
    private String password; //都是普通属性==============================

    public UserInfo(String name, String psw) {
        this.name = name;
        this.password = psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
            &quot;name=&#39;&quot; + name + &#39;&#39;&#39; +
            &quot;, password=&#39;&quot; + password + &#39;&#39;&#39; +
            &#39;}&#39;;
    }
}

public class TransientDemo {
    public static void main(String[] args) throws ClassNotFoundException {

        UserInfo userInfo = new UserInfo(&quot;程序员老王&quot;, &quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot; + userInfo);

        try {
            ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;)); //第二步开始序列化操作
            output.writeObject(new UserInfo(&quot;程序员老王&quot;, &quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;userinfo.txt&quot;)); //第三步开始反序列化操作
            Object o = input.readObject(); //ObjectInputStream的readObject方法会抛出ClassNotFoundException
            System.out.println(&quot;序列化之后信息：&quot; + o);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
序列化之前信息：UserInfo{name=&#39;程序员老王&#39;, password=&#39;123&#39;}
序列化之后信息：UserInfo{name=&#39;程序员老王&#39;, password=&#39;123&#39;}</pre>
<p id="transient序列化情况" style="margin: 10px 0px; padding: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; white-space: normal; background-color: rgb(255, 255, 255);">3.4、transient序列化情况</p>
<pre class="brush:php;toolbar:false">
package TransientTest;
import java.io.*;

class UserInfo implements Serializable { //第一步实现Serializable接口
    private String name;
    private transient String password; //特别注意：属性由transient关键字修饰===========

    public UserInfo(String name, String psw) {
        this.name = name;
        this.password = psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
            &quot;name=&#39;&quot; + name + &#39;&#39;&#39; +
            &quot;, password=&#39;&quot; + password + &#39;&#39;&#39; +
            &#39;}&#39;;
    }
}

public class TransientDemo {
    public static void main(String[] args) throws ClassNotFoundException {

        UserInfo userInfo = new UserInfo(&quot;程序员老王&quot;, &quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot; + userInfo);

        try {
            ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;)); //第二步开始序列化操作
            output.writeObject(new UserInfo(&quot;程序员老王&quot;, &quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;userinfo.txt&quot;)); //第三步开始反序列化操作
            Object o = input.readObject(); //ObjectInputStream的readObject方法会抛出ClassNotFoundException
            System.out.println(&quot;序列化之后信息：&quot; + o);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
序列化之前信息：UserInfo{name=&#39;程序员老王&#39;, password=&#39;123&#39;}
序列化之后信息：UserInfo{name=&#39;程序员老王&#39;, password=&#39;null&#39;}</pre>
<p>特别注意结果，添加transient修饰的属性值为默认值null！如果被transient修饰的属性为int类型，那它被序列化之后值一定是0，当然各位可以去试试，这能说明什么呢？说明被标记为transient的属性在对象被序列化的时候不会被保存(或者说变量不会持久化)</p>
<p>3.5、static序列化情况</p>
<pre class="brush:php;toolbar:false">
package TransientTest;
import java.io.*;

class UserInfo implements Serializable { //第一步实现Serializable接口
    private String name;
    private static String password; //特别注意：属性由static关键字修饰==============

    public UserInfo(String name, String psw) {
        this.name = name;
        this.password = psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
            &quot;name=&#39;&quot; + name + &#39;&#39;&#39; +
            &quot;, password=&#39;&quot; + password + &#39;&#39;&#39; +
            &#39;}&#39;;
    }
}

public class TransientDemo {
    public static void main(String[] args) throws ClassNotFoundException {

        UserInfo userInfo = new UserInfo(&quot;程序员老王&quot;, &quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot; + userInfo);

        try {
            ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;)); //第二步开始序列化操作
            output.writeObject(new UserInfo(&quot;程序员老王&quot;, &quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;userinfo.txt&quot;)); //第三步开始反序列化操作
            Object o = input.readObject(); //ObjectInputStream的readObject方法会抛出ClassNotFoundException
            System.out.println(&quot;序列化之后信息：&quot; + o);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
序列化之前信息：UserInfo{name=&#39;程序员老王&#39;, password=&#39;123&#39;}
序列化之后信息：UserInfo{name=&#39;程序员老王&#39;, password=&#39;123&#39;}</pre>
<p>这个时候，你就会错误的认为static修饰的也被序列化了，其实不然，实际上这里很容易被搞晕！明明取出null（默认值）就可以说明不会被序列化，这里明明没有变成默认值，为何还要说static不会被序列化呢？</p>
<p>实际上，反序列化后类中static型变量name的值实际上是当前JVM中对应static变量的值，这个值是JVM中的并不是反序列化得出的。也就是说被static修饰的变量并没有参与序列化！但是咱也不能口说无凭啊，是的，那我们就来看两个程序对比一下就明白了！</p>
<p><strong>第一个程序：这是一个没有被static修饰的name属性程序：</strong></p>
<pre class="brush:php;toolbar:false">
package Thread;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class UserInfo implements Serializable {
    private String name;
    private transient String psw;

    public UserInfo(String name, String psw) {
        this.name = name;
        this.psw = psw;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPsw() {
        return psw;
    }

    public void setPsw(String psw) {
        this.psw = psw;
    }

    public String toString() {
        return &quot;name=&quot; + name + &quot;, psw=&quot; + psw;
    }
}
public class TestTransient {
    public static void main(String[] args) {
        UserInfo userInfo = new UserInfo(&quot;程序员老过&quot;, &quot;456&quot;);
        System.out.println(userInfo);
        try {
            // 序列化，被设置为transient的属性没有被序列化
            ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;UserInfo.txt&quot;));
            o.writeObject(userInfo);
            o.close();
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
        try {
            //在反序列化之前改变name的值 =================================注意这里的代码
            userInfo.setName(&quot;程序员老改&quot;);
            // 重新读取内容
            ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;UserInfo.txt&quot;));
            UserInfo readUserInfo = (UserInfo) in .readObject();
            //读取后psw的内容为null
            System.out.println(readUserInfo.toString());
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
name=程序员老过, psw=456name=程序员老过, psw=null</pre>
<p>从程序运行结果中可以看出，在反序列化之前试着改变name的值为程序员老改，结果是没有成功的！</p>
<p><strong>第二个程序：这是一个被static修饰的name属性程序：</strong></p>
<pre class="brush:php;toolbar:false">
package Thread;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class UserInfo implements Serializable {
    private static final long serialVersionUID = 996890129747019948 L;
    private static String name;
    private transient String psw;

    public UserInfo(String name, String psw) {
        this.name = name;
        this.psw = psw;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPsw() {
        return psw;
    }

    public void setPsw(String psw) {
        this.psw = psw;
    }

    public String toString() {
        return &quot;name=&quot; + name + &quot;, psw=&quot; + psw;
    }
}
public class TestTransient {
    public static void main(String[] args) {
        UserInfo userInfo = new UserInfo(&quot;程序员老过&quot;, &quot;456&quot;);
        System.out.println(userInfo);
        try {
            // 序列化，被设置为transient的属性没有被序列化
            ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;UserInfo.txt&quot;));
            o.writeObject(userInfo);
            o.close();
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
        try {
            //在反序列化之前改变name的值
            userInfo.setName(&quot;程序员老改&quot;);
            // 重新读取内容
            ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;UserInfo.txt&quot;));
            UserInfo readUserInfo = (UserInfo) in .readObject();
            //读取后psw的内容为null
            System.out.println(readUserInfo.toString());
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
    }
}</pre>
<p>运行结果：</p>
<pre class="brush:php;toolbar:false">
name=程序员老过, psw=456name=程序员老改, psw=null</pre>
<p>从程序运行结果中可以看出，在反序列化之前试着改变name的值为程序员老改，结果是成功的！现在对比一下两个程序是不是就很清晰了？</p>
<p>static关键字修饰的成员属性优于非静态成员属性加载到内存中，同时静态也优于对象进入到内存中，被static修饰的成员变量不能被序列化，序列化的都是对象，静态变量不是对象状态的一部分，因此它不参与序列化。所以将静态变量声明为transient变量是没有用处的。因此，反序列化后类中static型变量name的值实际上是当前JVM中对应static变量的值，这个值是JVM中的并不是反序列化得出的。</p>
<p>3.6、final序列化情况</p>
<p>对于final关键字来讲，final变量将直接通过值参与序列化，至于代码程序我就不再贴出来了，大家可以试着用final修饰验证一下！</p>
<p>主要注意的是final 和transient可以同时修饰同一个变量，结果也是一样的，对transient没有影响，这里主要提一下，希望各位以后在开发中遇到这些情况不会满头雾水！</p>
<p>4、java类中serialVersionUID作用</p>
<p>既然提到了transient关键字就不得不提到序列化，既然提到了序列化，就不得不提到serialVersionUID了，它是啥呢？基本上有序列化就会存在这个serialVersionUID。</p>
<p><img alt="5.jpg" src="/d/file/p/20221028/1574755437434786.jpg" title="1574755437434786.jpg" /></p>
<p>serialVersionUID适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException，在开发中有时候可写可不写，建议最好还是写上比较好。</p>
<p id="transient关键字小结"><strong>5、transient关键字小结</strong></p>
<blockquote>
<p>1、变量被transient修饰，变量将不会被序列化<br />2、transient关键字只能修饰变量，而不能修饰方法和类。<br />3、被static关键字修饰的变量不参与序列化，一个静态static变量不管是否被transient修饰，均不能被序列化。<br />4、final变量值参与序列化，final transient同时修饰变量，final不会影响transient，一样不会参与序列化</p></blockquote>
<p>第二点需要注意的是：本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口</p>
<p>第三点需要注意的是：反序列化后类中static型变量的值实际上是当前JVM中对应static变量的值，这个值是JVM中的并不是反序列化得出的。</p>
<p>结语：被transient关键字修饰导致不被序列化，其优点是可以节省存储空间。优化程序！随之而来的是会导致被transient修饰的字段会重新计算，初始化！</p><!-- .entry-wrapper --></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/java/biji/717.html'>java窗口背景颜色设置</a><a>下一篇</a><a href='/java/biji/719.html'>java锁是什么？</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>