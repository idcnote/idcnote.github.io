<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>SQL Sever查询语句大全集锦_mysql教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了SQL Sever查询语句大全集锦，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！
一、 简单查询简单的Transact-S" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
	    <a href="/mysql/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>数据库笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">SQL Sever查询语句大全集锦</h1>
					</div>
                    <div class="panel-title">
                        2022-11-12 09:44:58                    </div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了SQL Sever查询语句大全集锦，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！
一、 简单查询简单的Transact-S</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了SQL Sever查询语句大全集锦，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>
<p><b>一、 简单查询</b>简单的Transact-SQL查询只包括选择列表、FROM子句和WHERE子句。它们分别说明所查询列、查询的表或视图、以及搜索条件等。</p>
<p>例如，下面的语句查询testtable表中姓名为&ldquo;张三&rdquo;的nickname字段和email字段。</p>
<p>代码:SELECT `nickname`,`email`FROM `testtable`WHERE `name`=&#39;张三&#39;</p>
<p><wbr />(一) 选择列表选择列表(select_list)指出所查询列，它可以是一组列名列表、星号、表达式、变量(包括局部变量和全局变量)等构成。</p>
<p><b>1</b><b>、选择所有列</b><b> <wbr /><wbr /><wbr /><wbr /><wbr /></b>例如，下面语句显示testtable表中所有列的数据：</p>
<p>代码:SELECT * FROM testtable</p>
<p><b>2</b><b>、选择部分列并指定它们的显示次序</b>查询结果集合中数据的排列顺序与选择列表中所指定的列名排列顺序相同。例如：代码:SELECT nickname,email FROM testtable</p>
<p><b>3</b><b>、更改列标题</b>在选择列表中，可重新指定列标题。定义格式为：列标题=列名列名 列标题如果指定的列标题不是标准的标识符格式时，应使用引号定界符，例如，下列语句使用汉字显示列标题：代码:SELECT 昵称=nickname,电子邮件=email <wbr /><wbr />FROM testtable</p>
<p><b>4</b><b>、删除重复行</b>SELECT语句中使用ALL或DISTINCT选项来显示表中符合条件的所有行或删除其中重复的数据行，默认为ALL。使用DISTINCT选项时，对于所有重复的数据行在SELECT返回的结果集合中只保留一行。</p>
<p><b>5</b><b>、限制返回的行数</b>使用TOP n [PERCENT]选项限制返回的数据行数，TOP n说明返回n行，而TOP n PERCENT时，说明n是表示一百分数，指定返回的行数等于总行数的百分之几。例如：代码:SELECT TOP 2 * FROM `testtable`代码:SELECT TOP 20 PERCENT * FROM `testtable`</p>
<p><b>(</b><b>二</b><b>) FROM</b><b>子句</b>FROM子句指定SELECT语句查询及与查询相关的表或视图。在FROM子句中最多可指定256个表或视图，它们之间用逗号分隔。在FROM子句同时指定多个表或视图时，如果选择列表中存在同名列，这时应使用对象名限定这些列所属的表或视图。例如在usertable和citytable表中同时存在cityid列，在查询两个表中的cityid时应使用下面语句格式加以限定：代码:SELECT `username`,citytable.cityidFROM `usertable`,`citytable`WHERE usertable.cityid=citytable.cityid在FROM子句中可用以下两种格式为表或视图指定别名：代码:表名 as 别名表名 别名例如上面语句可用表的别名格式表示为：代码:SELECT `username`,b.cityidFROM usertable a,citytable bWHERE a.cityid=b.cityidSELECT不仅能从表或视图中检索数据，它还能够从其它查询语句所返回的结果集合中查询数据。例如：代码:SELECT a.au_fname+a.au_lnameFROM authors a,titleauthor ta(SELECT `title_id`,`title`FROM `titles`WHERE ` ytd_sales`&gt;10000) AS tWHERE a.au_id=ta.au_idAND ta.title_id=t.title_id此例中，将SELECT返回的结果集合给予一别名t，然后再从中检索数据。</p>
<p><b>(</b><b>三</b><b>)</b> <b>使用</b><b>WHERE</b><b>子句设置查询条件</b>WHERE子句设置查询条件，过滤掉不需要的数据行。例如下面语句查询年龄大于20的数据：<wbr />代码:SELECT * FROM usertable WHERE age&gt;20 WHERE子句可包括各种条件运算符：比较运算符(大小比较)：&gt;、&gt;=、=、、!&gt;、!=10 AND age代码:SELECT * FROM `usertable` ORDER BY `age` DESC,`userid` ASC另外，可以根据表达式进行排序。</p>
<p><b>二、</b> <b>联合查询</b>UNION运算符可以将两个或两个以上上SELECT语句的查询结果集合合并成一个结果集合显示，即执行联合查询。</p>
<p>UNION的语法格式为：代码:select_statementUNION [ALL] selectstatement[UNION [ALL] selectstatement][&hellip;n]其中selectstatement为待联合的SELECT查询语句。ALL选项表示将所有行合并到结果集合中。不指定该项时，被联合查询结果集合中的重复行将只保留一行。联合查询时，查询结果的列标题为第一个查询语句的列标题。因此，要定义列标题必须在第一个查询语句中定义。要对联合查询结果排序时，也必须使用第一查询语句中的列名、列标题或者列序号。在使用UNION 运算符时，应保证每个联合查询语句的选择列表中有相同数量的表达式，并且每个查询选择表达式应具有相同的数据类型，或是可以自动将它们转换为相同的数据类型。在自动转换时，对于数值类型，系统将低精度的数据类型转换为高精度的数据类型。在包括多个查询的UNION语句中，其执行顺序是自左至右，使用括号可以改变这一执行顺序。例如：查询1 UNION (查询2 UNION 查询3)</p>
<p><b>三、连接查询</b><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr />在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，尔后通过连接进行查询。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr />连接可以在SELECT 语句的FROM子句或WHERE子句中建立，似是而非在FROM子句中指出连接时有助于将连接操作与WHERE子句中的搜索条件区分开来。所以，在Transact-SQL中推荐使用这种方法。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />SQL-92标准所定义的FROM子句的连接语法格式为： <wbr /><wbr />代码:FROM join_table join_type join_table [ON (join_condition)]其中join_table指出参与连接操作的表名，连接可以对同一个表操作，也可以对多表操作，对同一个表操作的连接又称做自连接。join_type 指出连接类型，可分为三种：内连接、外连接和交叉连接。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />内连接(INNER JOIN)使用比较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr />外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑运算符等构成。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr />无论哪种连接都不能对text、ntext和image数据类型列进行直接连接，但可以对这三种列进行间接连接。例如：代码:SELECT p1.pub_id,p2.pub_id,p1.pr_infoFROM pub_info AS p1 INNER JOIN pub_info AS p2ON DATALENGTH(p1.pr_info)=DATALENGTH(p2.pr_info)(一)内连接内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。</p>
<p><wbr />内连接分三种：1、等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。2、不等连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、、!。3、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。</p>
<p>例，下面使用等值连接列出authors和publishers表中位于同一城市的作者和出版社：代码:SELECT *FROM authors AS a INNER JOIN publishers AS pON a.city=p.city又如使用自然连接，在选择列表中删除authors 和publishers 表中重复列(city和state)：代码:SELECT a.*,p.pub_id,p.pub_name,p.countryFROM authors AS a INNER JOIN publishers AS pON a.city=p.city</p>
<p>(二)外连接内连接时，返回查询结果集合中的仅是符合查询条件( WHERE 搜索条件或 HAVING 条件)和连接条件的行。而采用外连接时，它返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左外连接时)、右表(右外连接时)或两个边接表(全外连接)中的所有数据行。</p>
<p>如下面使用左外连接将论坛内容和作者信息连接起来：代码:SELECT a.*,b.* FROM `luntan` LEFT JOIN usertable as bON a.username=b.username下面使用全外连接将city表中的所有作者以及user表中的所有作者，以及他们所在的城市：代码:SELECT a.*,b.*FROM city as a FULL OUTER JOIN user as bON a.username=b.username</p>
<p><wbr />(三)交叉连接交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。例，titles表中有6类图书，而publishers表中有8家出版社，则下列交叉连接检索到的记录数将等于6*8=48行。代码:SELECT `type`,`pub_name`FROM `titles` CROSS JOIN `publishers`ORDER BY `type`</p>
<p>SQL核心语句(非常实用的几个技巧)_ArticleContent1_lblContent&gt;插入数据向表中添加一个新记录，你要使用SQL INSERT 语句。这里有一个如何使用这种语句的例子：代码:INSERT mytable (mycolumn) VALUES (&lsquo;some data&#39;) 这个语句把字符串&#39;some data&#39;插入表mytable的mycolumn字段中。将要被插入数据的字段的名字在第一个括号中指定，实际的数据在第二个括号中给出。INSERT 语句的完整句法如下：代码:INSERT [INTO] {table_name|view_name} [(column_list)] {DEFAULT VALUES |Values_list | select_statement} 如果一个表有多个字段，通过把字段名和字段值用逗号隔开，你可以向所有的字段中插入数据。假设表mytable有三个字段first_column,second_column,和third_column。</p>
<p>下面的INSERT语句添加了一条三个字段都有值的完整记录：代码:INSERT mytable (first_column,second_column,third_column)VALUES (&lsquo;some data&#39;,&#39;some more data&#39;,&#39;yet more data&#39;) 注意你可以使用INSERT语句向文本型字段中插入数据。但是，如果你需要输入很长的字符串，你应该使用WRITETEXT语句。这部分内容对本书来说太高级了，因此不加讨论。要了解更多的信息，请参考Microsoft SQL Sever 的文档。如果你在INSERT 语句中只指定两个字段和数据会怎么样呢？换句话说，你向一个表中插入一条新记录，但有一个字段没有提供数据。在这种情况下，有下面的四种可能：如果该字段有一个缺省值，该值会被使用。例如，假设你插入新记录时没有给字段third_column提供数据，而这个字段有一个缺省值&#39;some value&#39;。在这种情况下，当新记录建立时会插入值&#39;some value&#39;。如果该字段可以接受空值，而且没有缺省值，则会被插入空值。如果该字段不能接受空值，而且没有缺省值，就会出现错误。你会收到错误信息：The column in table mytable may not be null.最后，如果该字段是一个标识字段，那么它会自动产生一个新值。当你向一个有标识字段的表中插入新记录时，只要忽略该字段，标识字段会给自己赋一个新值。注意向一个有标识字段的表中插入新记录后，你可以用SQL变量@@identity来访问新记录的标识字段的值。考虑如下的SQL语句：<wbr />代码:INSERT mytable (first_column) VALUES(&lsquo;some value&#39;) [code][code]INSERT anothertable(another_first,another_second)VALUES(@@identity,&#39;some value&#39;) 如果表mytable有一个标识字段，该字段的值会被插入表anothertable的another_first字段。这是因为变量@@identity总是保存最后一次插入标识字段的值。字段another_first应该与字段first_column有相同的数据类型。但是，字段another_first不能是应该标识字段。Another_first字段用来保存字段first_column的值。删除记录要从表中删除一个或多个记录，需要使用SQL DELETE语句。你可以给DELETE 语句提供WHERE 子句。WHERE子句用来选择要删除的记录。例如，下面的这个DELETE语句只删除字段first_column的值等于&#39;Delete Me&#39;的记录：<wbr />代码:DELETE mytable WHERE first_column=&#39;Deltet Me&#39; DELETE 语句的完整句法如下：<wbr />代码:DELETE [FROM] {table_name|view_name} [WHERE clause] 在SQL SELECT 语句中可以使用的任何条件都可以在DELECT 语句的WHERE子句中使用。例如，下面的这个DELETE语句只删除那些first_column字段的值为&#39;goodbye&#39;或second_column字段的值为&#39;so long&#39;的记录：<wbr />代码:DELETE mytable WHERE first_column=&#39;goodby&#39; OR second_column=&#39;so long&#39; 如果你不给DELETE 语句提供WHERE 子句，表中的所有记录都将被删除。你不应该有这种想法。如果你想删除应该表中的所有记录，应使用第十章所讲的TRUNCATE TABLE语句。</p>
<p>注意为什么要用TRUNCATE TABLE 语句代替DELETE语句？当你使用TRUNCATE TABLE语句时，记录的删除是不作记录的。也就是说，这意味着TRUNCATE TABLE 要比DELETE快得多。更新记录要修改表中已经存在的一条或多条记录，应使用SQL UPDATE语句。同DELETE语句一样，UPDATE语句可以使用WHERE子句来选择更新特定的记录。请看这个例子：<wbr />代码:UPDATE mytable SET first_column=&#39;Updated!&#39; WHERE second_column=&#39;Update Me!&#39; 这个UPDATE 语句更新所有second_column字段的值为&#39;Update Me!&#39;的记录。对所有被选中的记录，字段first_column的值被置为&#39;Updated!&#39;。下面是UPDATE语句的完整句法：<wbr />代码:UPDATE {table_name|view_name} SET [{table_name|view_name}]{column_list|variable_list|variable_and_column_list}[,{column_list2|variable_list2|variable_and_column_list2}&hellip;[,{column_listN|variable_listN|variable_and_column_listN}]][WHERE clause] 注意你可以对文本型字段使用UPDATE语句。但是，如果你需要更新很长的字符串，应使用UPDATETEXT语句。这部分内容对本书来说太高级了，因此不加讨论。要了解更多的信息，请参考Microsoft SQL Sever 的文档。如果你不提供WHERE子句，表中的所有记录都将被更新。有时这是有用的。例如，如果你想把表titles中的所有书的价格加倍，你可以使用如下的UPDATE 语句：你也可以同时更新多个字段。例如，下面的UPDATE语句同时更新first_column,second_column,和third_column这三个字段：<wbr />代码:UPDATE mytable SET first_column=&#39;Updated!&#39;Second_column=&#39;Updated!&#39;Third_column=&#39;Updated!&#39;WHERE first_column=&#39;Update Me1&#39; 技巧SQL忽略语句中多余的空格。你可以把SQL语句写成任何你最容易读的格式。用SELECT 创建记录和表你也许已经注意到，INSERT 语句与DELETE语句和UPDATE语句有一点不同，它一次只操作一个记录。然而，有一个方法可以使INSERT 语句一次添加多个记录。要作到这一点，你需要把INSERT 语句与SELECT 语句结合起来，象这样：<wbr />代码:INSERT mytable (first_column,second_column)SELECT another_first,another_secondFROM anothertableWHERE another_first=&#39;Copy Me!&#39; 这个语句从anothertable拷贝记录到mytable.只有表anothertable中字段another_first的值为&#39;Copy Me！&#39;的记录才被拷贝。当为一个表中的记录建立备份时，这种形式的INSERT 语句是非常有用的。在删除一个表中的记录之前，你可以先用这种方法把它们拷贝到另一个表中。如果你需要拷贝整个表，你可以使用SELECT INTO 语句。例如，下面的语句创建了一个名为newtable的新表，该表包含表mytable的所有数据：<wbr />代码:SELECT * INTO newtable FROM mytable 你也可以指定只有特定的字段被用来创建这个新表。要做到这一点，只需在字段列表中指定你想要拷贝的字段。另外，你可以使用WHERE 子句来限制拷贝到新表中的记录。下面的例子只拷贝字段second_columnd的值等于&#39;Copy Me!&#39;的记录的first_column字段。<wbr />代码:SELECT first_column INTO newtableFROM mytableWHERE second_column=&#39;Copy Me!&#39; 使用SQL修改已经建立的表是很困难的。例如，如果你向一个表中添加了一个字段，没有容易的办法来去除它。另外，如果你不小心把一个字段的数据类型给错了，你将没有办法改变它。但是，使用本节中讲述的SQL语句，你可以绕过这两个问题。例如，假设你想从一个表中删除一个字段。使用SELECT INTO 语句，你可以创建该表的一个拷贝，但不包含要删除的字段。这使你既删除了该字段，又保留了不想删除的数据。如果你想改变一个字段的数据类型，你可以创建一个包含正确数据类型字段的新表。创建好该表后，你就可以结合使用UPDATE语句和SELECT 语句，把原来表中的所有数据拷贝到新表中。通过这种方法，你既可以修改表的结构，又能保存原有的数据。_ArticleContent1_lblContent&gt;插入数据向表中添加一个新记录，你要使用SQL INSERT 语句。这里有一个如何使用这种语句的例子：<wbr />代码:INSERT mytable (mycolumn) VALUES (&lsquo;some data&#39;) 这个语句把字符串&#39;some data&#39;插入表mytable的mycolumn字段中。将要被插入数据的字段的名字在第一个括号中指定，实际的数据在第二个括号中给出。INSERT 语句的完整句法如下：<wbr />代码:INSERT [INTO] {table_name|view_name} [(column_list)] {DEFAULT VALUES | Values_list | select_statement} 如果一个表有多个字段，通过把字段名和字段值用逗号隔开，你可以向所有的字段中插入数据。假设表mytable有三个字段first_column,second_column,和third_column。下面的INSERT语句添加了一条三个字段都有值的完整记录：代码:INSERT mytable (first_column,second_column,third_column) VALUES (&lsquo;some data&#39;,&#39;some more data&#39;,&#39;yet more data&#39;)[code]注意你可以使用INSERT语句向文本型字段中插入数据。但是，如果你需要输入很长的字符串，你应该使用WRITETEXT语句。这部分内容对本书来说太高级了，因此不加讨论。要了解更多的信息，请参考Microsoft SQL Sever 的文档。如果你在INSERT 语句中只指定两个字段和数据会怎么样呢？换句话说，你向一个表中插入一条新记录，但有一个字段没有提供数据。在这种情况下，有下面的四种可能：如果该字段有一个缺省值，该值会被使用。例如，假设你插入新记录时没有给字段third_column提供数据，而这个字段有一个缺省值&#39;some value&#39;。在这种情况下，当新记录建立时会插入值&#39;some value&#39;。如果该字段可以接受空值，而且没有缺省值，则会被插入空值。如果该字段不能接受空值，而且没有缺省值，就会出现错误。你会收到错误信息：The column in table mytable may not be null.最后，如果该字段是一个标识字段，那么它会自动产生一个新值。当你向一个有标识字段的表中插入新记录时，只要忽略该字段，标识字段会给自己赋一个新值。注意向一个有标识字段的表中插入新记录后，你可以用SQL变量@@identity来访问新记录的标识字段的值。考虑如下的SQL语句：[code]INSERT mytable (first_column) VALUES(&lsquo;some value&#39;)<wbr />代码:INSERT anothertable(another_first,another_second) VALUES(@@identity,&#39;some value&#39;) 如果表mytable有一个标识字段，该字段的值会被插入表anothertable的another_first字段。这是因为变量@@identity总是保存最后一次插入标识字段的值。字段another_first应该与字段first_column有相同的数据类型。但是，字段another_first不能是应该标识字段。Another_first字段用来保存字段first_column的值。删除记录要从表中删除一个或多个记录，需要使用SQL DELETE语句。你可以给DELETE 语句提供WHERE 子句。WHERE子句用来选择要删除的记录。例如，下面的这个DELETE语句只删除字段first_column的值等于&#39;Delete Me&#39;的记录：<wbr />代码:DELETE mytable WHERE first_column=&#39;Deltet Me&#39; DELETE 语句的完整句法如下：<wbr />代码:DELETE [FROM] {table_name|view_name} [WHERE clause] 在SQL SELECT 语句中可以使用的任何条件都可以在DELECT 语句的WHERE子句中使用。例如，下面的这个DELETE语句只删除那些first_column字段的值为&#39;goodbye&#39;或second_column字段的值为&#39;so long&#39;的记录：<wbr />代码:DELETE mytable WHERE first_column=&#39;goodby&#39; OR second_column=&#39;so long&#39; 如果你不给DELETE 语句提供WHERE 子句，表中的所有记录都将被删除。你不应该有这种想法。如果你想删除应该表中的所有记录，应使用第十章所讲的TRUNCATE TABLE语句。注意为什么要用TRUNCATE TABLE 语句代替DELETE语句？当你使用TRUNCATE TABLE语句时，记录的删除是不作记录的。也就是说，这意味着TRUNCATE TABLE 要比DELETE快得多。更新记录要修改表中已经存在的一条或多条记录，应使用SQL UPDATE语句。同DELETE语句一样，UPDATE语句可以使用WHERE子句来选择更新特定的记录。请看这个例子：<wbr />代码:UPDATE mytable SET first_column=&#39;Updated!&#39; WHERE second_column=&#39;Update Me!&#39; 这个UPDATE 语句更新所有second_column字段的值为&#39;Update Me!&#39;的记录。对所有被选中的记录，字段first_column的值被置为&#39;Updated!&#39;。下面是UPDATE语句的完整句法：<wbr />代码:UPDATE {table_name|view_name} SET [{table_name|view_name}]{column_list|variable_list|variable_and_column_list}[,{column_list2|variable_list2|variable_and_column_list2}&hellip;[,{column_listN|variable_listN|variable_and_column_listN}]][WHERE clause] 注意你可以对文本型字段使用UPDATE语句。但是，如果你需要更新很长的字符串，应使用UPDATETEXT语句。这部分内容对本书来说太高级了，因此不加讨论。要了解更多的信息，请参考Microsoft SQL Sever 的文档。如果你不提供WHERE子句，表中的所有记录都将被更新。有时这是有用的。例如，如果你想把表titles中的所有书的价格加倍，你可以使用如下的UPDATE 语句：你也可以同时更新多个字段。例如，下面的UPDATE语句同时更新first_column,second_column,和third_column这三个字段：<wbr />代码:UPDATE mytable SET first_column=&#39;Updated!&#39;Second_column=&#39;Updated!&#39;Third_column=&#39;Updated!&#39;WHERE first_column=&#39;Update Me1&#39; 技巧SQL忽略语句中多余的空格。你可以把SQL语句写成任何你最容易读的格式。用SELECT 创建记录和表你也许已经注意到，INSERT 语句与DELETE语句和UPDATE语句有一点不同，它一次只操作一个记录。然而，有一个方法可以使INSERT 语句一次添加多个记录。要作到这一点，你需要把INSERT 语句与SELECT 语句结合起来，象这样：<wbr />代码:INSERT mytable (first_column,second_column)SELECT another_first,another_secondFROM anothertableWHERE another_first=&#39;Copy Me!&#39; 这个语句从anothertable拷贝记录到mytable.只有表anothertable中字段another_first的值为&#39;Copy Me！&#39;的记录才被拷贝。当为一个表中的记录建立备份时，这种形式的INSERT 语句是非常有用的。在删除一个表中的记录之前，你可以先用这种方法把它们拷贝到另一个表中。如果你需要拷贝整个表，你可以使用SELECT INTO 语句。例如，下面的语句创建了一个名为newtable的新表，该表包含表mytable的所有数据：<wbr />代码:SELECT * INTO newtable FROM mytable 你也可以指定只有特定的字段被用来创建这个新表。要做到这一点，只需在字段列表中指定你想要拷贝的字段。另外，你可以使用WHERE 子句来限制拷贝到新表中的记录。下面的例子只拷贝字段second_columnd的值等于&#39;Copy Me!&#39;的记录的first_column字段。<wbr />代码:SELECT first_column INTO newtableFROM mytableWHERE second_column=&#39;Copy Me!&#39; 使用SQL修改已经建立的表是很困难的。例如，如果你向一个表中添加了一个字段，没有容易的办法来去除它。另外，如果你不小心把一个字段的数据类型给错了，你将没有办法改变它。但是，使用本节中讲述的SQL语句，你可以绕过这两个问题。例如，假设你想从一个表中删除一个字段。使用SELECT INTO 语句，你可以创建该表的一个拷贝，但不包含要删除的字段。这使你既删除了该字段，又保留了不想删除的数据。如果你想改变一个字段的数据类型，你可以创建一个包含正确数据类型字段的新表。创建好该表后，你就可以结合使用UPDATE语句和SELECT 语句，把原来表中的所有数据拷贝到新表中。通过这种方法，你既可以修改表的结构，又能保存原有的数据。</p>
<div align="left" style="line-height: 180%"><wbr />
<p></p>
<p><b>SQL</b><b>语法</b><b>,SQL</b><b>语句大全</b><b>,SQL</b><b>基础</b></p>
<p>ＳＱＬ 语法参考手册(SQL)/数据类型2006-07-24 07:42《ＳＱＬ 语法参考手册(SQL)》DB2 提供了关连式资料库的查询语言 ＳＱＬ (Structured Query Language)，是一种非常口语化、既易学又易懂的语法。此一语言几乎是每个资料库系统都必须提供的，用以表示关连式的*作，包含了资料的定义（ＤＤＬ）以及资料的处理（ＤＭＬ）。SQL原来拼成SEQUEL，这语言的原型以&ldquo;系统 R&ldquo;的名字在 IBM 圣荷西实验室完成，经过IBM内部及其他的许多使用性及效率测试，其结果相当令人满意，并决定在系统R 的技术基础发展出来 IBM 的产品。而且美国国家标准学会（ANSI）及国际标准化组织（ISO）在1987遵循一个几乎是以 IBM SQL 为基础的标准关连式资料语言定义。 <wbr /><wbr />一、资料定义 ＤＤＬ（Data Definition Language) <wbr /><wbr />资料定语言是指对资料的格式和形态下定义的语言，他是每个资料库要建立时候时首先要面对的，举凡资料分哪些表格关系、表格内的有什麽栏位主键、表格和表格之间互相参考的关系等等，都是在开始的时候所必须规划好的。 <wbr /><wbr />１、建表格： <wbr /><wbr />Create TABLE table_name( <wbr /><wbr />column1 DATATYPE [NOT NULL] [NOT NULL PRIMARY KEY], <wbr /><wbr />column2 DATATYPE [NOT NULL], <wbr /><wbr />...） <wbr /><wbr />说明：　 <wbr /><wbr />DATATYPE --是资料的格式，详见表。 <wbr /><wbr />NUT NULL --可不可以允许资料有空的（尚未有资料填入）。 <wbr /><wbr />PRIMARY KEY --是本表的主键。 <wbr /><wbr />２、更改表格　 <wbr /><wbr />Alter TABLE table_name <wbr /><wbr />ADD COLUMN column_name DATATYPE <wbr /><wbr />说明：增加一个栏位（没有删除某个栏位的语法。 <wbr /><wbr />Alter TABLE table_name <wbr /><wbr />ADD PRIMARY KEY (column_name) <wbr /><wbr />说明：更改表得的定义把某个栏位设为主键。 <wbr /><wbr />Alter TABLE table_name <wbr /><wbr />Drop PRIMARY KEY (column_name) <wbr /><wbr />说明：把主键的定义删除。 <wbr /><wbr />３、建立索引　 <wbr /><wbr />Create INDEX index_name ON table_name (column_name) <wbr /><wbr />说明：对某个表格的栏位建立索引以增加查询时的速度。 <wbr /><wbr />４、删除　 <wbr /><wbr />Drop table_name <wbr /><wbr />Drop index_name <wbr /><wbr />二、的资料形态 DATATYPEs <wbr /><wbr />smallint <wbr /><wbr />16 位元的整数。 <wbr /><wbr />interger <wbr /><wbr />32 位元的整数。 <wbr /><wbr />decimal(p,s) <wbr /><wbr />p 精确值和 s 大小的十进位整数，精确值p是指全部有几个数(digits)大小值，s是指小数 <wbr /><wbr />点後有几位数。如果没有特别指定，则系统会设为 p=5; s=0 。 <wbr /><wbr />float <wbr /><wbr />32位元的实数。 <wbr /><wbr />double <wbr /><wbr />64位元的实数。 <wbr /><wbr />char(n) <wbr /><wbr />n 长度的字串，n不能超过 254。 <wbr /><wbr />varchar(n) <wbr /><wbr />长度不固定且其最大长度为 n 的字串，n不能超过 4000。 <wbr /><wbr />graphic(n) <wbr /><wbr />和 char(n) 一样，不过其单位是两个字元 double-bytes， n不能超过127。这个形态是为 <wbr /><wbr />了支援两个字元长度的字体，例如中文字。 <wbr /><wbr />vargraphic(n) <wbr /><wbr />可变长度且其最大长度为 n 的双字元字串，n不能超过 2000。 <wbr /><wbr />date <wbr /><wbr />包含了 年份、月份、日期。 <wbr /><wbr />time <wbr /><wbr />包含了 小时、分钟、秒。 <wbr /><wbr />timestamp <wbr /><wbr />包含了 年、月、日、时、分、秒、千分之一秒。 <wbr /><wbr />三、资料*作 ＤＭＬ （Data Manipulation Language) <wbr /><wbr />资料定义好之後接下来的就是资料的*作。资料的*作不外乎增加资料（insert)、查询资料（query）、更改资料（update) 、删除资料（delete）四种模式，以下分 别介绍他们的语法： <wbr /><wbr />１、增加资料： <wbr /><wbr />Insert INTO table_name (column1,column2,...) <wbr /><wbr />valueS ( value1,value2, ...) <wbr /><wbr />说明： <wbr /><wbr />1.若没有指定column 系统则会按表格内的栏位顺序填入资料。 <wbr /><wbr />2.栏位的资料形态和所填入的资料必须吻合。 <wbr /><wbr />3.table_name 也可以是景观 view_name。 <wbr /><wbr />Insert INTO table_name (column1,column2,...) <wbr /><wbr />Select columnx,columny,... FROM another_table <wbr /><wbr />说明：也可以经过一个子查询（subquery）把别的表格的资料填入。 <wbr /><wbr />２、查询资料： <wbr /><wbr />基本查询 <wbr /><wbr />Select column1,columns2,... <wbr /><wbr />FROM table_name <wbr /><wbr />说明：把table_name 的特定栏位资料全部列出来 <wbr /><wbr />Select * <wbr /><wbr />FROM table_name <wbr /><wbr />Where column1 = xxx <wbr /><wbr />[AND column2 〉 yyy] [OR column3 〈〉 zzz] <wbr /><wbr />说明： <wbr /><wbr />1.&#39;*&#39;表示全部的栏位都列出来。 <wbr /><wbr />2.Where 之後是接条件式，把符合条件的资料列出来。 <wbr /><wbr />Select column1,column2 <wbr /><wbr />FROM table_name <wbr /><wbr />orDER BY column2 [DESC] <wbr /><wbr />说明：ORDER BY 是指定以某个栏位做排序，[DESC]是指从大到小排列，若没有指明，则是从小到大 <wbr /><wbr />排列 <wbr /><wbr />组合查询 <wbr /><wbr />组合查询是指所查询得资料来源并不只有单一的表格，而是联合一个以上的 <wbr /><wbr />表格才能够得到结果的。 <wbr /><wbr />Select * <wbr /><wbr />FROM table1,table2 <wbr /><wbr />Where table1.colum1=table2.column1 <wbr /><wbr />说明： <wbr /><wbr />1.查询两个表格中其中 column1 值相同的资料。 <wbr /><wbr />2.当然两个表格相互比较的栏位，其资料形态必须相同。 <wbr /><wbr />3.一个复杂的查询其动用到的表格可能会很多个。 <wbr /><wbr />整合性的查询： <wbr /><wbr />Select COUNT (*) <wbr /><wbr />FROM table_name <wbr /><wbr />Where column_name = xxx <wbr /><wbr />说明： <wbr /><wbr />查询符合条件的资料共有几笔。 <wbr /><wbr />Select SUM(column1) <wbr /><wbr />FROM table_name <wbr /><wbr />说明： <wbr /><wbr />1.计算出总和，所选的栏位必须是可数的数字形态。 <wbr /><wbr />2.除此以外还有 AVG() 是计算平均、MAX()、MIN()计算最大最小值的整合性查询。 <wbr /><wbr />Select column1,AVG(column2) <wbr /><wbr />FROM table_name <wbr /><wbr />GROUP BY column1 <wbr /><wbr />HAVING AVG(column2) 〉 xxx <wbr /><wbr />说明： <wbr /><wbr />1.GROUP BY: 以column1 为一组计算 column2 的平均值必须和 AVG、SUM等整合性查询的关键字 <wbr /><wbr />一起使用。 <wbr /><wbr />2.HAVING : 必须和 GROUP BY 一起使用作为整合性的限制。 <wbr /><wbr />复合性的查询 <wbr /><wbr />Select * <wbr /><wbr />FROM table_name1 <wbr /><wbr />Where EXISTS ( <wbr /><wbr />Select * <wbr /><wbr />FROM table_name2 <wbr /><wbr />Where conditions ) <wbr /><wbr />说明： <wbr /><wbr />1.Where 的 conditions 可以是另外一个的 query。 <wbr /><wbr />2.EXISTS 在此是指存在与否。 <wbr /><wbr />Select * <wbr /><wbr />FROM table_name1 <wbr /><wbr />Where column1 IN ( <wbr /><wbr />Select column1 <wbr /><wbr />FROM table_name2 <wbr /><wbr />Where conditions ) <wbr /><wbr />说明：　 <wbr /><wbr />1. IN 後面接的是一个集合，表示column1 存在集合里面。 <wbr /><wbr />2. Select 出来的资料形态必须符合 column1。 <wbr /><wbr />其他查询 <wbr /><wbr />Select * <wbr /><wbr />FROM table_name1 <wbr /><wbr />Where column1 LIKE &#39;x%&#39; <wbr /><wbr />说明：LIKE 必须和後面的&#39;x%&#39; 相呼应表示以 x为开头的字串。 <wbr /><wbr />Select * <wbr /><wbr />FROM table_name1 <wbr /><wbr />Where column1 IN (&#39;xxx&#39;,&#39;yyy&#39;,..) <wbr /><wbr />说明：IN 後面接的是一个集合，表示column1 存在集合里面。 <wbr /><wbr />Select * <wbr /><wbr />FROM table_name1 <wbr /><wbr />Where column1 BETWEEN xx AND yy <wbr /><wbr />说明：BETWEEN 表示 column1 的值介於 xx 和 yy 之间。 <wbr /><wbr />３、更改资料： <wbr /><wbr />Update table_name <wbr /><wbr />SET column1=&#39;xxx&#39; <wbr /><wbr />Where conditoins <wbr /><wbr />说明： <wbr /><wbr />1.更改某个栏位设定其值为&#39;xxx&#39;。 <wbr /><wbr />2.conditions 是所要符合的条件、若没有 Where 则整个 table 的那个栏位都会全部被更改。 <wbr /><wbr />４、删除资料： <wbr /><wbr />Delete FROM table_name <wbr /><wbr />Where conditions <wbr /><wbr />说明：删除符合条件的资料。 <wbr /><wbr />说明：关于Where条件后面如果包含有日期的比较，不同数据库有不同的表达式。具体如下： <wbr /><wbr />(1)如果是ACCESS数据库，则为：Where mydate〉#2000-01-01# <wbr /><wbr />(2)如果是ORACLE数据库，则为：Where mydate〉cast(&#39;2000-01-01&#39; as date) <wbr /><wbr />或：Where mydate〉to_date(&#39;2000-01-01&#39;,&#39;yyyy-mm-dd&#39;) <wbr /><wbr />在Delphi中写成： <wbr /><wbr />thedate=&#39;2000-01-01&#39;; <wbr /><wbr />query1.SQL.add(&#39;select * from abc where mydate〉cast(&#39;+&#39;&#39;&#39;&#39;+thedate+&#39;&#39;&#39;&#39;+&#39; as date)&#39;); <wbr /><wbr />如果比较日期时间型，则为： <wbr /><wbr />Where mydatetime〉to_date(&#39;2000-01-01 10:00:01&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)Recordset对象一些有用的属性&quot;/〉 引用来自 增加一个 ：Recordset对象一些有用的属性rs.CursorType=rs.CursorLocation=rs.LockType = <wbr /><wbr />rs.CacheSize=rs.Pagesize=rs.Pagecount=rs.RecordCount=&#39;&#39;---- CursorType Values ----Const adOpenForwardOnly = 0 仅向前Const adOpenKeyset = 1 键集游标Const adOpenDynamic = 2 动态游标Const adOpenStatic = 3 静态游标&#39;&#39;---- LockType Values ----Const adLockReadOnly = 1 默认值，只读Const adLockPessimistic = 2 保守式记录锁定 <wbr /><wbr />Const adLockOptimistic = 3 开放式记录锁定，只在调用Update方法时锁定记录Const adLockBatchOptimistic = 4 开放式批更新&#39;&#39;---- CursorLocation Values ----Const adUseServer = 2Const adUseClient = 3 <wbr /><wbr />Set rs=Server.CreateObject(&quot;ADODB.Rrecordset&quot;) <wbr /><wbr />rs.Open.sqlst,conn,1,1 &#39;读取 <wbr /><wbr />rs.Open sqlst,conn,1,2 &#39;新增，修改，或删除）下一页 ：《SQL SERVER的数据类型》〉〉〉---------我想分页！--这么长的文章，在这里来个分页多好啊！哈哈----------〈〈〈《SQL SERVER的数据类型》1.SQL SERVER的数据类型 <wbr /><wbr />　　数据类弄是数据的一种属性，表示数据所表示信息的类型。任何一种计算机语言都定义了自己的数据类型。当然，不同的程序语言都具有不同的特点，所定义的数据类型的各类和名称都或多或少有些不同。SQLServer 提供了 25 种数据类型：　　&middot;Binary [(n)]　　&middot;Varbinary [(n)]　　&middot;Char [(n)]　　&middot;Varchar[(n)]　　&middot;Nchar[(n)]　　&middot;Nvarchar[(n)]　　&middot;Datetime　　&middot;Smalldatetime　　&middot;Decimal[(p[,s])]　　&middot;Numeric[(p[,s])]　　&middot;Float[(n)]　　&middot;Real　　&middot;Int　　&middot;Smallint　　&middot;Tinyint　　&middot;Money　　&middot;Smallmoney　　&middot;Bit　　&middot;Cursor　　&middot;Sysname　　&middot;Timestamp　　&middot;Uniqueidentifier　　&middot;Text　　&middot;Image　　&middot;Ntext <wbr /><wbr />(1)二进制数据类型 <wbr /><wbr />　　二进制数据包括 Binary、Varbinary 和 Image　　Binary 数据类型既可以是固定长度的(Binary),也可以是变长度的。　　Binary[(n)] 是 n 位固定的二进制数据。其中，n 的取值范围是从 1 到 8000。其存储窨的大小是 n + 4 个字节。　　Varbinary[(n)] 是 n 位变长度的二进制数据。其中，n 的取值范围是从 1 到 8000。其存储窨的大小是 n + 4个字节，不是n 个字节。　　在 Image 数据类型中存储的数据是以位字符串存储的，不是由 SQL Server 解释的，必须由应用程序来解释。例如，应用程序可以使用BMP、TIEF、GIF 和 JPEG 格式把数据存储在 Image 数据类型中。 <wbr /><wbr />(2)字符数据类型 <wbr /><wbr />　　字符数据的类型包括 Char，Varchar 和 Text　　字符数据是由任何字母、符号和数字任意组合而成的数据。　　Varchar 是变长字符数据，其长度不超过 8KB。Char 是定长字符数据，其长度最多为 8KB。超过 8KB 的ASCII 数据可以使用Text数据类型存储。例如，因为 Html 文档全部都是 ASCII 字符，并且在一般情况下长度超过 8KB，所以这些文档可以 Text 数据类型存储在SQL Server 中。 <wbr /><wbr />(3)Unicode 数据类型 <wbr /><wbr />　　Unicode 数据类型包括 Nchar,Nvarchar 和Ntext　　在 Microsoft SQL Server 中，传统的非 Unicode 数据类型允许使用由特定字符集定义的字符。在 SQL Server安装过程中，允许选择一种字符集。使用 Unicode 数据类型，列中可以存储任何由Unicode 标准定义的字符。在 Unicode 标准中，包括了以各种字符集定义的全部字符。使用Unicode数据类型，所战胜的窨是使用非 Unicode 数据类型所占用的窨大小的两倍。 <wbr /><wbr />　　在 SQL Server 中，Unicode 数据以 Nchar、Nvarchar 和 Ntext 数据类型存储。使用这种字符类型存储的列可以存储多个字符集中的字符。当列的长度变化时，应该使用Nvarchar 字符类型，这时最多可以存储 4000 个字符。当列的长度固定不变时，应该使用 Nchar 字符类型，同样，这时最多可以存储4000 个字符。当使用 Ntext 数据类型时，该列可以存储多于 4000 个字符。 <wbr /><wbr />(4)日期和时间数据类型 <wbr /><wbr />　　日期和时间数据类型包括 Datetime 和 Smalldatetime两种类型　　日期和时间数据类型由有效的日期和时间组成。例如，有效的日期和时间数据包括&ldquo;4/01/98 12:15:00:00:00 PM&rdquo;和&ldquo;1:28:29:15:01AM 8/17/98&rdquo;。前一个数据类型是日期在前，时间在后一个数据类型是霎时间在前，日期在后。在 Microsoft SQL Server中，日期和时间数据类型包括Datetime 和 Smalldatetime 两种类型时，所存储的日期范围是从 1753 年 1 月 1 日开始，到9999 年12 月 31 日结束(每一个值要求 8 个存储字节)。使用 Smalldatetime 数据类型时，所存储的日期范围是 1900年 1 月 1日 开始，到 2079 年 12 月 31 日结束(每一个值要求 4 个存储字节)。　　日期的格式可以设定。设置日期格式的命令如下：　　Set DateFormat {format | @format _var|　　其中，format | @format_var 是日期的顺序。有效的参数包括 MDY、DMY、YMD、YDM、MYD 和 DYM。在默认情况下，日期格式为MDY。　　例如，当执行 Set DateFormat YMD 之后，日期的格式为年 月 日 形式；当执行 Set DateFormat DMY 之后，日期的格式为日 月有年 形式 <wbr /><wbr />（5）数字数据类型 <wbr /><wbr />　　数字数据只包含数字。数字数据类型包括正数和负数、小数（浮点数）和整数　　整数由正整数和负整数组成，例如 39、25、0-2 和 33967。在 Micrsoft SQL Server 中，整数存储的数据类型是 　　 Int，Smallint和 Tinyint。Int 数据类型存储数据的范围大于 Smallint 数据类型存储数据的范围，而 Smallint 据类型存储数据的范围大于Tinyint 数据类型存储数据的范围。使用 Int 数据狗昔存储数据的范围是从 -2 147 483 648 到 2 147 483 647（每一个值要求4个字节存储空间）。使用 Smallint 数据类型时，存储数据的范围从 -32 768 到 32 767（每一个值要求2个字节存储空间）。使用Tinyint 数据类型时，存储数据的范围是从0 到255（每一个值要求1个字节存储空间）。　　精确小娄数据在 SQL Server 中的数据类型是 Decimal 和 Numeric。这种数据所占的存储空间根据该数据的位数后的位数来确定。　　在SQL Server 中，近似小数数据的数据类型是 Float 和 Real。例如，三分之一这个分数记作。3333333，当使用近似数据类型时能准确表示。因此，从系统中检索到的数据可能与存储在该列中数据不完全一样。 <wbr /><wbr />（6）货币数据表示正的或者负的货币数量 。 <wbr /><wbr />　　在 Microsoft SQL Server 中，货币数据的数据类型是Money 和 Smallmoney <wbr /><wbr />　　Money数据类型要求 8 个存储字节，Smallmoney 数据类型要求 4 个存储字节。 <wbr /><wbr />（7）特殊数据类型 <wbr /><wbr />　　特殊数据类型包括前面没有提过的数据类型。特殊的数据类型有3种，即 　　 Timestamp、Bit 和 Uniqueidentifier。　　Timestamp 用于表示SQL Server 活动的先后顺序，以二进投影的格式表示。Timestamp 数据与插入数据或者日期和时间没有关系。　　Bit 由 1 或者 0 组成。当表示真或者假、ON 或者 OFF 时，使用 Bit 数据类型。例如，询问是否是每一次访问的客户机请求可以存储在这种数据类型的列中。　　Uniqueidentifier 由 16 字节的十六进制数字组成，表示一个全局唯一的。当表的记录行要求唯一时，GUID是非常有用。例如，在客户标识号列使用这种数据类型可以区别不同的客户。 <wbr /><wbr />2.用户定义的数据类型 <wbr /><wbr />　　用户定义的数据类型基于在 Microsoft SQL Server 中提供的数据类型。当几个表中必须存储同一种数据类型时，并且为保证这些列有相同的数据类型、长度和可空性时，可以使用用户定义的数据类型。例如，可定义一种称为 　　postal_code 的数据类型，它基于 Char 数据类型。　　当创建用户定义的数据类型时，必须提供三个数：数据类型的名称、所基于的系统数据类型和数据类型的可空性。 <wbr /><wbr />（1）创建用户定义的数据类型 <wbr /><wbr />　　创建用户定义的数据类型可以使用 Transact-SQL 语句。系统存储过程 sp_addtype 可以来创建用户定义的数据类型。其语法形式如下：　　sp_addtype {type},[,system_data_bype][,&#39;null_type&#39;]　　其中，type 是用户定义的数据类型的名称。system_data_type 是系统提供的数据类型，例如 Decimal、Int、Char 　　等等。 null_type 表示该数据类型是如何处理空值的，必须使用单引号引起来，例如&#39;NULL&#39;、&#39;NOT NULL&#39;或者&#39;NONULL&#39;。　　例子：　　Use cust　　Exec sp_addtype ssn,&#39;Varchar(11)&#39;,&quot;Not Null&#39;　　创建一个用户定义的数据类型 ssn，其基于的系统数据类型是变长为11 的字符，不允许空。　　例子：　　Use cust　　Exec sp_addtype birthday,datetime,&#39;Null&#39;　　创建一个用户定义的数据类型 birthday，其基于的系统数据类型是 DateTime，允许空。　　例子：　　Use master　　Exec sp_addtype telephone,&#39;varchar(24),&#39;Not Null&#39;　　Eexc sp_addtype fax,&#39;varchar(24)&#39;,&#39;Null&#39;　　创建两个数据类型，即 telephone 和 fax <wbr /><wbr />（2）删除用户定义的数据类型 <wbr /><wbr />　　当用户定义的数据类型不需要时，可删除。删除用户定义的数据类型的命令是 sp_droptype {&#39;type&#39;}。　　例子：　　Use master　　Exec sp_droptype &#39;ssn&#39;　　注意：当表中的列还正在使用用户定义的数据类型时，或者在其上面还绑定有默认或者规则时，这种用户定义的数据类型不能删除。 <wbr /><wbr />　　以下为SQL SERVER7.0以上版本的字段类型说明。SQL SERVER6.5的字段类型说明请参考SQL SERVER提供的说明。字段类型 描述 <wbr /><wbr />bit 0或1的整型数字 <wbr /><wbr />int 从-2^31(-2,147,483,648)到2^31(2,147,483,647)的整型数字 <wbr /><wbr />smallint 从-2^15(-32,768)到2^15(32,767)的整型数字 <wbr /><wbr />tinyint 从0到255的整型数字 <wbr /><wbr />decimal 从-10^38到10^38-1的定精度与有效位数的数字 <wbr /><wbr />numeric decimal的同义词 <wbr /><wbr />money 从-2^63(-922,337,203,685,477.5808)到2^63-1(922,337,203,685,477.5807)的货币数据，最小货币单位千分之十 <wbr /><wbr />smallmoney 从-214,748.3648到214,748.3647的货币数据，最小货币单位千分之十 <wbr /><wbr />float 从-1.79E+308到1.79E+308可变精度的数字 <wbr /><wbr />real 从-3.04E+38到3.04E+38可变精度的数字 <wbr /><wbr />datetime 从1753年1月1日到9999年12日31的日期和时间数据，最小时间单位为百分之三秒或3.33毫秒 <wbr /><wbr />smalldatetime 从1900年1月1日到2079年6月6日的日期和时间数据，最小时间单位为分钟 <wbr /><wbr />timestamp 时间戳，一个数据库宽度的唯一数字 <wbr /><wbr />uniqueidentifier 全球唯一标识符GUID <wbr /><wbr />char 定长非Unicode的字符型数据，最大长度为8000 <wbr /><wbr />varchar 变长非Unicode的字符型数据，最大长度为8000 <wbr /><wbr />text 变长非Unicode的字符型数据，最大长度为2^31-1(2G) <wbr /><wbr />nchar 定长Unicode的字符型数据，最大长度为8000 <wbr /><wbr />nvarchar 变长Unicode的字符型数据，最大长度为8000 <wbr /><wbr />ntext 变长Unicode的字符型数据，最大长度为2^31-1(2G) <wbr /><wbr />binary 定长二进制数据，最大长度为8000 <wbr /><wbr />varbinary 变长二进制数据，最大长度为8000 <wbr /><wbr />image 变长二进制数据，最大长度为2^31-1(2G) <wbr /><wbr />〉〉〉---------我想分页！--这么长的文章，在这里来个分页多好啊！哈哈----------〈〈〈《SQL语句的基本语法》一.Select语句的完整语法为：Select[ALL|DISTINCT|DISTINCTROW|TOP]{*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,&hellip;]]}FROM tableexpression[,&hellip;][IN externaldatabase][Where&hellip;][GROUP BY&hellip;][HAVING&hellip;][ORDER BY&hellip;][WITH OWNERACCESS OPTION]说明：用中括号([])括起来的部分表示是可选的，用大括号({})括起来的部分是表示必须从中选择其中的一个。1 FROM子句FROM子句指定了Select语句中字段的来源。FROM子句后面是包含一个或多个的表达式(由逗号分开)，其中的表达式可为单一表名称、已保存的查询或由 INNER JOIN、LEFT JOIN 或 RIGHT JOIN 得到的复合结果。如果表或查询存储在外部数据库，在IN 子句之后指明其完整路径。例：下列SQL语句返回所有有定单的客户：Select orderID,Customer.customerIDFROM orders CustomersWhere orders.CustomerID=Customers.CustomeersID2 ALL、DISTINCT、DISTINCTROW、TOP谓词(1) ALL 返回满足SQL语句条件的所有记录。如果没有指明这个谓词，默认为ALL。例：Select ALL FirstName,LastNameFROM Employees(2) DISTINCT 如果有多个记录的选择字段的数据相同，只返回一个。(3) DISTINCTROW 如果有重复的记录，只返回一个(4) TOP显示查询头尾若干记录。也可返回记录的百分比，这是要用 TOP N PERCENT子句（其中N 表示百分比）例：返回5%定货额最大的定单Select TOP 5 PERCENT*FROM [ order Details]orDER BY UnitPrice*Quantity*(1-Discount) DESC3 用 AS 子句为字段取别名如果想为返回的列取一个新的标题，或者，经过对字段的计算或总结之后，产生了一个新的值，希望把它放到一个新的列里显示，则用AS保留。例：返回FirstName字段取别名为NickNameSelect FirstName AS NickName ,LastName ,CityFROM Employees例：返回新的一列显示库存价值Select ProductName ,UnitPrice ,UnitsInStock ,UnitPrice*UnitsInStock AS valueInStockFROM Products二 .Where 子句指定查询条件1 比较运算符比较运算符 含义= 等于〉 大于〈 小于〉= 大于等于〈= 小于等于〈〉 不等于!〉 不大于!〈 不小于例：返回96年1月的定单Select orderID, CustomerID, orderDateFROM ordersWhere orderDate〉#1/1/96# AND orderDate〈#1/30/96#注意：Mcirosoft JET SQL 中，日期用&lsquo;#&#39;定界。日期也可以用Datevalue()函数来代替。在比较字符型的数据时，要加上单引号&#39;&#39;，尾空格在比较中被忽略。例：Where orderDate〉#96-1-1#也可以表示为：Where orderDate〉Datevalue(&lsquo;1/1/96&#39;)使用 NOT 表达式求反。例：查看96年1月1日以后的定单Where Not orderDate〈=#1/1/96#2 范围（BETWEEN 和 NOT BETWEEN）BETWEEN &hellip;AND&hellip;运算符指定了要搜索的一个闭区间。例：返回96年1月到96年2月的定单。Where orderDate Between #1/1/96# And #2/1/96#3 列表（IN ，NOT IN）IN 运算符用来匹配列表中的任何一个值。IN子句可以代替用OR子句连接的一连串的条件。例：要找出住在 London、Paris或Berlin的所有客户Select CustomerID, CompanyName, ContactName, CityFROM CustomersWhere City In(&lsquo;London&#39;,&#39; Paris&#39;,&#39; Berlin&#39;)4 模式匹配(LIKE)LIKE运算符检验一个包含字符串数据的字段值是否匹配一指定模式。LIKE运算符里使用的通配符通配符 含义？ 任何一个单一的字符* 任意长度的字符# 0~9之间的单一数字[字符列表] 在字符列表里的任一值[！字符列表] 不在字符列表里的任一值- 指定字符范围，两边的值分别为其上下限例：返回邮政编码在（171）555-0000到（171）555-9999之间的客户Select CustomerID ,CompanyName,City,PhoneFROM CustomersWhere Phone Like &lsquo;(171)555-####&#39;LIKE运算符的一些样式及含义样式 含义 不符合LIKE &lsquo;A*&#39; A后跟任意长度的字符 Bc,c255LIKE&#39;5 <wbr /><wbr />&#39; 5*5 555LIKE&#39;5?5&#39; 5与5之间有任意一个字符 55,5wer5LIKE&#39;5##5&#39; 5235，5005 5kd5,5346LIKE&#39;[a-z]&#39; a-z间的任意一个字符 5,%LIKE&#39;[!0-9]&#39; 非0-9间的任意一个字符 0,1LIKE&#39;[[]&#39; 1,*三 .用ORDER BY子句排序结果orDER子句按一个或多个（最多16个）字段排序查询结果，可以是升序（ASC）也可以是降序（DESC），缺省是升序。ORDER子句通常放在SQL语句的最后。orDER子句中定义了多个字段，则按照字段的先后顺序排序。例：Select ProductName,UnitPrice, UnitInStockFROM ProductsorDER BY UnitInStock DESC , UnitPrice DESC, ProductName <wbr /><wbr />orDER BY 子句中可以用字段在选择列表中的位置号代替字段名，可以混合字段名和位置号。例：下面的语句产生与上列相同的效果。Select ProductName,UnitPrice, UnitInStockFROM ProductsorDER BY 1 DESC , 2 DESC,3 <wbr /><wbr />四 .运用连接关系实现多表查询例：找出同一个城市中供应商和客户的名字Select Customers.CompanyName, Suppliers.ComPany.NameFROM Customers, SuppliersWhere Customers.City=Suppliers.City例：找出产品库存量大于同一种产品的定单的数量的产品和定单Select ProductName,OrderID, UnitInStock, QuantityFROM Products, [Order Deails]Where Product.productID=[Order Details].ProductIDAND UnitsInStock〉Quantity另一种方法是用 Microsof JET SQL 独有的 JNNER JOIN语法：FROM table1 INNER JOIN table2ON table1.field1 comparision table2.field2其中comparision 就是前面Where子句用到的比较运算符。Select FirstName,lastName,OrderID,CustomerID,OrderDateFROM EmployeesINNER JOIN orders ON Employees.EmployeeID=Orders.EmployeeID注意：INNER JOIN不能连接Memo OLE Object Single Double 数据类型字段。在一个JOIN语句中连接多个ON子句语法：Select fieldsFROM table1 INNER JOIN table2ON table1.field1 compopr table2.field1 ANDON table1.field2 compopr table2.field2 orON table1.field3 compopr table2.field3也可以Select fieldsFROM table1 INNER JOIN（table2 INNER JOIN [( ]table3[INNER JOER] [( ]tablex[INNER JOIN]ON table1.field1 compopr table2.field1 <wbr /><wbr />ON table1.field2 compopr table2.field2 <wbr /><wbr />ON table1.field3 compopr table2.field3外部连接返回更多记录，在结果中保留不匹配的记录，不管存不存在满足条件的记录都要返回另一侧的所有记录。FROM table [LEFT|RIGHT]JOIN table2ON table1.field1comparision table.field2用左连接来建立外部连接，在表达式的左边的表会显示其所有的数据例：不管有没有定货量，返回所有商品Select ProductName ,OrderIDFROM ProductsLEFT JOIN orders ON Products.PrductsID=Orders.ProductID右连接与左连接的差别在于：不管左侧表里有没有匹配的记录，它都从左侧表中返回所有记录。例：如果想了解客户的信息，并统计各个地区的客户分布，这时可以用一个右连接，即使某个地区没有客户，也要返回客户信息。空值不会相互匹配，可以通过外连接才能测试被连接的某个表的字段是否有空值。Select *FROM talbe1LEFT JOIN table2 ON table1.a=table2.c1 连接查询中使用Iif函数实现以0值显示空值Iif表达式： Iif(IsNull(Amount,0,Amout)例：无论定货大于或小于￥50，都要返回一个标志。Iif([Amount]〉50,?Big order?,?Small order?)五. 分组和总结查询结果在SQL的语法里，GROUP BY和HAVING子句用来对数据进行汇总。GROUP BY子句指明了按照哪几个字段来分组，而将记录分组后，用HAVING子句过滤这些记录。GROUP BY 子句的语法Select fidldlistFROM tableWhere criteria[GROUP BY groupfieldlist [HAVING groupcriteria]]注：Microsoft Jet数据库 Jet 不能对备注或OLE对象字段分组。GROUP BY字段中的Null值以备分组但是不能被省略。在任何SQL合计函数中不计算Null值。GROUP BY子句后最多可以带有十个字段，排序优先级按从左到右的顺序排列。例：在&lsquo;WA&#39;地区的雇员表中按头衔分组后，找出具有同等头衔的雇员数目大于1人的所有头衔。Select Title ,Count(Title) as TotalFROM EmployeesWhere Region = &lsquo;WA&#39;GROUP BY TitleHAVING Count(Title)〉1JET SQL 中的聚积函数聚集函数 意义SUM ( ) 求和AVG ( ) 平均值COUNT ( ) 表达式中记录的数目COUNT (* ) 计算记录的数目MAX 最大值MIN 最小值VAR 方差STDEV 标准误差FIRST 第一个值LAST 最后一个值六. 用Parameters声明创建参数查询Parameters声明的语法:PARAMETERS name datatype[,name datatype[, &hellip;]]其中name 是参数的标志符,可以通过标志符引用参数.Datatype说明参数的数据类型.使用时要把PARAMETERS 声明置于任何其他语句之前.例:PARAMETERS[Low price] Currency,[Beginning date]datatimeSelect orderID ,OrderAmountFROM ordersWhere orderAMount〉[low price]AND orderDate〉=[Beginning date]七. 功能查询所谓功能查询,实际上是一种操作查询,它可以对数据库进行快速高效的操作.它以选择查询为目的,挑选出符合条件的数据,再对数据进行批处理.功能查询包括更新查询,删除查询,添加查询,和生成表查询.1 更新查询Update子句可以同时更改一个或多个表中的数据.它也可以同时更改多个字段的值.更新查询语法:Update 表名SET 新值Where 准则例:英国客户的定货量增加5%,货运量增加3%Update OEDERSSET orderAmount = orderAmount *1.1Freight = Freight*1.03Where ShipCountry = &lsquo;UK&#39;2 删除查询Delete子句可以使用户删除大量的过时的或冗于的数据.注:删除查询的对象是整个记录.Delete子句的语法:Delete [表名.*]FROM 来源表Where 准则例: 要删除所有94年前的定单Delete *FROM ordersWhere orderData〈#94-1-1#3 追加查询 <wbr /><wbr />Insert子句可以将一个或一组记录追加到一个或多个表的尾部.INTO 子句指定接受新记录的表valueS 关键字指定新记录所包含的数据值.Insert 子句的语法:INSETR INTO 目的表或查询(字段1,字段2,&hellip;)valueS(数值1,数值2,&hellip;)例:增加一个客户Insert INTO Employees(FirstName,LastName,title)valueS(&lsquo;Harry&#39;,&#39;Washington&#39;,&#39;Trainee&#39;)4 生成表查询可以一次性地把所有满足条件的记录拷贝到一张新表中.通常制作记录的备份或副本或作为报表的基础.Select INTO子句用来创建生成表查询语法:Select 字段1,字段2,&hellip;INTO 新表[IN 外部数据库]FROM 来源数据库Where 准则例:为定单制作一个存档备份Select *INTO ordersArchiveFROM orders八. 联合查询UNION运算可以把多个查询的结果合并到一个结果集里显示.UNION运算的一般语法:[表]查询1 UNION [ALL]查询2 UNION &hellip;例:返回巴西所有供给商和客户的名字和城市Select CompanyName,CityFROM SuppliersWhere Country = &lsquo;Brazil&#39;UNIONSelect CompanyName,CityFROM CustomersWhere Country = &lsquo;Brazil&#39;注:缺省的情况下,UNION子句不返回重复的记录.如果想显示所有记录,可以加ALL选项UNION运算要求查询具有相同数目的字段.但是,字段数据类型不必相同.每一个查询参数中可以使用GROUP BY 子句 或 HAVING 子句进行分组.要想以指定的顺序来显示返回的数据,可以在最后一个查询的尾部使用OREER BY子句.九. 交叉查询交叉查询可以对数据进行总和,平均,计数或其他总和计算法的计算,这些数据通过两种信息进行分组:一个显示在表的左部,另一个显示在表的顶部.Microsoft Jet SQL 用TRANSFROM语句创建交叉表查询语法:TRANSFORM aggfunctionSelect 语句GROUP BY 子句PIVOT pivotfield[IN(value1 [,value2[,&hellip;]]) ]Aggfounction指SQL聚积函数,Select语句选择作为标题的的字段,GROUP BY 分组说明：Pivotfield 在查询结果集中创建列标题时用的字段或表达式,用可选的IN子句限制它的取值.value代表创建列标题的固定值.例:显示在1996年里每一季度每一位员工所接的定单的数目:TRANSFORM Count(OrderID)Select FirstName&amp;&#39;&#39;&amp;LastName AS FullNameFROM Employees INNER JOIN ordersON Employees.EmployeeID = orders.EmployeeIDWhere DatePart(&ldquo;yyyy&rdquo;,OrderDate)= &lsquo;1996&#39;GROUP BY FirstName&amp;&#39;&#39;&amp;LastNameorDER BY FirstName&amp;&#39;&#39;&amp;LastNamePOVOT DatePart(&ldquo;q&rdquo;,OrderDate)&amp;&#39;季度&#39;十 .子查询子查询可以理解为 套查询.子查询是一个Select语句.1 表达式的值与子查询返回的单一值做比较语法: <wbr /><wbr />表达式 comparision [ANY|ALL|SOME](子查询)说明：ANY和SOME谓词是同义词,与比较运算符(=,〈,〉,〈〉,〈=,〉=)一起使用.返回一个布尔值True或False.ANY的意思是,表达式与子查询返回的一系列的值逐一比较,只要其中的一次比较产生True结果,ANY测试的返回 True值(既Where子句的结果),对应于该表达式的当前记录将进入主查询的结果中.ALL测试则要求表达式与子查询返回的一系列的值的比较都产生True结果,才回返回True值.例:主查询返回单价比任何一个折扣大于等于25%的产品的单价要高的所有产品Select * FROM ProductsWhere UnitPrice〉ANY(Select UnitPrice FROM[Order Details] Where Discount〉0.25)2 检查表达式的值是否匹配子查询返回的一组值的某个值语法:[NOT]IN(子查询)例:返回库存价值大于等于1000的产品.Select ProductName FROM ProductsWhere ProductID IN(Select PrdoctID FROM [Order DEtails]Where UnitPrice*Quantity〉= 1000)3检测子查询是否返回任何记录语法:[NOT]EXISTS (子查询)例:用EXISTS检索英国的客户Select ComPanyName,ContactNameFROM ordersWhere EXISTS(Select *FROM CustomersWhere Country = &lsquo;UK&#39; ANDCustomers.CustomerID= orders.CustomerID)〉〉〉---------我想分页！--这么长的文章，在这里来个分页多好啊！哈哈----------〈〈〈Sql Server 和 Access 操作数据库结构Sql语句下面是Sql Server 和 Access 操作数据库结构的常用Sql，希望对你有所帮助。内容由海娃整理，不正确与不完整之处还请提出，谢谢。新建表：create table [表名]([自动编号字段] int IDENTITY (1,1) PRIMARY KEY ,[字段1] nVarChar(50) default &#39;默认值&#39; null ,[字段2] ntext null ,[字段3] datetime,[字段4] money null ,[字段5] int default 0,[字段6] Decimal (12,4) default 0,[字段7] image null ,)删除表：Drop table [表名]插入数据：Insert INTO [表名] (字段1,字段2) VALUES (100,&#39;51WINDOWS.NET&#39;)删除数据：Delete FROM [表名] Where [字段名]〉100更新数据：Update [表名] SET [字段1] = 200,[字段2] = &#39;51WINDOWS.NET&#39; Where [字段三] = &#39;HAIWA&#39;新增字段：Alter TABLE [表名] ADD [字段名] NVARCHAR (50) NULL删除字段：Alter TABLE [表名] Drop COLUMN [字段名]修改字段：Alter TABLE [表名] Alter COLUMN [字段名] NVARCHAR (50) NULL重命名表：(Access 重命名表，请参考文章：在Access数据库中重命名表)引用来自 在Access数据库中重命名表Dim Conn,ConnStr,oCat,oTblConnStr = &quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&quot; &amp; Server.MapPath(&quot;data.mdb&quot;)Set oCat=Server.CreateObject(&quot;ADOX.Catalog&quot;) <wbr /><wbr />oCat.ActiveConnection = ConnStrSet oTbl = Server.CreateObject(&quot;ADOX.Table&quot;)Set oTbl = oCat.Tables(&quot;OldTable&quot;) &#39;要重命名的表名：OldTableoTbl.Name = &quot;NewTable&quot; &#39;新表名Set oCat = NothingSet oTbl = Nothingsp_rename &#39;表名&#39;, &#39;新表名&#39;, &#39;OBJECT&#39;新建约束：Alter TABLE [表名] ADD CONSTRAINT 约束名 CHECK ([约束字段] 〈= &#39;2000-1-1&#39;)删除约束：Alter TABLE [表名] Drop CONSTRAINT 约束名新建默认值Alter TABLE [表名] ADD CONSTRAINT 默认值名 DEFAULT &#39;51WINDOWS.NET&#39; FOR [字段名]删除默认值Alter TABLE [表名] Drop CONSTRAINT 默认值名删除Sql Server 中的日志，减小数据库文件大小dump transaction 数据库名 with no_logbackup log 数据库名 with no_logdbcc shrinkdatabase(数据库名)exec sp_dboption &#39;数据库名&#39;, &#39;autoshrink&#39;, &#39;true&#39;</p>
<p><b>SQL</b><b>查询语句精华大全</b><b>.txt</b></p>
<p>一、 简单查询</p>
<p>简单的Transact-SQL查询只包括选择列表、FROM子句和WHERE子句。它们分别说明所查询列、查询的</p>
<p>表或视图、以及搜索条件等。</p>
<p>例如，下面的语句查询testtable表中姓名为&ldquo;张三&rdquo;的nickname字段和email字段。</p>
<p>SELECT nickname,email</p>
<p>FROM testtable</p>
<p>WHERE name=&#39;张三&#39;</p>
<p>(一) 选择列表</p>
<p>选择列表(select_list)指出所查询列，它可以是一组列名列表、星号、表达式、变量(包括局部变</p>
<p>量和全局变量)等构成。</p>
<p>1、选择所有列</p>
<p>例如，下面语句显示testtable表中所有列的数据：</p>
<p>SELECT *</p>
<p>FROM testtable</p>
<p>2、选择部分列并指定它们的显示次序</p>
<p>查询结果集合中数据的排列顺序与选择列表中所指定的列名排列顺序相同。</p>
<p>例如：</p>
<p>SELECT nickname,email</p>
<p>FROM testtable</p>
<p>3、更改列标题</p>
<p>在选择列表中，可重新指定列标题。定义格式为：</p>
<p>列标题=列名</p>
<p>列名 列标题</p>
<p>如果指定的列标题不是标准的标识符格式时，应使用引号定界符，例如，下列语句使用汉字显示列</p>
<p>标题：</p>
<p>SELECT 昵称=nickname,电子邮件=email</p>
<p>FROM testtable</p>
<p>4、删除重复行</p>
<p>SELECT语句中使用ALL或DISTINCT选项来显示表中符合条件的所有行或删除其中重复的数据行，默认</p>
<p>为ALL。使用DISTINCT选项时，对于所有重复的数据行在SELECT返回的结果集合中只保留一行。</p>
<p>5、限制返回的行数</p>
<p>使用TOP n [PERCENT]选项限制返回的数据行数，TOP n说明返回n行，而TOP n PERCENT时，说明n是</p>
<p>表示一百分数，指定返回的行数等于总行数的百分之几。</p>
<p>例如：</p>
<p>SELECT TOP 2 *</p>
<p>FROM testtable</p>
<p>SELECT TOP 20 PERCENT *</p>
<p>FROM testtable</p>
<p>(二) FROM子句</p>
<p>FROM子句指定SELECT语句查询及与查询相关的表或视图。在FROM子句中最多可指定256个表或视图，</p>
<p>它们之间用逗号分隔。</p>
<p>在FROM子句同时指定多个表或视图时，如果选择列表中存在同名列，这时应使用对象名限定这些列</p>
<p>所属的表或视图。例如在usertable和citytable表中同时存在cityid列，在查询两个表中的cityid时应</p>
<p>使用下面语句格式加以限定：</p>
<p>SELECT username,citytable.cityid</p>
<p>FROM usertable,citytable</p>
<p>WHERE usertable.cityid=citytable.cityid</p>
<p>在FROM子句中可用以下两种格式为表或视图指定别名：</p>
<p>表名 as 别名</p>
<p>表名 别名</p>
<p>例如上面语句可用表的别名格式表示为：</p>
<p>SELECT username,b.cityid</p>
<p>FROM usertable a,citytable b</p>
<p>WHERE a.cityid=b.cityid</p>
<p>SELECT不仅能从表或视图中检索数据，它还能够从其它查询语句所返回的结果集合中查询数据。</p>
<p>例如：</p>
<p>SELECT a.au_fname+a.au_lname</p>
<p>FROM authors a,titleauthor ta</p>
<p>(SELECT title_id,title</p>
<p>FROM titles</p>
<p>WHERE ytd_sales&gt;10000</p>
<p>) AS t</p>
<p>WHERE a.au_id=ta.au_id</p>
<p>AND ta.title_id=t.title_id</p>
<p>此例中，将SELECT返回的结果集合给予一别名t，然后再从中检索数据。</p>
<p>(三) 使用WHERE子句设置查询条件</p>
<p>WHERE子句设置查询条件，过滤掉不需要的数据行。例如下面语句查询年龄大于20的数据：</p>
<p>SELECT *</p>
<p>FROM usertable</p>
<p>WHERE age&gt;20</p>
<p>WHERE子句可包括各种条件运算符：</p>
<p>比较运算符(大小比较)：&gt;、&gt;=、=、&lt;、&lt;=、&lt;&gt;、!&gt;、!&lt;</p>
<p>范围运算符(表达式值是否在指定的范围)：BETWEEN&hellip;AND&hellip;</p>
<p>NOT BETWEEN&hellip;AND&hellip;</p>
<p>列表运算符(判断表达式是否为列表中的指定项)：IN (项1,项2&hellip;&hellip;)</p>
<p>NOT IN (项1,项2&hellip;&hellip;)</p>
<p>模式匹配符(判断值是否与指定的字符通配格式相符):LIKE、NOT LIKE</p>
<p>空值判断符(判断表达式是否为空)：IS NULL、NOT IS NULL</p>
<p>逻辑运算符(用于多条件的逻辑连接)：NOT、AND、OR</p>
<p>1、范围运算符例：age BETWEEN 10 AND 30相当于age&gt;=10 AND age&lt;=30</p>
<p>2、列表运算符例：country IN (&#39;Germany&#39;,&#39;China&#39;)</p>
<p>3、模式匹配符例：常用于模糊查找，它判断列值是否与指定的字符串格式相匹配。可用于char、</p>
<p>varchar、text、ntext、datetime和smalldatetime等类型查询。</p>
<p>可使用以下通配字符：</p>
<p>百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。</p>
<p>下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。</p>
<p>方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</p>
<p>[^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</p>
<p>例如：</p>
<p>限制以Publishing结尾，使用LIKE &#39;%Publishing&#39;</p>
<p>限制以A开头：LIKE &#39;[A]%&#39;</p>
<p>限制以A开头外：LIKE &#39;[^A]%&#39;</p>
<p>4、空值判断符例WHERE age IS NULL</p>
<p>5、逻辑运算符：优先级为NOT、AND、OR</p>
<p>(四)查询结果排序</p>
<p>使用ORDER BY子句对查询返回的结果按一列或多列排序。ORDER BY子句的语法格式为：</p>
<p>ORDER BY {column_name [ASC|DESC]} [,&hellip;n]</p>
<p>其中ASC表示升序，为默认值，DESC为降序。ORDER BY不能按ntext、text和image数据类型进行排</p>
<p>序。</p>
<p>例如：</p>
<p>SELECT *</p>
<p>FROM usertable</p>
<p>ORDER BY age desc,userid ASC</p>
<p>另外，可以根据表达式进行排序。</p>
<p>二、 联合查询</p>
<p>UNION运算符可以将两个或两个以上上SELECT语句的查询结果集合合并成一个结果集合显示，即执行联</p>
<p>合查询。UNION的语法格式为：</p>
<p>select_statement</p>
<p>UNION [ALL] selectstatement</p>
<p>[UNION [ALL] selectstatement][&hellip;n]</p>
<p>其中selectstatement为待联合的SELECT查询语句。</p>
<p>ALL选项表示将所有行合并到结果集合中。不指定该项时，被联合查询结果集合中的重复行将只保留一</p>
<p>行。</p>
<p>联合查询时，查询结果的列标题为第一个查询语句的列标题。因此，要定义列标题必须在第一个查询语</p>
<p>句中定义。要对联合查询结果排序时，也必须使用第一查询语句中的列名、列标题或者列序号。</p>
<p>在使用UNION 运算符时，应保证每个联合查询语句的选择列表中有相同数量的表达式，并且每个查询选</p>
<p>择表达式应具有相同的数据类型，或是可以自动将它们转换为相同的数据类型。在自动转换时，对于数值类</p>
<p>型，系统将低精度的数据类型转换为高精度的数据类型。</p>
<p>在包括多个查询的UNION语句中，其执行顺序是自左至右，使用括号可以改变这一执行顺序。例如：</p>
<p>查询1 UNION (查询2 UNION 查询3)</p>
<p>三、连接查询</p>
<p>通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型</p>
<p>数据库管理系统的一个标志。</p>
<p>在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在</p>
<p>一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带</p>
<p>来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，尔后通过连接进行</p>
<p>查询。</p>
<p>连接可以在SELECT 语句的FROM子句或WHERE子句中建立，似是而非在FROM子句中指出连接时有助于</p>
<p>将连接操作与WHERE子句中的搜索条件区分开来。所以，在Transact-SQL中推荐使用这种方法。</p>
<p>SQL-92标准所定义的FROM子句的连接语法格式为：</p>
<p>FROM join_table join_type join_table</p>
<p>[ON (join_condition)]</p>
<p>其中join_table指出参与连接操作的表名，连接可以对同一个表操作，也可以对多表操作，对同一</p>
<p>个表操作的连接又称做自连接。</p>
<p>join_type 指出连接类型，可分为三种：内连接、外连接和交叉连接。内连接(INNER JOIN)使用比</p>
<p>较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用</p>
<p>的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。</p>
<p>外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)</p>
<p>和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹</p>
<p>配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的</p>
<p>数据行。</p>
<p>交叉连接(CROSS JOIN)没有WHERE 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的</p>
<p>数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>
<p>连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑</p>
<p>运算符等构成。</p>
<p>无论哪种连接都不能对text、ntext和image数据类型列进行直接连接，但可以对这三种列进行间接</p>
<p>连接。例如：</p>
<p>SELECT p1.pub_id,p2.pub_id,p1.pr_info</p>
<p>FROM pub_info AS p1 INNER JOIN pub_info AS p2</p>
<p>ON DATALENGTH(p1.pr_info)=DATALENGTH(p2.pr_info)</p>
<p>(一)内连接</p>
<p>内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。内连接分</p>
<p>三种：</p>
<p>1、等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接</p>
<p>表中的所有列，包括其中的重复列。</p>
<p>2、不等连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些</p>
<p>运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;。</p>
<p>3、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询</p>
<p>结果集合中所包括的列，并删除连接表中的重复列。</p>
<p>例，下面使用等值连接列出authors和publishers表中位于同一城市的作者和出版社：</p>
<p>SELECT *</p>
<p>FROM authors AS a INNER JOIN publishers AS p</p>
<p>ON a.city=p.city</p>
<p>又如使用自然连接，在选择列表中删除authors 和publishers 表中重复列(city和state)：</p>
<p>SELECT a.*,p.pub_id,p.pub_name,p.country</p>
<p>FROM authors AS a INNER JOIN publishers AS p</p>
<p>ON a.city=p.city</p>
<p>(二)外连接</p>
<p>内连接时，返回查询结果集合中的仅是符合查询条件( WHERE 搜索条件或 HAVING 条件)和连接条件</p>
<p>的行。而采用外连接时，它返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左外</p>
<p>连接时)、右表(右外连接时)或两个边接表(全外连接)中的所有数据行。</p>
<p>如下面使用左外连接将论坛内容和作者信息连接起来：</p>
<p>SELECT a.*,b.* FROM luntan LEFT JOIN usertable as b</p>
<p>ON a.username=b.username</p>
<p>下面使用全外连接将city表中的所有作者以及user表中的所有作者，以及他们所在的城市：</p>
<p>SELECT a.*,b.*</p>
<p>FROM city as a FULL OUTER JOIN user as b</p>
<p>ON a.username=b.username</p>
<p>(三)交叉连接</p>
<p>交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到结果集合中的数</p>
<p>据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</p>
<p>例，titles表中有6类图书，而publishers表中有8家出版社，则下列交叉连接检索到的记录数将等</p>
<p>于6*8=48行。</p>
<p>SELECT type,pub_name</p>
<p>FROM titles CROSS JOIN publishers</p>
<p>ORDER BY typeSQL核心语句(非常实用的几个技巧)插入数据</p>
<p>向表中添加一个新记录，你要使用SQL INSERT 语句。这里有一个如何使用这种语句的例子：</p>
<p>INSERT mytable (mycolumn) VALUES (&lsquo;some data&#39;)</p>
<p>这个语句把字符串&#39;some data&#39;插入表mytable的mycolumn字段中。将要被插入数据的字段的名字在第一个括号中指定，实际的数据在第二个括号中给出。</p>
<p>INSERT 语句的完整句法如下：</p>
<p>INSERT [INTO] {table_name|view_name} [(column_list)] {DEFAULT VALUES |</p>
<p>Values_list | select_statement}</p>
<p>如果一个表有多个字段，通过把字段名和字段值用逗号隔开，你可以向所有的字段中插入数据。假设表mytable有三个字段first_column,second_column,和third_column。下面的INSERT语句添加了一条三个字段都有值的完整记录：</p>
<p>INSERT mytable (first_column,second_column,third_column)</p>
<p>VALUES (&lsquo;some data&#39;,&#39;some more data&#39;,&#39;yet more data&#39;)</p>
<p>注意</p>
<p>你可以使用INSERT语句向文本型字段中插入数据。但是，如果你需要输入很长的字符串，你应该使用WRITETEXT语句。这部分内容对本书来说太高级了，因此不加讨论。要了解更多的信息，请参考Microsoft SQL Sever 的文档。</p>
<p>如果你在INSERT 语句中只指定两个字段和数据会怎么样呢？换句话说，你向一个表中插入一条新记录，但有一个字段没有提供数据。在这种情况下，有下面的四种可能：</p>
<p>如果该字段有一个缺省值，该值会被使用。例如，假设你插入新记录时没有给字段third_column提供数据，而这个字段有一个缺省值&#39;some value&#39;。在这种情况下，当新记录建立时会插入值&#39;some value&#39;。</p>
<p>如果该字段可以接受空值，而且没有缺省值，则会被插入空值。</p>
<p>如果该字段不能接受空值，而且没有缺省值，就会出现错误。你会收到错误信息：</p>
<p>The column in table mytable may not be null.</p>
<p>最后，如果该字段是一个标识字段，那么它会自动产生一个新值。当你向一个有标识字段的表中插入新记录时，只要忽略该字段，标识字段会给自己赋一个新值。</p>
<p>注意</p>
<p>向一个有标识字段的表中插入新记录后，你可以用SQL变量@@identity来访问新记录</p>
<p>的标识字段的值。考虑如下的SQL语句：</p>
<p>INSERT mytable (first_column) VALUES(&lsquo;some value&#39;)</p>
<p>INSERT anothertable(another_first,another_second)</p>
<p>VALUES(@@identity,&#39;some value&#39;)</p>
<p>如果表mytable有一个标识字段，该字段的值会被插入表anothertable的another_first字段。这是因为变量@@identity总是保存最后一次插入标识字段的值。</p>
<p>字段another_first应该与字段first_column有相同的数据类型。但是，字段another_first不能是应该标识字段。Another_first字段用来保存字段first_column的值。</p>
<p>删除记录</p>
<p>要从表中删除一个或多个记录，需要使用SQL DELETE语句。你可以给DELETE 语句提供WHERE 子句。WHERE子句用来选择要删除的记录。例如，下面的这个DELETE语句只删除字段first_column的值等于&#39;Delete Me&#39;的记录：</p>
<p>DELETE mytable WHERE first_column=&#39;Deltet Me&#39;</p>
<p>DELETE 语句的完整句法如下：</p>
<p>DELETE [FROM] {table_name|view_name} [WHERE clause]</p>
<p>在SQL SELECT 语句中可以使用的任何条件都可以在DELECT 语句的WHERE子句中使用。例如，下面的这个DELETE语句只删除那些first_column字段的值为&#39;goodbye&#39;或second_column字段的值为&#39;so long&#39;的记录：</p>
<p>DELETE mytable WHERE first_column=&#39;goodby&#39; OR second_column=&#39;so long&#39;</p>
<p>如果你不给DELETE 语句提供WHERE 子句，表中的所有记录都将被删除。你不应该有这种想法。如果你想删除应该表中的所有记录，应使用第十章所讲的TRUNCATE TABLE语句。</p>
<p>注意</p>
<p>为什么要用TRUNCATE TABLE 语句代替DELETE语句？当你使用TRUNCATE TABLE语句时，记录的删除是不作记录的。也就是说，这意味着TRUNCATE TABLE 要比DELETE快得多。</p>
<p>更新记录</p>
<p>要修改表中已经存在的一条或多条记录，应使用SQL UPDATE语句。同DELETE语句一样，UPDATE语句可以使用WHERE子句来选择更新特定的记录。请看这个例子：</p>
<p>UPDATE mytable SET first_column=&#39;Updated!&#39; WHERE second_column=&#39;Update Me!&#39;</p>
<p>这个UPDATE 语句更新所有second_column字段的值为&#39;Update Me!&#39;的记录。对所有被选中的记录，字段first_column的值被置为&#39;Updated!&#39;。</p>
<p>下面是UPDATE语句的完整句法：</p>
<p>UPDATE {table_name|view_name} SET [{table_name|view_name}]</p>
<p>{column_list|variable_list|variable_and_column_list}</p>
<p>[,{column_list2|variable_list2|variable_and_column_list2}&hellip;</p>
<p>[,{column_listN|variable_listN|variable_and_column_listN}]]</p>
<p>[WHERE clause]</p>
<p>注意</p>
<p>你可以对文本型字段使用UPDATE语句。但是，如果你需要更新很长的字符串，应使用UPDATETEXT语句。这部分内容对本书来说太高级了，因此不加讨论。要了解更多的信息，请参考Microsoft SQL Sever 的文档。</p>
<p>如果你不提供WHERE子句，表中的所有记录都将被更新。有时这是有用的。例如，如果你想把表titles中的所有书的价格加倍，你可以使用如下的UPDATE 语句：</p>
<p>你也可以同时更新多个字段。例如，下面的UPDATE语句同时更新first_column,second_column,和third_column这三个字段：</p>
<p>UPDATE mytable SET first_column=&#39;Updated!&#39;</p>
<p>Second_column=&#39;Updated!&#39;</p>
<p>Third_column=&#39;Updated!&#39;</p>
<p>WHERE first_column=&#39;Update Me1&#39;</p>
<p>技巧</p>
<p>SQL忽略语句中多余的空格。你可以把SQL语句写成任何你最容易读的格式。</p>
<p>用SELECT 创建记录和表</p>
<p>你也许已经注意到，INSERT 语句与DELETE语句和UPDATE语句有一点不同，它一次只操作一个记录。然而，有一个方法可以使INSERT 语句一次添加多个记录。要作到这一点，你需要把INSERT 语句与SELECT 语句结合起来，象这样：</p>
<p>INSERT mytable (first_column,second_column)</p>
<p>SELECT another_first,another_second</p>
<p>FROM anothertable</p>
<p>WHERE another_first=&#39;Copy Me!&#39;</p>
<p>这个语句从anothertable拷贝记录到mytable.只有表anothertable中字段another_first的值为&#39;Copy Me！&#39;的记录才被拷贝。</p>
<p>当为一个表中的记录建立备份时，这种形式的INSERT 语句是非常有用的。在删除一个表中的记录之前，你可以先用这种方法把它们拷贝到另一个表中。</p>
<p>如果你需要拷贝整个表，你可以使用SELECT INTO 语句。例如，下面的语句创建了一个名为newtable的新表，该表包含表mytable的所有数据：</p>
<p>SELECT * INTO newtable FROM mytable</p>
<p>你也可以指定只有特定的字段被用来创建这个新表。要做到这一点，只需在字段列表中指定你想要拷贝的字段。另外，你可以使用WHERE 子句来限制拷贝到新表中的记录。下面的例子只拷贝字段second_columnd的值等于&#39;Copy Me!&#39;的记录的first_column字段。</p>
<p>SELECT first_column INTO newtable</p>
<p>FROM mytable</p>
<p>WHERE second_column=&#39;Copy Me!&#39;</p>
<p>使用SQL修改已经建立的表是很困难的。例如，如果你向一个表中添加了一个字段，没有容易的办法来去除它。另外，如果你不小心把一个字段的数据类型给错了，你将没有办法改变它。但是，使用本节中讲述的SQL语句，你可以绕过这两个问题。</p>
<p>例如，假设你想从一个表中删除一个字段。使用SELECT INTO 语句，你可以创建该表的一个拷贝，但不包含要删除的字段。这使你既删除了该字段，又保留了不想删除的数据。</p>
<p>如果你想改变一个字段的数据类型，你可以创建一个包含正确数据类型字段的新表。创建好该表后，你就可以结合使用UPDATE语句和SELECT 语句，把原来表中的所有数据拷贝到新表中。通过这种方法，你既可以修改表的结构，又能保存原有的数据。</p></div>

<p>注：关于SQL Sever查询语句大全集锦的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>
			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/mysql/biji/3272.html'>SQL Server SQL的SUBSTR()函数使用示例</a><a>下一篇</a><a href='/mysql/biji/3274.html'>SQL Server 、access数据库 top分页方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>