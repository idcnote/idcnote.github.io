<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>SQL Server 数据库主键的生成方式小结(sqlserver,mysql)_mysql教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了SQL Server 数据库主键的生成方式小结(sqlserver,mysql)，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！主" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
	    <a href="/mysql/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>数据库笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">SQL Server 数据库主键的生成方式小结(sqlserver,mysql)</h1>
					</div>
                    <div class="panel-title">
                        2022-11-12 09:46:52                    </div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了SQL Server 数据库主键的生成方式小结(sqlserver,mysql)，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！主</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了SQL Server 数据库主键的生成方式小结(sqlserver,mysql)，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>主键的生成方式主要有三种：一. 数据库自动生成二. GUID三. 开发创建严格讲这三种产生方式有一定的交叉点，其定位方式将在下面进行讲解。第一种方式，主要将其定位在自增长的标识种子：可以设置起始数值，及增长步长。其优点在于使用时完全将并发任务交于数据库引擎管理，你不用担心存在多用户使用的时候会产生两个相同的ID的情况。其缺点也在于此，多数的数据库不提供直接获取标识ID的方式，对于开发人员来说产生ID的方式是透明的，开发人员几乎无法干预此项。对于数据的迁移也不是很方便。由于存在上面的利弊，这种自增长的ID一般多用于设计基础表（系统运行的基础信息，如员工表）主键，而极少（根本不）用于主从表主、外键，因为在产生主从表数据并关联时，必须确定主表的ID，然后才能定位从表的关联ID。例(MsSQL):
<p>代码如下:</p>
<pre>
<code> 
--创建测试表 
CREATE TABLE [Identity]( 
Id INT IDENTITY(1,2) NOT NULL PRIMARY KEY,--种子的起始值1，步长2 
Number VARCHAR(20) UNIQUE NOT NULL, 
Name VARCHAR(20) NOT NULL, 
Password VARCHAR(20) DEFAULT(123), 
Description VARCHAR(40) NULL 
) 
--插入记录 
INSERT INTO [Identity](Number,Name,Description) VALUES(&#39;001&#39;,&#39;1st&#39;,&#39;Id=1,因为起始值1&#39;) 
INSERT INTO [Identity](Number,Name,Description) VALUES(&#39;002&#39;,&#39;2nd&#39;,&#39;Id=3,因为起始值1，步长2&#39;) 
INSERT INTO [Identity](Number,Name,Description) VALUES(&#39;003&#39;,&#39;3rd&#39;,&#39;Id=5,由于字符长度超长，报错插入失败，造成此Id产生后被放弃&#39;) 
INSERT INTO [Identity](Number,Name,Description) VALUES(&#39;004&#39;,&#39;4th&#39;,&#39;Id=7 not 5,因为第三条记录插入失败&#39;) 
--检索记录，查看结果 
SELECT * FROM [Identity] 
</code></pre>结果：(1 行受影响)(1 行受影响)消息 8152，级别 16，状态 14，第 3 行将截断字符串或二进制数据。语句已终止。(1 行受影响)(3 行受影响)Id Number Name Password Description1 001 1st 123 Id=1,因为起始值13 002 2nd 123 Id=3,因为起始值1，步长27 004 4th 123 Id=7 not 5,因为第三条记录插入失败第二种方式，GUID即Globally Unique Identifier，也称为UUID（Universally Unique IDentifier），全球唯一标识符，GUID一般由32位十六进制的数值组成，其中包含网卡地址、时间及其他信息。任何两台电脑都不会产生相同的GUID，他的优点在唯一性，当需要数据库整合时，能节约不少劳动力。比如总公司和分公司各自系统独立运行，所有分公司数据定期需要提交到总部，可以避免合并数据时主键冲突问题，同时GUID还兼具自增长标识种子特点，无需开发人员太多的关注。但是GUID信息量大，占用空间也大，关联检索时，估计效率上也不是很高，对于32位的十六进制其可读性也差，虽然主键有对用户的无意义性，但是在设计或者调试交流时很不方便。从长远考虑，为了保证数据的可移植性，一般还是会选择使用GUID来作为主键。例(MsSQL):
<p>代码如下:</p>
<pre>
<code> 
--创建测试表 
CREATE TABLE GUID( 
Id UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,--当然你也可以用字符串来保存 
Number VARCHAR(20) UNIQUE NOT NULL, 
Name VARCHAR(20) NOT NULL, 
Password VARCHAR(20) DEFAULT(123) 
) 
--插入记录 
INSERT INTO GUID(Id,Number,Name) VALUES(NewID(),&#39;001&#39;,&#39;1st&#39;) 
INSERT INTO GUID(Id,Number,Name) VALUES(NewID(),&#39;002&#39;,&#39;2nd&#39;) 
INSERT INTO GUID(Id,Number,Name) VALUES(NewID(),&#39;003&#39;,&#39;3rd&#39;) 
--检索记录，查看结果 
SELECT * FROM GUID 
</code></pre>结果：Id Number Name Password8E194F55-B4D3-4C85-8667-33BC6CD33BBC 001 1st 1237141F202-7D0E-4992-9164-5043EC9FC6F6 002 2nd 123E0E365A0-8748-4656-AF24-5D0B216D2095 003 3rd 123第三种方式开发创建，其便捷性在于可控制性，此可控制性是指其组成形式，可以是整形、也可以是字符型，你可以根据实际情况给予多样的组成及产生形式，说到这里可能有的朋友就想起来自动产生单号，如：20120716001或者PI-201207-0001等等，没错，自我创建同样适用于这些类似的应用。说到自我创建，多数首先想到的是取Max(Id)+1，这种方式虽然省事，但是实际上对于定制（在生产单号之类的有一定意义的信息时可能会有这样的需求，主键没必要）及并发的处理并不是很好。如，当前表中最大编号为1000，当C1和C2用户同时取这个Id处理时，得到的都是1001，导致保存失败。常规的做法是在取值时候加锁，但是当多用户频繁操作时，性能是个很大的问题，其中主要的原因之一是直接操作的业务数据表。针对此种情况，解决方案是使用键值表来保存表名、当前或者下一个Id及其他信息，如果系统中多个表Id都使用这种方式，那么键值表中就会有多条相应的规则记录；当然也可以让整个数据库所有表的Id从都按相同的规则从一个源产生，那么键值表中只需要一条规则记录即可。下面来看看这样一个使用键值表例子的演变(MsSQL):
<p>代码如下:</p>
<pre>
<code> 
--创建键值表 
CREATE TABLE KeyTable( 
ID INT IDENTITY(1,1) PRIMARY KEY NOT NULL, 
TCode VARCHAR(20) UNIQUE NOT NULL, 
TName VARCHAR(50) NOT NULL, 
TKey INT NOT NULL, 
) 
GO 
--插入测试记录 
INSERT INTO KeyTable(TCode,TName,TKey) 
VALUES(&#39;T001&#39;,&#39;Test&#39;,0) 
GO 
--创建获取指定表ID的存储过程，也可以修改成函数 
CREATE PROCEDURE UP_NewTableID 
@TCode VARCHAR(20),@NextID INT OUTPUT 
AS 
DECLARE @CurTKey INT,@NextTKey INT 
BEGIN TRAN TransID 
SELECT @CurTKey=TKey 
FROM KeyTable 
WHERE TCode = @TCode 
IF @@ROWCOUNT = 0 
BEGIN 
ROLLBACK TRAN TransID 
RAISERROR(&#39;Warning: No such row is exists&#39;,16,1) 
RETURN 
END 
SET @NextTKey = @CurTKey + 1 
--WAITFOR DELAY &#39;00:00:05&#39; 
UPDATE KeyTable 
SET TKey = @NextTKey 
WHERE TCode = @TCode 
IF @@ROWCOUNT = 0 
BEGIN 
ROLLBACK TRAN TransID 
RAISERROR(&#39;Warning: No such row is updated&#39;,16,1) 
RETURN 
END 
COMMIT TRAN TransID 
SET @NextID = @NextTKey 
GO 
</code></pre>执行存储过程UP_NewTableID:
<p>代码如下:</p>
<pre>
<code> 
DECLARE @NextID INT 
EXEC UP_NewTableID &#39;T001&#39;,@NextID OUTPUT 
PRINT @NextID 
</code></pre>运行的时会发现很正常，获取的结果也很正确。但是如果在高并发的情况，多个用户可能就会获取相同的ID，如果获取的ID后是用于保存对应表中的记录，那么最多只有一个用户能保存成功。下面模拟一下并发情形，将上面的存储过程UP_NewTableID中语句WAITFOR DELAY &#39;00:00:05&#39;的注释去掉，打开3个查询分析器的窗体，依次执行上面语句。预期是想分别获得1,2,3，但是也许会发现多个窗体的运行结果都是：1。这就是说在更新语句执行之前，大家都获取的ID是0，所以下一个数值都是为1。（实际的数值，根据DELAY的参数大小及运行时间按间隔有关）从这方面来分析的话有的朋友可能就会想到，是否可以在更新语句执行时判断ID是不是原始ID了？修改过程：
<p>代码如下:</p>
<pre>
<code> 
ALTER PROCEDURE UP_NewTableID 
@TCode VARCHAR(20),@NextID INT OUTPUT 
AS 
DECLARE @CurTKey INT,@NextTKey INT 
BEGIN TRAN TransID 
SELECT @CurTKey=TKey 
FROM KeyTable 
WHERE TCode=@TCode 
IF @@ROWCOUNT=0BEGIN 
ROLLBACK TRAN TransID 
RAISERROR(&#39;Warning: No such row is exists&#39;,16,1) 
RETURN 
END 
SET @NextTKey=@CurTKey+1 
WAITFOR DELAY &#39;00:00:05&#39; 
UPDATE KeyTable 
SET TKey=@NextTKey 
WHERE TCode=@TCode AND TKey=@CurTKey--此处加上TKey的校验 
IF @@ROWCOUNT=0BEGIN 
ROLLBACK TRAN TransID 
RAISERROR(&#39;Warning: No such row is updated&#39;,16,1) 
RETURN 
END 
COMMIT TRAN TransID 
SET @NextID=@NextTKey 
GO 
</code></pre>如果打开个3个执行过程来模拟并发，那么会有2个窗体出现：消息 50000，级别 16，状态 1，过程 UP_NewTableID，第 28 行Warning: No such row is updated由此会看到还是会由于并发导致有用户操作失败，但是较上一个至少将错误出现的时间点提前了。那么有没有更好的方法，从查询到更新结束整个事务过程中，不会有任何其他事务插入其中来搅局的办法呢，答案很明确，有，使用锁！需要选择适当的锁，否则效果将和上面的一样。
<p>代码如下:</p>
<pre>
<code> 
ALTER PROCEDURE UP_NewTableID 
@TCode VARCHAR(20),@NextID INT OUTPUT 
AS 
DECLARE @CurTKey INT,@NextTKey INT 
BEGIN TRAN TransID 
SELECT @CurTKey=TKey 
FROM KeyTable WITH (UPDLOCK)--采用更新锁，并保持到事务完成 
WHERE TCode=@TCode 
IF @@ROWCOUNT=0BEGIN 
ROLLBACK TRAN TransID 
RAISERROR(&#39;Warning: No such row is exists&#39;,16,1) 
RETURN 
END 
SET @NextTKey=@CurTKey+1 
WAITFOR DELAY &#39;00:00:05&#39; 
UPDATE KeyTable 
SET TKey=@NextTKey 
WHERE TCode=@TCode--此处无需验证TKey是否与SELECT的相同 
COMMIT TRAN TransID 
SET @NextID=@NextTKey 
GO 
</code></pre>可以打开N（N&gt;=2)个窗体来进行测试，将会看到所有操作都被串行化，结果就是我们想要的那样。如此注释或者去掉模仿并发的语句WAITFOR DELAY &#39;00:00:05&#39;即可。如前面所说，这同样适应于单据编号类似编码的产生形式，只要对前面的代码及键值表稍作修改即可，有兴趣的朋友可以一试。如果是从前端取得这个编号，并应用于各个记录，那么可能存在跳号的可能。如果为了保证不存在跳号，一种解决方案就是使用跳号表，将跳号记录定期扫描并应用于其他记录。另一种解决方案是将记录的保存操作放置到编号产生的过程中，形成一个串行化的事务。俗话说萝卜白菜各有所爱，您用哪一种自有你的道理。

<p>注：关于SQL Server 数据库主键的生成方式小结(sqlserver,mysql)的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>
			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/mysql/biji/3472.html'>Java 实现连接sql server 2000</a><a>下一篇</a><a href='/mysql/biji/3474.html'>Sql Server 2012 转换函数的比较(Cast、Convert和Parse)</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>