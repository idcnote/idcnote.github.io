<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>SQL Server  触发器实例代码_mysql教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了SQL Server  触发器实例代码，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！定义： 何为触发器？在SQL Server里" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
	    <a href="/mysql/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>数据库笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">SQL Server  触发器实例代码</h1>
					</div>
                    <div class="panel-title">
                        2022-11-12 09:47:13                    </div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了SQL Server  触发器实例代码，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！定义： 何为触发器？在SQL Server里</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了SQL Server  触发器实例代码，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>定义： 何为触发器？在SQL Server里面也就是对某一个表的一定的操作，触发某种条件，从而执行的一段程序。触发器是一个特殊的存储过程。常见的触发器有三种：分别应用于Insert , Update , Delete 事件。我为什么要使用触发器？比如，这么两个表：
<p>代码如下:</p>
<pre>
<code> 
Create Table Student( --学生表 
StudentID int primary key, --学号 
.... 
) 
Create Table BorrowRecord( --学生借书记录表 
BorrowRecord int identity(1,1), --流水号 
StudentID int , --学号 
BorrowDate datetime, --借出时间 
ReturnDAte Datetime, --归还时间 
... 
) 
</code></pre>用到的功能有:1.如果我更改了学生的学号,我希望他的借书记录仍然与这个学生相关(也就是同时更改借书记录表的学号);2.如果该学生已经毕业，我希望删除他的学号的同时，也删除它的借书记录。等等。这时候可以用到触发器。对于1，创建一个Update触发器：
<p>代码如下:</p>
<pre>
<code> 
Create Trigger truStudent 
On Student --在Student表中创建触发器 
for Update --为什么事件触发 
As --事件触发后所要做的事情 
if Update(StudentID) 
begin 
Update BorrowRecord 
Set StudentID=i.StudentID 
From BorrowRecord br , Deleted d ,Inserted i --Deleted和Inserted临时表 
Where br.StudentID=d.StudentID 
end 
</code></pre>理解触发器里面的两个临时的表：Deleted , Inserted 。注意Deleted 与Inserted分别表示触发事件的表&ldquo;旧的一条记录&rdquo;和&ldquo;新的一条记录&rdquo;。一个数据库系统中有两个虚拟表用于存储在表中记录改动的信息，分别是：虚拟表Inserted 虚拟表Deleted在表记录新增时 存放新增的记录 不存储记录修改时 存放用来更新的新记录 存放更新前的记录删除时 不存储记录 存放被删除的记录一个Update 的过程可以看作为：生成新的记录到Inserted表，复制旧的记录到Deleted表，然后删除Student记录并写入新纪录。对于2，创建一个Delete触发器
<p>代码如下:</p>
<pre>
<code> 
Create trigger trdStudent 
On Student 
for Delete 
As 
Delete BorrowRecord 
From BorrowRecord br , Delted d 
Where br.StudentID=d.StudentID 
</code></pre>从这两个例子我们可以看到了触发器的关键：A.2个临时的表；B.触发机制。SQL触发器实例2
<p>代码如下:</p>
<pre>
<code> 
/* 
建立虚拟测试环境，包含：表[卷烟库存表]，表[卷烟销售表]。 
请大家注意跟踪这两个表的数据，体会触发器到底执行了什么业务逻辑，对数据有什么影响。 
为了能更清晰的表述触发器的作用，表结构存在数据冗余，且不符合第三范式，这里特此说明。 
*/ 
USE Master 
GO 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;U&#39; AND NAME = &#39;卷烟库存表&#39;) 
DROP TABLE 卷烟库存表 
GO 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;U&#39; AND NAME = &#39;卷烟销售表&#39;) 
DROP TABLE 卷烟销售表 
GO 
--业务规则：销售金额 = 销售数量 * 销售单价 业务规则。 
CREATE TABLE 卷烟销售表 
( 
卷烟品牌 VARCHAR(40) PRIMARY KEY NOT NULL, 
购货商 VARCHAR(40) NULL, 
销售数量 INT NULL, 
销售单价 MONEY NULL, 
销售金额 MONEY NULL 
) 
GO 
--业务规则：库存金额 = 库存数量 * 库存单价 业务规则。 
CREATE TABLE 卷烟库存表 
( 
卷烟品牌 VARCHAR(40) PRIMARY KEY NOT NULL, 
库存数量 INT NULL, 
库存单价 MONEY NULL, 
库存金额 MONEY NULL 
) 
GO 
--创建触发器，示例1 
/* 
创建触发器[T_INSERT_卷烟库存表]，这个触发器较简单。 
说明： 每当[卷烟库存表]发生 INSERT 动作，则引发该触发器。 
触发器功能： 强制执行业务规则，保证插入的数据中，库存金额 = 库存数量 * 库存单价。 
注意： [INSERTED]、[DELETED]为系统表，不可创建、修改、删除，但可以调用。 
重要： 这两个系统表的结构同插入数据的表的结构。 
*/ 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;TR&#39; AND NAME = &#39;T_INSERT_卷烟库存表&#39;) 
DROP TRIGGER T_INSERT_卷烟库存表 
GO 
CREATE TRIGGER T_INSERT_卷烟库存表 
ON 卷烟库存表 
FOR INSERT 
AS 
--提交事务处理 
BEGIN TRANSACTION 
--强制执行下列语句，保证业务规则 
UPDATE 卷烟库存表 
SET 库存金额 = 库存数量 * 库存单价 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 from INSERTED) 
COMMIT TRANSACTION 
GO 
/* 
针对[卷烟库存表]，插入测试数据： 
注意，第一条数据（红塔山新势力）中的数据符合业务规则， 
第二条数据（红塔山人为峰）中，[库存金额]空，不符合业务规则， 
第三条数据（云南映像）中，[库存金额]不等于[库存数量]乘以[库存单价]，不符合业务规则。 
第四条数据库存数量为0。 
请注意在插入数据后，检查[卷烟库存表]中的数据是否 库存金额 = 库存数量 * 库存单价。 
*/ 
INSERT INTO 卷烟库存表(卷烟品牌,库存数量,库存单价,库存金额) 
SELECT &#39;红塔山新势力&#39;,100,12,1200 UNION ALL 
SELECT &#39;红塔山人为峰&#39;,100,22,NULL UNION ALL 
SELECT &#39;云南映像&#39;,100,60,500 UNION ALL 
SELECT &#39;玉溪&#39;,0,30,0 
GO 
--查询数据 
SELECT * FROM 卷烟库存表 
GO 
/* 
</code></pre>结果集RecordId 卷烟品牌 库存数量 库存单价 库存金额-------- ------------ -------- ------- ---------1 红塔山新势力 100 12.0000 1200.00002 红塔山人为峰 100 22.0000 2200.00003 云南映像 100 60.0000 6000.00004 玉溪 0 30.0000 .0000（所影响的行数为 4 行）*/--触发器示例2
<p>代码如下:</p>
<pre>
<code> 
/* 
创建触发器[T_INSERT_卷烟销售表]，该触发器较复杂。 
说明: 每当[卷烟库存表]发生 INSERT 动作，则引发该触发器。 
触发器功能： 实现业务规则。 
业务规则: 如果销售的卷烟品牌不存在库存或者库存为零，则返回错误。 
否则则自动减少[卷烟库存表]中对应品牌卷烟的库存数量和库存金额。 
*/ 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;TR&#39; AND NAME = &#39;T_INSERT_卷烟销售表&#39;) 
DROP TRIGGER T_INSERT_卷烟销售表 
GO 
CREATE TRIGGER T_INSERT_卷烟销售表 
ON 卷烟销售表 
FOR INSERT 
AS 
BEGIN TRANSACTION 
--检查数据的合法性：销售的卷烟是否有库存，或者库存是否大于零 
IF NOT EXISTS ( 
SELECT 库存数量 
FROM 卷烟库存表 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 FROM INSERTED) 
) 
BEGIN 
--返回错误提示 
RAISERROR(&#39;错误！该卷烟不存在库存，不能销售。&#39;,16,1) 
--回滚事务 
ROLLBACK 
RETURN 
END 
IF EXISTS ( 
SELECT 库存数量 
FROM 卷烟库存表 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 FROM INSERTED) AND 
库存数量 &lt;= 0 
) 
BEGIN 
--返回错误提示 
RAISERROR(&#39;错误！该卷烟库存小于等于0，不能销售。&#39;,16,1) 
--回滚事务 
ROLLBACK 
RETURN 
END 
--对合法的数据进行处理 
--强制执行下列语句，保证业务规则 
UPDATE 卷烟销售表 
SET 销售金额 = 销售数量 * 销售单价 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 FROM INSERTED) 
DECLARE @卷烟品牌 VARCHAR(40) 
SET @卷烟品牌 = (SELECT 卷烟品牌 FROM INSERTED) 
DECLARE @销售数量 MONEY 
SET @销售数量 = (SELECT 销售数量 FROM INSERTED) 
UPDATE 卷烟库存表 
SET 库存数量 = 库存数量 - @销售数量, 
库存金额 = (库存数量 - @销售数量)*库存单价 
WHERE 卷烟品牌 = @卷烟品牌 
COMMIT TRANSACTION 
GO 
--请大家自行跟踪[卷烟库存表]和[卷烟销售表]的数据变化。 
--针对[卷烟销售表]，插入第一条测试数据，该数据是正常的。 
INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额) 
SELECT &#39;红塔山新势力&#39;,&#39;某购货商&#39;,10,12,1200 
GO 
--针对[卷烟销售表]，插入第二条测试数据，该数据 销售金额 不等于 销售单价 * 销售数量。 
--触发器将自动更正数据，使 销售金额 等于 销售单价 * 销售数量。 
INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额) 
SELECT &#39;红塔山人为峰&#39;,&#39;某购货商&#39;,10,22,2000 
GO 
--针对[卷烟销售表]，插入第三条测试数据，该数据中的卷烟品牌在 卷烟库存表中找不到对应。 
--触发器将报错。 
INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额) 
SELECT &#39;红河V8&#39;,&#39;某购货商&#39;,10,60,600 
GO 
</code></pre>/*结果集服务器: 消息 50000，级别 16，状态 1，过程 T_INSERT_卷烟销售表，行 15错误！该卷烟不存在库存，不能销售。*/--针对[卷烟销售表]，插入第三条测试数据，该数据中的卷烟品牌在 卷烟库存表中库存为0。--触发器将报错。INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额)SELECT &#39;玉溪&#39;,&#39;某购货商&#39;,10,30,300GO/*结果集服务器: 消息 50000，级别 16，状态 1，过程 T_INSERT_卷烟销售表，行 29错误！该卷烟库存小于等于0，不能销售。*/--查询数据SELECT * FROM 卷烟库存表SELECT * FROM 卷烟销售表GO/*补充：1、本示例主要通过一个简单的业务规则实现来进行触发器使用的说明，具体的要根据需要灵活处理；2、关于触发器要理解并运用好 INSERTED ，DELETED 两个系统表；3、本示例创建的触发器都是 FOR INSERT ,具体的语法可参考：Trigger语法
<p>代码如下:</p>
<pre>
<code> 
CREATE TRIGGER trigger_name 
ON { table | view } 
[ WITH ENCRYPTION ] --用于加密触发器 
{ 
{ { FOR | AFTER | INSTEAD OF } { [ INSERT ] [ , ] [ UPDATE ] } 
[ WITH APPEND ] 
[ NOT FOR REPLICATION ] 
AS 
[ { IF UPDATE ( column ) 
[ { AND | OR } UPDATE ( column ) ] 
[ ...n ] 
| IF ( COLUMNS_UPDATED ( ) { bitwise_operator } updated_bitmask ) 
{ comparison_operator } column_bitmask [ ...n ] 
} ] 
sql_statement [ ...n ] 
} 
} 
</code></pre>4、关于触发器，还应该注意(1)、DELETE 触发器不能捕获 TRUNCATE TABLE 语句。(2)、触发器中不允许以下 Transact-SQL 语句：ALTER DATABASE CREATE DATABASE DISK INITDISK RESIZE DROP DATABASE LOAD DATABASELOAD LOG RECONFIGURE RESTORE DATABASERESTORE LOG(3)、触发器最多可以嵌套 32 层。*/--修改触发器--实质上，是将 CREATE TRIGGER ... 修改为 ALTER TRIGGER ...即可。--删除触发器DROP TRIGGER xxxGO--删除测试环境DROP TABLE 卷烟库存表GODROP TABLE 卷烟销售表GODROP TRIGGER T_INSERT_卷烟库存表GODROP TRIGGER T_INSERT_卷烟销售表GO##################################################################触发器的基础知识和例子：create trigger tr_nameon table/view{for | after | instead of } [update][,][insert][,][delete][with encryption]as {batch | if update (col_name) [{and|or} update (col_name)] }说明：1 tr_name ：触发器名称2 on table/view ：触发器所作用的表。一个触发器只能作用于一个表3 for 和after ：同义4 after 与instead of :sql 2000新增项目afrer 与 instead of 的区别After在触发事件发生以后才被激活,只可以建立在表上Instead of代替了相应的触发事件而被执行,既可以建立在表上也可以建立在视图上5 insert、update、delete：激活触发器的三种操作，可以同时执行，也可选其一6 if update (col_name)：表明所作的操作对指定列是否有影响，有影响，则激活触发器。此外，因为delete 操作只对行有影响，所以如果使用delete操作就不能用这条语句了(虽然使用也不出错，但是不能激活触发器，没意义)。7 触发器执行时用到的两个特殊表：deleted ,inserteddeleted 和inserted 可以说是一种特殊的临时表，是在进行激活触发器时由系统自动生成的，其结构与触发器作用的表结构是一样的，只是存放 的数据有差异。续下面表格说明deleted 与inserted 数据的差异deleted 与inserted 数据的差异Inserted存放进行insert和update 操作后的数据Deleted存放进行delete 和update操作前的数据注意：update 操作相当于先进行delete 再进行insert ,所以在进行update操作时，修改前的数据拷贝一条到deleted 表中，修改后的数据在存到触发器作用的表的同时，也同时生成一条拷贝到insered表中<strong>SQL Server 2000中的触发器使用</strong>触发器是数据库应用中的重用工具，它的应用很广泛。这几天写一个化学数据统计方面的软件，需要根据采样，自动计算方差，在这里，我使用了触发器。　　下面我摘录了SQL Server官方教程中的一段关于触发器的文字，确实有用的一点文字描述。　　可以定义一个无论何时用INSERT语句向表中插入数据时都会执行的触发器。　　当触发INSERT触发器时，新的数据行就会被插入到触发器表和inserted表中。inserted表是一个逻辑表，它包含了已经插入的数据行的一个副本。inserted表包含了INSERT语句中已记录的插入动作。inserted表还允许引用由初始化INSERT语句而产生的日志数据。触发器通过检查inserted表来确定是否执行触发器动作或如何执行它。inserted表中的行总是触发器表中一行或多行的副本。　　日志记录了所有修改数据的动作(INSERT、UPDATE和DELETE语句)，但在事务日志中的信息是不可读的。然而，inserted表允许你引用由INSERT语句引起的日志变化，这样就可以将插入数据与发生的变化进行比较，来验证它们或采取进一步的动作。也可以直接引用插入的数据，而不必将它们存储到变量中。　　示例　　在本例中，将创建一个触发器。无论何时订购产品（无论何时向Order Details表中插入一条记录），这个触发器都将更新Products表中的一列(UnitsInStock)。用原来的值减去订购的数量值即为新值。
<p>代码如下:</p>
<pre>
<code> 

USE Northwind 

CREATE TRIGGER OrdDet_Insert 
ON [Order Details] 
FOR INSERT 
AS 
UPDATE P SET 
UnitsInStock = P.UnitsInStock &ndash; I.Quantity 
FROM Products AS P INNER JOIN Inserted AS I 
ON P.ProductID = I.ProductID 
</code></pre>　　DELETE触发器的工作过程　　当触发DELETE触发器后，从受影响的表中删除的行将被放置到一个特殊的deleted表中。deleted表是一个逻辑表，它保留已被删除数据行的一个副本。deleted表还允许引用由初始化DELETE语句产生的日志数据。　　使用DELETE触发器时，需要考虑以下的事项和原则：　　&middot;当某行被添加到deleted表中时，它就不再存在于数据库表中；因此，deleted表和数据库表没有相同的行。　　&middot;创建deleted表时，空间是从内存中分配的。deleted表总是被存储在高速缓存中。　　&middot;为DELETE动作定义的触发器并不执行TRUNCATE TABLE语句，原因在于日志不记录TRUNCATE TABLE语句。　　示例　　在本例中，将创建一个触发器，无论何时删除一个产品类别（即从Categories表中删除一条记录），该触发器都会更新Products表中的Discontinued列。所有受影响的产品都标记为1，标示不再使用这些产品了。
<p>代码如下:</p>
<pre>
<code> 
USE Northwind 

CREATE TRIGGER Category_Delete 
ON Categories 
FOR DELETE 
AS 
UPDATE P SET Discontinued = 1 
FROM Products AS P INNER JOIN deleted AS d 
ON P.CategoryID = d.CategoryID 
</code></pre>　　UPDATE触发器的工作过程　　可将UPDATE语句看成两步操作：即捕获数据前像(before image)的DELETE语句，和捕获数据后像(after image)的INSERT语句。当在定义有触发器的表上执行UPDATE语句时，原始行（前像）被移入到deleted表，更新行（后像）被移入到inserted表。　　触发器检查deleted表和inserted表以及被更新的表，来确定是否更新了多行以及如何执行触发器动作。　　可以使用IF UPDATE语句定义一个监视指定列的数据更新的触发器。这样，就可以让触发器容易的隔离出特定列的活动。当它检测到指定列已经更新时，触发器就会进一步执行适当的动作，例如发出错误信息指出该列不能更新，或者根据新的更新的列值执行一系列的动作语句。　　语法IF UPDATE (&lt;column_name&gt;)　　例1　　本例阻止用户修改Employees表中的EmployeeID列。
<p>代码如下:</p>
<pre>
<code> 
USE Northwind 

GO 
CREATE TRIGGER Employee_Update 
ON Employees 
FOR UPDATE 
AS 
IF UPDATE (EmployeeID) 
BEGIN 
RAISERROR (&#39;Transaction cannot be processed.\ 
***** Employee ID number cannot be modified.&#39;, 10, 1) 
ROLLBACK TRANSACTION 
END 
</code></pre>　　INSTEAD OF触发器的工作过程　　可以在表或视图上指定INSTEAD OF触发器。执行这种触发器就能够替代原始的触发动作。INSTEAD OF触发器扩展了视图更新的类型。对于每一种触发动作(INSERT、UPDATE或 DELETE)，每一个表或视图只能有一个INSTEAD OF触发器。　　INSTEAD OF触发器被用于更新那些没有办法通过正常方式更新的视图。例如，通常不能在一个基于连接的视图上进行DELETE操作。然而，可以编写一个INSTEAD OF DELETE触发器来实现删除。上述触发器可以访问那些如果视图是一个真正的表时已经被删除的数据行。将被删除的行存储在一个名为deleted的工作表中，就像AFTER触发器一样。相似地，在UPDATE INSTEAD OF触发器或者INSERT INSTEAD OF触发器中，你可以访问inserted表中的新行。　　不能在带有WITH CHECK OPTION定义的视图中创建INSTEAD OF触发器。示例　　在本例中，创建了一个德国客户表和一个墨西哥客户表。放置在视图上的INSTEAD OF触发器将把更新操作重新定向到适当的基表上。这时发生的插入是对CustomersGer表的插入而不是对视图的插入。　　创建两个包含客户数据的表：
<p>代码如下:</p>
<pre>
<code> 

SELECT * INTO CustomersGer FROM Customers WHERE Customers.Country = &#39;Germany&#39; 

SELECT * INTO CustomersMex FROM Customers WHERE Customers.Country = &#39;Mexico&#39; 
GO 
</code></pre>　　在该数据上创建视图：
<p>代码如下:</p>
<pre>
<code> 
CREATE VIEW CustomersView AS 

SELECT * FROM CustomersGer 
UNION 
SELECT * FROM CustomersMex 
GO 
</code></pre>　　创建一个在上述视图上的INSTEAD OF触发器：
<p>代码如下:</p>
<pre>
<code> 
CREATE TRIGGER Customers_Update2 

ON CustomersView 
INSTEAD OF UPDATE AS 
DECLARE @Country nvarchar(15) 
SET @Country = (SELECT Country FROM Inserted) 
IF @Country = &#39;Germany&#39; 
BEGIN 
UPDATE CustomersGer 
SET CustomersGer.Phone = Inserted.Phone 
FROM CustomersGer JOIN Inserted 
ON CustomersGer.CustomerID = Inserted.CustomerID 
END 
ELSE 
IF @Country = &#39;Mexico&#39; 
BEGIN 
UPDATE CustomersMex 
SET CustomersMex.Phone = Inserted.Phone 
FROM CustomersMex JOIN Inserted 
ON CustomersMex.CustomerID = Inserted.CustomerID 
END 
</code></pre>　　通过更新视图，测试触发器：
<p>代码如下:</p>
<pre>
<code> 
UPDATE CustomersView SET Phone = &#39; 030-007xxxx&#39; 

WHERE CustomerID = &#39;ALFKI&#39; 
SELECT CustomerID, Phone FROM CustomersView 
WHERE CustomerID = &#39;ALFKI&#39; 
SELECT CustomerID, Phone FROM CustomersGer 
WHERE CustomerID = &#39;ALFKI&#39; 
</code></pre>　　那么具体的讲，对于多列数据，如何计算方差呢？：
<p>代码如下:</p>
<pre>
<code> 

CREATE TRIGGER [calT1T2T3] ON dbo.DCLB 

FOR INSERT,UPDATE 
AS 
update P 
SET 
/**//* 
计算方差的触发器 
*/ 
P.T1=(I.P1+I.P2+I.P3+I.P4+I.P5+I.P6), 
P.T2=(I.Y1+I.Y2+I.Y3+I.Y4+I.Y5+I.Y6 ), 
P.T3=SQRT(P.T1*P.T1+P.T2*P.T2) 
FROM DCLB AS P INNER JOIN Inserted AS I 
ON P.SID = I.SID 
</code></pre>　　触发器的使用很方便，而且也很简单，重要的是理解inserted过程。可将UPDATE语句看成两步操作：即捕获数据前像(before image)的DELETE语句，和捕获数据后像(after image)的INSERT语句。当在定义有触发器的表上执行UPDATE语句时，原始行（前像）被移入到deleted表，更新行（后像）被移入到inserted表。触发器检查deleted表和inserted表以及被更新的表，来确定是否更新了多行以及如何执行触发器动作。认识了一下触发器的作用！
<p>代码如下:</p>
<pre>
<code> 
/* 
建立虚拟测试环境，包含：表[卷烟库存表]，表[卷烟销售表]。 
请大家注意跟踪这两个表的数据，体会触发器到底执行了什么业务逻辑，对数据有什么影响。 
为了能更清晰的表述触发器的作用，表结构存在数据冗余，且不符合第三范式，这里特此说明。 
*/ 
USE Master 
GO 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;U&#39; AND NAME = &#39;卷烟库存表&#39;) 
DROP TABLE 卷烟库存表 
GO 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;U&#39; AND NAME = &#39;卷烟销售表&#39;) 
DROP TABLE 卷烟销售表 
GO 
--业务规则：销售金额 = 销售数量 * 销售单价 业务规则。 
CREATE TABLE 卷烟销售表 
( 
卷烟品牌 VARCHAR(40) PRIMARY KEY NOT NULL, 
购货商 VARCHAR(40) NULL, 
销售数量 INT NULL, 
销售单价 MONEY NULL, 
销售金额 MONEY NULL 
) 
GO 
--业务规则：库存金额 = 库存数量 * 库存单价 业务规则。 
CREATE TABLE 卷烟库存表 
( 
卷烟品牌 VARCHAR(40) PRIMARY KEY NOT NULL, 
库存数量 INT NULL, 
库存单价 MONEY NULL, 
库存金额 MONEY NULL 
) 
GO 
--创建触发器，示例1 
/* 
创建触发器[T_INSERT_卷烟库存表]，这个触发器较简单。 
说明： 每当[卷烟库存表]发生 INSERT 动作，则引发该触发器。 
触发器功能： 强制执行业务规则，保证插入的数据中，库存金额 = 库存数量 * 库存单价。 
注意： [INSERTED]、[DELETED]为系统表，不可创建、修改、删除，但可以调用。 
重要： 这两个系统表的结构同插入数据的表的结构。 
*/ 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;TR&#39; AND NAME = &#39;T_INSERT_卷烟库存表&#39;) 
DROP TRIGGER T_INSERT_卷烟库存表 
GO 
CREATE TRIGGER T_INSERT_卷烟库存表 
ON 卷烟库存表 
FOR INSERT 
AS 
--提交事务处理 
BEGIN TRANSACTION 
--强制执行下列语句，保证业务规则 
UPDATE 卷烟库存表 
SET 库存金额 = 库存数量 * 库存单价 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 from INSERTED) 
COMMIT TRANSACTION 
GO 
/* 
针对[卷烟库存表]，插入测试数据： 
注意，第一条数据（红塔山新势力）中的数据符合业务规则， 
第二条数据（红塔山人为峰）中，[库存金额]空，不符合业务规则， 
第三条数据（云南映像）中，[库存金额]不等于[库存数量]乘以[库存单价]，不符合业务规则。 
第四条数据库存数量为0。 
请注意在插入数据后，检查[卷烟库存表]中的数据是否 库存金额 = 库存数量 * 库存单价。 
*/ 
INSERT INTO 卷烟库存表(卷烟品牌,库存数量,库存单价,库存金额) 
SELECT &#39;红塔山新势力&#39;,100,12,1200 UNION ALL 
SELECT &#39;红塔山人为峰&#39;,100,22,NULL UNION ALL 
SELECT &#39;云南映像&#39;,100,60,500 UNION ALL 
SELECT &#39;玉溪&#39;,0,30,0 
GO 
--查询数据 
SELECT * FROM 卷烟库存表 
GO 
</code></pre>/*结果集RecordId 卷烟品牌 库存数量 库存单价 库存金额-------- ------------ -------- ------- ---------1 红塔山新势力 100 12.0000 1200.00002 红塔山人为峰 100 22.0000 2200.00003 云南映像 100 60.0000 6000.00004 玉溪 0 30.0000 .0000（所影响的行数为 4 行）*/--触发器示例2
<p>代码如下:</p>
<pre>
<code> 
/* 
创建触发器[T_INSERT_卷烟销售表]，该触发器较复杂。 
说明: 每当[卷烟库存表]发生 INSERT 动作，则引发该触发器。 
触发器功能： 实现业务规则。 
业务规则: 如果销售的卷烟品牌不存在库存或者库存为零，则返回错误。 
否则则自动减少[卷烟库存表]中对应品牌卷烟的库存数量和库存金额。 
*/ 
IF EXISTS (SELECT NAME FROM SYSOBJECTS WHERE XTYPE = &#39;TR&#39; AND NAME = &#39;T_INSERT_卷烟销售表&#39;) 
DROP TRIGGER T_INSERT_卷烟销售表 
GO 
CREATE TRIGGER T_INSERT_卷烟销售表 
ON 卷烟销售表 
FOR INSERT 
AS 
BEGIN TRANSACTION 
--检查数据的合法性：销售的卷烟是否有库存，或者库存是否大于零 
IF NOT EXISTS ( 
SELECT 库存数量 
FROM 卷烟库存表 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 FROM INSERTED) 
) 
BEGIN 
--返回错误提示 
RAISERROR(&#39;错误！该卷烟不存在库存，不能销售。&#39;,16,1) 
--回滚事务 
ROLLBACK 
RETURN 
END 
IF EXISTS ( 
SELECT 库存数量 
FROM 卷烟库存表 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 FROM INSERTED) AND 
库存数量 &lt;= 0 
) 
BEGIN 
--返回错误提示 
RAISERROR(&#39;错误！该卷烟库存小于等于0，不能销售。&#39;,16,1) 
--回滚事务 
ROLLBACK 
RETURN 
END 
--对合法的数据进行处理 
--强制执行下列语句，保证业务规则 
UPDATE 卷烟销售表 
SET 销售金额 = 销售数量 * 销售单价 
WHERE 卷烟品牌 IN (SELECT 卷烟品牌 FROM INSERTED) 
DECLARE @卷烟品牌 VARCHAR(40) 
SET @卷烟品牌 = (SELECT 卷烟品牌 FROM INSERTED) 
DECLARE @销售数量 MONEY 
SET @销售数量 = (SELECT 销售数量 FROM INSERTED) 
UPDATE 卷烟库存表 
SET 库存数量 = 库存数量 - @销售数量, 
库存金额 = (库存数量 - @销售数量)*库存单价 
WHERE 卷烟品牌 = @卷烟品牌 
COMMIT TRANSACTION 
GO 
--请大家自行跟踪[卷烟库存表]和[卷烟销售表]的数据变化。 
--针对[卷烟销售表]，插入第一条测试数据，该数据是正常的。 
INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额) 
SELECT &#39;红塔山新势力&#39;,&#39;某购货商&#39;,10,12,1200 
GO 
--针对[卷烟销售表]，插入第二条测试数据，该数据 销售金额 不等于 销售单价 * 销售数量。 
--触发器将自动更正数据，使 销售金额 等于 销售单价 * 销售数量。 
INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额) 
SELECT &#39;红塔山人为峰&#39;,&#39;某购货商&#39;,10,22,2000 
GO 
--针对[卷烟销售表]，插入第三条测试数据，该数据中的卷烟品牌在 卷烟库存表中找不到对应。 
--触发器将报错。 
INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额) 
SELECT &#39;红河V8&#39;,&#39;某购货商&#39;,10,60,600 
GO 
</code></pre>/*结果集服务器: 消息 50000，级别 16，状态 1，过程 T_INSERT_卷烟销售表，行 15错误！该卷烟不存在库存，不能销售。*/--针对[卷烟销售表]，插入第三条测试数据，该数据中的卷烟品牌在 卷烟库存表中库存为0。--触发器将报错。INSERT INTO 卷烟销售表(卷烟品牌,购货商,销售数量,销售单价,销售金额)SELECT &#39;玉溪&#39;,&#39;某购货商&#39;,10,30,300GO/*结果集服务器: 消息 50000，级别 16，状态 1，过程 T_INSERT_卷烟销售表，行 29错误！该卷烟库存小于等于0，不能销售。*/--查询数据SELECT * FROM 卷烟库存表SELECT * FROM 卷烟销售表GO/*补充：1、本示例主要通过一个简单的业务规则实现来进行触发器使用的说明，具体的要根据需要灵活处理；2、关于触发器要理解并运用好 INSERTED ，DELETED 两个系统表；3、本示例创建的触发器都是 FOR INSERT ,具体的语法可参考：Trigger语法
<p>代码如下:</p>
<pre>
<code> 
CREATE TRIGGER trigger_name 
ON { table | view } 
[ WITH ENCRYPTION ] --用于加密触发器 
{ 
{ { FOR | AFTER | INSTEAD OF } { [ INSERT ] [ , ] [ UPDATE ] } 
[ WITH APPEND ] 
[ NOT FOR REPLICATION ] 
AS 
[ { IF UPDATE ( column ) 
[ { AND | OR } UPDATE ( column ) ] 
[ ...n ] 
| IF ( COLUMNS_UPDATED ( ) { bitwise_operator } updated_bitmask ) 
{ comparison_operator } column_bitmask [ ...n ] 
} ] 
sql_statement [ ...n ] 
} 
} 
</code></pre>4、关于触发器，还应该注意(1)、DELETE 触发器不能捕获 TRUNCATE TABLE 语句。(2)、触发器中不允许以下 Transact-SQL 语句：ALTER DATABASE CREATE DATABASE DISK INITDISK RESIZE DROP DATABASE LOAD DATABASELOAD LOG RECONFIGURE RESTORE DATABASERESTORE LOG(3)、触发器最多可以嵌套 32 层。*/--修改触发器--实质上，是将 CREATE TRIGGER ... 修改为 ALTER TRIGGER ...即可。--删除触发器DROP TRIGGER xxxGO--删除测试环境DROP TABLE 卷烟库存表GODROP TABLE 卷烟销售表GODROP TRIGGER T_INSERT_卷烟库存表GODROP TRIGGER T_INSERT_卷烟销售表GO##################################################################触发器的基础知识和例子：create trigger tr_nameon table/view{for | after | instead of } [update][,][insert][,][delete][with encryption]as {batch | if update (col_name) [{and|or} update (col_name)] }说明：1 tr_name ：触发器名称2 on table/view ：触发器所作用的表。一个触发器只能作用于一个表3 for 和after ：同义4 after 与instead of :sql 2000新增项目afrer 与 instead of 的区别After在触发事件发生以后才被激活,只可以建立在表上Instead of代替了相应的触发事件而被执行,既可以建立在表上也可以建立在视图上5 insert、update、delete：激活触发器的三种操作，可以同时执行，也可选其一6 if update (col_name)：表明所作的操作对指定列是否有影响，有影响，则激活触发器。此外，因为delete 操作只对行有影响，所以如果使用delete操作就不能用这条语句了(虽然使用也不出错，但是不能激活触发器，没意义)。7 触发器执行时用到的两个特殊表：deleted ,inserteddeleted 和inserted 可以说是一种特殊的临时表，是在进行激活触发器时由系统自动生成的，其结构与触发器作用的表结构是一样的，只是存放 的数据有差异。续下面表格说明deleted 与inserted 数据的差异deleted 与inserted 数据的差异Inserted存放进行insert和update 操作后的数据Deleted存放进行delete 和update操作前的数据注意：update 操作相当于先进行delete 再进行insert ,所以在进行update操作时，修改前的数据拷贝一条到deleted 表中，修改后的数据在存到触发器作用的表的同时，也同时生成一条拷贝到insered表中

<p>注：关于SQL Server  触发器实例代码的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>
			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/mysql/biji/3513.html'>SQL Server 判断某个字段包含大写字母的解决办法</a><a>下一篇</a><a href='/mysql/biji/3515.html'>SQL Server 重温事务的解决办法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>