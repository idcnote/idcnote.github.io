<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>网站前端和后台性能优化的34条宝贵经验和方法_mysql教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了网站前端和后台性能优化的34条宝贵经验和方法，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！
1 减少HTTP请" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
	    <a href="/mysql/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>数据库笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">网站前端和后台性能优化的34条宝贵经验和方法</h1>
					</div>
                    <div class="panel-title">
                        2022-11-12 09:22:00                    </div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了网站前端和后台性能优化的34条宝贵经验和方法，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！
1 减少HTTP请</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了网站前端和后台性能优化的34条宝贵经验和方法，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>
<p><strong>1 减少HTTP请求数量 (Minimize HTTP Requests)</strong><wbr /><wbr /></p>
<p>tag:content</p>
<p>80%的用户响应时间被花费在前端，而这其中的绝大多数时间是用于下载页面中的图片、样式表、脚本以及Flash这些组件。减少这些组件的数量就可以减少展示页面所需的请求数，而这是提高网页响应速度的关键。</p>
<p>朴素的页面设计当然是减少组件的一种途径，但有没有能兼顾丰富的页面内容和快速的响应速度的方法呢？下面就是一些不错的技巧，能在提供丰富的页面展现的同时，减少Http请求数量：</p>
<p>合并文件，通过把所有脚本置于一个脚本文件里或者把所有样式表放于一个样式表文件中，从而减少Http请求的数量。当不同页面需要应用不同的脚本或样式时，合并这些文件会是一个很大的挑战，不过在发布网站时进行这种合并，将是提高网站响应速度的重要一步。</p>
<p><wbr /><wbr /></p>
<p>CSS Sprites是减少图片请求的首选方案。把所有的背景图片合并到一张图中，使用CSS的background-image 和background-position 属性去控制展现恰当的图片区域。</p>
<p><wbr /><wbr /></p>
<p>Image maps把多张图片组合成为一张图片。图片的总大小是不变的，但减少Http请求数会提高页面的响应速度。Image maps只能用于图片在网页中相邻的情况，比如导航条。制定image maps中的图片坐标是个很麻烦的过程，而且容易出错。同时给导航使用image maps也并不易读，所以并不推荐使用。</p>
<p><wbr /><wbr /></p>
<p>内联图片使用data: URL scheme 把图片数据嵌入页面，但这会增加Html文档的大小。把内联图片合并到你被缓存的的样式表中是一个能既减少HTTP请求数又不会增加页面大小的方法。但目前并不是所有的主流浏览器都支持内联图片。</p>
<p><wbr /><wbr /></p>
<p>减少页面的Http请求数量是第一步，而且对于提高用户初次访问体验是最重要的一步。正如在 Tenni Theurer的blog中的Browser Cache Usage - Exposed!里描述的，每天，有 40%-60%的访客并没有你的网站的缓存文件。提高这些初次访客的访问速度是提高用户体验的关键。</p>
<p><wbr /><wbr /><strong>2 使用内容分布式网络 (Use a Content Delivery Network)</strong></p>
<p>tag:server</p>
<p>用户连接你的网站服务器的速度影响响应的快慢。把你的网站布置在多台分布于不同地域的服务器上，会让用户觉得你的页面加载速度更快。那么我们应该从哪里开始呢？</p>
<p>不要一开始就把重新设计你的网站使其能够适应分布式结构作为实现网站地域分布的第一步。根据你的网站的复杂程度不同，更新网站结构的过程也许会包含诸如同步会话状态、在服务器间复制数据库等一系列复杂的步骤。这样你提高用户访问速度的目的反而会被更新网站架构的工作耽误。</p>
<p>记住，用户80-90%的访问时间被花费在下载页面中的图片、样式表、脚本、Flash这些组件上。这是网站展示的黄金法则。那么与其重新设计网站的结构，不如先实现这些静态组件的分布。这不仅仅可以大幅减少响应时间，而且由于内容分布式网络（content delivery networks）的存在，这将是个很简单的工作。</p>
<p>内容分布式网络（CDN）是一系列分布在不同地域的服务器的集合，能够更有效的给用户发送信息。它会根据一种衡量网域距离的方法，选取为某个用户发送数据的服务器。比如，到达用户最少跳或者最快相应速度的服务器会被选中。</p>
<p>一些大型Internet公司拥有他们自己的CDN，但使用公用的CDN服务提供商更为划算，比如 Akamai Technologies, Mirror Image Internet, 或者Limelight Networks。对于刚起步的公司和个人网站来说，CDN服务的花费也许会偏高。但当你的目标用户越来越多而且趋于国际化，用CDN来降低响应时间就很必要了。在Yahoo!，把静态的内容从自己的网络服务器移到CDN提高了用户20%甚至更多的访问速度。转向CDN会是一个只需要相对简单的代码更新的工作，而且那将会显著的提高你的网站访问速度。</p>
<p><wbr /><wbr /><strong>3 给头部添加一个失效期或者Cache-Control (Add an Expires or a Cache-Control Header)</strong></p>
<p>tag:server</p>
<p>这条法则包含两方面：</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 对于静态组件：把头部的缓存期设为某个遥远的未来，使其能够&ldquo;永不过期&rdquo;。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 对于动态组件：使用适当的Cache-Control头部帮助浏览器执行特定的请求。</p>
<p>网页设计越来越丰富，页面里包含了越来越多的脚本、样式表、图片和Flash。页面的初次访问者也许会发送多个HTTP请求，但通过给头部添加失效期，你可以使那些组件被缓存。这会避免下次浏览页面时的不必要的HTTP请求。给图片文件的头部设置失效时间更为常用，但包括脚本文件、样式表和 Flash之类的所有组件的头部都应该被设置失效时间。</p>
<p>浏览器（还有代理服务器）使用缓存以减少HTTP请求的数量和大小，提高网页的加载速度。服务器在HTTP相应中通过头部中的过期时间告知客户端一个组件可以被缓存多久。下面是一个far future的过期头部，告诉浏览器这个响应直到2010年4月15日才会过期：Expires: Thu, 15 Apr 2010 20:00:00 GMT</p>
<p>如果你使用的是Apache服务器，使用ExpiresDefault 指令会设置一个相对于当前时间的过期时间。这里有一个通过ExpiresDefault 指令把过期时间设为请求时间之后10年的例子：ExpiresDefault &quot;access plus 10 years&quot;</p>
<p>记住，如果你使用了far future过期头部，你必须在组件更新时更换它的名字。在Yahoo!我们通常在建设网站的过程中执行这样的步骤：组件的名字里包含了它的版本，比如：yahoo_2.0.6.js。</p>
<p>使用一个far future过期头部只会在用户已经访问你的网站之后起作用。它不会影响一个没有缓存的初次访问者的HTTP请求数量。所以这一切的效果取决于多少用户访问页面时有一份预缓存（一份&quot;预缓存&quot;中已经包含了页面的所有组件）。我们对此在Yahoo！做过测试，发现拥有预缓存的用户在 75-85%。给头部添加far future失效期，可以增加浏览器缓存的组件数量并重复用于随后的页面浏览而不需要通过用户的网络发送哪怕一个字节。</p>
<p><wbr /><wbr /></p>
<p><strong>4 Gzip压缩组件(Gzip Components)</strong></p>
<p>tag:server</p>
<p>前台工程师的决策能够显著的减少在网络上传输 HTTP请求和响应花费的时间。确实，终端用户的带宽速度、Internet服务提供商和连接交换机的服务器这些因素都是开发小组所不能控制的。但还有一些其它因素会影响响应的时间，比如压缩文件，就会减少HTTP响应的大小从而减少响应的时间。</p>
<p><wbr /><wbr /></p>
<p>从HTTP/1.1开始，Web客户端就被设定为支持HTTP请求的头部中Accept-Encoding指定的压缩格式：Accept-Encoding: gzip, deflate</p>
<p>当服务器检测到请求头部中的这一代吗，它就会使用客户端提供的方法列表中的一个来压缩响应内容。而服务器通过响应头部中的Content- Encoding来告知客户端它所使用的压缩方式：Content-Encoding: gzip</p>
<p>Gzip是当前最常用也是最有效的压缩方式，GNU项目开发了这一方法并且符合RFC 1952标准。另外一种你可能见过的压缩格式是deflate，但它没有那么有效和常用。</p>
<p>使用gzip压缩通常会减少70%的响应大小。当前浏览器中大约90%的Internet通讯传输声明支持gzip。如果你使用Apache服务器，配置gzip的模块取决于服务器的版本：Apache 1.3 使用mod_gzip ，而Apache 2.x 使用mod_deflate。</p>
<p>浏览器和代理会有一些已知的问题，可能导致浏览器的预期内容和获得的实际压缩内容不匹配。幸运的是，这种情况随着旧浏览器的使用者减少而减少。 Apache的模块可以通过自动添加适当的变化响应文件头来解决这些问题。</p>
<p>服务器会根据文件类型选择gzip压缩的内容，但一般情况下，服务器选择压缩的内容会过于局限。大部分网站会压缩它们的Html文档，而压缩脚本和样式表也是值得一做的，但很多网站并没有这样做，事实上，压缩在包括 XML和JSON在内的任何文本响应都是值得的。图片和PDF文件不应该被gzip压缩，因为它们已经是被压缩了的文件，gzip它们不仅浪费CPU甚至还有增大文件大小的可能。</p>
<p>Gzip尽可能多的文件类型是减少页面大小从而提高用户体验的一个简单的方法。</p>
<p><wbr /><wbr /><strong>5 把样式表放在前面(Put Stylesheets at the Top)</strong></p>
<p>tag:css</p>
<p>在研究Yahoo！的性能时，我们发现把样式表挪到文档的头部可以让页面的加载显得更快。因为把样式表放在头部可以让页面逐步呈现。</p>
<p>关心网站性能的前台工程师通常希望页面能够逐步加载；即，我们希望浏览器能够把已经获得的内容尽快展现。这对于内容很多的页面以及网络连接较慢的用户尤为重要。给予用户视觉上的反馈（比如进度提示）的重要性，已经经过了很详尽的论证。而对于我们来说，Html 页面本身就可以作为进度提示！当浏览器逐步加载页面时，头部、导航条、顶部的logo等等这些都可以作为对正在等待页面的用户的可视的反馈。而这会从整体上提高用户体验。</p>
<p>把样式表放在文档的最后，会导致包括IE在内的大部分浏览器不进行逐步呈现。浏览器为了避免当样式改变时重绘元素而中止呈现。用户会十分无聊的看到一个空白的页面。</p>
<p>Html规范明确规定样式表应该被包含在页面的HEAD中：&ldquo;和A不同，LINK只能在文档的HEAD部位出现，但它可以出现多次。&rdquo;空白的屏幕或者由于没有应用样式而引起的内容的闪现都不值得去尝试。最好的方法是遵循HTML规范，把样式表放在文档的HEAD部位。</p>
<p><wbr /><wbr /><strong>6 把脚本放在最后(Put Scripts at the Bottom)</strong></p>
<p>tag:javascript</p>
<p>脚本可能会堵塞并发的下载。HTTP/1.1规范建议浏览器在每个域名下只进行两个并发下载。如果你把图片放在多个域名下，可以实现多于两个的并发下载。当脚本被下载时，即使使用不同的域名。浏览器也不会进行任何其它的下载。</p>
<p>有些情况下把脚本放到底部并不太容易。比如，脚本使用了document.write 来添加部分页面中的内容，就不能放到页面中更后面的位置。还可能有作用域的问题。很多情况下，还有一些变通的方法。</p>
<p>通常的建议是使用延迟脚本。DEFER属性表明脚本不包含document.write，而且提示浏览器继续展现。不幸的是，Firefox不支持DEFER属性。IE中，脚本可以被延迟，但并不如你期望的那么久。如果一个脚本可以被延迟，那么它也可以被放在页面的底部。这会让你的页面加载的更快。</p>
<p><wbr /><wbr /></p>
<p><strong>7 不使用CSS表达式 (Avoid CSS Expressions)</strong></p>
<p>tag:css</p>
<p><wbr /><wbr /></p>
<p>CSS表达式是一种有力的（同时也很危险的）动态设置CSS属性的方法。从IE5开始支持CSS表达式。比如，使用CSS表达式可以实现背景颜色每小时变换的效果。background-color: expression_r( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</p>
<p>如上所示，表达式方法采用了 Javascript的表达。CSS属性则被设为Javascript表达式的结果。其它的浏览器会忽略CSS表达式，所以对于设置专属IE的属性以便在不同浏览器间能有一致的体验是有用的。、</p>
<p>而CSS表达式的问题是它比大多数人期望的执行次数更频繁。表达式不仅仅在页面展现和重新设置大小的时候执行，在页面滚动，甚至用户在页面上挪动鼠标时都会执行。给CSS表达式添加一个计数器可以跟踪CSS在什么时候和怎样执行。在页面上移动鼠标可以轻易的产生一万次以上的执行。</p>
<p>使用一次性的表达式是减少CSS表达式的执行次数的一个方法，当表达式第一次执行时，CSS表达式会被一个确定的值代替。如果在页面生命周期中，样式属性必须动态的设定，使用事件处理替代CSS表达式是一个可选的方法。如果必须使用CSS表达式，要记得它们会执行上千次并影响页面的性能。</p>
<p><wbr /><wbr /><strong>8 使用外部的JavaScript和CSS (Make JavaScript and CSS External)</strong></p>
<p>tag:javascript,css</p>
<p><wbr /><wbr /></p>
<p>很多性能规则都是解决怎样处理独立的组件的问题的。但是，考虑这些之前，你应该先考虑一个更基本的问题：JavaScript和CSS应该被放于外部的文件，还是内联在页面里？</p>
<p>在实际应用中使用外部的文件往往产生更快的页面，因为浏览器会缓存JavaScript和CSS文件。而内联在页面里的JavaScript和CSS会在每次请求页面时下载。这会减少所需的HTTP请求数，但增大HTML文档的体积。而另一方面，如果放在外部文件里的JavaScript和CSS被浏览器缓存，则既不用增加HTTP请求的数量，HTML文档的体积也会减少。</p>
<p>关键的问题是，外部的JavaScript和CSS的组件被缓存的频率和HTML文档被请求的次数相关。虽然很难去量化，但可以被用很多指标衡量。如果你的网站的用户在每个会话中浏览了很多网页而且很多页面重用了相同的JavaSctipt和样式表，缓存外部文件是有很大潜在的好处的。</p>
<p>很多网站都符合这样的指标。对于这些网站来说，最好的解决方案是把JavaScript和CSS发布为单独的文件。唯一的例外，对于主页，内联的文件更好一些，例如 Yahoo!&#39;s front page 和 My Yahoo!。主页在每个会话中只有很少浏览（也许只有一次），你会发现内联的 JavaScript和CSS会让终端用户的响应更快。</p>
<p>对于有很多页面浏览量的首页来说，有很多能平衡内联文件所提供的HTTP请求减少的效果与外部文件缓存获得的好处的技巧。一种这样的技巧就是把JavaScript和CSS内联在说夜里，但在页面完成加载时动态下载外部文件。随后的页面会调用浏览器中已经缓存的外部文件。</p>
<p><wbr /><wbr /><strong>9 减少DNS的查询 (Reduce DNS Lookups)</strong></p>
<p>tag:content</p>
<p><wbr /><wbr /></p>
<p>正如电话簿使人名和他们的电话号码相对应，域名系统（DNS）能够使域名和IP地址相对应。当你在浏览器中键入http://www.yahoo.com，浏览器链接的DNS解析器会返回服务器的 IP地址。域名解析会耗费一些时间，DNS查找给定域名的IP地址一般会耗费20-120毫秒。在DNS查找结束前，浏览器不会从目标域名那里下载任何东西。</p>
<p>DNS查询会被缓存以便优化性能。会有一个专门的缓存服务器进行缓存，用户的ISP或者本地网络会维护它，但独立用户的电脑里也会有缓存。DNS信息存在于操作系统的DNS缓存里（微软Windows操作系统里的&ldquo;DNS客户服务&rdquo;）。大部分浏览器有它们自己的缓存，与操作系统的缓存相独立。当浏览器在自己的缓存里保存了DNS的记录，它不会向操作系统发出请求记录的要求。</p>
<p>IE默认缓存DNS查询30分钟，在注册表的DnsCacheTimeout的键值中设定。Firefox则缓存DNS查询一分钟，在配置network.dnsCacheExpiration 中设定。（Fasterfox 将它变为一小时。）</p>
<p>当客户端的DNS缓存被清空（包括浏览器和操作系统的缓存），DNS查询的数量等同于网页中单独的域名的数量。包括页面中的链接，图片，脚本文件，样式表，Flash对象等。减少不同域名的数量则会减少DNS查询的数量。</p>
<p>减少不同域名的数量可能减少页面并行的下载数量。减少 DNS查询缩短了响应时间，但减少了并行下载数也许会增加响应时间。我的建议是将组件分布在两到四个域名之间。这能很好的折中减少DNS查询提高的速度和维持较高水平的并行下载的效果。</p>
<p><wbr /><wbr /><strong><strong></strong>10 缩小JavaScript和CSS (Minify JavaScript and CSS)</strong></p>
<p>tag:javascript,css</p>
<p><wbr /><wbr /></p>
<p>缩小是指从代码中删除不必要的字母，减少文件体积从而提高加载速度。缩减代码时需要移除所有的注释，以及不需要的空白（空格，新行和tab）。这样处理JavaScript之后，会由于下载文件的体积被减少而提高响应的性能。两个常用的缩减JavaScript代码的工具是JSMin 和YUI Compressor。YUI compressor也可以压缩CSS。</p>
<p>代码混淆是另一个可用于源代码的优化方案。它比压缩更为复杂，而且在混淆的过程中更容易产生 Bug。纵观U.S.的前十大网站，压缩获得了21%的体积减小而代码混淆达到了25%。虽然代码混淆的压缩程度更高，但压缩JavaScript的风险更小。</p>
<p>不仅仅要压缩外部的脚本和样式表，内敛的&lt;script&gt;和&lt;style&gt;部分也可以而且应当被压缩。即使你gzip了你的脚本和样式，压缩它们仍然能减少5%以上的体积。随着JavaScript和CSS的应用和体积的增加，压缩你的代码获得的收益也会越来越多。</p>
<p><wbr /><wbr /></p>
<p><strong><strong></strong>11 避免重定向 (Avoid Redirects)</strong></p>
<p>tag:content</p>
<p>重定向结束于 301或302状态码。这里有一个301响应的HTTP头的例子：<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> HTTP/1.1 301 Moved Permanently<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> Location: http://example.com/newuri<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> Content-Type: text/html</p>
<p>浏览器会自动把用户转向Location域中指明的Url地址。HTTP头里包含了重定向所需的所有信息。响应的主体一般是空的。301或者302响应都不会被实际缓存，除非添加额外的头部，比如 Expires或者Cache- Control指明了它应该被缓存。meta refresh标签和JavaScript也可以将用户重定向到不同的URL，但如果你必须执行重定向，最好的方法是使用标准的3XX HTTP状态代码，以便使后退按钮工作正常。</p>
<p>需要谨记的是，重定向降低了用户体验。在用户和HTML文档之间插入的重定向延误了页面的呈现和组件下载，因为它们都不可能在获得HTML文档之前开始。</p>
<p><wbr /><wbr /></p>
<p>一种最浪费性能的重定向频繁发生而网络开发者们却往往没有意识到，那就是当地址中应当有一个左斜线（/）却没有的时候。比如，访问http://astrology.yahoo.com/astrology会导致一个301效应并重定向到http://astrology.yahoo.com/astrology/（注意这里加了一个左斜线）。在Apache中，这可以使用mod_rewrite,或者在Apache事件处理中使用DirectorySlash指令来修补。</p>
<p><wbr /><wbr /></p>
<p>使用重定向的另一个常见场景是连接旧网站和新网站。还包括连接网站的不同部分，或者在不同情况下（比如依据浏览器的类型，用户的类型等）重定向用户。使用重定向来连接两个网站很简单而且需要很少的额外代码。虽然在这些情况下使用重定向减少了开发者的麻烦，但却降低了用户体验。如果两部分在同一个服务器上，可以使用Alias 和rewrite来替代重定向。如果域名变更引起了重定向，可以创建一个CNAME（一种可以创建一个别名使一个域名指向另一个的DNS记录）结合 Alias 或者mod_rewrite来替代重定向。</p>
<p><wbr /><wbr /><strong>12 移除重复的脚本 (Remove Duplicate Scripts)</strong></p>
<p>tag:javascript</p>
<p><wbr /><wbr /></p>
<p>在同一个页面中包含两个相同的脚本文件降低了性能。这并不如你想象的那么罕见。在对美国十大网站中的检查中，发现它们中的两个包含了重复的脚本。有两个主要因素增加了一个页面包含两个相同脚本的几率&mdash;&mdash;团队的大小和脚本的数量。当脚本被重复包含时，由于增加了不必要的HTTP请求和JavaScript的执行，影响了性能。</p>
<p>不必要的HTTP请求在IE中存在，而Firefox终没有。在IE中，如果一个外部脚本被包含了两次而且没有被缓存，在页面加载的过程中会产生两次HTTP请求。即使脚本被缓存了，当用户重载页面时，多余的HTTP请求也会发生。</p>
<p>产生多余的HTTP请求的同时，多次执行脚本也会浪费时间。在Firefox和IE中，无论是否被缓存，脚本都会被重复执行。</p>
<p><wbr /><wbr /></p>
<p>避免脚本被意外加载两次的一个方法是在你的模板系统中执行一个脚本管理模块。通常的方式是在HTML页面中使用SCRIPT标签来添加一个脚本：</p>
<p>&lt;script type=&quot;text/javascript&quot; src=&quot;menu_1.0.17.js&quot;&gt;&lt;/script&gt;</p>
<p>HP 中，可以选择创建一个叫做insertScript的方法：&lt;?php insertScript(&quot;menu.js&quot;) ?&gt;</p>
<p>这个函数不仅仅能防止脚本被重复加载多次，还可以解决脚本的其他问题，比如独立性检测以及为脚本添加版本号码以应对far future Expires头部。</p>
<p><wbr /><wbr /><strong>13 设定ETags (Configure ETags)</strong></p>
<p>tag:server</p>
<p><wbr /><wbr /></p>
<p>实体标签（ETags）是服务器和浏览器用于确定浏览器中缓存的组件和服务器中的是否对应的一种机制。（&quot;entity&quot;是组件的另一种说法：图片、脚本、样式表等等）添加 ETags用于辨别组件提供了比单纯利用&ldquo;最后修改时间&rdquo;更为灵活的机制。ETag是一个唯一标识组件的特定版本的字符串。它的唯一格式规范是字符串必须被引号引用。来源服务器使用ETag响应头来设定一个组件的ETag：</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> HTTP/1.1 200 OK<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> ETag: &quot;10c24bc-4ab-457e1c1f&quot;<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> Content-Length: 12195</p>
<p><wbr /><wbr /></p>
<p>当浏览器晚些时候需要检测一个组件时，它使用If-None-Match 头部把ETag传回来源服务器。如果ETag匹配了，会返回一个304状态码，在这个例子里它会减少12195个字节的响应：<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> GET /i/yahoo.gif HTTP/1.1<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> Host: us.yimg.com<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> HTTP/1.1 304 Not Modified</p>
<p><wbr /><wbr /></p>
<p>ETag的问题是它们往往在网站的一个服务器中被设为唯一的，当浏览器从一个服务器得到了组件并在稍后试图到另一个服务器验证时，ETag会不匹配，而这在使用多个服务器来处理请求的网站中是很常见的。默认情况下，Apache和IIS在ETag中嵌入的数据戏剧性的减少了应用多台服务器的网站的ETag验证成功几率。</p>
<p><wbr /><wbr /></p>
<p>Apache1.3和2.新版本的ETag格式是inode-size- timestamp。虽然一个给定的文件在多台服务器中处于同一个目录，而且有同样的大小，权限，时间戳，但它的inode在不同服务器中是不同的。</p>
<p><wbr /><wbr /></p>
<p>IIS5.0和6.0有同样的问题。IIS中ETag的格式是Filetimestamp:ChangeNumber。 ChangeNumber用来跟踪IIS配置的改变次数。一个网站的所有IIS不可能有相同的ChangeNumber。</p>
<p><wbr /><wbr /></p>
<p>这导致的结果是，Apache和IIS对完全相同的组件产生的ETag在不同服务器间不能匹配。如果ETags不匹配，用户不会得到小而快的304响应，而是一个普通的200响应和组件的所有数据。如果你把你的网站放在了一个服务器里，这不会是一个问题。但如果你的网站有多台服务器，而且你使用了Apache和IIS 默认的ETag配置，你的用户会访问页面的速度会变慢，你的服务器加载的程度更高，消耗了更大的带宽，代理服务器不能有效的缓存你的内容。即使你的组件有一个ar future Expires头部，当用户重载或者刷新页面时，依然会发送一个GET请求。</p>
<p><wbr /><wbr /></p>
<p>如果你不打算利用ETags提供的灵活的验证模式，你最好把ETag统统移除。Last-Modified头部的验证方式给予组件的时间戳。移除ETag 同时减少响应和随后的请求中的HTTP头部大小。这篇微软的支持文档描述了怎样在IIS中移除 ETags。在Apache中，你只要在Apache配置文件中添加如下一行：<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> FileETag none</p>
<p><wbr /><wbr /></p>
<p><strong>14 让Ajax可以缓存 (Make Ajax Cacheable)</strong></p>
<p>tag:content</p>
<p>Ajax 的好处之一是它能给用户提供瞬间的响应，因为它从服务端异步请求数据。但Ajax不能保证用户在等候那些异步的JavaScript和XML响应返回时什么都不做。在应用程序中，用户是否继续等待取决于Ajax怎样应用。比如，在一个基于Web的Email客户端用户会等候Ajax返回他们所搜索的邮件信息。记住异步并不代表&ldquo;即刻&rdquo;。</p>
<p>为了提高性能，优化Ajax响应很重要。提高Ajax性能最重要的方式是使响应缓存，正如&ldquo;添加一个过期期限和缓存控制头&rdquo;这一节讨论的。这些原则同样适用于Ajax。</p>
<p><wbr /><wbr /></p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * Gzip组件<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 减少DNS查询<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 压缩JavaScript<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 避免重定向<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 设定ETag</p>
<p><wbr /><wbr /></p>
<p>我们看一个例子。一个Web2，0的邮件客户端可能会用Ajax自动下载用户地址簿。如果用户从上次使用邮件网站以来没有修改她的地址簿，那么如果Ajax响应使用了长期失效时间或者缓存控制头部，地址簿就可以从缓存中读取出来。浏览器必须被告知&ldquo;使用之前的缓存地址簿&rdquo;而不是&ldquo;请求一个新的地址簿&rdquo;。可以在地址簿Ajax的URL中添加一个标识用户最后一次修改地址簿的时间戳，比如，&amp;t=1190241612。如果地址簿从最后一次下载后没有被更改，时间戳将相同而地址簿将会从浏览器的缓存中得到来替代额外的HTTP传输。如果用户更改了她的地址簿，时间戳会保证新的URL不会和缓存中的匹配，而且浏览器会请求会请求更新的地址簿记录。</p>
<p><wbr /><wbr /></p>
<p>即使你的Ajax响应时动态创建的，而且只适用于一个用户，它们依然会被缓存。这样做会让你的Web2.0应用程序更快。</p>
<p><wbr /><wbr /><strong>15 更早的刷新缓冲区 (Flush the Buffer Early)</strong></p>
<p>tag:server</p>
<p>当用户请求一个页面，服务端会花费200至500毫秒的时间组合HTML页面。在这期间，浏览器会静静等待数据到来。PHP中有flush（）函数，它允许你向浏览器发送部分就绪的HTML响应，这样浏览器可以在服务器处理余下的HTML页面时去获取组件。这样的好处主要在忙碌的后台和轻松的前台间可以看到。</p>
<p><wbr /><wbr /></p>
<p>在HEAD后面是放置刷新操作的好地方，因为头部的HTML代码更容易产生，而且可以让你放置任何CSS和JavaScript文件，以便浏览器在后台工作依然进行时并行开始获取组件。</p>
<p>例子：</p>
<p>... &lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt;... &lt;!-- content --&gt;</p>
<p>Yahoo! search先行研究并且进行了真人测试证明了使用这项技术的好处。</p>
<p><wbr /><wbr /><strong>16 在Ajax请求中使用GET方法 (Use GET for AJAX Requests)</strong></p>
<p>tag:server</p>
<p>Yahoo! Mail 团队发现进行XMLHttpRequest的时候，POST方法在浏览器中分两步执行：先发送头部，然后发送数据。所以最好使用只发送一个TCP包（除非你有很多的cookie）的GET方法。IE中URL的最大长度是2000，所以如果你发送超过 2000的数据就不能使用GET方法。</p>
<p><wbr /><wbr /></p>
<p>一个有趣的现象是，POST方法并不像GET那样实际发送数据（而Get则名副其实）。基于 HTTP规范，GET方法意味着取回数据，所以当你只是请求数据时使用GET方法更为有意义（从语义上来说），而在发送需要储存在服务器端的数据时则相反使用POST。</p>
<p><strong>17 后加载组件 (Post-load Components)</strong></p>
<p>tag:content</p>
<p><wbr /><wbr /></p>
<p>你可以仔细端详下你的页面然后自问：&ldquo;什么是在页面初始化时必须的？&rdquo;那么其余的内容和组件可以放在后面。</p>
<p><wbr /><wbr /></p>
<p>JavaScript是理想的用来分割onload事件之前和之后的选择。例如你有执行拖放、下拉和动画的JavaScript代码和菜单，它们可以稍后加载，因为用户在初始呈现之后才会在页面上拖动元素。其他的可以被后加载的地方包括隐藏的内容（当用户做某项操作才会展现的内容）和被折叠的图片。</p>
<p><wbr /><wbr /></p>
<p>可以帮助你的工具有： YUI Image Loader能帮助你延缓加载折叠的图片，而且YUI Get utility 能够很简单的包装运行中的JS和CSS。比如，打开Firebug的网络选项卡去查看Yahoo! Home Page。</p>
<p><wbr /><wbr /></p>
<p>当性能指标和其它网站开发的好的实践一致时是不错的。渐进增强的观念告诉我们当支持JavaScript时，会提高用户体验，但你必须确保在没有JavaScript时页面也能工作。所以当你确保页面工作正常时，你会通过延后加载的那些更花哨的脚本比如拖放和动画，来增强你的页面。</p>
<p><wbr /><wbr /></p>
<p><strong>18 预先加载组件 (Preload Components)</strong></p>
<p>tag:content</p>
<p><wbr /><wbr /></p>
<p>预加载看起来和后加载原则是个矛盾，但它其实是为了另外一个目的。预加载组件让你可以利用浏览器的空闲时间来加载之后需要的组件（比如图片，样式表和脚本）。这样当用户浏览下一个页面的时候，大部分组件都已经在缓存里了而页面会加载的更快。</p>
<p><wbr /><wbr /></p>
<p>有几种预加载的类型：</p>
<p><wbr /><wbr /></p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 无条件预加载-当原本内容加载完成时，立刻开始获取一些额外的组件。比如到google.com看下一个sprite图片怎样被在onload事件后请求的。在google.com的首页里并没有用到sprite图片，但被用在接下来的结果页面里。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 有条件的预加载-根据用户的行为来猜测用户什么时候到达下个页面然后据此预加载。在search.yahoo.com上，你可以看到额外的组件在你在输入框中输入时是怎样被加载的。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 有预期的加载-当登录重新设计的网站时进行加载。你通常会在重新设计网站后听到：&ldquo;新网站很酷，但它比以前的要慢&rdquo;。这个问题的部分原因是用户访问旧网站时有所有的缓存，而对于新的来说，缓存是空的。你可以通过在登录重新设计的网站前预加载一些组件来缓解这方面的影响。你的旧网站可以用浏览器空闲的时间来请求新网站中用到的脚本和图片。</p>
<p><wbr /><wbr /><strong>19 减小DOM元素的数量 (Reduce the Number of DOM Elements)</strong></p>
<p>tag:content</p>
<p><wbr /><wbr /></p>
<p>复杂的页面意味着更多的字节需要被下载而且也意味着在JavaScript中遍历DOM更慢。比如你在页面中添加一个事件，让它在500或者 5000个DOM元素中循环，它们的效率是不同的。</p>
<p><wbr /><wbr /></p>
<p>更多的DOM元素表明有些标签需要被改良而并不一定需要移除实际内容。你是否为了布局而使用繁琐的网一样的表格？你是否只是为了弥补一些布局的问题而使用了更多的div标签？也许还有更好和更符合语义的标签可以使用。</p>
<p><wbr /><wbr /></p>
<p><wbr /><wbr />YUI CSS utilities可以很好的帮助进行布局:grid.css 可以帮助你进行所有的布局，front.css 和 reset.css 可以帮助你去除浏览器默认的格式。这是你开始重新审视你的标签的机会，比如只在语义符合时使用div标签，而不是用它来另起一行。</p>
<p><wbr /><wbr /></p>
<p>DOM 元素的数量很好检测，只要在Firebug的控制台里输入：document.getElementsByTagName_r(&#39;*&#39;).length</p>
<p><wbr /><wbr /></p>
<p>那么多少DOM元素算多呢？查看下类似的使用较好的标签的页面。比如Yahoo! Home Page是一个很丰富的页面但只有700以下的DOM元素（HTML 标签）。</p>
<p><wbr /><wbr /></p>
<p><strong>20 分域部署部件：Split Components Across Domains</strong></p>
<p>tag：内容</p>
<p>将部件分割能使你获得最大的并行下载效率。但你同时需要注意不使用多于2~4个域名，以避免DNS查询导致的问题。例如，你可以将HTML内容和动态的组建放于 www.example.org域名下，将静态组件分别放于static1.example.org和static2.example.org之下。</p>
<p><wbr /><wbr /></p>
<p>查看Tenni Theurer和Patty Chi的&quot;Maximizing Parallel Downloads in the Carpool Lane&quot;获取更多关于并行下载的信息。</p>
<p><wbr /><wbr /><strong>21 减少Iframe的数量 Minimize the Number of iframes</strong></p>
<p>tag：内容</p>
<p><wbr /><wbr /></p>
<p>Iframes 能够使HTML文档被插入进父级文档中。首先需要明确iframe的工作方式，才能有效的利用这一形式。</p>
<p><wbr /><wbr /></p>
<p>&lt;iframe&gt; 的优点：</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 对于第三方内容，比如广告，能够在不影响父级设计的情况下快捷插入。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 提供安全沙箱，不影响父级。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 能够并行下载脚本。</p>
<p><wbr /><wbr /></p>
<p>&lt;iframe&gt; 的缺点：</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 即使是空的也会有消耗。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 会锁住页面的onload事件。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 不支持语义表达。</p>
<p><wbr /><wbr /><strong>22 避免404错误 No 404s</strong></p>
<p>tag：内容</p>
<p><wbr /><wbr /></p>
<p>一个获得没用的404响应的HTTP请求对于宝贵的HTTP请求资源来说是完全不必要的，而且这样还会减慢用户的体验。</p>
<p><wbr /><wbr /></p>
<p>有的网站提供了有帮助的404错误信息，比如&quot;你是否在寻找&hellip;&hellip;？&quot;，这样虽然能提高用户体验，但同样浪费了服务端资源（比如数据库）。尤其不妙的是在请求一个外部的Javascript脚本文件失败时获得的一个404错误，因为这样不但会堵塞并行的下载，而且浏览器会尝试分析404响应的内容，来辨识它是否是有用的Javascript代码。</p>
<p><wbr /><wbr /><strong>23 减少Cookie的大小 Reduce Cookie Size</strong></p>
<p>tag：cookie</p>
<p><wbr /><wbr /></p>
<p>有多种理由让我们应用HTTP cookie，比如身份验证，或者个性化设置。Cookie中的信息在服务端和浏览器间被放在HTTP头中交换。尽量减少cookie的体积对减少用户获得响应的时间十分重要。</p>
<p><wbr /><wbr /></p>
<p>查看Tenni Theurer和Patty Chi的&quot;When the Cookie Crumbles&quot;获取更多信息。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 去除不必要的 cookie。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 尽量减少cookie的大小。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 留心将cookie设置在适当的域名下，避免影响到其他网站。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 设置适当的过期时间。一个较早的过期时间或者不设置过期时间会更快的删除cookie，从而减少用户的响应时间。</p>
<p><wbr /><wbr /><strong>24 为部件使用没有cookie的域名 Use Cookie-free Domains for Components</strong></p>
<p>tag：cookie</p>
<p><wbr /><wbr /></p>
<p>当浏览其请求一个静态图片并一同发送cookie时，服务器并不需要这些cookie。这样只是毫无益处的创建了多余的网络流量。应当保证静态的部件在请求时没有携带cookie，所以需要把你的静态部件放在另一个子域名下。</p>
<p><wbr /><wbr /></p>
<p>如果你的域名是www.example.org，你可以将你的静态部件放在static.example.org中。如果你把cookie设置在顶级域名example.org上而不是 www.example.org，那么所有发送至static.example.org的请求会包括那些cookie。在这种情况下，你可以买一个全新的没有cookie的域名来放置你的静态部件。Yahoo！使用了yimg.com，YouTube试用了ytimg.com，Amazon使用的是 images-amazon.com。</p>
<p><wbr /><wbr /></p>
<p>将静态部件放于没有cookie的域名下的另一个好处是一些代理服务器会拒绝缓存有cookie 的部件。于此相关的一点是，如果你怀疑你应该为你的首页使用example.org还是www.example.org，考虑cookie的赢下。省略 www会让你不得不把cookie写到*.example.org下，所以考虑性能，最好使用www.子域名，然后把cookie写到这个子域名下。</p>
<p><wbr /><wbr /><strong>25 减少DOM的读取 Minimize DOM Access</strong></p>
<p>tag：javascript<wbr /><wbr /></p>
<p>利用Javascript读取 DOM元素很慢，所以为了获得响应更快的页面，你应该：</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 缓存被读取的元素的引用。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 脱机更新节点然后把它们加回到树结构中。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 避免利用Javascript定位布局。</p>
<p><wbr /><wbr /></p>
<p><strong>26 开发灵巧的事件处理程序 Develop Smart Event Handlers</strong></p>
<p>tag：javascript<wbr /><wbr /></p>
<p>如果有太多的事件处理逻辑部署在DOM树的不同元素上，它们的频繁执行会拖慢页面的响应速度。而使用事件委托是一个好的解决方法。如果在一个Div中有10个按钮，与其在每个按钮上都放一个事件处理程序，步入只在Div上放一个事件处理程序。事件会冒泡上溯，这样你就会捕获这一事件，并找出是哪个按钮发起的它。</p>
<p>同样，你并不需要等待onload事件来启动一些操作DOM树的程序。你只需要保证你需要操作的元素可用就可以了。你不需要等待所有的图片下载完毕，你应当使用DOMContentLoaded事件来替代onload事件，当然，目前并不是所有浏览器都支持这一事件，你可以使用YUI Event组件，其中包含了一个onAvailable函数。</p>
<p>查看Julien Lecomte的&quot;High Performance Ajax Applications&quot;获取更多信息。</p>
<p><wbr /><wbr /><strong>27 选择&lt;link&gt;而不是@import Choose &lt;link&gt; over @import</strong></p>
<p>tag：css<wbr /><wbr /></p>
<p>前面提到把CSS应当放在最顶端来提供预显。在IE中，放在页面底部的@import和&lt;link&gt;效果是一样的，所以最好不要用它。</p>
<p><wbr /><wbr /><strong>28 不使用过滤器 Avoid Filters</strong></p>
<p>tag：css<wbr /><wbr /></p>
<p>IE专有的AlphaImageLoader过滤器是为了解决半透明真色PNG图片在IE7之前的版本中显示的问题。这个过滤器会在图片下载时堵塞住展示。而且它会消耗内存并影响每个元素而不仅仅是每张图片，所以这个过滤器的问题很多。<wbr /><wbr /></p>
<p>所以最好在IE中完全不使用AlphaImageLoader过滤器，而使用渐淡的 PNG8图片。如果你明确需要AlphaImageLoader，请使用hack _filter，从而不影响到你的IE7+的用户。</p>
<p><wbr /><wbr /><strong>29 优化图片 Optimize Images</strong></p>
<p>tag：images<wbr /><wbr /></p>
<p>当设计师制作好网站的图片后，还有些事情应该是你在把这些图片上传到服务器之前做的。</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 你可以检查GIF图片中的调色板是否和图片中的色彩数一致。使用imagemagick来帮助你方便的检查：<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> identify -verbose image.gif<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> 如果你看到一个4色的图片却有一个256色的调色板，那么还有很大的空间来做性能优化。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 试试把GIF转换成PNG是否会节省空间，这是常有的事情。由于浏览器支持的限制，开发者往往怀疑是否该使用PNG，但这是过去的事情了。唯一的问题是真色的PNG图片的半透明问题，但同样，GIF不是真色的而且也不支持丰富的透明效果。所以GIF可以做的，PNG或者PNG8同样可以做到（除了动画）。一条简单的imagemagick语句就可以提供可用的PNG：<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> convert image.gif image.png<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> &ldquo;我们强调的是，给PNG一个机会！&rdquo;<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 使用pngcrush或者任何的PNG优化工具，例如：<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> pngcrush image.png -rem alla -reduce -brute result.png<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 使用 jpegtran处理JPEG图片。这个工具会无损操作JPEG图片，比如旋转，而且可以用来优化图片，比如去除图片中的注释和其他无用的信息（比如 EXIF信息）。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> jpegtran -copy none -optimize -perfect src.jpg dest.jpg</p>
<p><wbr /><wbr /><strong>30 优化CSS精灵 Optimize CSS Sprites</strong></p>
<p>tag：images</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 横向布局Sprite中的图片往往比纵向布局会减少文件大小。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 在一个Sprite中组合相近的颜色会降低颜色的数量，从而达到适合PNG8的低于256色的标准。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * &ldquo;对移动设备友好&rdquo;，不在Sprite里留下大的空隙。这并不十分影响文件的大小，但会减少客户端代理将图片解压为像素映射的内存消耗，100*100的图片是一万像素，而1000*1000则是一百万像素。</p>
<p><strong>31 不要在HTML中缩放图片 Don&#39;t Scale Images in HTML</strong></p>
<p>tag：images<wbr /><wbr /></p>
<p>不要使用大小超过需要的图片，即使你能够在HTML中设置它的属性。如果你需要</p>
<p>&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;</p>
<p>那么就使用恰好100*100px的图片，而不是使用缩放后的500*500的图片。</p>
<p><wbr /><wbr /><strong>32 使用小的可缓存的Favicon.ico Make favicon.ico Small and Cacheable</strong></p>
<p>tag：images<wbr /><wbr /></p>
<p>favicon.icon是放在服务器根目录的一个图片，它是个麻烦却不得不处理，因为即使你不关心，浏览器依然会请求这张图片，所以最好不要提供一个404的错误。而且由于它是在同一服务器下的，Cookie也会随着每次请求一并发送。这张图片同样干扰下载队列，比如在IE中，当你在onload 事件中请求额外的组件时，favicon会在这些额外组件之前下载。</p>
<p>所以为了减少favicon.ico的不利影响，我们应当：</p>
<p><wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 使用小图片，小于1k为佳。<wbr /><wbr /><wbr /><wbr /><wbr /><wbr /> * 设置你认为合适的过期时间（因为你如果更新了图片，你并不能修改它的名字）。你可以设置过期为未来的几个月。你可以借鉴下你当前的 favicon.ico的最后更新时间来作为设置依据。</p>
<p>Imagemagick 能够帮助你创建小图片。</p>
<p><wbr /><wbr /><strong>33 保证组件大小小于25K Keep Components under 25K</strong></p>
<p>tag：mobile<wbr /><wbr /></p>
<p>这一限制是因为iPone不会缓存大于25K的组件，注意这里指的是未压缩前的大小。这就是为什么缩小大小很重要，因为单单gzip并不足够。<wbr /><wbr /></p>
<p>查看Wayne Shea和Tenni Theurer的&quot;Performance Research, Part 5: iPhone Cacheability - Making it Stick&quot;获取更多信息。</p>
<p><wbr /><wbr /><strong>34 把组件打包进多部分文档中 Pack Components into a Multipart Document</strong></p>
<p>tag：mobile<wbr /><wbr /></p>
<p>把组件打包进多部分文档类似一封包含有附件的邮件，它能让你通过一个HTTP请求获取多个组件（记住HTTP请求是很昂贵的）。当你使用这一技术，请先检查客户端是否支持它(iPone不支持)。</p>

<p>注：关于网站前端和后台性能优化的34条宝贵经验和方法的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>
			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/mysql/biji/1044.html'>MySQL主从库不同步问题解决方法</a><a>下一篇</a><a href='/mysql/biji/1046.html'>MySQL 获得当前日期时间的函数小结</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>