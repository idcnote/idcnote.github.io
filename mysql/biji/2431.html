<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>10种Java开发者编写SQL语句时常见错误示例_mysql教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了10种Java开发者编写SQL语句时常见错误示例，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！
Java开发者对于" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
	    <a href="/mysql/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>数据库笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">10种Java开发者编写SQL语句时常见错误示例</h1>
					</div>
                    <div class="panel-title">
                        2022-11-12 09:37:11                    </div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了10种Java开发者编写SQL语句时常见错误示例，具有一定的参考价值，可以用来参考一下。

对此感兴趣的朋友，看看idc笔记做的技术笔记！
Java开发者对于</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了10种Java开发者编写SQL语句时常见错误示例，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>
<p>Java开发者对于面向对象编程思维与命令行编程思维的协调程度，取决于他们如下几种能力的水平：</p>
<p>技巧(任何人都可以编写命令行形式的代码)教条(有的人使用&ldquo;模式 - 模式&rdquo;的方式，即模式无处不在，并以名字作为标识)情绪状况(在初期，真正面向对象形式的代码比起命令式代码会更加难懂。)</p>
<p style="text-align: center">【图片暂缺】</p>
<p>但是，当Java开发人员编写SQL语句时，一切都变得不同了。SQL是一种说明式语言，与面向对象思想和命令式思想无关。在SQL语言中，查询非常容易表达。但它也不是那么容易以最佳或最正确地方式编写出来。开发人员不仅需要重新思考自己的编程模式，还需要从集合论的角度进行深入思考。</p>
<p>以下是Java开发人员使JDBC或jOOQ编写SQL语句时，<strong>几种常见的错误：</strong></p>
<p></p>
<h3><strong>1.忘记了NULL</strong></h3>
<p></p>
<p><strong>误解NULL的含义可能是Java开发人员编写SQL最常犯的错误。这有可能是因为NULL也被称为UNKNOWN，但也有其他的原因。当然如果它只被叫做UNKNOWN，会更容易理解一些。另一个原因是，JDBC在获取数据，或绑定变量时，SQL中的NULL被映射到Java中的null。这可能会导致人们认为类似Java中null==null的情况,SQL中也存在NULL= NULL。</strong></p>
<p><strong>一个更离奇的误解NULL的例子是，当NULL谓词用于行值表达式时。</strong></p>
<p><strong>另一个微妙的问题产生与对NOTIn 反连接中NULL含义的误解。</strong></p>
<p></p>
<h3><strong>解决办法</strong></h3>
<p></p>
<p><strong>不断的训练自己。要时刻明确NULL的含义，每次你写SQL时，都要考虑：</strong></p>
<p><strong>对于NULL来说谓词是否正确?NULL是否影响该函数的结果?<strong>2.在Java内存中处理数据</strong></strong></p>
<p><strong><strong>一些Java开发者十分了解SQL特性。偶尔JOIN，零散的UNION，没什么问题。但如果遇到视窗功能，结果集分组等情况又怎么样呢?很多Java开发人员会把SQL数据加载到内存，把数据转换成一些适合的集合类型，以十分冗长的循环结构在集合上执行恼人数学运算(至少在Java 8改进容器之前是这样的)。</strong></strong></p>
<p><strong><strong>但一些SQL数据库除了支持SQL标准外，还支持先进的OLAP特性，执行效率更好，且更容易编写。一个非标准的例子就是甲骨文的MODEL子句。只是让数据库进行数据处理过程，将最终获取的结果加载到Java内存中。因为一些非常聪明的人已经优化了这些昂贵的产品。所以，事实上，通过向OLAP数据库上进行迁移，您将得到两个好处：</strong></strong></p>
<p><strong><strong>简洁。它可能使得在SQL中编写正确代码会比在Java中相对容易性能。该数据库将可能比你的算法要快。更重要的是，你不必再通过网络传输数百万条记录。<strong>解决办法</strong></strong></strong></p>
<p><strong><strong><strong>每次你在Java中实现以数据为中心的算法时，要试着问问自己：有没有办法让数据库执行这些工作，而只把结果交付给我?</strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong>3.尽量使用UNION，而不是UNION ALL</strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong>相对于UNION，UNION ALL需要额外的关键字显得相形见绌。如果在SQL标准已定义如下支持，那将会好很多：</strong></strong></strong></p>
<p><strong><strong><strong>UNION(允许重复)UNION DISTINCT(去掉重复)一般很少需要去除重复(有时去重甚至是错误的)，而且对于具有很多列的大结果集，它往往很慢，因为这两个子查询需要排序，每个元组都需要与随后的元组进行比较。</strong></strong></strong></p>
<p><strong><strong><strong>需要注意的是，即使SQL标准指定了INTERSECTALL和EXCEPTALL，但几乎没有任何数据库实现这些用处不大的操作。</strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong>解决办法</strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong>你每次写到UNION时，要考虑下你是否实际上想写的是UNIONALL。</strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong>4.使用JDBC分页功能将大量结果分页</strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong>大多数数据库都支持通过LIMIT.. OFFSET，TOP .. START AT、OFFSET.. FETCH等子句以某种方式对结果进行分页。在没有对这些子句的支持下，但仍然有ROWNUM(Oracle)或ROW_NUMBER()OVER()(DB2，SQL Server 2008和更低版本)，这比在内存中分页要快得多。而且这对于大数据集更是明显。</strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong>解决办法</strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong>只要使用那些子句或工具(如jOOQ)，可以为你模拟上述分页子句。</strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong>5.将Java内存中实现连接</strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong>从SQL的发展的初期，一些开发商在面对SQL连接时仍然有一种不安的感觉。一直存在着一种固有的恐惧---JOIN速度缓慢。如果基于成本的优化器选择执行嵌套循环，创建一个连接表源之前，加载完整表到数据库内存，那速度确实十分缓慢。但很这少发生。通过适当的谓词，约束和索引，MERGEJOIN和 HASHJOIN操作是非常快的。这与正确的元数据相关(我不用再举Tom Kyte的例子了)。然而，也有仍然可能有不少Java开发人要会从单独的查询中加载两个表到map容器中，在java内存中以某种方式进行连接操作。</strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong>解决办法</strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong>如果你从多个步骤的多个表中进行了SELECT操作，那要慎重考虑一下是否可以在一条语句中表达你所需要的查询功能。<strong>6.使用DISTINCT或UNION从一个笛卡尔积中删除重复</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>冗长连接的存在，会导致SQL语句中起作用的关系显得十分松散。具体地，如果涉及到多列外键关系，很有可能忘记在JOINON子句上添加谓词。这可能会导致重复的记录，但也许只在特殊情况下。然后一些开发者可能会选择使用DISTINCT再次删除这些重复记录。这种错误有三种危害：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>可能治标不治本。甚至在某些边缘情况下，标都治不了这在有很多列的大结果集上会十分的缓慢。DISTINCT会执行ORDER BY操作来删除重复。这在大型笛卡尔积中也十分的缓慢，因为这样做仍然会导致在内存中加载大量数据。解决办法</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>作为一个经验法则，当你得到不想要的重复结果时，应该首先检查你的连接谓词。因为有可能是在某个地方存在着一个不易察觉的笛卡尔积。</strong></strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong><strong>7.不使用MERGE语句</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>严格意义上讲，这不是一个真正的错误，可能只是对于功能强大的MERGE语句缺乏足够的认知或存在着某种恐惧而已。有些数据库包括其他形式的UPSERT 语句，如MySQL的ONDUPLICATE KEY UPDATE子句。但MERGE真的十分强大，最重要的是在数据库中，它在很大程度上扩展了SQL标准，如SQL Server。</strong></strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong><strong>解决办法</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>如果你通过链接INSERT和UPDATE或链接SELECT... FOR UPDATE来实现UPSERTING，那么你要多想一想。抛开与运行条件的风险，你也许可以使用一个简单的MERGE语句来达到目的。</strong></strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong><strong>8.使用了聚合函数，而不是窗体功能</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>引入窗函数之前，使用GROUPBY子句与投影聚合函数是汇总数据的唯一方式。这在大部分情况下都十分有效，如果聚集后的数据需要由常规的数据进行补充，该分组的查询可以置于连接子查询中。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>但是，SQL：2003定义了窗口功能，目前很多主流的数据库厂商也纷纷实现了窗口功能。窗口功能可以聚集结果集中未被分组的数据。事实上，每个窗口的功能支持自身独立的PARTITIONBY子句，这对于报表类应用是一个非常有用的工具。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>使用窗口功能将：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>导致更多的可读性SQL(减少子查询中非专用GROUP BY子句的存在)提高性能，作为一个RDBMS很可能更容易优化其窗口功能。<strong>解决办法</strong></strong></strong></strong></strong></p>
<p><strong><strong><strong><strong><strong>当你在一个子查询写一个GROUPBY子句时，仔细想想这是否能用一个窗口函数来完成。</strong></strong></strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong><strong><strong>9.使用内存排序法进行间接排序</strong></strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong><strong>在SQLORDER BY子句支持多种类型的表达式，包括CASE语句，这对间接排序非常有用。你应该永远可能在Java内存中对数据进行排序，因为你认为：</strong></strong></strong></strong></strong></p>
<p><strong><strong><strong><strong><strong>SQL排序太慢SQL排序不能做到这一点<strong>解决办法</strong></strong></strong></strong></strong></strong></p>
<p><strong><strong><strong><strong><strong><strong>如果你在内存中对任何SQL数据进行排序，请仔细想想，你是否能把排序迁移至数据库中。这和将分页迁移至数据库中的原因一样。</strong></strong></strong></strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong><strong><strong><strong>10 一个接一个的插入大量的记录</strong></strong></strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong><strong><strong>JDBC包含了批处理，而且你应该使用它。面对成千上万的记录，切勿为每一条记录都创建一个新的PreparedStatement来进行插入操作。如果你要将所有记录都插入到同一个表，使用单一的SQL语句和多个绑定值集合建立一个批处理的INSERT语句。根据您的数据库和数据库配置，您可能需要在一定数量的插入的记录后进行提交，为了保持UNDO日志不过分庞大。</strong></strong></strong></strong></strong></strong></p>
<p></p>
<h3><strong><strong><strong><strong><strong><strong>解决办法</strong></strong></strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong><strong><strong>始终批量插入大型数据集。</strong></strong></strong></strong></strong></strong></p>
<p><strong><strong><strong><strong><strong><strong>Java开发者编写SQL语句时常见的10种错误，大家是不是有了大概了解，希望在编写的过程中一定要特别注意！</strong></strong></strong></strong></strong></strong></p>

<p>注：关于10种Java开发者编写SQL语句时常见错误示例的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>
			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/mysql/biji/2430.html'>升级SQL Server 2014的四个要点示例</a><a>下一篇</a><a href='/mysql/biji/2432.html'>SQL Server使用sp_password重置SA密码的解决办法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>