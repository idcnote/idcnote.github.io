<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>深入解析php中的foreach问题_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="前言：php4中引入了foreach结构，这是一种遍历数组的简单方式。相比传统的for循环，foreach能够更加便捷的获取键值对。在php5之前，foreach仅能用于数组；php5之后，利用foreach还能遍" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">深入解析php中的foreach问题</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>前言：php4中引入了foreach结构，这是一种遍历数组的简单方式。相比传统的for循环，foreach能够更加便捷的获取键值对。在php5之前，foreach仅能用于数组；php5之后，利用foreach还能遍</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><STRONG>前言：<BR></STRONG>php4中引入了foreach结构，这是一种遍历数组的简单方式。相比传统的for循环，foreach能够更加便捷的获取键值对。在php5之前，foreach仅能用于数组；php5之后，利用foreach还能遍历对象（详见：遍历对象）。本文中仅讨论遍历数组的情况。<br><br>foreach虽然简单，不过它可能会出现一些意外的行为，特别是代码涉及引用的情况下。<BR>下面列举了几种case，有助于我们进一步认清foreach的本质。<BR><STRONG>问题1：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="65369" class="copybut" id="copybut65369" onclick="doCopy('code65369')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code65369"><BR>$arr = array(1,2,3);<BR>foreach($arr as $k =&gt; &$v) {<BR>&nbsp;&nbsp;&nbsp; $v = $v * 2;<BR>}<BR>// now $arr is array(2, 4, 6)<BR>foreach($arr as $k =&gt; $v) {<BR>&nbsp;&nbsp;&nbsp; echo "$k", " =&gt; ", "$v";<BR>}<BR></div><BR>先从简单的开始，如果我们尝试运行上述代码，就会发现最后输出为0=&gt;2&nbsp; 1=&gt;4&nbsp; 2=&gt;4 。<BR>为何不是0=&gt;2&nbsp; 1=&gt;4&nbsp; 2=&gt;6 ？<BR>其实，我们可以认为 foreach($arr as $k =&gt; $v) 结构隐含了如下操作，分别将数组当前的'键'和当前的'值'赋给变量$k和$v。具体展开形如：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="57083" class="copybut" id="copybut57083" onclick="doCopy('code57083')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code57083"><BR>foreach($arr as $k =&gt; $v){ <BR>&nbsp;&nbsp;&nbsp; //在用户代码执行之前隐含了2个赋值操作<BR>&nbsp;&nbsp;&nbsp; $v = currentVal(); <BR>&nbsp;&nbsp;&nbsp; $k = currentKey();<BR>&nbsp;&nbsp;&nbsp; //继续运行用户代码<BR>&nbsp;&nbsp;&nbsp; ……<BR>}<BR></div><BR>根据上述理论，现在我们重新来分析下第一个foreach：<BR>第1遍循环，由于$v是一个引用，因此$v = &$arr[0]，$v=$v*2相当于$arr[0]*2，因此$arr变成2,2,3<BR>第2遍循环，$v = &$arr[1]，$arr变成2,4,3<BR>第3遍循环，$v = &$arr[2]，$arr变成2,4,6<BR><STRONG>随后代码进入了第二个foreach：<BR></STRONG>第1遍循环，隐含操作$v=$arr[0]被触发，由于此时$v仍然是$arr[2]的引用，即相当于$arr[2]=$arr[0]，$arr变成2,4,2<BR>第2遍循环，$v=$arr[1]，即$arr[2]=$arr[1]，$arr变成2,4,4<BR>第3遍循环，$v=$arr[2]，即$arr[2]=$arr[2]，$arr变成2,4,4<BR>OK，分析完毕。<BR><STRONG>如何解决类似问题呢？php手册上有一段提醒：<BR></STRONG><FONT style="COLOR: #ff0000">Warning : 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用unset()来将其销毁。<BR></FONT><div class="codetitle"><span><a style="CURSOR: pointer" data="35057" class="copybut" id="copybut35057" onclick="doCopy('code35057')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code35057"><BR>$arr = array(1,2,3);<BR>foreach($arr as $k =&gt; &$v) {<BR>&nbsp;&nbsp;&nbsp; $v = $v * 2;<BR>}<BR>unset($v);<BR>foreach($arr as $k =&gt; $v) {<BR>&nbsp;&nbsp;&nbsp; echo "$k", " =&gt; ", "$v";<BR>}<BR>// 输出 0=&gt;2&nbsp; 1=&gt;4&nbsp; 2=&gt;6<BR></div><BR>从这个问题中我们可以看出，引用很有可能会伴随副作用。如果不希望无意识的修改导致数组内容变更，最好及时unset掉这些引用。<BR><STRONG>问题2：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="74578" class="copybut" id="copybut74578" onclick="doCopy('code74578')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code74578"><BR>$arr = array('a','b','c');<BR>foreach($arr as $k =&gt; $v) {<BR>&nbsp;&nbsp;&nbsp; echo key($arr), "=&gt;", current($arr);<BR>}<BR>// 打印 1=&gt;b 1=&gt;b 1=&gt;b<BR></div><BR>这个问题更加诡异。按照手册的说法，key和current分别是取数组中当前元素的的键值。<BR>那为何key($arr)一直是1，current($arr)一直是b呢?<BR>先用vld查看编译之后的opcode:<br><br>我们从第3行的ASSIGN指令看起，它代表将array('a','b','c')赋值给$arr。<BR>由于$arr为CV，array('a','b','c')为TMP，因此ASSIGN指令找到实际执行的函数为ZEND_ASSIGN_SPEC_CV_TMP_HANDLER。这里需要特别指出，CV是PHP5.1之后才增加的一种变量cache，它采用数组的形式来保存zval**，被cache住的变量再次使用时无需去查找active符号表，而是直接去CV数组中获取，由于数组访问速度远超hash表，因而可以提高效率。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="56015" class="copybut" id="copybut56015" onclick="doCopy('code56015')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code56015"><BR>static int ZEND_FASTCALL&nbsp; ZEND_ASSIGN_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; zend_op *opline = EX(opline);<BR>&nbsp;&nbsp;&nbsp; zend_free_op free_op2;<BR>&nbsp;&nbsp;&nbsp; zval *value = _get_zval_ptr_tmp(&opline-&gt;op2, EX(Ts), &free_op2 TSRMLS_CC);<br><br>&nbsp;&nbsp;&nbsp; // CV数组中创建出$arr**指针<BR>&nbsp;&nbsp;&nbsp; zval **variable_ptr_ptr = _get_zval_ptr_ptr_cv(&opline-&gt;op1, EX(Ts), BP_VAR_W TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp; if (IS_CV == IS_VAR && !variable_ptr_ptr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将array赋值给$arr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = zend_assign_to_variable(variable_ptr_ptr, value, 1 TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!RETURN_VALUE_UNUSED(&opline-&gt;result)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AI_SET_PTR(EX_T(opline-&gt;result.u.var).var, value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PZVAL_LOCK(value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ZEND_VM_NEXT_OPCODE();<BR>}<BR></div><BR>ASSIGN指令完成之后，CV数组中被加入zval**指针，指针指向实际的array，这表示$arr已经被CV缓存了起来。<br><br>接下来执行数组的循环操作，我们来看FE_RESET指令，它对应的执行函数为<STRONG>ZEND_FE_RESET_SPEC_CV_HANDLER：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="38261" class="copybut" id="copybut38261" onclick="doCopy('code38261')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code38261"><BR>static int ZEND_FASTCALL&nbsp; ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; if (……) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 通过CV数组获取指向array的指针<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr = _get_zval_ptr_cv(&opline-&gt;op1, EX(Ts), BP_VAR_R TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; // 将指向array的指针保存到zend_execute_data-&gt;Ts中(Ts用于存放代码执行期的temp_variable)<BR>&nbsp;&nbsp;&nbsp; AI_SET_PTR(EX_T(opline-&gt;result.u.var).var, array_ptr);<BR>&nbsp;&nbsp;&nbsp; PZVAL_LOCK(array_ptr);<BR>&nbsp;&nbsp;&nbsp; if (iter) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; } else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 重置数组内部指针<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_internal_pointer_reset(fe_ht);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ce) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 设置EX_T(opline-&gt;result.u.var).fe.fe_pos用于保存数组内部指针<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_get_pointer(fe_ht, &EX_T(opline-&gt;result.u.var).fe.fe_pos);<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ……<BR>}<BR></div><BR>这里主要将2个重要的指针存入了zend_execute_data-&gt;Ts中:<BR><FONT style="COLOR: #ff0000">&#8226;EX_T(opline-&gt;result.u.var).var ---- 指向array的指针<BR>&#8226;EX_T(opline-&gt;result.u.var).fe.fe_pos ---- 指向array内部元素的指针<BR></FONT>FE_RESET指令执行完毕之后，内存中实际情况如下：<BR>
<P><br><br>接下来我们继续查看FE_FETCH，它对应的执行函数为ZEND_FE_FETCH_SPEC_VAR_HANDLER：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="64965" class="copybut" id="copybut64965" onclick="doCopy('code64965')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code64965"><BR>static int ZEND_FASTCALL&nbsp; ZEND_FE_FETCH_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; zend_op *opline = EX(opline);<br><br>&nbsp;&nbsp;&nbsp; // 注意指针是从EX_T(opline-&gt;op1.u.var).var.ptr获取的<BR>&nbsp;&nbsp;&nbsp; zval *array = EX_T(opline-&gt;op1.u.var).var.ptr;<BR>&nbsp;&nbsp;&nbsp; ……<br><br>&nbsp;&nbsp;&nbsp; switch (zend_iterator_unwrap(array, &iter TSRMLS_CC)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_INVALID:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_PLAIN_OBJECT: {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_PLAIN_ARRAY:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fe_ht = HASH_OF(array);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 特别注意：<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FE_RESET指令中将数组内部元素的指针保存在EX_T(opline-&gt;op1.u.var).fe.fe_pos<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 此处获取该指针<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_set_pointer(fe_ht, &EX_T(opline-&gt;op1.u.var).fe.fe_pos);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 获取元素的值<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (zend_hash_get_current_data(fe_ht, (void **) &value)==FAILURE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZEND_VM_JMP(EX(op_array)-&gt;opcodes+opline-&gt;op2.u.opline_num);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (use_key) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 1, NULL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 数组内部指针移动到下一个元素<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_move_forward(fe_ht);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 移动之后的指针保存到EX_T(opline-&gt;op1.u.var).fe.fe_pos<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zend_hash_get_pointer(fe_ht, &EX_T(opline-&gt;op1.u.var).fe.fe_pos);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ZEND_ITER_OBJECT:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; ……<BR>}<BR></div><BR>根据FE_FETCH的实现，我们大致上明白了foreach($arr as $k =&gt; $v)所做的事情。它会根据zend_execute_data-&gt;Ts的指针去获取数组元素，在获取成功之后，将该指针移动到下一个位置再重新保存。</P>
<P></P>
<P>简单来说，由于第一遍循环中FE_FETCH中已经将数组的内部指针移动到了第二个元素，所以在foreach内部调用key($arr)和current($arr)时，实际上获取的便是1和'b'。<BR><STRONG>那为何会输出3遍1=&gt;b呢？<BR></STRONG>我们继续看第9行和第13行的SEND_REF指令，它表示将$arr参数压栈。紧接着一般会使用DO_FCALL指令去调用key和current函数。PHP并非被编译成本地机器码，因此php采用这样的opcode指令去模拟实际CPU和内存的工作方式。<BR><STRONG>查阅PHP源码中的SEND_REF：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="84855" class="copybut" id="copybut84855" onclick="doCopy('code84855')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84855"><BR>static int ZEND_FASTCALL&nbsp; ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; // 从CV中获取$arr指针的指针<BR>&nbsp;&nbsp;&nbsp; varptr_ptr = _get_zval_ptr_ptr_cv(&opline-&gt;op1, EX(Ts), BP_VAR_W TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp; ……<br><br>&nbsp;&nbsp;&nbsp; // 变量分离，此处重新copy了一份array专门用于key函数<BR>&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);<BR>&nbsp;&nbsp;&nbsp; varptr = *varptr_ptr;<BR>&nbsp;&nbsp;&nbsp; Z_ADDREF_P(varptr);<br><br>&nbsp;&nbsp;&nbsp; // 压栈<BR>&nbsp;&nbsp;&nbsp; zend_vm_stack_push(varptr TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp; ZEND_VM_NEXT_OPCODE();<BR>}<BR></div><BR>上述代码中的SEPARATE_ZVAL_TO_MAKE_IS_REF是一个宏：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="51743" class="copybut" id="copybut51743" onclick="doCopy('code51743')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51743"><BR>#define SEPARATE_ZVAL_TO_MAKE_IS_REF(ppzv)&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; if (!PZVAL_IS_REF(*ppzv)) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL(ppzv);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_ISREF_PP((ppzv));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>SEPARATE_ZVAL_TO_MAKE_IS_REF的主要作用为，如果变量不是一个引用，则在内存中copy出一份新的。本例中它将array('a','b','c')复制了一份。因此变量分离之后的内存为：<BR>注意，变量分离完成之后，CV数组中的指针指向了新copy出来的数据，而通过zend_execute_data-&gt;Ts中的指针则依然可以获取旧的数据。<BR><STRONG>接下来的循环就不一一赘述了，结合上图来说：<BR></STRONG><FONT style="COLOR: #ff0000">&#8226;foreach结构使用的是下方蓝色的array，会依次遍历a，b，c<BR>&#8226;key、current使用的是上方黄色的array，它的内部指针永远指向b<BR></FONT>至此我们明白了为何key和current一直返回array的第二个元素，由于没有外部代码作用于copy出来的array，它的内部指针便永远不会移动。<BR><STRONG>问题3：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="51079" class="copybut" id="copybut51079" onclick="doCopy('code51079')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51079"><BR>$arr = array('a','b','c');<BR>foreach($arr as $k =&gt; &$v) {<BR>&nbsp;&nbsp;&nbsp; echo key($arr), '=&gt;', current($arr);<BR>}// 打印 1=&gt;b 2=&gt;c =&gt;<BR></div><BR><FONT style="COLOR: #ff0000">本题与问题2仅有一点区别：本题中的foreach使用了引用。</FONT>用VLD查看本题，发现与问题2代码编译出来的opcode一样。因此我们采用问题2的跟踪方法，逐步查看opcode对应的实现。<BR><STRONG>首先foreach会调用FE_RESET:<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="26512" class="copybut" id="copybut26512" onclick="doCopy('code26512')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code26512"><BR>static int ZEND_FASTCALL&nbsp; ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value & ZEND_FE_RESET_VARIABLE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 从CV中获取变量<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr_ptr = _get_zval_ptr_ptr_cv(&opline-&gt;op1, EX(Ts), BP_VAR_R TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 针对遍历array的情况<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value & ZEND_FE_FETCH_BYREF) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将保存array的zval设置为is_ref<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_ISREF_PP(array_ptr_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr = *array_ptr_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_ADDREF_P(array_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ……<BR>}<BR></div><BR><FONT style="COLOR: #ff0000">问题2中已经分析了一部分FE_RESET的实现。</FONT>这里需要特别注意，本例foreach获取值采用了引用，因此在执行的时候FE_RESET中会进入与上题不同的另一个分支。<BR>最终，FE_RESET会将array的is_ref设置为true，此时内存中只有一份array的数据。<BR><STRONG>接下来分析SEND_REF：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="213" class="copybut" id="copybut213" onclick="doCopy('code213')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code213"><BR>static int ZEND_FASTCALL&nbsp; ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; // 从CV中获取$arr指针的指针<BR>&nbsp;&nbsp;&nbsp; varptr_ptr = _get_zval_ptr_ptr_cv(&opline-&gt;op1, EX(Ts), BP_VAR_W TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp; ……<br><br>&nbsp;&nbsp;&nbsp; // 变量分离，由于此时CV中的变量本身就是一个引用，此处不会copy一份新的array<BR>&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);<BR>&nbsp;&nbsp;&nbsp; varptr = *varptr_ptr;<BR>&nbsp;&nbsp;&nbsp; Z_ADDREF_P(varptr);<br><br>&nbsp;&nbsp;&nbsp; // 压栈<BR>&nbsp;&nbsp;&nbsp; zend_vm_stack_push(varptr TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp; ZEND_VM_NEXT_OPCODE();<BR>}<BR></div><BR>宏SEPARATE_ZVAL_TO_MAKE_IS_REF仅仅分离is_ref=false的变量。由于之前array已经被设置了is_ref=true，因此它不会被拷贝一份副本。换句话说，此时内存中依然只有一份array数据。</P>
<P></P>
<P>上图解释了前2次循环为何会输出1=&gt;b 2=&gt;C。在第3次循环FE_FETCH的时候，将指针继续向前移动。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="52552" class="copybut" id="copybut52552" onclick="doCopy('code52552')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code52552"><BR>ZEND_API int zend_hash_move_forward_ex(HashTable *ht, HashPosition *pos)<BR>{<BR>&nbsp;&nbsp;&nbsp; HashPosition *current = pos ? pos : &ht-&gt;pInternalPointer;<BR>&nbsp;&nbsp;&nbsp; IS_CONSISTENT(ht);<BR>&nbsp;&nbsp;&nbsp; if (*current) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *current = (*current)-&gt;pListNext;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SUCCESS;<BR>&nbsp;&nbsp;&nbsp; } else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FAILURE;<BR>}<BR></div><BR>由于此时内部指针已经指向了数组的最后一个元素，因此再向前移动会指向NULL。将内部指针指向NULL之后，我们再对数组调用key和current，则分别会返回NULL和false，表示调用失败，此时是echo不出字符的。<BR><STRONG>&nbsp;问题4：<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="95536" class="copybut" id="copybut95536" onclick="doCopy('code95536')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code95536"><BR>$arr = array(1, 2, 3);<BR>$tmp = $arr;<BR>foreach($tmp as $k =&gt; &$v){<BR>&nbsp;&nbsp;&nbsp; $v *= 2;<BR>}<BR>var_dump($arr, $tmp); // 打印什么？<BR></div><BR>该题与foreach关系不大，不过既然涉及到了foreach，就一起拿来讨论吧:)<BR>代码里首先创建了数组$arr，随后将该数组赋给了$tmp，在接下来的foreach循环中，对$v进行修改会作用于数组$tmp上，但是却并不作用到$arr。<BR><STRONG>为什么呢?<BR></STRONG>这是由于在php中，赋值运算是将一个变量的值拷贝到另一个变量中，因此修改其中一个，并不会影响到另一个。<BR>题外话：这并不适用于object类型，从PHP5起，对象的便总是默认通过引用进行赋值，举例来说：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="19699" class="copybut" id="copybut19699" onclick="doCopy('code19699')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code19699"><BR>class A{<BR>&nbsp;&nbsp;&nbsp; public $foo = 1;<BR>}<BR>$a1 = $a2 = new A;<BR>$a1-&gt;foo=100;<BR>echo $a2-&gt;foo; // 输出100，$a1与$a2其实为同一个对象的引用<BR></div><BR>回到题目中的代码，现在我们可以确定$tmp=$arr其实是值拷贝，整个$arr数组会被再复制一份给$tmp。理论上讲，赋值语句执行完毕之后，内存中会有2份一样的数组。<BR>也许有同学会疑问，如果数组很大，岂不是这种操作会很慢？<BR>幸好php有更聪明的处理办法。实际上，当$tmp=$arr执行之后，内存中依然只有一份array。查看php源码中的zend_assign_to_variable实现（摘自php5.3.26）：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="47211" class="copybut" id="copybut47211" onclick="doCopy('code47211')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code47211"><BR>static inline zval* zend_assign_to_variable(zval **variable_ptr_ptr, zval *value, int is_tmp_var TSRMLS_DC)<BR>{<BR>&nbsp;&nbsp;&nbsp; zval *variable_ptr = *variable_ptr_ptr;<BR>&nbsp;&nbsp;&nbsp; zval garbage;<BR>&nbsp;&nbsp;&nbsp; ……<BR>　　// 左值为object类型<BR>&nbsp;&nbsp;&nbsp; if (Z_TYPE_P(variable_ptr) == IS_OBJECT && Z_OBJ_HANDLER_P(variable_ptr, set)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; // 左值为引用的情况<BR>&nbsp;&nbsp;&nbsp; if (PZVAL_IS_REF(variable_ptr)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 左值refcount__gc=1的情况<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Z_DELREF_P(variable_ptr)==0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GC_ZVAL_CHECK_POSSIBLE_ROOT(*variable_ptr_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 非临时变量<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!is_tmp_var) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (PZVAL_IS_REF(value) && Z_REFCOUNT_P(value) &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALLOC_ZVAL(variable_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *variable_ptr_ptr = variable_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *variable_ptr = *value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_REFCOUNT_P(variable_ptr, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zval_copy_ctor(variable_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // $tmp=$arr会运行到这里，<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // value为指向$arr里实际array数据的指针，variable_ptr_ptr为$tmp里指向数据指针的指针<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 仅仅是复制指针，并没有真正拷贝实际的数组<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *variable_ptr_ptr = value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // value的refcount__gc值+1，本例中refcount__gc为1，Z_ADDREF_P之后为2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_ADDREF_P(value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_UNSET_ISREF_PP(variable_ptr_ptr);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; return *variable_ptr_ptr;<BR>}<BR></div><BR>可见$tmp = $arr的本质就是将array的指针进行复制，然后将array的refcount自动加1.用图表达出此时的内存，依然只有一份array数组：<BR><BR>既然只有一份array，那foreach循环中修改$tmp的时候，为何$arr没有跟着改变？<BR>继续看PHP源码中的ZEND_FE_RESET_SPEC_CV_HANDLER函数，这是一个OPCODE HANDLER，它对应的OPCODE为FE_RESET。该函数负责在foreach开始之前，将数组的内部指针指向其第一个元素。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="11558" class="copybut" id="copybut11558" onclick="doCopy('code11558')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code11558"><BR>static int ZEND_FASTCALL&nbsp; ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<BR>{<BR>&nbsp;&nbsp;&nbsp; zend_op *opline = EX(opline);<BR>&nbsp;&nbsp;&nbsp; zval *array_ptr, **array_ptr_ptr;<BR>&nbsp;&nbsp;&nbsp; HashTable *fe_ht;<BR>&nbsp;&nbsp;&nbsp; zend_object_iterator *iter = NULL;<BR>&nbsp;&nbsp;&nbsp; zend_class_entry *ce = NULL;<BR>&nbsp;&nbsp;&nbsp; zend_bool is_empty = 0;<BR>&nbsp;&nbsp;&nbsp; // 对变量进行FE_RESET<BR>&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value & ZEND_FE_RESET_VARIABLE) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr_ptr = _get_zval_ptr_ptr_cv(&opline-&gt;op1, EX(Ts), BP_VAR_R TSRMLS_CC);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (array_ptr_ptr == NULL || array_ptr_ptr == &EG(uninitialized_zval_ptr)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // foreach一个object<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (Z_TYPE_PP(array_ptr_ptr) == IS_OBJECT) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 本例会进入该分支<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Z_TYPE_PP(array_ptr_ptr) == IS_ARRAY) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注意此处的SEPARATE_ZVAL_IF_NOT_REF<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 它会重新复制一个数组出来<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 真正分离$tmp和$arr，变成了内存中的2个数组<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SEPARATE_ZVAL_IF_NOT_REF(array_ptr_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (opline-&gt;extended_value & ZEND_FE_FETCH_BYREF) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_SET_ISREF_PP(array_ptr_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array_ptr = *array_ptr_ptr;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z_ADDREF_P(array_ptr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……<BR>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // 重置数组内部指针<BR>&nbsp;&nbsp;&nbsp; ……<BR>}<BR></div><BR>从代码中可以看出，真正执行变量分离并不是在赋值语句执行的时候，而是推迟到了使用变量的时候，这也是Copy On Write机制在PHP中的实现。<BR>FE_RESET之后，内存的变化如下：<BR><br><br>上图解释了为何foreach并不会对原来的$arr产生影响。至于ref_count以及is_ref的变化情况，感兴趣的同学可以详细阅读ZEND_FE_RESET_SPEC_CV_HANDLER和ZEND_SWITCH_FREE_SPEC_VAR_HANDLER的具体实现（均位于php-src/zend/zend_vm_execute.h中），本文不做详细剖析:)<BR></P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/83456.html'>浅析jQuery(function(){})与(function(){})(jQuery)之间的区别</a><a>下一篇</a><a href='/php/biji/83458.html'>PHP中创建图像并绘制文字的例子</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>