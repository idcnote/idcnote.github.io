<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>JavaScript中原型和原型链详解_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="javascript中的每个对象都有一个内置的属性prototype，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。意思是是prototype属性保存着对另一个JavaScript对" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">JavaScript中原型和原型链详解</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>javascript中的每个对象都有一个内置的属性prototype，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。意思是是prototype属性保存着对另一个JavaScript对</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>javascript中的每个对象都有一个内置的属性prototype，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。意思是是prototype属性保存着对另一个JavaScript对象的引用，这个对象作为当前对象的父对象。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="78405" class="copybut" id="copybut78405" onclick="doCopy('code78405')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code78405"><br />
A.prototype = new B();<br />
</div><br />
理解prototype不应把它和继承混淆。A的prototype为B的一个实例，可以理解A将B中的方法和属性全部克隆了一遍。A能使用B的方法和属性。这里强调的是克隆而不是继承。可以出现这种情况：A的prototype是B的实例，同时B的prototype也是A的实例。</p>
<p>继续看下面的分析：</p>
<p><strong>私有变量和函数</strong></p>
<p>在函数内部定义的变量和函数，如果不对外提供接口，外部是无法访问到的，也就是该函数的私有的变量和函数。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="70119" class="copybut" id="copybut70119" onclick="doCopy('code70119')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code70119"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Box(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var color = "blue";//私有变量<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var fn = function() //私有函数<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&lt;/script&gt;<br />
</div><br />
这样在函数对象Box外部无法访问变量color和fn，他们就变成私有的了：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="48093" class="copybut" id="copybut48093" onclick="doCopy('code48093')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code48093"><br />
var obj = new Box();<br />
&nbsp;&nbsp;&nbsp; alert(obj.color);//弹出 undefined<br />
&nbsp;&nbsp;&nbsp; alert(obj.fn);//同上<br />
</div></p>
<p><strong>静态变量和函数</strong></p>
<p>当定义一个函数后通过点号 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="87614" class="copybut" id="copybut87614" onclick="doCopy('code87614')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code87614"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Obj(){};</p>
<p>&nbsp;&nbsp;&nbsp; Obj.num = 72;//静态变量<br />
&nbsp;&nbsp;&nbsp; Obj.fn = function()&nbsp; //静态函数<br />
&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp; }&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; alert(Obj.num);//72<br />
&nbsp;&nbsp;&nbsp; alert(typeof Obj.fn)//function</p>
<p>&nbsp;&nbsp;&nbsp; var t = new Obj();<br />
&nbsp;&nbsp;&nbsp; alert(t.name);//undefined<br />
&nbsp;&nbsp;&nbsp; alert(typeof t.fn);//undefined<br />
&lt;/script&gt;<br />
</div></p>
<p><strong>实例变量和函数</strong></p>
<p>在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，js也能做到这样<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="69051" class="copybut" id="copybut69051" onclick="doCopy('code69051')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code69051"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function Box(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.a=[]; //实例变量<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.fn=function(){ //实例方法</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(typeof Box.a); //undefined<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(typeof Box.fn); //undefined</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var box=new Box();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(typeof box.a); //object<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(typeof box.fn); //function<br />
&lt;/script&gt;<br />
</div></p>
<p>为实例变量和方法添加新的方法和属性<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="51297" class="copybut" id="copybut51297" onclick="doCopy('code51297')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51297"><br />
&lt;script type="text/javascript"&gt;<br />
function Box(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.a=[]; //实例变量<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.fn=function(){ //实例方法</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var box1=new Box();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; box1.a.push(1);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; box1.fn={};<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(box1.a); //[1]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(typeof box1.fn); //object</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var box2=new Box();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(box2.a); //[]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(typeof box2.fn); //function<br />
&lt;/script&gt;<br />
</div></p>
<p>在box1中修改了a和fn，而在box2中没有改变，由于数组和函数都是对象，是引用类型，这就说明box1中的属性和方法与box2中的属性与方法虽然同名但却不是一个引用，而是对Box对象定义的属性和方法的一个复制。</p>
<p>这个对属性来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然是不科学的，这可肿么办呢，prototype应运而生。</p>
<p><strong>基本概念</strong></p>
<p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。那么，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。</p>
<p>使用原型的好处是可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p>
<p>在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链。</p>
<p><strong>含义</strong></p>
<p>函数可以用来作为构造函数来使用。另外只有函数才有prototype属性并且可以访问到，但是对象实例不具有该属性，只有一个内部的不可访问的__proto__属性。__proto__是对象中一个指向相关原型的神秘链接。按照标准，__proto__是不对外公开的，也就是说是个私有属性，但是Firefox的引擎将他暴露了出来成为了一个共有的属性，我们可以对外访问和设置。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="78000" class="copybut" id="copybut78000" onclick="doCopy('code78000')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code78000"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; var Browser = function(){};<br />
&nbsp;&nbsp;&nbsp; Browser.prototype.run = function(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("I'm Gecko,a kernel of firefox&#65532;");<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; var Bro = new Browser();<br />
&nbsp;&nbsp;&nbsp; Bro.run();<br />
&lt;/script&gt;<br />
</div></p>
<p>当我们调用Bro.run()方法时，由于Bro中没有这个方法，所以，他就会去他的__proto__中去找，也就是Browser.prototype，所以最终执行了该run()方法。（在这里，函数首字母大写的都代表构造函数，以用来区分普通函数）</p>
<p>当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（__proto__）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="97890" class="copybut" id="copybut97890" onclick="doCopy('code97890')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code97890"><br />
&lt;script type="text/javascript"&gt;<br />
function Person(name){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造函数<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name=name;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Person.prototype.printName=function() //原型对象<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.name);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var person1=new Person('Byron');//实例化对象<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(person1.__proto__);//Person<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(person1.constructor);//自己试试看会是什么吧<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log(Person.prototype);//指向原型对象Person<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var person2=new Person('Frank');<br />
&lt;/script&gt;<br />
</div><br />
Person的实例person1中包含了name属性，同时自动生成一个__proto__属性，该属性指向Person的prototype，可以访问到prototype内定义的printName方法，大概就是这个样子的:</p>
<p></p>
<p>每个JavaScript函数都有prototype属性，这个属性引用了一个对象，这个对象就是原型对象。原型对象初始化的时候是空的，我们可以在里面自定义任何属性和方法，这些方法和属性都将被该构造函数所创建的对象继承。</p>
<p>那么，现在问题来了。构造函数、实例和原型对象三者之间有什么关系呢？</p>
<p><strong>构造函数、实例和原型对象的区别</strong></p>
<p>实例就是通过构造函数创建的。实例一创造出来就具有constructor属性（指向构造函数）和__proto__属性（指向原型对象），</p>
<p>构造函数中有一个prototype属性，这个属性是一个指针，指向它的原型对象。</p>
<p>原型对象内部也有一个指针（constructor属性）指向构造函数:Person.prototype.constructor = Person;</p>
<p>实例可以访问原型对象上定义的属性和方法。</p>
<p>在这里person1和person2就是实例，prototype是他们的原型对象。</p>
<p>再举个栗子：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="64778" class="copybut" id="copybut64778" onclick="doCopy('code64778')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code64778"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Animal(name)&nbsp;&nbsp; //积累构造函数<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = name;//设置对象属性<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; Animal.prototype.behavior = function() //给基类构造函数的prototype添加behavior方法<br />
&nbsp;&nbsp;&nbsp; {&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("this is a "+this.name);<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; var Dog = new Animal("dog");//创建Dog对象<br />
&nbsp;&nbsp;&nbsp; var Cat = new Animal("cat");//创建Cat对象</p>
<p>&nbsp;&nbsp;&nbsp; Dog.behavior();//通过Dog对象直接调用behavior方法<br />
&nbsp;&nbsp;&nbsp; Cat.behavior();//output "this is a cat"</p>
<p>&nbsp;&nbsp;&nbsp; alert(Dog.behavior==Cat.behavior);//output true;<br />
&lt;/script&gt;<br />
</div></p>
<p>可以从程序运行结果看出，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。（可以试一下将Animal.prototype.behavior 中的prototype属性去掉，看看还能不能运行。）在这里，prototype属性指向Animal对象。</p>
<p><strong>数组对象实例</strong></p>
<p>再看个数组对象的实例。当我们创建出array1这个对象的时候，array1实际在Javascript引擎中的对象模型如下：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="64115" class="copybut" id="copybut64115" onclick="doCopy('code64115')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code64115"><br />
var array1 = [1,2,3];<br />
</div></p>
<p></p>
<p>array1对象具有一个length属性值为3，但是我们可以通过如下的方法来为array1增加元素：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="39548" class="copybut" id="copybut39548" onclick="doCopy('code39548')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code39548"><br />
array1.push(4); <br />
</div><br />
push这个方法来自于array1的__proto__成员指向对象的一个方法(Array.prototye.push())。正是因为所有的数组对象（通过[]来创建的）都包含有一个指向同一个具有push,reverse等方法对象(Array.prototype)的__proto__成员，才使得这些数组对象可以使用push,reverse等方法。</p>
<p><strong>函数对象实例<br />
</strong><div class="codetitle"><span><a style="CURSOR: pointer" data="13249" class="copybut" id="copybut13249" onclick="doCopy('code13249')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code13249"><br />
function Base() {&nbsp; <br />
&nbsp;&nbsp;&nbsp; this.id = "base" <br />
}&nbsp;&nbsp; <br />
</div></p>
<p></p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="65587" class="copybut" id="copybut65587" onclick="doCopy('code65587')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code65587"><br />
var obj = new Base(); <br />
</div><br />
这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是：</p>
<p></p>
<p>new操作符具体干了什么呢&#63;其实很简单，就干了三件事情。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="8572" class="copybut" id="copybut8572" onclick="doCopy('code8572')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code8572"><br />
var obj&nbsp; = {};&nbsp; <br />
obj.__proto__ = Base.prototype;&nbsp; <br />
Base.call(obj); <br />
</div></p>
<p><strong>原型链</strong></p>
<p>原型链：当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找，如果prototype没有，就会去prototype关联的前辈prototype那里寻找，如果再没有则继续查找Prototype.Prototype引用的对象，依次类推，直到Prototype.….Prototype为undefined（Object的Prototype就是undefined）从而形成了所谓的“原型链”。</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="32734" class="copybut" id="copybut32734" onclick="doCopy('code32734')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code32734"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Shape(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "shape";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.toString = function(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.name;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function TwoShape(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "2 shape";<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function Triangle(side,height){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "Triangle";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.side = side;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.height = height;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getArea = function(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.side*this.height/2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; TwoShape.prototype = new Shape();<br />
&nbsp;&nbsp;&nbsp; Triangle.prototype = new TwoShape();<br />
&lt;/script&gt;<br />
</div></p>
<p>这里，用构造器Shape()新建了一个实体，然后用它去覆盖该对象的原型。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="60247" class="copybut" id="copybut60247" onclick="doCopy('code60247')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60247"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Shape(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "shape";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.toString = function(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.name;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function TwoShape(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "2 shape";<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; function Triangle(side,height){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "Triangle";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.side = side;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.height = height;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.getArea = function(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.side*this.height/2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; TwoShape.prototype = new Shape();<br />
&nbsp;&nbsp;&nbsp; Triangle.prototype = new TwoShape();</p>
<p>&nbsp;&nbsp;&nbsp; TwoShape.prototype.constructor = TwoShape;<br />
&nbsp;&nbsp;&nbsp; Triangle.prototype.constructor = Triangle;</p>
<p>&nbsp;&nbsp;&nbsp; var my = new Triangle(5,10);<br />
&nbsp;&nbsp;&nbsp; my.getArea();<br />
&nbsp;&nbsp;&nbsp; my.toString();//Triangle<br />
&nbsp;&nbsp;&nbsp; my.constructor;//Triangle(side,height)<br />
&lt;/script&gt;<br />
</div></p>
<p><strong>原型继承</strong></p>
<p>原型继承：在原型链的末端，就是Object构造函数prototype属性指向的那个原型对象。这个原型对象是所有对象的祖先，这个老祖宗实现了诸如toString等所有对象天生就该具有的方法。其他内置构造函数，如Function，Boolean，String，Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些特征。</p>
<p>ECMAScript中，实现继承的方法就是依靠原型链实现的。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="24594" class="copybut" id="copybut24594" onclick="doCopy('code24594')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code24594"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Box(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //被继承的函数叫做超类型（父类，基类）<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "Jack";<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; function Tree(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //继承的函数叫做子类型（子类，派生类）<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.age = 300;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; //通过原型链继承，赋值给子类型的原型属性<br />
&nbsp;&nbsp;&nbsp; //new Box()会将box构造里的信息和原型里的信息都交给Tree<br />
&nbsp;&nbsp;&nbsp; Tree.prototype = new Box();//Tree继承了Box,通过原型，形成链条</p>
<p>&nbsp;&nbsp;&nbsp; var tree = new Tree();<br />
&nbsp;&nbsp;&nbsp; alert(tree.name);//弹出 Jack<br />
&lt;/script&gt;<br />
</div></p>
<p>原型链的问题：原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中最主要的问题来自包含引用类型的值原型。包含引用类型的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上回变成另一个类型的实例。于是，原先的实例属性也就变成了原型的属性。</p>
<p>在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。再加上刚刚讨论的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。</p>
<p>再举个栗子：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="58110" class="copybut" id="copybut58110" onclick="doCopy('code58110')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code58110"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Person(name)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = name;//设置对象属性<br />
&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp; Person.prototype.company = "Microsoft";//设置原型的属性<br />
&nbsp;&nbsp;&nbsp; Person.prototype.SayHello = function() //原型的方法<br />
&nbsp;&nbsp;&nbsp; {&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("Hello,I'm "+ this.name+ " of " + this.company);<br />
&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp; var BillGates = new Person("BillGates");//创建person对象<br />
&nbsp;&nbsp;&nbsp; BillGates.SayHello();//继承了原型的内容，输出"Hello,I'm BillGates of Microsoft"</p>
<p>&nbsp;&nbsp;&nbsp; var Jobs = new Person("Jobs");<br />
&nbsp;&nbsp;&nbsp; Jobs.company = "Apple";//设置自己的company属性，掩盖了原型的company属性<br />
&nbsp;&nbsp;&nbsp; Jobs.SayHello = function()<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("Hi,"+this.name + " like " + this.company);<br />
&nbsp;&nbsp;&nbsp; };<br />
&nbsp;&nbsp;&nbsp; Jobs.SayHello();//自己覆盖的属性和方法，输出"Hi,Jobs like Apple"<br />
&nbsp;&nbsp;&nbsp; BillGates.SayHello();//Jobs的覆盖没有影响原型，BillGates还是照样输出<br />
&lt;/script&gt;<br />
</div></p>
<p>看下面一个原型链例子：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="31003" class="copybut" id="copybut31003" onclick="doCopy('code31003')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code31003"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Year(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.value = 21;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; Year.prototype = {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; method:function(){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp; function Hi(){</p>
<p>&nbsp;&nbsp;&nbsp; };<br />
&nbsp;&nbsp;&nbsp; //设置Hi的prototype属性为Year的实例对象<br />
&nbsp;&nbsp;&nbsp; Hi.prototype = new Year();<br />
&nbsp;&nbsp;&nbsp; Hi.prototype.year = 'Hello World';</p>
<p>&nbsp;&nbsp;&nbsp; Hi.prototype.constructor = Hi;</p>
<p>&nbsp;&nbsp;&nbsp; var test = new Hi();//创建一个Hi的新实例</p>
<p>&nbsp;&nbsp;&nbsp; //原型链<br />
&nbsp;&nbsp;&nbsp; test [Hi的实例]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hi.prototype [Year的实例]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {year:'Hello World'}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Year.prototype<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {method:……};<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object.prototype<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {toString:...};</p>
<p>&lt;/script&gt;<br />
</div></p>
<p>从上面例子中，test对象从Hi.prototype和Year.prototype中继承下来；因此他能访问Year的原型方法method，同时他能访问实例属性value</p>
<p><strong>__ptoto__属性</strong></p>
<p>__ptoto__属性（IE浏览器不支持）是实例指向原型对象的一个指针，它的作用就是指向构造函数的原型属性constructor，通过这两个属性，就可以访问原型里的属性和方法了。</p>
<p>Javascript中的对象实例本质上是由一系列的属性组成的，在这些属性中，有一个内部的不可见的特殊属性——__proto__，该属性的值指向该对象实例的原型，一个对象实例只拥有一个唯一的原型。</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="38884" class="copybut" id="copybut38884" onclick="doCopy('code38884')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code38884"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Box(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //大写，代表构造函数<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box.prototype.name = "trigkit4";//原型属性<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box.prototype.age = "21";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box.prototype.run = function()//原型方法<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.name + this.age + 'studying';<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; var box1 = new Box();<br />
&nbsp;&nbsp;&nbsp; var box2 = new Box();<br />
&nbsp;&nbsp;&nbsp; alert(box1.constructor);//构造属性，可以获取构造函数本身，<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //作用是被原型指针定位，然后得到构造函数本身<br />
&lt;/script&gt;&nbsp;&nbsp; <br />
</div></p>
<p><strong>__proto__属性和prototype属性的区别</strong></p>
<p>prototype是function对象中专有的属性。<br />
__proto__是普通对象的隐式属性，在new的时候，会指向prototype所指的对象；<br />
__ptoto__实际上是某个实体对象的属性，而prototype则是属于构造函数的属性。__ptoto__只能在学习或调试的环境下使用。</p>
<p><strong>原型模式的执行流程</strong></p>
<p>1.先查找构造函数实例里的属性或方法，如果有，就立即返回。<br />
2.如果构造函数的实例没有，就去它的原型对象里找，如果有，就立即返回</p>
<p><strong>原型对象的<br />
</strong><div class="codetitle"><span><a style="CURSOR: pointer" data="88682" class="copybut" id="copybut88682" onclick="doCopy('code88682')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code88682"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Box(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //大写，代表构造函数<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box.prototype.name = "trigkit4";//原型属性<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box.prototype.age = "21";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Box.prototype.run = function()//原型方法<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.name + this.age + 'studying';<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; var box1 = new Box();<br />
&nbsp;&nbsp;&nbsp; alert(box1.name);//trigkit4,原型里的值<br />
&nbsp;&nbsp;&nbsp; box1.name = "Lee";<br />
&nbsp;&nbsp;&nbsp; alert(box1.name);//Lee,就进原则</p>
<p>&nbsp;&nbsp;&nbsp; var box2 = new Box();<br />
&nbsp;&nbsp;&nbsp; alert(box2.name);//trigkit4,原型的值，没有被box1修改<br />
&lt;/script&gt;<br />
</div></p>
<p><strong>构造函数的<br />
</strong><div class="codetitle"><span><a style="CURSOR: pointer" data="65846" class="copybut" id="copybut65846" onclick="doCopy('code65846')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code65846"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Box(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = "Bill";<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; Box.prototype.name = "trigkit4";//原型属性<br />
&nbsp;&nbsp;&nbsp; Box.prototype.age = "21";<br />
&nbsp;&nbsp;&nbsp; Box.prototype.run = function()//原型方法<br />
&nbsp;&nbsp;&nbsp; {&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.name + this.age + 'studying';<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; var box1 = new Box();<br />
&nbsp;&nbsp;&nbsp; alert(box1.name);//Bill,原型里的值<br />
&nbsp;&nbsp;&nbsp; box1.name = "Lee";<br />
&nbsp;&nbsp;&nbsp; alert(box1.name);//Lee,就进原则<br />
&lt;/script&gt;<br />
</div></p>
<p>综上，整理一下：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="60910" class="copybut" id="copybut60910" onclick="doCopy('code60910')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60910"><br />
&lt;script type="text/javascript"&gt;<br />
&nbsp;&nbsp;&nbsp; function Person(){};</p>
<p>&nbsp;&nbsp;&nbsp; Person.prototype.name = "trigkit4";<br />
&nbsp;&nbsp;&nbsp; Person.prototype.say = function(){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("&#65532;Hi");<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; var p1 = new Person();//prototype是p1和p2的原型对象<br />
&nbsp;&nbsp;&nbsp; var p2 = new Person();//p2为实例化对象，其内部有一个__proto__属性，指向Person的prototype</p>
<p>&nbsp;&nbsp;&nbsp; console.log(p1.prototype);//undefined,这个属性是一个对象，访问不到<br />
&nbsp;&nbsp;&nbsp; console.log(Person.prototype);//Person<br />
&nbsp;&nbsp;&nbsp; console.log(Person.prototype.constructor);//原型对象内部也有一个指针（constructor属性）指向构造函数<br />
&nbsp;&nbsp;&nbsp; console.log(p1.__proto__);//这个属性是一个指针指向prototype原型对象<br />
&nbsp;&nbsp;&nbsp; p1.say();//实例可以访问到在原型对象上定义的属性和方法</p>
<p>&lt;/script&gt;<br />
</div></p>
<p><strong>工厂模式<br />
</strong><div class="codetitle"><span><a style="CURSOR: pointer" data="49161" class="copybut" id="copybut49161" onclick="doCopy('code49161')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49161"><br />
&nbsp;function createObject(name,age){<br />
&nbsp;&nbsp;&nbsp; var obj = new Object();<br />
&nbsp;&nbsp;&nbsp; obj.name = name;<br />
&nbsp;&nbsp;&nbsp; obj.age = age;<br />
&nbsp;&nbsp;&nbsp; return obj;<br />
}<br />
</div></p>
<p>工厂模式解决了实例化对象大量重复的问题，但还有一个问题，那就是根本无法搞清楚他们到底是哪个对象的实例。<br />
使用构造函数的方法，既解决了重复实例化的问题，又解决了对象识别的问题。</p>
<p>使用构造函数的方法和工厂模式的不同之处在于：</p>
<p>1.构造函数方法没有显示的创建对象(new Object());<br />
2.直接将属性和方法赋值给this对象<br />
3.没有return 语句</p>
<p>当使用了构造函数，并且new 构造函数()，那么就在后台执行了new Object()；<br />
函数体内的this代表了new Object()出来的对象</p>
<p>1.判断属性是在构造函数的实例里，还是在原型里，可以使用`hasOwnProperty()`函数<br />
2.字面量创建的方式使用constructor属性不会指向实例，而会指向Object，构造函数创建的方式则相反<br />
为什么指向Object？因为Box.prototype = {};这种写法其实就是创建了一个新对象。<br />
而每创建一个函数，就会同时创建它的prototype，这个对象也会自动获取constructor属性<br />
3.如果是实例方法，不同的实例化，他们的方法地址是不一样的，是唯一的<br />
4.如果是原型方法，那么他们的地址的共享的</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/98327.html'>Java编程中使用XFire框架调用WebService程序接口</a><a>下一篇</a><a href='/php/biji/98329.html'>简介JavaScript中的getUTCFullYear()方法的使用</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>