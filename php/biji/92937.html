<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>JavaScript中对循环语句的优化技巧深入探讨_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="循环是所有编程语言中最为重要的机制之一，几乎任何拥有实际意义的计算机程序（排序、查询等）都里不开循环。 而循环也正是程序优化中非常让人头疼的一环，我们往往需要不断去优化" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">JavaScript中对循环语句的优化技巧深入探讨</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>循环是所有编程语言中最为重要的机制之一，几乎任何拥有实际意义的计算机程序（排序、查询等）都里不开循环。 而循环也正是程序优化中非常让人头疼的一环，我们往往需要不断去优化</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P>循环是所有编程语言中最为重要的机制之一，几乎任何拥有实际意义的计算机程序（排序、查询等）都里不开循环。 而循环也正是程序优化中非常让人头疼的一环，我们往往需要不断去优化程序的复杂度，却因循环而纠结在时间复杂度和空间复杂度之间的抉择。 <br><br>在 javascript 中，有3种原生循环，for () {}, while () {}和do {} while ()，其中最为常用的要数for () {}。 <br><br>然而for正是 javascript 工程师们在优化程序时最容易忽略的一种循环。</P>
<P>我们先来回顾一下for的基本知识。 <BR>javascript 的for语法继承自c语言，for循环的基本语法有两种使用方法。</P>
<P><STRONG>1. 循环数组</STRONG></P>
<P><STRONG>for循环的基本语法</STRONG></P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="182" class="copybut" id="copybut182" onclick="doCopy('code182')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code182"><BR>for ( /* 初始化 */2 /* 判断条件 */2 /* 循环处理 */ ) {<BR>&nbsp; //... 逻辑代码<BR>}<BR></div></P>
<P>我们以一段实例代码来进行详细说明。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="91896" class="copybut" id="copybut91896" onclick="doCopy('code91896')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code91896"><BR>var array = [1, 2, 3, 4, 5];<BR>var sum&nbsp;&nbsp; = 0;</P>
<P>for (var i = 0, len = array.length; i &lt; len; ++i) {<BR>&nbsp; sum += array[i];<BR>}</P>
<P>console.log('The sum of the array\'s items is %d.', sum);<BR>//=&gt; The sum of the array's items is 15.<BR></div></P>
<P>在这段代码中，我们首先定义并初始化了一个用存储待累加项的数组和一个总和整形变量。 接下来，我们开始进行循环。在该for循环的初始化代码中，我们也定义并初始化了两个变量： i(计数器)和len(循环数组长度的别名)，当i小於len时，循环条件成立，执行逻辑代码；每次逻辑代码执行完毕以后，i自增1。 </P>
<P>在循环的逻辑代码中，我们把当前循环的数组项加到总和变量中。 <BR>这个循环用流程图表示为如下:</P>
<P><br><br>从这个流程图中我们不难发现，程序中真正的循环体不仅有我们的逻辑代码，还包含了实现循环自身的执行判断和循环处理。 <BR>这样，我们的优化思路就清晰了，我们可以从四个方面进行优化。</P>
<P>1.循环体前的初始化代码<BR>2.循环体中的执行判断条件<BR>3.逻辑代码<BR>4.逻辑代码后的处理代码</P>
<P>ps: 其中第一点和第二点存在重要关系。</P>
<P><BR><STRONG>1.1 优化初始化代码和执行判断条件</STRONG></P>
<P>我们先来看看一段大家都非常熟悉的代码。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="69870" class="copybut" id="copybut69870" onclick="doCopy('code69870')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code69870"><BR>// wrong!<BR>for (var i = 02 i &lt; list.length2 ++i) {<BR>&nbsp; //... 逻辑代码<BR>}</div><BR>相信现在大部分写着 javascript 的工程师依然使用着这段看似狠正常的循环方法，但为什麼我在这里说它是错误的呢？ <BR>我们把这个循环的所有东西都拆开来看看：</P>
<P>1.初始化代码 - 这段循环只定义并初始化了一个计数器变量。<BR>2.执行判断条件 - 当计数器小於list的长度时成立。<BR>3.处理代码 - 计数器自增1。</P>
<P>我们再回顾一下上面的流程图，发现有什麼倪端没？ <BR>真正的循环体不仅有我们的逻辑代码，还包含了实现循环自身的执行判断和处理代码。 也就是说，i &lt; list.length这个判断条件是每一次循环前都要执行的。而 javascript 中，对对象的属性或方法进行读取时，需要进行一次查询。 <BR>似乎明白了点什麼了吧？这个判断条件存在两个操作：1. 从list数组中查询length属性；2. 比较i与list.length的大小。 <BR>假设list数组含有 n 个元素，则程序需要在这个循环的执行判断中进行 2n 次操作。</P>
<P>如果我们把代码改成这样：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="9391" class="copybut" id="copybut9391" onclick="doCopy('code9391')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code9391"><BR>// Well<BR>for (var i = 0, len = list.length; i &lt; len; ++i) {<BR>&nbsp; //...<BR>}<BR></div></P>
<P>在这段改进后的代码中，我们在循环体执行前的初始化代码中， 增加定义并初始化了一个len变量，用於存储list.length的值（关於变量、表达式、指针和值的相关内容将在第二篇中讨论）。 这样，我们在循环体中的执行判断中就无需再次对list数组进行属性查询，操作数为原先的一半。</P>
<P>以上步骤我们完善了算法的时间复杂度，而如果要继续优化空间复杂度的话，要如何做呢？ 如果你的逻辑代码不受循环顺序限制，那你可以尝试以下优化方式。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="90828" class="copybut" id="copybut90828" onclick="doCopy('code90828')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code90828"><BR>for (var i = list.length - 1; i &gt;= 0; --i) {<BR>&nbsp; //...<BR>}<BR></div></P>
<P>这段代码通过把循环顺序倒置，把i计数器从最后一个元素下标（list.length - 1）开始，向前循环。 以达到把循环所需变量数减到 1 个，而且在执行判断中，降低了变量查询的次数，减少了执行 cpu 指令前的耗时。</P>
<P><STRONG>1.2 优化逻辑代码</STRONG></P>
<P>在循环中，我们得到循环当前的数组元素自然是为了对其或利用其进行一些操作，这不免会出现对该元素数次的调用。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="73074" class="copybut" id="copybut73074" onclick="doCopy('code73074')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code73074"><BR>var array = [<BR>&nbsp; { name: 'Will Wen Gunn', type: 'hentai' },<BR>&nbsp; { name: 'Vill Lin', type: 'moegril' }<BR>];</P>
<P>for (var i = array.length - 1; i &gt;= 0; --i) {<BR>&nbsp; console.log('Name: %s', array[i].name);<BR>&nbsp; console.log('He/She is a(n) %s', array[i].type);</P>
<P>&nbsp; console.log('\r\n');<BR>}<BR>/*=&gt;<BR>&nbsp; Name: Vill Lin<BR>&nbsp; He/She is a(n) moegril</P>
<P>&nbsp; Name: Will Wen Gunn<BR>&nbsp; He/She is a(n) hentai<BR>&nbsp;*/<BR></div></P>
<P>这段代码中，程序需要对每个数组元素的name和type属性进行查询。 如果数组有 n 个元素，程序就进行了 4n 次对象查询。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="99778" class="copybut" id="copybut99778" onclick="doCopy('code99778')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code99778"><BR>1. array[i]<BR>2. array[i].name<BR>3. array[i]<BR>4. array[i].type<BR></div></P>
<P>相信此时你一定想到了解决方法了吧，那就是把当前数组元素的值赋值到一个变量中，然后在逻辑代码中使用它。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="19668" class="copybut" id="copybut19668" onclick="doCopy('code19668')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code19668"><BR>var array = [<BR>&nbsp; { name: 'Will Wen Gunn', type: 'hentai' },<BR>&nbsp; { name: 'Vill Lin', type: 'moegril' }<BR>];<BR>var person = null;</P>
<P>for (var i = array.length - 1; i &gt;= 0 && (person = array[i]); --i) {<BR>&nbsp; console.log('Name: %s', person.name);<BR>&nbsp; console.log('He/She is a(n) %s', person.type);</P>
<P>&nbsp; console.log('\r\n');<BR>}<BR>person = null;<BR></div></P>
<P>这样看起来的确美观了不少。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="86556" class="copybut" id="copybut86556" onclick="doCopy('code86556')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code86556"><BR>&nbsp;1. array[i] =&gt; var person<BR>&nbsp;2. person.name<BR>&nbsp;3. person.type<BR></div></P>
<P>有点像 emcascript5 中的foreach，不过这两者之间差别狠大，这里不多做解释。</P>
<P>ps：感谢大家的指正，经过实验得知，如果数组内的元素是直接传值定义的，则在循环中得到值一定是值，而非指针。 所以无论是定义表达式还是变量，都会有额外的内存空间请求。</P>
<P><STRONG>1.3 优化处理代码</STRONG></P>
<P>实际上，循环体中的处理代码并没有太多东西可以进行优化，i计数器也就是自增1就足够了。 <BR>ps：如果有什麼好的建议或方法，欢迎提供。:）</P>
<P><STRONG>2. 循环对象（object）</STRONG></P>
<P>在 javascript 中，for还可以对 object 的属性和方法进行历遍。 需要注意的是，for循环无法对对象所属的包装类型或是构造函数中原型属性、方法（prototype）进行历遍。</P>
<P>语法比循环数组还要简单。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="85892" class="copybut" id="copybut85892" onclick="doCopy('code85892')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code85892"><BR>for (/* 初始化 */ var key in object) {<BR>&nbsp; //... 逻辑代码<BR>}<BR></div></P>
<P>我们常常这个方法来进行对对象的操作。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="61325" class="copybut" id="copybut61325" onclick="doCopy('code61325')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code61325"><BR>var person = {<BR>&nbsp; 'name'&nbsp; : 'Will Wen Gunn',<BR>&nbsp; 'type'&nbsp; : 'hentai',<BR>&nbsp; 'skill' : ['Programming', 'Photography', 'Speaking', 'etc']<BR>};</P>
<P>for (var key in person) {<BR>&nbsp; value = person[key];</P>
<P>&nbsp; // if the value is array, convert it to a string<BR>&nbsp; if (value instanceof Array) {<BR>&nbsp;&nbsp;&nbsp; value = value.join(', ');<BR>&nbsp; }</P>
<P>&nbsp; console.log('%s: %s', key, value);<BR>}<BR>/*=&gt;<BR>&nbsp;name: Will Wen Gunn<BR>&nbsp;type: hentai<BR>&nbsp;skill: Programming, Photography, Speaking, etc<BR>&nbsp;*/</div></P>
<P>&nbsp;如果你曾使用过 mongodb，那你对它的 query 机制绝对不会陌生。 因为 mongodb 的 query 机制就像是它的 api 的灵魂，灵活的 curd 操作方式为 mongodb 赢得了不少人气和发展动力。</P>
<P>而在 nanodb 的 mongo api 实现中，query 的实现方式就大面积地使用了循环对象。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="35026" class="copybut" id="copybut35026" onclick="doCopy('code35026')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code35026"><BR>var myDB&nbsp;&nbsp; = nano.db('myDB');<BR>var myColl = myDB.collection('myColl');</P>
<P>var _cursor = myColl.find({<BR>&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp; : 'repo',<BR>&nbsp; language : 'JavaScript'<BR>});</P>
<P>_cursor<BR>&nbsp; .sort({<BR>&nbsp;&nbsp;&nbsp; star: 1<BR>&nbsp; })<BR>&nbsp; .toArray(function(err, rows) {<BR>&nbsp;&nbsp;&nbsp; if (err)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return console.error(err);</P>
<P>&nbsp;&nbsp;&nbsp; console.log(rows);<BR>&nbsp; });<BR></div></P>
<P>而我们需要优化的，并非循环本身，而是对你需要进行历遍的对象进行优化。 <BR>就比如说 nanodb 中的 nanocollection 类，虽然表面看上去就是一个数组， 存有所有的元素，或是一个对象，用元素的 id 作为键，然后对元素进行存储。</P>
<P>但事实并非如此，曾经使用过 underscore 的同学应该会知道其中的_.invert方法。 这是一个相当有趣的方法，它把所传入的对象的键与值反过来。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="87365" class="copybut" id="copybut87365" onclick="doCopy('code87365')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code87365"><BR>var person = {<BR>&nbsp; 'name' : 'Will Wen Gunn',<BR>&nbsp; 'type' : 'hentai'<BR>};</P>
<P>var _inverted = _.invert(person);<BR>console.log(_inverted);<BR>/*=&gt;<BR>&nbsp;{<BR>&nbsp;&nbsp; 'Will Wen Gunn' : 'name',<BR>&nbsp;&nbsp; 'hentai'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 'type'<BR>&nbsp;}<BR>&nbsp;*/<BR></div></P>
<P>如果你是需要使用循环对象来对对象的某些属性的值进行查询，那你就可以尝试一下以下方法。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="30349" class="copybut" id="copybut30349" onclick="doCopy('code30349')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code30349"><BR>var person = {<BR>&nbsp; 'name' : 'Will Wen Gunn',<BR>&nbsp; 'type' : 'hentai'<BR>};</P>
<P>var name = 'Will Wen Gunn';</P>
<P>var _inverted = _.invert(person);</P>
<P>if (_inverted[name] === 'name') {<BR>&nbsp; console.log('Catched!');<BR>}<BR>//=&gt; Catched!<BR></div></P>
<P>然而利用for进行对象查询并没有太大的可优化之处，一切都还需从实际需求出发。: p</P>
<P>接下来我们来看看其他两种循环，while () {}和do {} while ()。 相信任何接收过计算机科学课程的朋友都这两个循环都不会陌生。他们唯一的区别就在与执行循环体的逻辑顺序。</P>
<P>while () {}的执行顺序与for () {}类似，执行判断在逻辑代码之前，不过省去了初始化和处理代码。 <BR>当给予的条件时，便执行逻辑代码，直到条件不再成立为止。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="54512" class="copybut" id="copybut54512" onclick="doCopy('code54512')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code54512"><BR>var sum = 0;</P>
<P>while (sum &lt; 10) {<BR>&nbsp; sum += sum + 1;<BR>}</P>
<P>console.log(sum);<BR>//=&gt; 15<BR></div></P>
<P>do {} while ()则是把执行判断放到了逻辑代码之后，也就是“先斩后奏”。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="82024" class="copybut" id="copybut82024" onclick="doCopy('code82024')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code82024"><BR>var sum = 0;</P>
<P>do {<BR>&nbsp; sum += sum + 1;<BR>} while (sum &lt; 10);</P>
<P>console.log(sum);<BR>//=&gt; 15<BR></div></P>
<P>while () {}与do {} while ()同样不需要计数器，而是通过某些条件来判断是否执行或继续执行逻辑代码。</P>
<P><STRONG>3. while () {}和do {} while ()</STRONG></P>
<P>while () {}和do {} while ()主要用於业务逻辑中，为达到某一目的而不断执行一系列操作，如任务队列。</P>
<P>但这两种循环是危险的，因为它们默认只受执行条件的控制，如果一旦逻辑代码内一直没有对执行判断產生任何影响，就会出现死循环。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="46371" class="copybut" id="copybut46371" onclick="doCopy('code46371')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code46371"><BR>var sum = 02</P>
<P>// warning!<BR>while (sum &lt; 10) {<BR>&nbsp; sum = 1 + 12<BR>}<BR></div></P>
<P>这样的代码无异於while (true) {}，所以在使用之前，必须明确执行条件和如何对执行条件產生影响的方法。</P>
<P><STRONG>4. 善用循环控制语句</STRONG></P>
<P>相信所有 javascript 工程师都使用过break语句，但continue语句却相对少用。 实际上，在不少优秀的 javascript 开源项目中，都能发现continue的身影。</P>
<P>为了地瞭解continue语句的作用，我们还是先来看看一段实例代码</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="79888" class="copybut" id="copybut79888" onclick="doCopy('code79888')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code79888"><BR>// Node.js Broadcast Server<BR>var net&nbsp; = require('net');<BR>var util = require('util');</P>
<P>var broadcastServer = net.createServer();</P>
<P>// Client Store<BR>broadcastServer.clients = [];</P>
<P>// Clients Broadcast Method<BR>net.Socket.prototype.broadcast = function(msg) {<BR>&nbsp; var clients = broadcastServer.clients;<BR>&nbsp; // 获得发佈广播的客户端在集閤中的下标<BR>&nbsp; var index&nbsp;&nbsp; = clients.indexOf(this);</P>
<P>&nbsp; for (var i = clients.length - 1; i &gt;= 0; --i) {<BR>&nbsp;&nbsp;&nbsp; if (i === index) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果为发佈广播的客户端，则结束当前循环体<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; currClient = clients[i];</P>
<P>&nbsp;&nbsp;&nbsp; if (!currClient.destroyed) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currClient.write(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; util.format(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '\r[Echo Client %s:%d] %s\nInput: ',<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currClient.remoteAddress, currClient.remotePort, msg)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; }<BR>};</P>
<P>// A new client connected<BR>broadcastServer.on('connection', function(client) {<BR>&nbsp; broadcastServer.clients.push(client);</P>
<P>&nbsp; // Welcome<BR>&nbsp; client.write('[Broadcast Server] Welcome!\nInput:');<BR>&nbsp; client.broadcast(client, 'Joined!');</P>
<P>&nbsp; // Message handle<BR>&nbsp; client.on('data', function(msg) {<BR>&nbsp;&nbsp;&nbsp; client.broadcast(msg);<BR>&nbsp;&nbsp;&nbsp; client.write('\rInput:');<BR>&nbsp; });</P>
<P>&nbsp; // Disconnect handle<BR>&nbsp; client.on('end', function() {<BR>&nbsp;&nbsp;&nbsp; client.broadcast('Left!');<BR>&nbsp; })<BR>});</P>
<P>// Bind<BR>broadcastServer.listen(8080, function() {<BR>&nbsp; console.log('Broadcast Server bound.');<BR>});</div></P>
<P>这段代码基於 node.js 的net模块实现了一个 broadcast server，在其中的broadcast方法中，我们使用了continue语句， 用以实现将信息向除发佈广播的客户端外的所有已建立连接的客户端。</P>
<P>代码内容相当简单， 当某一客户端需要向其他客户端发佈广播时，则调用该客户端所对应client对象的broadcast方法， 在broadcast方法中，程序会先获取当前客户端在以缓存的客户端 socket 集合中的位置下标， 然后对所有客户端 socket 进行循环发佈，当循环计数器来到之前获得的位置下标，则跳过当前循环体中的逻辑代码，继续下一个循环。</P>
<P>相信学习过 c/c++ 语言的工程师都会从各种地方得到这样一个忠告：“不要使用 goto 语句。”</P>
<P>而这个“臭名昭著”的goto语句其实就是一个代码流程控制器，关於goto语句的详细内容这里不会详细说明。 然而 javascript 没有明显的goto语句，但从break语句和continue语句中，不难发现 javascript 中goto的影子。</P>
<P>这是因为break语句和continue语句允许接受由一个定义好的 label 名称，以进行代码跳转。</P>
<P>我们来看看 mdn 提供的实例代码。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="52780" class="copybut" id="copybut52780" onclick="doCopy('code52780')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code52780"><BR>var i, j;</P>
<P>loop1:<BR>for (i = 0; i &lt; 3; i++) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //The first for statement is labeled "loop1"<BR>&nbsp;&nbsp; loop2:<BR>&nbsp;&nbsp; for (j = 0; j &lt; 3; j++) {&nbsp;&nbsp; //The second for statement is labeled "loop2"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == 1 && j == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue loop1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log("i = " + i + ", j = " + j);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp; }<BR>}</P>
<P>// Output is:<BR>//&nbsp;&nbsp; "i = 0, j = 0"<BR>//&nbsp;&nbsp; "i = 0, j = 1"<BR>//&nbsp;&nbsp; "i = 0, j = 2"<BR>//&nbsp;&nbsp; "i = 1, j = 0"<BR>//&nbsp;&nbsp; "i = 2, j = 0"<BR>//&nbsp;&nbsp; "i = 2, j = 1"<BR>//&nbsp;&nbsp; "i = 2, j = 2"<BR>// Notice how it skips both "i = 1, j = 1" and "i = 1, j = 2"<BR></div></P>
<P>在这段实例代码中，实现了两层循环，而在每层循环外都定义了一个label，用於之后的continue语句进行调用。</P>
<P>第一层循环在loop1的 label 中，也就是说在后面的程序中，如果在continue语句或break语句选择了loop1 label，就会跳出最外层循环。 <BR>第二层循环在顶层循环中的loop2的 label 中，若在continue语句或break语句中选择了loop2 label，就会回到顶层循环的循环体内。</P>
<P>通过使用循环控制语句，我们可以对原有的循环执行判断进行干涉，以至於可以构建出十分复杂的逻辑系统。 说句题外话，linux kernel 中有非常多的goto语句，至於为什麼还是能经常听到不要用goto语句之流的言论，就自己 google 吧。</P>
<P><STRONG>5. 高级循环</STRONG></P>
<P><STRONG>5.1 展开循环</STRONG></P>
<P>我们先来看看两段代码，你猜猜哪一个的性能更加。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="60661" class="copybut" id="copybut60661" onclick="doCopy('code60661')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60661"><BR>// Setup<BR>var array = [<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"],<BR>&nbsp; ["DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA", "DATA"]<BR>];<BR>function process(item) {<BR>&nbsp; // Do something with item<BR>}</P>
<P>// Case 1<BR>for (var i = array.length - 1; i &gt;= 0; i--) {<BR>&nbsp; for (var j = array[i].length - 1; j &gt;= 0; i--) {<BR>&nbsp;&nbsp;&nbsp; process(array[i][j]);<BR>&nbsp; }<BR>}</P>
<P>// Case 2<BR>for (var i = array.length - 1; i &gt;= 0; i = i - 4) {<BR>&nbsp; for (var j = array[i].length - 1; j &gt;= 0; j = j - 6) {<BR>&nbsp;&nbsp;&nbsp; process(array[i][j]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 1]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 2]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 3]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 4]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 5]);<BR>&nbsp; }<BR>&nbsp; for (var j = array[i - 1].length - 1; j &gt;= 0; j = j - 6) {<BR>&nbsp;&nbsp;&nbsp; process(array[i][j]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 1]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 2]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 3]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 4]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 5]);<BR>&nbsp; }<BR>&nbsp; for (var j = array[i - 2].length - 1; j &gt;= 0; j = j - 6) {<BR>&nbsp;&nbsp;&nbsp; process(array[i][j]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 1]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 2]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 3]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 4]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 5]);<BR>&nbsp; }<BR>&nbsp; for (var j = array[i - 3].length - 1; j &gt;= 0; j = j - 6) {<BR>&nbsp;&nbsp;&nbsp; process(array[i][j]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 1]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 2]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 3]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 4]);<BR>&nbsp;&nbsp;&nbsp; process(array[i][j - 5]);<BR>&nbsp; }<BR>}<BR></div><BR>我需要对array中的所有子数组的元素进行历遍，有两种方案，一种是我们平常所使用的方法，另一种是把循环任务展开。 答案是 case 2 性能更好，因为在每 6 个元素之间的执行判断都全部删除了，自然比往常的都要快。</P>
<P>这里我们来看看一种更给力的解决方案。 如果一个业务环节中需要对大数据集进行迭代处理，而这个数据集从开始迭代起，数据量不会再改变， 那麼可以考虑採用一种名为 duff 装置的技术。这项技术是以其的创造者 tom duff 的名字来命名的， 这项技术最先实现於 c 语言。后来 jeff greenberg 将其移植到 javascript 中，并经过 andrew b. king 修改并提出了一种更为高效的版本。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="10459" class="copybut" id="copybut10459" onclick="doCopy('code10459')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code10459"><BR>//credit: Speed Up Up Your Site (New Riders, 2003)<BR>var iterations = Math.floor(values.length / 8);<BR>var leftover = values.length % 8;<BR>var i = 0;</P>
<P>if (leftover &gt; 0) {<BR>&nbsp; do {<BR>&nbsp;&nbsp;&nbsp; process(values[i++]);<BR>&nbsp; } while (--leftover &gt; 0);<BR>}<BR>do {<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>&nbsp; process(values[i++]);<BR>} while (--iterations &gt; 0);<BR></div></P>
<P>这种技术的工作原理是通过计算values的长度除以 8 以得到需要迭代的次数，并以math.floor()函数来保证结果为整数， 然后再计算不能被 8 整除时的餘数，并对这些元素单独进行处理，其餘则 8 次为单次展开次数来进行迭代。</P>
<P>我将这种装置再加以封装，可以得到一种带有异步味道的 api。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="87624" class="copybut" id="copybut87624" onclick="doCopy('code87624')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code87624"><BR>function duff(array, mapper) {<BR>&nbsp; var n = Math.floor(array.length / 8);<BR>&nbsp; var l = array.length % 8;</P>
<P>&nbsp; var i = 0;<BR>&nbsp; if (l &gt; 0) {<BR>&nbsp;&nbsp;&nbsp; do {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; } while (--i &gt; 0);<BR>&nbsp; }<BR>&nbsp; do {<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp;&nbsp;&nbsp; mapper(array[i++]);<BR>&nbsp; } while (--n &gt; 0);<BR>}</P>
<P>duff([...], function(item) {<BR>&nbsp; //...<BR>});<BR></div></P>
<P>这里是一组对於以上三种迭代解决方案的性能测试及其结果。http://jsperf.com/spreaded-loop</P>
<P><STRONG>5.2 非原生循环</STRONG></P>
<P>在任何编程语言中，能够实现循环的，不止语言所提供的原生循环语句，还可以通过其他方式来间接实现。</P>
<P>让我们先来温习一下高中数学的一点内容——数列的通项公式。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="82688" class="copybut" id="copybut82688" onclick="doCopy('code82688')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code82688"><BR>bacause<BR>&nbsp; a[1] = 1<BR>&nbsp; a[n] = 2 * a[n - 1] + 1</P>
<P>so<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[n] + 1 = 2 * a[n - 1] + 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2 * (a[n - 1] + 1)<BR>(a[n] + 1) / (a[n - 1] + 1) = 2</P>
<P>then<BR>&nbsp; a[n] + 1 = (a[n] + 1) / (a[n - 1] + 1) * (a[n - 1] + 1) / (a[n - 2] + 1) * ... * (a[2] + 1) / (a[1] + 1) * (a[i] + 1)<BR>&nbsp; a[n] + 1 = 2 * 2 * ... * 2 * 2<BR>&nbsp; a[n] + 1 = 2^n<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[n] = 2^n - 1</P>
<P>final<BR>&nbsp; a[n] = 2^n - 1<BR></div></P>
<P>看了上面这段简单的演算，估计你也猜到我们将要讨论的内容了吧。 是的，我们还可以使用递归来实现循环。</P>
<P>递归是数学和计算机科学中非常重要的一种应用方法，它是指函数在其使用时调用其自身。</P>
<P>在 node.js 社区中，递归被用来实现一种非常重要的技术：中间件技术。 这是一段尚未公佈的新版本的 webjs 中的中间件实现代码。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="70938" class="copybut" id="copybut70938" onclick="doCopy('code70938')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code70938"><BR>/**<BR>&nbsp;* Middlewares run method<BR>&nbsp;* @param&nbsp; {String} url Current request url<BR>&nbsp;* @param&nbsp; {Object} req the request object<BR>&nbsp;* @param&nbsp; {Object} res the response object<BR>&nbsp;* @param&nbsp; {Function} out Complete Callback<BR>&nbsp;* @return {Function}&nbsp;&nbsp;&nbsp;&nbsp; the server<BR>&nbsp;*/<BR>server.runMiddlewares = function(url, req, res, out) {<BR>&nbsp; var index = -1;</P>
<P>&nbsp; var middlewares = this._usingMiddlewares;</P>
<P>&nbsp; // run the next middleware if it is exists<BR>&nbsp; function next(err) {<BR>&nbsp;&nbsp;&nbsp; index++;</P>
<P>&nbsp;&nbsp;&nbsp; // current middleware<BR>&nbsp;&nbsp;&nbsp; var curr = middlewares[index];</P>
<P>&nbsp;&nbsp;&nbsp; if (curr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var check = new RegExp(curr.route);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check the route<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (check.test(url)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function later() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debug('A middleware says it need to be later on %s', url);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The dependencies do not right now<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (middlewares.indexOf(curr) !== middlewares.length - 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _later(curr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index--;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; debug('A middleware dependencies wrong');</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This middleware can not run<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Run the middleware<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (utils.isFunc(curr.handler)) {</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Normal middleware function<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr.handler(req, res, next, later);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (utils.isObject(curr.handler) && utils.isFunc(curr.handler.emit)) {</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Server object<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr.handler.emit('request', req, res, next, later);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // There are something wrong about the middleware<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch(err) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Out to next step of the pipeline<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; }</P>
<P>&nbsp; // if the middleware depend on other middlewares,<BR>&nbsp; // it can let it later to run<BR>&nbsp; function _later(curr) {<BR>&nbsp;&nbsp;&nbsp; var i = middlewares.indexOf(curr);<BR>&nbsp;&nbsp;&nbsp; var _tmp1 = middlewares.slice(0, i);<BR>&nbsp;&nbsp;&nbsp; _tmp1.push(middlewares[i + 1], curr);<BR>&nbsp;&nbsp;&nbsp; var _tmp2 = middlewares.slice(i + 2);<BR>&nbsp;&nbsp;&nbsp; [].push.apply(_tmp1, _tmp2);<BR>&nbsp;&nbsp;&nbsp; middlewares = _tmp1;<BR>&nbsp; }</P>
<P>&nbsp; // first middleware<BR>&nbsp; next();</P>
<P>&nbsp; return this;<BR>};<BR></div></P>
<P>虽然这段代码看上去狠复杂，不过如果我们对其精简之后，就清晰许多了。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="6187" class="copybut" id="copybut6187" onclick="doCopy('code6187')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code6187"><BR>server.runMiddlewares = function(url, req, res, out) {<BR>&nbsp; var index = -1;</P>
<P>&nbsp; var middlewares = this._usingMiddlewares;</P>
<P>&nbsp; // run the next middleware if it is exists<BR>&nbsp; function next(err) {<BR>&nbsp;&nbsp;&nbsp; index++;</P>
<P>&nbsp;&nbsp;&nbsp; // current middleware<BR>&nbsp;&nbsp;&nbsp; var curr = middlewares[index];</P>
<P>&nbsp;&nbsp;&nbsp; if (curr) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var check = new RegExp(curr.route);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Check the route<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (check.test(url)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // run the current middleware<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr.handler(req, res, next);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Out to next step of the pipeline<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; }</P>
<P>&nbsp; // first middleware<BR>&nbsp; next();</P>
<P>&nbsp; return this;<BR>};<BR></div></P>
<P>递归之所以可以用於中间件系统的实现，是因为递归是最适合 node.js 中异步 i/o 的程序流程响应方式。</P>
<P>在这段中间件实现代码中，this._usingmiddlewares为循环数组，function next()是循环体，其中check.test(url)为执行判断条件， 而循环处理代码就是循环体中最前面的index计数器自增 1 和next函数自身的递归调用。</P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/92936.html'>$.extend 的一个小问题</a><a>下一篇</a><a href='/php/biji/92938.html'>PHP易混淆知识整理笔记</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>