<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>基于vue-ssr服务端渲染入门分析_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了基于vue-ssr服务端渲染入门分析，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！<br />
第一部分 基本介绍<br />
1、前言" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/122.html"></a></li><li><a href="/php/phpbiji/123.html"></a></li><li><a href="/php/phpbiji/124.html"></a></li><li><a href="/php/phpbiji/125.html"></a></li><li><a href="/php/phpbiji/126.html"></a></li><li><a href="/php/phpbiji/127.html"></a></li><li><a href="/php/phpbiji/128.html"></a></li><li><a href="/php/phpbiji/129.html"></a></li><li><a href="/php/phpbiji/130.html"></a></li><li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">基于vue-ssr服务端渲染入门分析</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了基于vue-ssr服务端渲染入门分析，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！<br />
第一部分 基本介绍<br />
1、前言</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了基于vue-ssr服务端渲染入门分析，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>
<h2><strong>第一部分 基本介绍</strong></h2>
<h3><strong>1、前言</strong></h3>
<p><strong>服务端渲染实现原理机制：在服务端拿数据进行解析渲染，直接生成html片段返回给前端。然后前端可以通过解析后端返回的html片段到前端页面，大致有以下两种形式：</strong></p>
<p><strong>1、服务器通过模版引擎直接渲染整个页面，例如java后端的vm模版引擎，php后端的smarty模版引擎。2、服务渲染生成html代码块, 前端通过AJAX获取然后使用js动态添加。</strong></p>
<h3><strong>2、服务端渲染的优劣</strong></h3>
<p><strong>服务端渲染能够解决两大问题：</strong></p>
<p><strong>1、seo问题，有利于搜索引擎蜘蛛抓取网站内容，利于网站的收录和排名。2、首屏加载过慢问题，例如现在成熟的SPA项目中，打开首页需要加载很多资源，通过服务端渲染可以加速首屏渲染。同样服务端渲染也会有弊端，主要是根据自己的业务场景来选择适合方式，由于服务端渲染前端页面，必将会给服务器增加压力。</strong></p>
<h3><strong><strong>3、SSR的实现原理</strong></strong></h3>
<p><strong><strong>客户端请求服务器，服务器根据请求地址获得匹配的组件，在调用匹配到的组件返回 Promise (官方是preFetch方法)来将需要的数据拿到。最后再通过</strong></strong></p>
<p><strong><strong>代码如下：</strong></strong></p>
<pre>
<strong><strong>
<code>
&lt;script&gt;window.__initial_state=data&lt;/script&gt;</code></strong></strong></pre>
<p><strong><strong>将其写入网页，最后将服务端渲染好的网页返回回去。</strong></strong></p>
<p><strong><strong>接下来客户端会将vuex将写入的 initial_state 替换为当前的全局状态树，再用这个状态树去检查服务端渲染好的数据有没有问题。遇到没被服务端渲染的组件，再去发异步请求拿数据。说白了就是一个类似React的 shouldComponentUpdate 的Diff操作。</strong></strong></p>
<p><strong><strong>Vue2使用的是单向数据流，用了它，就可以通过 SSR 返回唯一一个全局状态， 并确认某个组件是否已经SSR过了。</strong></strong></p>
<h3><strong><strong><strong>4、vue后端渲染主要插件：vue-server-renderer</strong></strong></strong></h3>
<p><strong><strong><strong>由于virtual dom的引入，使得vue的服务端渲染成为了可能，下面是官方 vue-server-renderer提供的渲染流程图:</strong></strong></strong></p>
<p style="text-align: center"><strong><strong><strong>【512pic.com温馨提示：图片暂缺】</strong></strong></strong></p>
<p><strong><strong><strong>可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。</strong></strong></strong></p>
<p><strong><strong><strong>source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）;</strong></strong></strong></p>
<p><strong><strong><strong>前面的source部分就是业务开发的代码，开发完成之后通过 webpack 进行构建，生成对应的bundle，这里不再赘述client bundle,就是一个可在浏览器端执行的打包文件；这里说下server bundle, vue2提供 vue-server-renderer模块，模块可以提供两种render: rendererer/bundleRenderer ,下面分别介绍下这两种render。</strong></strong></strong></p>
<p><strong><strong><strong>renderer接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此vue-server-renderer提供了另外一种渲染模式，通过一个 bundleRenderer去做渲染。</strong></strong></strong></p>
<p><strong><strong><strong>bundleRenderer是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以server entry按照一定的要求打包生成一个 server-bundle,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。 renderer生成完成之后，都存在两个接口，分别是renderToString和renderToStream，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快。</strong></strong></strong></p>
<h2><strong><strong><strong><strong>第二部分 从零开始搭建</strong></strong></strong></strong></h2>
<h3><strong><strong><strong><strong>1、前言</strong></strong></strong></strong></h3>
<p><strong><strong><strong><strong>上一节我们大致讲了为什么需要使用vue后端渲染，以及vue后端渲染的基本原理，这节内容我们将从零开始搭建属于自己的vue后端渲染脚手架，当然不能不参考官方页面响应的实例vue-hackernews-2.0，从零开始搭建项目,源码在将在下节与大家共享。</strong></strong></strong></strong></p>
<h2><strong><strong><strong><strong>2、前期准备</strong></strong></strong></strong></h2>
<p><strong><strong><strong><strong>基本环境要求：node版本6.10.1以上，npm版本3.10.10以上，本机环境是这样的，建议升级到官方最新版本。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>使用的技术栈：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>1、vue 2.4.22、vuex 2.3.13、vue-router 2.7.04、vue-server-renderer 2.4.25、express 4.15.46、axios 0.16.27、qs 6.5.08、q https://github.com/kriskowal/q.git9、webpack 3.5.010、mockjs 1.0.1-beta311、babel 相关插件</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>以上是主要是用的技术栈，在构建过程中会是用相应的插件依赖包来配合进行压缩打包，以下是npm init后package.json文件所要添加的依赖包。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
&quot;dependencies&quot;: {
 &quot;axios&quot;: &quot;^0.16.2&quot;,
 &quot;es6-promise&quot;: &quot;^4.1.1&quot;,
 &quot;express&quot;: &quot;^4.15.4&quot;,
 &quot;lodash&quot;: &quot;^4.17.4&quot;,
 &quot;q&quot;: &quot;git+https://github.com/kriskowal/q.git&quot;,
 &quot;qs&quot;: &quot;^6.5.0&quot;,
 &quot;vue&quot;: &quot;^2.4.2&quot;,
 &quot;vue-router&quot;: &quot;^2.7.0&quot;,
 &quot;vue-server-renderer&quot;: &quot;^2.4.2&quot;,
 &quot;vuex&quot;: &quot;^2.3.1&quot;
 },
 &quot;devDependencies&quot;: {
 &quot;autoprefixer&quot;: &quot;^7.1.2&quot;,
 &quot;babel-core&quot;: &quot;^6.25.0&quot;,
 &quot;babel-loader&quot;: &quot;^7.1.1&quot;,
 &quot;babel-plugin-syntax-dynamic-import&quot;: &quot;^6.18.0&quot;,
 &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,
 &quot;babel-preset-env&quot;: &quot;^1.6.0&quot;,
 &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;,
 &quot;compression&quot;: &quot;^1.7.1&quot;,
 &quot;cross-env&quot;: &quot;^5.0.5&quot;,
 &quot;css-loader&quot;: &quot;^0.28.4&quot;,
 &quot;extract-text-webpack-plugin&quot;: &quot;^3.0.0&quot;,
 &quot;file-loader&quot;: &quot;^0.11.2&quot;,
 &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.6.1&quot;,
 &quot;glob&quot;: &quot;^7.1.2&quot;,
 &quot;less&quot;: &quot;^2.7.2&quot;,
 &quot;less-loader&quot;: &quot;^2.2.3&quot;,
 &quot;lru-cache&quot;: &quot;^4.1.1&quot;,
 &quot;mockjs&quot;: &quot;^1.0.1-beta3&quot;,
 &quot;style-loader&quot;: &quot;^0.19.0&quot;,
 &quot;sw-precache-webpack-plugin&quot;: &quot;^0.11.4&quot;,
 &quot;url-loader&quot;: &quot;^0.5.9&quot;,
 &quot;vue-loader&quot;: &quot;^13.0.4&quot;,
 &quot;vue-style-loader&quot;: &quot;^3.0.3&quot;,
 &quot;vue-template-compiler&quot;: &quot;^2.4.2&quot;,
 &quot;vuex-router-sync&quot;: &quot;^4.2.0&quot;,
 &quot;webpack&quot;: &quot;^3.5.0&quot;,
 &quot;webpack-dev-middleware&quot;: &quot;^1.12.0&quot;,
 &quot;webpack-hot-middleware&quot;: &quot;^2.18.2&quot;,
 &quot;webpack-merge&quot;: &quot;^4.1.0&quot;,
 &quot;webpack-node-externals&quot;: &quot;^1.6.0&quot;
 }
</code></strong></strong></strong></strong></pre>
<h3><strong><strong><strong><strong>3、项目主目录搭建</strong></strong></strong></strong></h3>
<p><strong><strong><strong><strong>基本目录结构如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
├── LICENSE
├── README.md
├── build
│ ├── setup-dev-server.js
│ ├── vue-loader.config.js
│ ├── webpack.base.config.js
│ ├── webpack.client.config.js
│ └── webpack.server.config.js
├── log
│ ├── err.log
│ └── out.log
├── package.json
├── pmlog.json
├── server.js
└── src
 ├── App.vue
 ├── app.js
 ├── assets
 │ ├── images
 │ ├── style
 │ │ └── css.less
 │ └── views
 │  └── index.css
 ├── components
 │ ├── Banner.vue
 │ ├── BottomNav.vue
 │ ├── FloorOne.vue
 │ └── Header.vue
 ├── entry-client.js
 ├── entry-server.js
 ├── index.template.html
 ├── public
 │ ├── conf.js
 │ └── utils
 │  ├── api.js
 │  └── confUtils.js
 ├── router
 │ └── index.js
 ├── static
 │ ├── img
 │ │ └── favicon.ico
 │ └── js
 │  └── flexible.js
 ├── store
 │ ├── actions.js
 │ ├── getters.js
 │ ├── index.js
 │ ├── modules
 │ │ └── Home.js
 │ ├── mutationtypes.js
 │ └── state.js
 └── views
  └── index
   ├── conf.js
   ├── index.vue
   ├── mock.js
   └── service.js
</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>文件目录基本介绍：</strong></strong></strong></strong></p>
<ol>
	<li><strong><strong><strong><strong>views文件夹下分模块文件，模块文件下下又分模块本身的.vue文件（模版文件），index.js文件（后台数据交互文件），mock.js（本模块的mock假数据），conf.js（配置本模块一些参数，请求路径，模块名称等信息）</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>components 公共组件文件夹</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>router 主要存放前端路由配置文件，写法规范按照vue-router官方例子即可。</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>store 主要是存放共享状态文件，里面包含action.js,getter.js,mutationtype.js等，后期会根据模块再细分这些。</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>public 主要存放公共组件代码和项目使用的公共文件代码，例如后期我们将axios封装成公共的api库文件等等</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>static文件夹代表静态文件，不会被webpack打包的</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>app.js 是项目入口文件</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>App.vue 是项目入口文件</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>entry-client和entry-server分别是客户端入口文件和服务端的入口文件</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>index.template.html是整个项目的模版文件</strong></strong></strong></strong></li>
</ol>
<p></p>
<h3><strong><strong><strong><strong>开始编写app.js项目入口代码</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>使用vue开发项目入口文件一般都会如下写法：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import Vue from &#39;vue&#39;;
import App from &#39;./index.vue&#39;;
import router from &#39;./router&#39;
import store from &#39;./store&#39;;

new Vue({
 el: &#39;#app&#39;,
 store,
 router,
 render: (h) =&gt; h(App)
});

</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>这种写法是程序共享一个vue实例，但是在后端渲染中很容易导致交叉请求状态污染，导致数据流被污染了。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>所以，避免状态单例,我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，同样router和store入口文件也需要重新创建一个实例。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>为了配合webpack动态加载路由配置，这里会改写常规路由引入写法，这样可以根据路由路径来判断加载相应的组件代码：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import Home from &#39;../views/index/index.vue&#39;
// 改写成
component: () =&gt; (&#39;../views/index/index.vue&#39;)</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>以下是路由的基本写法router，对外会抛出一个createRouter方法来创建一个新的路由实例：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;;
Vue.use(Router)
export function createRouter() {
 return new Router({
  mode: &#39;history&#39;,
  routes: [{
   name:&#39;Home&#39;,
   path: &#39;/&#39;,
   component: () =&gt;
    import (&#39;../views/index/index.vue&#39;)
  }]
 })
}
</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>以下是store状态管理的基本写法，对外暴露了一个createStore方法，方便每次访问创建一个新的实例：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
// store.js
import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
import * as actions from &#39;./actions&#39;
import getters from &#39;./getters&#39;
import modules from &#39;./modules/index&#39;
Vue.use(Vuex)
export function createStore() {
 return new Vuex.Store({
 actions,
 getters,
 modules,
 strict: false
 })
}
</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>结合写好的router和store入口文件代码来编写整个项目的入口文件app.js代码内容，同样最终也会对外暴露一个createApp方法，在每次创建app的时候保证router，store，app都是新创建的实例，这里还引入了一个vue路由插件vuex-router-sync，主要作用是同步路由状态(route state)到 store，以下是app.js完整代码：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import { createRouter } from &#39;./router&#39;
import { createStore } from &#39;./store&#39;
import { sync } from &#39;vuex-router-sync&#39;
require(&#39;./assets/style/css.less&#39;);
export function createApp () {
 // 创建 router 和 store 实例
 const router = createRouter()
 const store = createStore()
 // 同步路由状态(route state)到 store
 sync(store, router)
 // 创建应用程序实例，将 router 和 store 注入
 const app = new Vue({
 router,
 store,
 render: h =&gt; h(App)
 })
 // 暴露 app, router 和 store。
 return { app, router, store }
}
</code></strong></strong></strong></strong></pre>
<p></p>
<h3><strong><strong><strong><strong>entry-client.js代码编写：</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>首页引入从app文件中暴露出来的createApp方法，在每次调用客户端的时候，重新创建一个新的app，router，store，部分代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import { createApp } from &#39;./app&#39;
const { app, router, store } = createApp()</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>这里我们会使用到onReady方法，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候，例子代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import { createApp } from &#39;./app&#39;
const { app, router, store } = createApp()
router.onReady(() =&gt; {
 app.$mount(&#39;#app&#39;)
})</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>我们会调用一个新方法beforeResolve，只有在router2.5.0以上的版本才会有的方法，注册一个类似于全局路由保护router.beforeEach()，除了在导航确认之后，在所有其他保护和异步组件已解决之后调用。基本写法如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
router.beforeResolve((to, from, next) =&gt; {
 // to 和 from 都是 路由信息对象
 // 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。
 const matched = router.getMatchedComponents(to)
 const prevMatched = router.getMatchedComponents(from)
})</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>服务端把要给客户端的 state 放在了 window. INITIAL_STATE 这个全局变量上面。前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（ INITIAL_STATE ），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。基本代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
// 将服务端渲染时候的状态写入vuex中
if (window.__INITIAL_STATE__) {
 store.replaceState(window.__INITIAL_STATE__)
}</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>接下来贴出来完整的客户端代码，这里的Q也可以不用引入，直接使用babel就能编译es6自带的Promise，因为本人使用习惯了，这里可以根据自身的需求是否安装：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import { createApp } from &#39;./app&#39;
import Q from &#39;q&#39;
import Vue from &#39;vue&#39;

Vue.mixin({
 beforeRouteUpdate (to, from, next) {
 const { asyncData } = this.$options
 if (asyncData) {
  asyncData({
  store: this.$store,
  route: to
  }).then(next).catch(next)
 } else {
  next()
 }
 }
})
const { app, router, store } = createApp()

// 将服务端渲染时候的状态写入vuex中
if (window.__INITIAL_STATE__) {
 store.replaceState(window.__INITIAL_STATE__)
}

router.onReady(() =&gt; {
 router.beforeResolve((to, from, next) =&gt; {
  const matched = router.getMatchedComponents(to)
  const prevMatched = router.getMatchedComponents(from)
  // 我们只关心之前没有渲染的组件
  // 所以我们对比它们，找出两个匹配列表的差异组件
  let diffed = false
  const activated = matched.filter((c, i) =&gt; {
  return diffed || (diffed = (prevMatched[i] !== c))
  })
  if (!activated.length) {
  return next()
  }
  // 这里如果有加载指示器(loading indicator)，就触发
  Q.all(activated.map(c =&gt; {
  if (c.asyncData) {
   return c.asyncData({ store, route: to })
  }
  })).then(() =&gt; {
  // 停止加载指示器(loading indicator)
  next()
  }).catch(next)
 })
 app.$mount(&#39;#app&#39;)
})

</code></strong></strong></strong></strong></pre>
<p></p>
<h3><strong><strong><strong><strong>entry-server.js代码编写：</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>基本编写和客户端的差不多，因为这是服务端渲染，涉及到与后端数据交互定义的问题，我们需要在这里定义好各组件与后端交互使用的方法名称，这样方便在组件内部直接使用，这里根我们常规在组件直接使用ajax获取数据有些不一样，代码片段如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
//直接定义组件内部asyncData方法来触发相应的ajax获取数据
if (Component.asyncData) {
 return Component.asyncData({
 store,
 route: router.currentRoute
 })
}
</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>以下是完整的服务端代码：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import { createApp } from &#39;./app&#39;
import Q from &#39;q&#39;
export default context =&gt; {
 return new Q.Promise((resolve, reject) =&gt; {
 const { app, router, store } = createApp()
 router.push(context.url)
 router.onReady(() =&gt; {
  const matchedComponents = router.getMatchedComponents()
  if (!matchedComponents.length) {
  return reject({ code: 404 })
  }
  // 对所有匹配的路由组件调用 `asyncData()`
  Q.all(matchedComponents.map(Component =&gt; {
  if (Component.asyncData) {
   return Component.asyncData({
   store,
   route: router.currentRoute
   })
  }
  })).then(() =&gt; {
  // 在所有预取钩子(preFetch hook) resolve 后，
  // 我们的 store 现在已经填充入渲染应用程序所需的状态。
  // 当我们将状态附加到上下文，
  // 并且 `template` 选项用于 renderer 时，
  // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。
  context.state = store.state
  resolve(app)
  }).catch(reject)
 }, reject)
 })
}
</code></strong></strong></strong></strong></pre>
<h3><strong><strong><strong><strong>4、脚手架其他目录介绍：</strong></strong></strong></strong></h3>
<p><strong><strong><strong><strong>到这里src下面主要的几个文件代码已经编写完成，接下里介绍下整个项目的目录结构如下：</strong></strong></strong></strong></p>
<p style="text-align: center"><strong><strong><strong><strong>【512pic.com温馨提示：图片暂缺】</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>主要几个文件介绍如下：</strong></strong></strong></strong></p>
<ol>
	<li><strong><strong><strong><strong>build 主要存放webpack打包配置文件</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>dist webpack打包后生成的目录</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>log 使用pm2监控进程存放的日志文件目录</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>server.js node服务器启动文件</strong></strong></strong></strong></li>
	<li><strong><strong><strong><strong>pmlog.json pm2配置文件</strong></strong></strong></strong></li>
</ol>
<p><strong><strong><strong><strong>server.js入口文件编写</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>我们还需要编写在服务端启动服务的代码server.js，我们会使用到部分node原生提供的api，片段代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
const Vue = require(&#39;vue&#39;)
const express = require(&#39;express&#39;)
const path = require(&#39;path&#39;)
const LRU = require(&#39;lru-cache&#39;)
const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;)
const fs = require(&#39;fs&#39;)
const net = require(&#39;net&#39;)</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>大致思路是，引入前端模版页面index.template.html，使用express启动服务，引入webpack打包项目代码的dist文件，引入缓存模块（这里不做深入介绍，后期会单独详细介绍），判断端口是否被占用，自动启动其他接口服务。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>引入前端模版文件并且设置环境变量为production，片段代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
const template = fs.readFileSync(&#39;./src/index.template.html&#39;, &#39;utf-8&#39;)
const isProd = process.env.NODE_ENV === &#39;production&#39;</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>vue-server-renderer插件的具体使用，通过读取dist文件夹下的目录文件，来创建createBundleRenderer函数，并且使用LRU来设置缓存的时间，通过判断是生产环境还是开发环境，调用不同的方法，代码片段如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
const resolve = file =&gt; path.resolve(__dirname, file)
function createRenderer (bundle, options) {
 return createBundleRenderer(bundle, Object.assign(options, {
 template,
 cache: LRU({
  max: 1000,
  maxAge: 1000 * 60 * 15
 }),
 basedir: resolve(&#39;./dist&#39;),
 runInNewContext: false
 }))
}
let renderer;
let readyPromise
if (isProd) {
 const bundle = require(&#39;./dist/vue-ssr-server-bundle.json&#39;)
 const clientManifest = require(&#39;./dist/vue-ssr-client-manifest.json&#39;)
 renderer = createRenderer(bundle, {
 clientManifest
 })
} else {
 readyPromise = require(&#39;./build/setup-dev-server&#39;)(server, (bundle, options) =&gt; {
 renderer = createRenderer(bundle, options)
 })
}
</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>使用express启动服务，代码片段如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
const server = express()；

//定义在启动服务钱先判断中间件中的缓存是否过期，是否直接调用dist文件。
const serve = (path, cache) =&gt; express.static(resolve(path), {
 maxAge: cache &amp;&amp; isProd ? 1000 * 60 * 60 * 24 * 30 : 0
})
server.use(&#39;/dist&#39;, serve(&#39;./dist&#39;, true))
server.get(&#39;*&#39;, (req, res) =&gt; {
 const context = {
 title: &#39;hello&#39;,
 url: req.url
 }
 renderer.renderToString(context, (err, html) =&gt; {
 if (err) {
  res.status(500).end(&#39;Internal Server Error&#39;)
  return
 }
 res.end(html)
 })
})

</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>判断端口是否被占用，片段代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
function probe(port, callback) {
 let servers = net.createServer().listen(port)
 let calledOnce = false
 let timeoutRef = setTimeout(function() {
  calledOnce = true
  callback(false, port)
 }, 2000)
 timeoutRef.unref()
 let connected = false
 servers.on(&#39;listening&#39;, function() {
  clearTimeout(timeoutRef)

  if (servers)
   servers.close()

  if (!calledOnce) {
   calledOnce = true
   callback(true, port)
  }
 })
 servers.on(&#39;error&#39;, function(err) {
  clearTimeout(timeoutRef)

  let result = true
  if (err.code === &#39;EADDRINUSE&#39;)
   result = false

  if (!calledOnce) {
   calledOnce = true
   callback(result, port)
  }
 })
}
const checkPortPromise = new Promise((resolve) =&gt; {
 (function serverport(_port) {
  let pt = _port || 8080;
  probe(pt, function(bl, _pt) {
   // 端口被占用 bl 返回false
   // _pt：传入的端口号
   if (bl === true) {
    // console.log(&quot;\n Static file server running at&quot; + &quot;\n\n=&gt; http://localhost:&quot; + _pt + &#39;\n&#39;);
    resolve(_pt);
   } else {
    serverport(_pt + 1)
   }
  })
 })()

})
checkPortPromise.then(data =&gt; {
 uri = &#39;http://localhost:&#39; + data;
 console.log(&#39;启动服务路径&#39;+uri)
 server.listen(data);
});

</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>到这里，基本的代码已经编写完成，webpack打包配置文件基本和官方保持不变，接下来可以尝试启动本地的项目服务，这里简要的使用网易严选首页作为demo示例，结果如下：</strong></strong></strong></strong></p>
<p style="text-align: center"><strong><strong><strong><strong>【512pic.com温馨提示：图片暂缺】</strong></strong></strong></strong></p>
<h2><strong><strong><strong><strong>第三部分 mockjs和axios配合使用</strong></strong></strong></strong></h2>
<h2><strong><strong><strong><strong>1、前言</strong></strong></strong></strong></h2>
<p><strong><strong><strong><strong>上一节大致介绍了服务端和客户端入口文件代码内容，现在已经可以正常运行你的后端渲染脚手架了，这一节，跟大家分享下如何使用axios做ajax请求，如何使用mockjs做本地假数据，跑通本地基本逻辑，为以后前后端连调做准备。</strong></strong></strong></strong></p>
<h3><strong><strong><strong><strong>2、前期准备</strong></strong></strong></strong></h3>
<p><strong><strong><strong><strong>需要用npm安装axios，mockjs依赖包,由于mockjs只是代码开发的辅助工具，所以安装的时候我会加--save-dev来区分，具体可以根据自己的需求来定，当然，如果有mock服务平台的话，可以直接走mock平台造假数据，本地直接访问mock平台的接口，例如可以使用阿里的Rap平台管理工具生成。</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
npm install axios --save
npm install mockjs --save-dev</code></strong></strong></strong></strong></pre>
<h3><strong><strong><strong><strong>3、简要介绍axios</strong></strong></strong></strong></h3>
<p><strong><strong><strong><strong>其他请求方式，代码示例如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
axios.request(config);
axios.get(url[,config]);
axios.delete(url[,config]);
axios.head(url[,config]);
axios.post(url[,data[,config]]);
axios.put(url[,data[,config]])
axios.patch(url[,data[,config]])</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>具体详细可以点击查看axios基本使用介绍</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>api.js完整代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import axios from &#39;axios&#39;
import qs from &#39;qs&#39;
import Q from &#39;q&#39;
/**
 * 兼容 不支持promise 的低版本浏览器
 */
require(&#39;es6-promise&#39;).polyfill();
import C from &#39;../conf&#39;

axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;
axios.defaults.withCredentials = true

function ajax(url, type, options) {

 return Q.Promise((resolve, reject) =&gt; {
 axios({
  method: type,
  url: C.HOST + url,
  params: type === &#39;get&#39; ? options : null,
  data: type !== &#39;get&#39; ? qs.stringify(options) : null
  })
  .then((result) =&gt; {
  if (result &amp;&amp; result.status === 401) {
   // location.href = &#39;/views/401.html&#39;
  }
  if (result &amp;&amp; result.status === 200) {
   if (result.data.code === 200) {
   resolve(result.data.data);
   } else if (result.data.code === 401) {
   reject({
    nopms: true,
    msg: result.data.msg
   });
   } else {
   reject({
    error: true,
    msg: result.data.msg
   });
   }
  } else {
   reject({
   errno: result.errno,
   msg: result.msg
   });
  }
  })
  .catch(function(error) {
  console.log(error, url);
  });
 })
}

const config = {
 get(url, options) {
 const _self = this;
 return Q.Promise((resolve, reject) =&gt; {
  ajax(url, &#39;get&#39;, options)
  .then((data) =&gt; {
   resolve(data);
  }, (error) =&gt; {
   reject(error);
  });
 })
 },

 post(url, options) {
 const _self = this;
 return Q.Promise((resolve, reject) =&gt; {
  ajax(url, &#39;post&#39;, options)
  .then((data) =&gt; {
   resolve(data);
  }, (error) =&gt; {
   reject(error);
  });
 })
 },

 put(url, options) {
 const _self = this;
 return Q.Promise((resolve, reject) =&gt; {
  ajax(url, &#39;put&#39;, options)
  .then((data) =&gt; {
   resolve(data);
  }, (error) =&gt; {
   reject(error);
  });
 })
 },

 delete(url, options) {
 const _self = this;
 return Q.Promise((resolve, reject) =&gt; {
  ajax(url, &#39;delete&#39;, options)
  .then((data) =&gt; {
   resolve(data);
  }, (error) =&gt; {
   reject(error);
  });
 })
 },

 jsonp(url, options) {
 const _self = this;
 return Q.Promise((resolve, reject) =&gt; {
  ajax(url, &#39;jsonp&#39;, options)
  .then((data) =&gt; {
   resolve(data);
  }, (error) =&gt; {
   reject(error);
  });
 })
 }
};

export default config;

</code></strong></strong></strong></strong></pre>
<p></p>
<h3><strong><strong><strong><strong>mockjs项目基本配置如下：</strong></strong></strong></strong></h3>
<p></p>
<p><strong><strong><strong><strong>1、在public下新建conf.js全局定义请求url地址，代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
module.exports = {
 HOST: &quot;http://www.xxx.com&quot;,
 DEBUGMOCK: true
};</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>2、在views/index根目录下新建conf.js，定义组件mock的请求路径，并且定义是否开始单个组件使用mock数据还是线上接口数据，代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
const PAGEMOCK = true;
const MODULECONF = {
 index: {
 NAME: &#39;首页&#39;,
 MOCK: true,
 API: {
  GET: &#39;/api/home&#39;,
 }
 }
};
</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>3、在组件内部定义mockjs来编写mock假数据，代码如下：</strong></strong></strong></strong></p>
<p><strong><strong><strong><strong>代码如下：</strong></strong></strong></strong></p>
<pre>
<strong><strong><strong><strong>
<code>
import Mock from &#39;mockjs&#39;;
const mData = {
 index: {
 API: {
  GET: {
  &quot;code&quot;: 200,
  &quot;data&quot;: {
   &quot;pin&quot;: &#39;wangqi&#39;,
   &quot;name&quot;: &#39;王奇&#39;
  }
  }
 }
 }
}</code></strong></strong></strong></strong></pre>
<p><strong><strong><strong><strong>以上就是基本的流程，如果有更好更灵活的使用方案，希望能够参与沟通并且分享，项目工作流已经在github上分享，并且会继续维护更新， 点击查看详情，希望对大家的学习有所帮助，也希望大家多多支持php教程。</strong></strong></strong></strong></p>

<p>注：关于基于vue-ssr服务端渲染入门分析的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/110135.html'>PHP简单聊天室的实现方法</a><a>下一篇</a><a href='/php/biji/114940.html'>在vue中添加Echarts图表的基本使用教程</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>