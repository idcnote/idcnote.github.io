<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>分析基于webpack和vue.js搭建开发环境_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了分析基于webpack和vue.js搭建开发环境，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！<br />
前言<br />
在对着产品高举" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">分析基于webpack和vue.js搭建开发环境</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了分析基于webpack和vue.js搭建开发环境，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！<br />
前言<br />
在对着产品高举</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了分析基于webpack和vue.js搭建开发环境，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>
<h3>前言</h3>
<p>在对着产品高举中指怒发心中之愤后，真正能够解决问题的是自身上的改变，有句话说的好：你虽然改变不了全世界，但是你有机会改变你自己。秉承着&ldquo;不听老人言，吃亏在眼前&rdquo;的优良作风，我还是决定玩火自焚。</p>
<h3>问题所在</h3>
<p>之前的项目总结为以下内容：</p>
<p>1、AMD模块规范开发，使用requirejs实现，使用rjs打包，最终导致的结果是，输出的项目臃肿，肿的就像一坨狗不理&hellip;&hellip;不忍直视</p>
<p>2、使用gulp进行打包，这一点貌似没有可吐槽的地方，毕竟都是被grunt折磨过来的&hellip;&hellip;</p>
<p>3、数据的渲染使用模板引擎，这就意味着你要手动管理DOM，这样，你的业务代码参杂着你的数据处理、DOM管理，满屏幕的毛线&hellip;&hellip;</p>
<p>4、模块化不足，虽然使用require进行了模块管理，但是大部分业务逻辑还是充斥在一个文件里，这与最近流行的组件化概念冰火不容，拒绝落后&hellip;&hellip;</p>
<p>5、诸如 扩展性 、 维护性 我想早已不言而喻，不需赘述，再述就真TM是累赘了。</p>
<h3>新框架要解决的问题：</h3>
<p>1、要使构建输出的项目像你邻家小妹妹一样、瘦的皮包骨。（也许是营养不良）</p>
<p>2、要实现真正的模块化、组件化的开发方式，真正去解决维护难、扩展难的问题。（从此不怕产品汪）</p>
<p>3、业务逻辑专注数据处理，手动管理DOM的年代就像&hellip;&hellip;像什么呢？（毕竟成人用品也越来越自动化了）</p>
<p>4、等等&hellip;&hellip;.（其实好处无需赘述，来，往下看）</p>
<p>为了达成以上目标，我们探讨一下解决方案：</p>
<h3>1、老项目的构建输出为什么臃肿？</h3>
<p>答：因为使用的是require的rjs进行构建打包的，了解rjs的都知道，它会把项目所有依赖都打包在一个文件里，如果项目中有很多页面依赖这个模块，那么rjs并不会把这个模块提取出来作为公共模块，所以就会有很多复制性的内容，所以项目自然臃肿。</p>
<p>解决方案：使用webpack配合相应的loader，来完成模块加载和构建的工作。</p>
<h3>2、老项目为什么模块化的不足？</h3>
<p>答：老项目的模块化，仅仅体现在js层面，解决了模块引用的问题，但在开发方式上，依然可以看做是过程式的，这样的结果就导致了项目的难扩展和难维护，让开发人员在与产品汪的对峙中，并不从容。</p>
<p>解决方案：Vue.js能够很好的解决组件化的问题，配合 Vue.js 官方提供的 vue-loader 能够很好的结合webpack做组件化的开发架构。</p>
<h3>3、如何避免手动管理DOM？</h3>
<p>答：如果你在做数据展示这一块的开发工作，相信你一定体会颇深，发送http请求到服务端，拿到返回的数据后手动渲染DOM至页面，这是最原始的开发方式，无非再加一个模板引擎之类的，但最终还是避免不了手动渲染，如果页面逻辑复杂，比如给你来一个翻页的功能，再来一个筛选项，估计你会觉得世界并不那么美好。</p>
<p>解决方案：MVVM模式能够很好的解决这个问题，而Vue.js的核心也是MVVM。</p>
<h3>webpack</h3>
<p>你肯定听说过webpack，如果直接对你描述什么是webpack你可能感受不到他的好处，那么在这之前，我相信你肯定使用过gulp或者grunt，如果你没使用过也可以，至少你要听说过并且知道gulp和grunt是干什么的，假如这个你还不清楚，那么你并不是一个合格的前端开发人员，这篇文章也不适合你，你可以从基础的地方慢慢学起。</p>
<p>gulp和grunt对于每一个前端开发人员应该是不陌生的，它们为前端提供了自动化构建的能力，并且有自己的生态圈，有很多插件，使得我们告别刀耕火种的时代，但是它们并没有解决模块加载的问题，比如我们之前的项目是使用gulp构建的，但是模块化得工作还是要靠require和rjs来完成，而gulp除了完成一些其他任务之外，就变成了帮助我们免除手动执行命令的工具了，别无它用。</p>
<p>而webpack就不同了，webpack的哲学是一切皆是模块，无论是js/css/sass/img/coffeejs/ttf&hellip;.等等，webpack可以使用自定义的loader去把一切资源当做模块加载，这样就解决了模块依赖的问题，同时，利用插件还可以对项目进行优化，由于模块的加载和项目的构建优化都是通过webpack一个&rdquo;人&ldquo;来解决的，所以模块的加载和项目的构建优化并不是无机分离的，而是有机的结合在一起的，是一个组合的过程，这使得webpack在这方面能够完成的更出色，这也是webpack的优势所在。</p>
<p>如果你看不懂上面的描述，没关系，你只需要知道一下几点：</p>
<p>1、过去使用require和rjs等进行模块加载的方式，可以替换为webpack提供的指定loader去完成，你也可以自己开发加载特定资源的loader。</p>
<p>2、过去使用gulp和grunt完成项目构建优化的方式，可以替换成webpack提供的插件和特定的配置去完成。</p>
<p>3、由于模块的加载和项目的构建优化有机的结合，所以webpack能够更好的完成这项工作</p>
<p>4、并不是说有了webpack就淘汰的gulp等，有些特定的任务，还是要使用gulp去自定义完成的。但是不保证webpack的未来发展趋势会怎么样。</p>
<h3>Vue.js</h3>
<p>Vue.js是一个MVVM模式的框架，如果读者有angular经验，一定能够很快入门Vue的，那么问题来了，为什么使用Vue而不用angular，</p>
<p>首先，Vue的体积小，轻量在移动端开发始终是一个不可忽略的话题，其次，Vue在实现上与angular有本质的区别，读者可以通过下面两个链接来了解：</p>
<p>1、Vue的变化追踪和计算属性的区别等</p>
<p>2、Vue 与 angular 及 react 等框架的对比</p>
<p>3、第三点就是Vue提供了webpack的loader &mdash;-&gt; [vue-loader]，使用它可以让项目的组件化思想更加清晰</p>
<p>综上所述，这就是选用Vue的原因</p>
<h3>npm 和 nodejs</h3>
<p>npm 的全称是 nodejs包管理，现在越来越多的项目(包)都可以通过npm来安装管理，nodejs是js运行在服务器端的平台，它使得js的能力进一步提高，我们还要使用nodejs配合 webpack 来完成热加载的功能。所以读者最好有nodejs的开发经验，如果有express的经验更好。</p>
<h3>让我们一步一步从零搭建这个项目</h3>
<p>首先新建一个目录，名为 myProject ，这是我们的项目目录。然后执行一些基本的步骤，比如 npm init 命令，在我们的项目中生成 package.json 文件，这几乎是必选的，因为我们的项目要有很多依赖，都是通过npm来管理的，而npm对于我们项目的管理，则是通过package.json文件：</p>
<p>代码如下：</p>
<pre>
<code>
 npm init</code></pre>
<p>执行npm init之后，会提示你填写一些项目的信息，一直回车默认就好了，或者直接执行 npm init -y 直接跳过询问步骤</p>
<p>然后我们新建一个叫做 app 的目录，这个是我们页面模块的目录，再在app目录下建立一个index目录，假设这个是首页模块的目录，然后再在index目录下建立一个 index.html 文件和 index.js 文件，分别是首页入口html文件和主js文件，然后再在index目录下建立一个components目录，这个目录用作存放首页组件模块的目录，因为我们最终要实现组件化开发。这样，当你完成上面的步骤后，你的项目看上去应该是这样的：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/201704050933214.jpg" /></p>
<p>接下来通过npm安装项目依赖项：</p>
<p>代码如下：</p>
<pre>
<code>
 npm install\
 webpack webpack-dev-server\
 vue-loader vue-html-loader css-loader vue-style-loader vue-hot-reload-api\
 babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015\
 babel-runtime@5\
 --save-dev

npm install vue --save
</code></pre>
<p>这个时候，你的package.json文件看起来应该是这样的：</p>
<p>代码如下：</p>
<pre>
<code>
 "devDependencies": {
 "babel-core": "^6.3.17",
 "babel-loader": "^6.2.0",
 "babel-plugin-transform-runtime": "^6.3.13",
 "babel-preset-es2015": "^6.3.13",
 "babel-runtime": "^5.8.34",
 "css-loader": "^0.23.0",
 "vue-hot-reload-api": "^1.2.2",
 "vue-html-loader": "^1.0.0",
 "vue-style-loader": "^1.0.0",
 "vue-loader": "^7.2.0",
 "webpack": "^1.12.9",
 "webpack-dev-server": "^1.14.0"
 },
 "dependencies": {
 "vue": "^1.0.13"
 },</code></pre>
<p>我们安装了 babel 一系列包，用来解析ES6语法，因为我们使用ES6来开发项目，如果你不了解ES6语法，建议你看一看阮老师的教程，然后我们安装了一些loader包，比如css-loader/vue-loader等等，因为webpack是使用这些指定的loader去加载指定的文件的。</p>
<p>另外我们还使用 npm install vue &ndash;save 命令安装了 vue ，这个就是我们要在项目中使用的vue.js，我们可以直接像开发nodejs应用一样，直接require(&lsquo;vue&#39;);即可，而不需要通过script标签引入，这一点在开发中很爽。</p>
<p>安装完了依赖，编辑以下文件并保存到相应位置：</p>
<p>1、index.html文件：</p>
<p>代码如下：</p>
<pre>
<code>
 &lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
 &lt;head&gt;
 &lt;meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no"&gt;
 &lt;meta charset="utf-8"&gt;
 &lt;title&gt;首页&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;!-- vue的组件以自定义标签的形式使用 --&gt;
 &lt;favlist&gt;&lt;/favlist&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>2、index.js文件：</p>
<p>代码如下：</p>
<pre>
<code>
 import Vue from 'Vue'
import Favlist from './components/Favlist'

new Vue({
 el: 'body',
 components: { Favlist }
})
</code></pre>
<p>3、在components目录下新建一个 Favlist.vue 文件，作为我们的第一个组件：</p>
<p>代码如下：</p>
<pre>
<code>
 &lt;template&gt;
 &lt;div v-for="n in 10"&gt;div&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
 export default {
  data () {
   return {
    msg: 'Hello World!'
   }
  }
 }
&lt;/script&gt;

&lt;style&gt;
 html{
  background: red;
 }
&lt;/style&gt;
</code></pre>
<p>要看懂上面的代码，你需要了解vue.js，假如你看不懂也没关系，我们首先在index.html中使用了自定义标签（即组件），然后在index.js中引入了Vue和我们的Favlist.vue组件，Favlist.vue文件中，我们使用了基本的vue组件语法，最后，我们希望它运行起来，这个时候，我们就需要webpack了。</p>
<p>在项目目录下新建 build 目录，用来存放我们的构建相关的代码文件等，然后在build目录下新建 webpack.config.js 这是我们的webpack配置文件，webpack需要通过读取你的配置，进行相应的操作，类似于gulpfile.js或者gruntfile.js等。</p>
<p>webpack.config.js</p>
<p>代码如下：</p>
<pre>
<code>
 // nodejs 中的path模块
var path = require('path');

module.exports = {
 // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件
 entry: path.resolve(__dirname, '../app/index/index.js'),
 // 输出配置
 output: {
  // 输出路径是 myProject/output/static
  path: path.resolve(__dirname, '../output/static'),
  publicPath: 'static/',
  filename: '[name].[hash].js',
  chunkFilename: '[id].[chunkhash].js'
 },
 module: {
  
  loaders: [
   // 使用vue-loader 加载 .vue 结尾的文件
   {
    test: /\.vue$/, 
    loader: 'vue' 
   }
  ]
 }
}
</code></pre>
<p>上例中，相信你已经看懂了我的配置，入口文件是index.js文件，配置了相应输出，然后使用 vue-loader 去加载 .vue 结尾的文件，接下来我们就可以构建项目了，我们可以在命令行中执行：</p>
<p>代码如下：</p>
<pre>
<code>
 webpack --display-modules --display-chunks --config build/webpack.config.js</code></pre>
<p>通过webpack命令，并且通过 &ndash;config 选项指定了我们配置文件的位置是 &lsquo;build/webpack.config.js&#39;，并通过 &ndash;display-modules 和 &ndash;display-chunks 选项显示相应的信息。如果你执行上面的命令，可能得到下图的错误：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/201704050933225.jpg" /></p>
<p>错误提示我们应该选择合适的loader去加载这个 &lsquo;./app/index/index.js&#39; 这个文件，并且说不期望index.js文件中的标识符（Unexpected token），这是因为我们使用了ES6的语法 import 语句，所以我们要使用 babel-loader 去加载我们的js文件，在配置文件中添加一个loaders项目，如下：</p>
<p>代码如下：</p>
<pre>
<code>
 // nodejs 中的path模块
var path = require('path');

module.exports = {
 // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件
 entry: path.resolve(__dirname, '../app/index/index.js'),
 // 输出配置
 output: {
  // 输出路径是 myProject/output/static
  path: path.resolve(__dirname, '../output/static'),
  publicPath: 'static/',
  filename: '[name].[hash].js',
  chunkFilename: '[id].[chunkhash].js'
 },
 module: {
  
  loaders: [
   // 使用vue-loader 加载 .vue 结尾的文件
   {
    test: /\.vue$/, 
    loader: 'vue' 
   },
   {
    test: /\.js$/,
    loader: 'babel?presets=es2015',
    exclude: /node_modules/
   }
  ]
 }
}
</code></pre>
<p>现在再运行构建命令 ： &lsquo;webpack &ndash;display-modules &ndash;display-chunks &ndash;config build/webpack.config.js&#39;</p>
<p>sorry，不出意外，你应该得到如下错误：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/201704050933226.jpg" /></p>
<p>它说没有发现 &lsquo;./components/Favlist&#39; 模块，而我们明明有 ./components/Favlist.vue 文件，为什么它没发现呢？它瞎了？其实是这样的，当webpack试图去加载模块的时候，它默认是查找以 .js 结尾的文件的，它并不知道 .vue 结尾的文件是什么鬼玩意儿，所以我们要在配置文件中告诉webpack，遇到 .vue 结尾的也要去加载，添加 resolve 配置项，如下：</p>
<p>代码如下：</p>
<pre>
<code>
 // nodejs 中的path模块
var path = require('path');

module.exports = {
 // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件
 entry: path.resolve(__dirname, '../app/index/index.js'),
 // 输出配置
 output: {
  // 输出路径是 myProject/output/static
  path: path.resolve(__dirname, '../output/static'),
  publicPath: 'static/',
  filename: '[name].[hash].js',
  chunkFilename: '[id].[chunkhash].js'
 },
 resolve: {
  extensions: ['', '.js', '.vue']
 },
 module: {
  
  loaders: [
   // 使用vue-loader 加载 .vue 结尾的文件
   {
    test: /\.vue$/, 
    loader: 'vue' 
   },
   {
    test: /\.js$/,
    loader: 'babel?presets=es2015',
    exclude: /node_modules/
   }
  ]
 }
}

</code></pre>
<p>这样，当我们去加载 &lsquo;./components/Favlist&#39; 这样的模块时，webpack首先会查找 ./components/Favlist.js 如果没有发现Favlist.js文件就会继续查找 Favlist.vue 文件，现在再次运行构建命令，我们成功了，这时我们会在我们的输出目录中看到一个js文件：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/201704050933227.jpg" /></p>
<p>之所以会这样输出，是因为我们的 webpack.config.js 文件中的输出配置中指定了相应的输出信息，这个时候，我们修改 index.html ，将输出的js文件引入：</p>
<p>代码如下：</p>
<pre>
<code>
 &lt;!DOCTYPE html&gt;
&lt;html lang="zh"&gt;
 &lt;head&gt;
 &lt;meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no"&gt;
 &lt;meta charset="utf-8"&gt;
 &lt;title&gt;首页&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;!-- vue的组件以自定义标签的形式使用 --&gt;
 &lt;favlist&gt;&lt;/favlist&gt;

 &lt;script src="../../output/static/main.ce853b65bcffc3b16328.js"&gt;&lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>然后用浏览器打开这个页面，你可以看到你写的代码正确的执行了。</p>
<p>那么问题来了，难道我们每次都要手动的引入输出的js文件吗？因为每次构建输出的js文件都带有 hash 值，如 main.ce853b65bcffc3b16328.js，就不能更智能一点吗？每次都自动写入？怎么会不可能，否则这东西还能火吗，要实现这个功能，我们就要使用webpack的插件了，html-webpack-plugin插件，这个插件可以创建html文件，并自动将依赖写入html文件中。</p>
<p>首先安装 html-webpack-plugin 插件：</p>
<p>代码如下：</p>
<pre>
<code>
npm install html-webpack-plugin --save-dev</code></pre>
<p>然后在修改配置项：</p>
<p>代码如下：</p>
<pre>
<code>
 // nodejs 中的path模块
var path = require('path');
var HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件
  entry: path.resolve(__dirname, '../app/index/index.js'),
  // 输出配置
  output: {
    // 输出路径是 myProject/output/static
    path: path.resolve(__dirname, '../output/static'),
    publicPath: 'static/',
    filename: '[name].[hash].js',
    chunkFilename: '[id].[chunkhash].js'
  },
  resolve: {
    extensions: ['', '.js', '.vue']
  },
  module: {
    
    loaders: [
      // 使用vue-loader 加载 .vue 结尾的文件
      {
        test: /\.vue$/, 
        loader: 'vue'  
      },
      {
        test: /\.js$/,
        loader: 'babel?presets=es2015',
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: '../index.html',
      template: path.resolve(__dirname, '../app/index/index.html'),
      inject: true
    })
  ]
}

</code></pre>
<p></p>
<p>然后再次执行构建命令，成功之后，看你的输出目录，多出来一个index.html文件，双击它，代码正确执行，你可以打开这个文件查看一下，webpack自动帮我们引入了相应的文件。</p>
<p>问题继续来了，难道每次我们都要构建之后才能查看运行的代码吗？那岂不是很没有效率，别担心，webpack提供了几种方式，进行热加载，在开发模式中，我们使用这种方式来提高效率，这里要介绍的，是使用webpack-dev-middleware中间件和webpack-hot-middleware中间件，首先安装两个中间件：</p>
<p></p>
<p>代码如下：</p>
<pre>
<code>
npm install webpack-dev-middleware webpack-hot-middleware --save-dev</code></pre>
<p>另外，还要安装express，这是一个nodejs框架</p>
<p>代码如下：</p>
<pre>
<code>
 npm install express --save-dev</code></pre>
<p>在开始之前，我先简单介绍一下这两个中间件，之所以叫做中间件，是因为nodejs的一个叫做express的框架中有中间件的概念，而这两个包要作为express中间件使用，所以称它们为中间件，那么他们能干什么呢？</p>
<h3>1、webpack-dev-middleware</h3>
<p>我们之前所面临的问题是，如果我们的代码改动了，我们要想看到浏览器的变化，需要先对项目进行构建，然后才能查看效果，这样对于开发效率来讲，简直就是不可忍受的一件事，试想我仅仅修改一个背景颜色就要构建一下项目，这尼玛坑爹啊，好在有webpack-dev-middleware中间件，它是对webpack一个简单的包装，它可以通过连接服务器服务那些从webpack发射出来的文件，它有一下几点好处：</p>
<p>1、不会向硬盘写文件，而是在内存中，注意我们构建项目实际就是向硬盘写文件。</p>
<p>2、当文件改变的时候，这个中间件不会再服务旧的包，你可以直接帅新浏览器就能看到最新的效果，这样你就不必等待构建的时间，所见即所得。</p>
<p>下面我们在build目录中创建一个 dev-server.js 的文件，并写入一下内容：</p>
<p>代码如下：</p>
<pre>
<code>
 // 引入必要的模块
var express = require('express')
var webpack = require('webpack')
var config = require('./webpack.config')

// 创建一个express实例
var app = express()

// 调用webpack并把配置传递过去
var compiler = webpack(config)

// 使用 webpack-dev-middleware 中间件
var devMiddleware = require('webpack-dev-middleware')(compiler, {
  publicPath: config.output.publicPath,
  stats: {
    colors: true,
    chunks: false
  }
})

// 注册中间件
app.use(devMiddleware)

// 监听 8888端口，开启服务器
app.listen(8888, function (err) {
  if (err) {
    console.log(err)
    return
  }
  console.log('Listening at http://localhost:8888')
})

</code></pre>
<p>此时，我们在项目根目录运行下面的命令，开启服务：</p>
<p>代码如下：</p>
<pre>
<code>
 node build/dev-server.js</code></pre>
<p>如果看到下图所示，证明你的服务成功开启了：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/201704050933228.jpg" /></p>
<p>接下来打开浏览器，输入：http://localhost:8888/app/index/index.html</p>
<p>回车，如果不出意外，你应该得到一个404，如下图：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/201704050933229.jpg" /></p>
<p>我们要对我们的 webpack.config.js 配置文件做两处修改：</p>
<p>1、将 config.output.publicPath 修改为 &lsquo;/&lsquo;：</p>
<p>代码如下：</p>
<pre>
<code>
 output: {
  // 输出路径是 myProject/output/static
  path: path.resolve(__dirname, '../output/static'),
  publicPath: '/',
  filename: '[name].[hash].js',
  chunkFilename: '[id].[chunkhash].js'
}, </code></pre>
<p>2、将 plugins 中 HtmlWebpackPlugin 中的 filename 修改为 &lsquo;app/index/index.html&#39;</p>
<p>代码如下：</p>
<pre>
<code>
 plugins: [
  new HtmlWebpackPlugin({
    filename: 'app/index/index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
]</code></pre>
<p>重启服务，再刷新页面，如果看到如下界面，证明你成功了：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/2017040509332210.jpg" /></p>
<p>但是这样开发模式下的确是成功了，可是我们直接修改了 webpack.config.js 文件，这就意味着当我们执行 构建命令 的时候，配置变了，那么我们的构建也跟着变了，所以，一个好的方式是，不去修改webpack.config.js文件，我们在build目录下新建一个 webpack.dev.conf.js文件，意思是开发模式下要读取的配置文件，并写入一下内容：</p>
<p>代码如下：</p>
<pre>
<code>
 var HtmlWebpackPlugin = require('html-webpack-plugin')
var path = require('path');
// 引入基本配置
var config = require('./webpack.config');

config.output.publicPath = '/';

config.plugins = [
  new HtmlWebpackPlugin({
    filename: 'app/index/index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
];

module.exports = config;

</code></pre>
<p>这样，我们在dev环境下的配置文件中覆盖了基本配置文件，我们只需要在dev-server.js中将</p>
<p>代码如下：</p>
<pre>
<code>
 var config = require('./webpack.config')</code></pre>
<p>修改为：</p>
<p>代码如下：</p>
<pre>
<code>
 var config = require('./webpack.dev.conf')</code></pre>
<p>即可，然后，重启服务，刷新浏览器，你应该得到同样的成功结果，而这一次当我们执行构建命令：</p>
<p>代码如下：</p>
<pre>
<code>
 webpack --display-modules --display-chunks --config build/webpack.config.js</code></pre>
<p>并不会影响构建输出，因为我们没有直接修改webpack.config.js文件。</p>
<p>现在我们已经使用 webpack-dev-middleware 搭建基本的开发环境了，但是我们并不满足，因为我们每次都要手动去刷新浏览器，所谓的热加载，意思就是说能够追踪我们代码的变化，并自动更新界面，甚至还能保留程序状态。要完成热加载，我们就需要使用另外一个中间件 webpack-hot-middleware</p>
<h3>2、webpack-hot-middleware</h3>
<p>webpack-hot-middleware 只配合 webpack-dev-middleware 使用，它能给你提供热加载。</p>
<p>它的使用很简单，总共分4步：</p>
<p>1、安装，我们上面已经安装过了2、在 webpack.dev.conf.js 配置文件中添加三个插件，如下：</p>
<p>代码如下：</p>
<pre>
<code>
 var HtmlWebpackPlugin = require('html-webpack-plugin')
var path = require('path');
var webpack = require('webpack');
// 引入基本配置
var config = require('./webpack.config');

config.output.publicPath = '/';

config.plugins = [
  // 添加三个插件
  new webpack.optimize.OccurenceOrderPlugin(),
  new webpack.HotModuleReplacementPlugin(),
  new webpack.NoErrorsPlugin(),

  new HtmlWebpackPlugin({
    filename: 'app/index/index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
];

module.exports = config;
</code></pre>
<p>3、在 webpack.config.js 文件中入口配置中添加 &lsquo;webpack-hot-middleware/client&#39;，如下：</p>
<p></p>
<div class="codetitle"><u>复制代码</u> 代码如下:</div>
<div class="codebody" id="code38766">entry: [&#39;webpack-hot-middleware/client&#39;, path.resolve(__dirname, &#39;../app/index/index.js&#39;)],</div>
<p></p>
<p>4、在 dev-server.js 文件中使用插件</p>
<p>代码如下：</p>
<pre>
<code>
 // 引入必要的模块
var express = require('express')
var webpack = require('webpack')
var config = require('./webpack.dev.conf')

// 创建一个express实例
var app = express()

// 调用webpack并把配置传递过去
var compiler = webpack(config)

// 使用 webpack-dev-middleware 中间件
var devMiddleware = require('webpack-dev-middleware')(compiler, {
  publicPath: config.output.publicPath,
  stats: {
    colors: true,
    chunks: false
  }
})

// 使用 webpack-hot-middleware 中间件
var hotMiddleware = require('webpack-hot-middleware')(compiler)

// 注册中间件
app.use(devMiddleware)
// 注册中间件
app.use(hotMiddleware)

// 监听 8888端口，开启服务器
app.listen(8888, function (err) {
  if (err) {
    console.log(err)
    return
  }
  console.log('Listening at http://localhost:8888')
})
</code></pre>
<p>ok，现在重启的服务，然后修改 Favlist.vue 中的页面背景颜色为 &lsquo;#000&#39;：</p>
<p>代码如下：</p>
<pre>
<code>
 &lt;style&gt;
  html{
    background: #000;
  }
&lt;/style&gt;</code></pre>
<p>然后查看你的浏览器，是不是你还没有刷新就已经得带改变了？</p>
<p>那么这样就完美了吗？还没有，如果你细心，你会注意到，我们上面在第2步中修改了 webpack.config.js 这个基本配置文件，修改了入口配置，如下：</p>
<p></p>
<div class="codetitle"><u>复制代码</u> 代码如下:</div>
<div class="codebody" id="code38766">entry: [&#39;webpack-hot-middleware/client&#39;, path.resolve(__dirname, &#39;../app/index/index.js&#39;)],</div>
<p></p>
<p>这也会导致我们之前讨论过的问题，就是会影响构建，所以我们不要直接修改 webpack.config.js 文件，我们还是在 webpack.dev.conf.js 文件中配置，如下：</p>
<p>代码如下：</p>
<pre>
<code>
var HtmlWebpackPlugin = require('html-webpack-plugin')
var path = require('path');
var webpack = require('webpack');
// 引入基本配置
var config = require('./webpack.config');

config.output.publicPath = '/';

config.plugins = [
  new webpack.optimize.OccurenceOrderPlugin(),
  new webpack.HotModuleReplacementPlugin(),
  new webpack.NoErrorsPlugin(),
  new HtmlWebpackPlugin({
    filename: 'app/index/index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
];

// 动态向入口配置中注入 webpack-hot-middleware/client
var devClient = 'webpack-hot-middleware/client';
Object.keys(config.entry).forEach(function (name, i) {
  var extras = [devClient]
  config.entry[name] = extras.concat(config.entry[name])
})

module.exports = config;

</code></pre>
<p>但是我们还是要讲 webpack.config.js 文件中的入口配置修改为多入口配置的方式，这个修改不会影响构建，所以无所谓：</p>
<p>代码如下：</p>
<pre>
<code>
 entry: {
  index: path.resolve(__dirname, '../app/index/index.js')
},</code></pre>
<p>重启你的服务，刷新一下浏览器，然后修改 Favlist.vue 中的背景色为 green：</p>
<p>代码如下：</p>
<pre>
<code>
 &lt;style&gt;
  html{
    background: green;
  }
&lt;/style&gt;</code></pre>
<p>再次查看浏览器，发现可以热加载。但是这样就结束了吗？还没有，不信你修改 index.html 文件，看看会不会热加载，实际上不会，你还是需要手动刷新页面，为了能够当 index.html 文件的改动也能够触发自动刷新，我们还需要做一些工作。</p>
<h3>第一步：在 dev-server.js 文件中监听html文件改变事件，修改后的 dev-server.js 文件如下：</h3>
<p>代码如下：</p>
<pre>
<code>
 // 引入必要的模块
var express = require('express')
var webpack = require('webpack')
var config = require('./webpack.dev.conf')

// 创建一个express实例
var app = express()

// 调用webpack并把配置传递过去
var compiler = webpack(config)

// 使用 webpack-dev-middleware 中间件
var devMiddleware = require('webpack-dev-middleware')(compiler, {
  publicPath: config.output.publicPath,
  stats: {
    colors: true,
    chunks: false
  }
})

var hotMiddleware = require('webpack-hot-middleware')(compiler)

// webpack插件，监听html文件改变事件
compiler.plugin('compilation', function (compilation) {
  compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {
    // 发布事件
    hotMiddleware.publish({ action: 'reload' })
    cb()
  })
})

// 注册中间件
app.use(devMiddleware)
// 注册中间件
app.use(hotMiddleware)

// 监听 8888端口，开启服务器
app.listen(8888, function (err) {
  if (err) {
    console.log(err)
    return
  }
  console.log('Listening at http://localhost:8888')
})

</code></pre>
<p>从上面的代码中可以看到，我们增加了如下代码：</p>
<p>代码如下：</p>
<pre>
<code>
 // webpack插件，监听html文件改变事件
compiler.plugin('compilation', function (compilation) {
  compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {
    // 发布事件
    hotMiddleware.publish({ action: 'reload' })
    cb()
  })
})</code></pre>
<p>这段代码可能你看不懂，因为这涉及到webpack插件的编写，读者可以参阅下面的连接：</p>
<p>webpack 插件doc1</p>
<p>webpack 插件doc2</p>
<p>在这段代码中，我们监听了 &lsquo;html-webpack-plugin-after-emit&#39; 事件，那么这个事件是从哪里发射的呢？我们通过名字可知，这个事件应该和html-webpack-plugin这个插件有关，在npm搜索html-webpack-plugin 插件，在页面最底部我们可以发现如下图：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/2017040509332211.jpg" /></p>
<p>我们可以看到，html-webpack-plugin 这个插件的确提供了几个可选的事件，下面也提供了使用方法，这样，我们就能够监听到html文件的变化，然后我们使用下面的代码发布一个事件：</p>
<p>代码如下：</p>
<pre>
<code>
hotMiddleware.publish({ action: 'reload' })</code></pre>
<p>第二步：修改 webpack.dev.conf.js 文件如下：</p>
<p>代码如下：</p>
<pre>
<code>
 var HtmlWebpackPlugin = require('html-webpack-plugin')
var path = require('path');
var webpack = require('webpack');
// 引入基本配置
var config = require('./webpack.config');

config.output.publicPath = '/';

config.plugins = [
  new webpack.optimize.OccurenceOrderPlugin(),
  new webpack.HotModuleReplacementPlugin(),
  new webpack.NoErrorsPlugin(),
  new HtmlWebpackPlugin({
    filename: 'app/index/index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
];

// var devClient = 'webpack-hot-middleware/client';
var devClient = './build/dev-client';
Object.keys(config.entry).forEach(function (name, i) {
  var extras = [devClient]
  config.entry[name] = extras.concat(config.entry[name])
})

module.exports = config;

</code></pre>
<p>我们修改了devClient变量，将 &lsquo;webpack-hot-middleware/client&#39; 替换成 &lsquo;./build/dev-client&#39;，最终会导致，我们入口配置会变成下面这样：</p>
<p>代码如下：</p>
<pre>
<code>
 entry: {
  index: [
    './build/dev-client',
    path.resolve(__dirname, '../app/index/index.js')
  ]
},</code></pre>
<p>第三步：新建 build/dev-client.js 文件，并编辑如下内容：</p>
<p>代码如下：</p>
<pre>
<code>
 var hotClient = require('webpack-hot-middleware/client')

// 订阅事件，当 event.action === 'reload' 时执行页面刷新
hotClient.subscribe(function (event) {
  if (event.action === 'reload') {
    window.location.reload()
  }
})
</code></pre>
<p>这里我们除了引入 &lsquo;webpack-hot-middleware/client&#39; 之外订阅了一个事件，当 event.action === &lsquo;reload&#39; 时触发，还记得我们在 dev-server.js 中发布的事件吗：</p>
<p>代码如下：</p>
<pre>
<code>
hotMiddleware.publish({ action: 'reload' })</code></pre>
<p>这样，当我们的html文件改变后，就可以监听的到，最终会执行页面刷新，而不需要我们手动刷新，现在重启服务，去尝试能否对html文件热加载吧。答案是yes。好了，开发环境终于搞定了，下面我们再来谈一谈生产环境，也就是构建输出，我们现在可以执行一下构建命令，看看输出的内容是什么，为了不必每次都要输入下面这条长命令：</p>
<p></p>
<div class="codetitle"><u>复制代码</u> 代码如下:</div>
<div class="codebody" id="code8453">webpack --display-modules --display-chunks --config build/webpack.config.js</div>
<p></p>
<p>我们在 package.js 文件中添加 &ldquo;scripts&rdquo; 项，如下图：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/2017040509332212.jpg" /></p>
<p>这样，我们就可以通过执行下面命令来进行构建，同时我们还增加了一条开启开发服务器的命令：</p>
<p>代码如下：</p>
<pre>
<code>
 // 构建
npm run build
// 开启开发服务器
npm run dev</code></pre>
<p>回过头来，我们执行构建命令： npm run build，查看输出内容，如下图：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/2017040509332213.jpg" /></p>
<p>现在我们只有一个js文件输出了，并没有css文件输出，在生产环境，我们希望css文件生成单独的文件，所以我们要使用 extract-text-webpack-plugin 插件，安装：</p>
<p>代码如下：</p>
<pre>
<code>
 npm install extract-text-webpack-plugin --save-dev</code></pre>
<p>然后在build目录下新建 webpack.prod.conf.js 文件，顾名思义，这个使我们区别于开发环境，用于生产环境的配置文件，并编辑一下内容：</p>
<p>代码如下：</p>
<pre>
<code>
 var HtmlWebpackPlugin = require('html-webpack-plugin')
var ExtractTextPlugin = require('extract-text-webpack-plugin')
var path = require('path');
var webpack = require('webpack');
// 引入基本配置
var config = require('./webpack.config');

config.vue = {
  loaders: {
    css: ExtractTextPlugin.extract("css")
  }
};

config.plugins = [
  // 提取css为单文件
  new ExtractTextPlugin("../[name].[contenthash].css"),

  new HtmlWebpackPlugin({
    filename: '../index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
];

module.exports = config;

</code></pre>
<p>上面的代码中，我们覆盖了 webpack.config.js 配置文件的 config.plugins 项，并且添加了 config.vue 项，补血药知道为什么，就是这么用的，如果一定要知道为什么也可以，这需要你多去了解vue以及vue-loader的工作原理.</p>
<p>然后修改 package.json 文件中的 script 项为如下：</p>
<p>代码如下：</p>
<pre>
<code>
 "scripts": {
  "build": "webpack --display-modules --display-chunks --config build/webpack.prod.conf.js",
  "dev": "node ./build/dev-server.js"
},</code></pre>
<p>我们使用 webpack.prod.conf.js 为配置去构建，接下来执行：</p>
<p>代码如下：</p>
<pre>
<code>
npm run build</code></pre>
<p>查看你的输出内容，如下图，css文件未提取出来了：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/2017040509332214.jpg" /></p>
<p>另外我们还可以添加如下插件在我们的 webpack.prod.conf.js 文件中，作为生产环境使用：</p>
<p>代码如下：</p>
<pre>
<code>
 config.plugins = [
  new webpack.DefinePlugin({
    'process.env': {
      NODE_ENV: '"production"'
    }
  }),
  // 压缩代码
  new webpack.optimize.UglifyJsPlugin({
    compress: {
      warnings: false
    }
  }),
  new webpack.optimize.OccurenceOrderPlugin(),
  // 提取css为单文件
  new ExtractTextPlugin("../[name].[contenthash].css"),
  new HtmlWebpackPlugin({
    filename: '../index.html',
    template: path.resolve(__dirname, '../app/index/index.html'),
    inject: true
  })
];
</code></pre>
<p>大家可以搜索这些插件，了解他的作用，这篇文章要介绍的太多，所以我一一讲解了。</p>
<p>到这里实际上搭建的已经差不多了，唯一要做的就是完善，比如公共模块的提取，如何加载图片，对于第一个问题，如何提取公共模块，我们可以使用 CommonsChunkPlugin 插件，在 webpack.prod.conf.js 文件中添加如下插件：</p>
<p>代码如下：</p>
<pre>
<code>
 new webpack.optimize.CommonsChunkPlugin({
  name: 'vendors',
  filename: 'vendors.js',
}),</code></pre>
<p>然后在 webpack.config.js 文件中配置入口文件：</p>
<p>代码如下：</p>
<pre>
<code>
 entry: {
  index: path.resolve(__dirname, '../app/index/index.js'),
  vendors: [
    'Vue'
  ]
},</code></pre>
<p>上面代码的意思是，我们把Vue.js当做公共模块单独打包，你可以在这个数组中增加其他模块，一起作为公共模块打包成一个文件，我们执行构建命令，然后查看输出，如下图，成功提取：</p>
<p><img alt="" src="//files.512pic.com/file_images/article/201704/2017040509332215.jpg" /></p>
<p>对于加载图片的问题，我们知道，webpack的哲学是一切皆是模块，然后通过相应的loader去加载，所以加载图片，我们就需要使用到 url-loader，在webpack.config.js 文件中添加一个loader配置：</p>
<p>代码如下：</p>
<pre>
<code>
 loaders: [
  // 使用vue-loader 加载 .vue 结尾的文件
  {
    test: /\.vue$/, 
    loader: 'vue'  
  },
  {
    test: /\.js$/,
    loader: 'babel?presets=es2015',
    exclude: /node_modules/
  },
  // 加载图片
  {
    test: /\.(png|jpg|gif|svg)$/,
    loader: 'url',
    query: {
      limit: 10000,
      name: '[name].[ext]?[hash:7]'
    }
  }
]</code></pre>
<p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持php教程。</p>

<p>注：关于分析基于webpack和vue.js搭建开发环境的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/115772.html'>Vue.js路由vue-router使用方法详解</a><a>下一篇</a><a href='/php/biji/115774.html'>Vue学习笔记进阶篇之函数化组件解析</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>