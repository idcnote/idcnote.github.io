<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>解析Linux内核的基本的模块管理与时间管理操作_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="内核模块管理<br />
<br />
Linux设备驱动会以内核模块的形式出现，因此学会编写Linux内核模块编程是学习linux设备驱动的先决条件。<br />
Linux内核的整体结构非常庞大，其包含的组件非常多。我" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">解析Linux内核的基本的模块管理与时间管理操作</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>内核模块管理<br />
<br />
Linux设备驱动会以内核模块的形式出现，因此学会编写Linux内核模块编程是学习linux设备驱动的先决条件。<br />
Linux内核的整体结构非常庞大，其包含的组件非常多。我</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p style="text-align: left"><strong>内核模块管理<br />
</strong>Linux设备驱动会以内核模块的形式出现，因此学会编写Linux内核模块编程是学习linux设备驱动的先决条件。</p>
<p style="text-align: left">Linux内核的整体结构非常庞大，其包含的组件非常多。我们把需要的功能都编译到linux内核,以模块方式扩展内核功能。</p>
<p style="text-align: left">先来看下最简单的内核模块<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
#include &lt;linux/init.h&gt; 
#include &lt;linux/module.h&gt; 
 
 
static int __init hello_init(void) 
{ 
    printk(KERN_ALERT "Hello world! %s, %d\n", __FILE__, __LINE__); 
    return 0; 
} 
 
static void __exit hello_exit(void) 
{ 
 
    printk(KERN_ALERT "Hello world! %s, %d\n", __FILE__, __LINE__); 
} 
 
module_init(hello_init); 
module_exit(hello_exit); 
 
MODULE_LICENSE("GPL"); 
MODULE_AUTHOR("Mikcy Liu"); 
MODULE_DESCRIPTION("A simple Module"); 
MODULE_ALIAS("a simple module"); 
</pre>
</div>
<p style="text-align: left">头文件init.h包含了宏_init和_exit，它们允许释放内核占用的内存。<br />
module_init()和hello_exit()是模块编程中最基本也是必须的两个函数。<br />
module_init()是驱动程序初始化的入口点。<br />
hello_exit是模块的退出和清理函数。此处可以做所有终止该驱动程序时相关的清理工作。</p>
<p style="text-align: left">内核模块中用于输出的函数式内核空间的printk()而非用户空间的printf(),printk()的用法和printf()相似，但前者可定义输出级别。printk()可作为一种最基本的内核调试手段</p>
<p style="text-align: left">前者可以定义输出级别,在 &lt;内核目录&gt;/include/linux/kernel.h中</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
#define KERN_EMERG   "&lt;0&gt;"  /* system is unusable          */ 
#define KERN_ALERT   "&lt;1&gt;"  /* action must be taken immediately   */ 
#define KERN_CRIT    "&lt;2&gt;"  /* critical conditions         */ 
#define KERN_ERR    "&lt;3&gt;"  /* error conditions           */ 
#define KERN_WARNING  "&lt;4&gt;"  /* warning conditions          */ 
#define KERN_NOTICE   "&lt;5&gt;"  /* normal but significant condition   */ 
#define KERN_INFO    "&lt;6&gt;"  /* informational            */ 
#define KERN_DEBUG   "&lt;7&gt;"  /* debug-level messages         */ 
</pre>
</div>
<p style="text-align: left">未设定级别的，在&lt;内核目录&gt;/kernel/printk.c中定义</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
/* printk's without a loglevel use this.. */ 
#define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */ 
 #define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */ 
</pre>
</div>
<p style="text-align: left">只有当printk打印信息时的loglevel小于DEFAULT_CONSOLE_LOGLEVEL的值（优先级高于console loglevel），这些信息才会被打印到console上。</p>
<p style="text-align: left">模块声明与描述</p>
<ul>
<li style="text-align: left">&nbsp;&nbsp; 在linux模块中，我们可以使用</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_LICENSE(license)&nbsp;&nbsp; //定义模块的license，一般为GPL，或相关公司的license</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_AUTHOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //模块的作者</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_DESCRIPTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //对模块程序的描述，string</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_VERSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //版本</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_DEVICE_TABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //模块程序所支持的设备，string</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_ALIAS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //别名</li>
<li style="text-align: left">&nbsp;&nbsp; MODULE_PARM(var,type)&nbsp;&nbsp;&nbsp;&nbsp; //模块参数</li>
</ul>
<p style="text-align: left"><strong>模块编译<br />
</strong>首先看看Makefile文件：</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
obj-m := hello.o 
KERNEL_BUILD := /lib/modules/$(shell uname -r)/build 
all: 
    make -C $(KERNEL_BUILD) M=$(shell pwd) modules 
clean: 
    -rm -rf *.o *.ko *.mod.c .*.cmd *.order *.symvers .tmpversions 
KERNELBUILD :=/lib/modules/$(shell uname -r)/

</pre>
</div>
<p style="text-align: left">build是编译内核模块需要的Makefile的路径，Ubuntu下是/lib/modules/2.6.31-14-generic/build</p>
<p style="text-align: left">如果是Arm平台的开发板,则-C选项指定的位置(即内核源代码目录),其中保存有内核的顶层Makefile文件.</p>
<p style="text-align: left">make -C $(KERNEL_BUILD) M=$(shell pwd) modules 编译内核模块。-C 将工作目录转到KERNEL_BUILD，调用该目录下的Makefile，并向这个Makefile传递参数M的值是$(shell pwd) modules。</p>
<p style="text-align: left">M=选项让该makefile在构造modules目标之前返回到模块源代码目录。然后modules目标指向obj-m变量中设定的模块</p>
<p style="text-align: left">执行make命令开始编译模块,生成hello.ko，执行make clean可清除编译产生的文件。</p>
<p style="text-align: left">1、添加模块</p>
<div class="phpstudycode">
<pre class="brush:bash;" style="text-align: left">
   insmod hello.ko

</pre>
</div>
<p style="text-align: left">2、查看模块</p>
<div class="phpstudycode">
<pre class="brush:bash;" style="text-align: left">
  lsmod | grep hello

</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp; lsmod命令实际上读取并分析/proc/modules文件，也可以cat /proc/modules文件</p>
<p style="text-align: left">&nbsp;&nbsp; 在模块所在目录下执行</p>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; modinfo&nbsp; hello.ko可以查看模块信息,如下所示</p>
<div class="phpstudycode">
<pre class="brush:plain;" style="text-align: left">
filename:    hello.ko
alias:     a simple module
description:  A simple Module
author:     Mikcy Liu
license:    GPL
srcversion:   875C95631F4F336BBD4216C
depends:    
vermagic:    3.5.0-17-generic SMP mod_unload modversions 686

</pre>
</div>
<p style="text-align: left">3、删除模块</p>
<div class="phpstudycode">
<pre class="brush:bash;" style="text-align: left">
 rmmod hello
</pre>
</div>
<p style="text-align: left"><br />
<strong>模块加载函数</strong></p>
<p style="text-align: left">Linux内核模块加载函数一般以__init标识声明，典型的模块加载函数的形式如下：</p>
<div class="phpstudycode">
<pre class="brush:bash;" style="text-align: left">
static int __init initialization_function(void) { 
   //初始化代码  
}  
module_init(initialization_function); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 模块加载函数必须以“module_init(函数名)”的形式指定。它返回整形值，若初始化成功，应返回0。而在初始化失败时。应该返回错误编码。</p>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 在linux内核里，错误编码是一个负值，在&lt;linux/errno.h&gt;中定义，包含-ENODEV、-ENOMEM之类的符号值。返回相应的错误编码是种非常好的习惯，因为只有这样，用户程序才可以利用perror等方法把它们转换成有意义的错误信息字符串。</p>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 在linux2.6内核中，所有标识为__init的函数在连接的时候都会放在.init.text（这是module_init宏在目标代码中增加的一个特殊区段，用于说明内核初始化函数的所在位置）这个区段中，此外，所有的__init函数在区段.initcall.init中还保存着一份函数指针，在初始化时内核会通过这些函数指针调用这些__init函数，并在初始化完成后释放init区段（包括.init.text和.initcall.init等）。所以大家应注意不要在结束初始化后仍要使用的函数上使用这个标记。</p>
<p style="text-align: left"><strong>模块卸载函数</strong></p>
<p style="text-align: left">Linux内核卸载模块函数一般以__exit标识声明，典型的模块卸载函数的形式如下：</p>
<div class="phpstudycode">
<pre class="brush:bash;" style="text-align: left">
static void __exit cleanup_function(void) {   
 //释放代码  
}  
module_exit(cleanup_function); 
</pre>
</div>
<p style="text-align: left">模块卸载函数在模块卸载时被调用，不返回任何值，必须以”module_exit(函数名)”的形式来指定<br />
与__init一样__exit也可以使对应函数在运行完成后自动回收内存。</p>
<p style="text-align: left">一般来说，模块卸载函数完成与模块加载函数相反的功能： <br />
如果模块加载函数注册了 XXX模块，则模块卸载函数应注销XXX。<br />
若模块加载函数动体申请了内存，则模块卸载函数应释放该内存。<br />
若模块加载函数申请了硬件资源，则模块卸载函数应释放这些硬件资源。 <br />
若模块加载函数开启了硬件，则模块卸载函数应关闭硬件。</p>
<p style="text-align: left"><br />
<strong>内核时间管理<br />
</strong>(1)内核中的时间概念 <br />
&nbsp;&nbsp;&nbsp; 时间管理在linux内核中占有非常重要的作用。 <br />
&nbsp;&nbsp;&nbsp; 相对于事件驱动而言，内核中有大量函数是基于时间驱动的。 <br />
&nbsp;&nbsp;&nbsp; 有些函数是周期执行的，比如每10毫秒刷新一次屏幕； <br />
&nbsp;&nbsp;&nbsp; 有些函数是推后一定时间执行的，比如内核在500毫秒后执行某项任务。 <br />
&nbsp;&nbsp;&nbsp; 要区分： <br />
&nbsp;&nbsp;&nbsp; *绝对时间和相对时间 <br />
&nbsp;&nbsp;&nbsp; *周期性产生的事件和推迟执行的事件 <br />
&nbsp;&nbsp;&nbsp; 周期性事件是由系统系统定时器驱动的 <br />
&nbsp;<br />
(2)HZ值 <br />
&nbsp;&nbsp;&nbsp; 内核必须在硬件定时器的帮助下才能计算和管理时间。 <br />
&nbsp;&nbsp;&nbsp; 定时器产生中断的频率称为节拍率(tick rate)。 <br />
&nbsp;&nbsp;&nbsp; 在内核中指定了一个变量HZ，内核初始化的时候会根据这个值确定定时器的节拍率。 <br />
&nbsp;&nbsp;&nbsp; HZ定义在&lt;asm/param.h&gt;，在i386平台上，目前采用的HZ值是1000。 <br />
&nbsp;&nbsp;&nbsp; 也就是时钟中断每秒发生1000次，周期为1毫秒。即： <br />
&nbsp;&nbsp;&nbsp; #define HZ 1000 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; 注意！HZ不是个固定不变的值，它是可以更改的，可以在内核源代码配置的时候输入。 <br />
&nbsp;&nbsp;&nbsp; 不同的体系结构其HZ值是不一样的，比如arm就采用100。 <br />
&nbsp;&nbsp;&nbsp; 如果在驱动中要使用系统的中断频率，直接使用HZ，而不要用100或1000 <br />
&nbsp;<br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; a.理想的HZ值 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i386的HZ值一直采用100，直到2.5版后才改为1000。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提高节拍率意味着时钟中断产生的更加频繁，中断处理程序也会更频繁地执行。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 带来的好处有： <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *内核定时器能够以更高的频率和更高的准确度运行 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *依赖定时器执行的系统调用，比如poll()和select()，运行的精度更高 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *提高进程抢占的准确度 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (缩短了调度延时，如果进程还剩2ms时间片，在10ms的调度周期下，进程会多运行8ms。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于耽误了抢占，对于一些对时间要求严格的任务会产生影响) <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 坏处有： <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *节拍率要高，系统负担越重。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中断处理程序将占用更多的处理器时间。 <br />
&nbsp;<br />
&nbsp;(3)jiffies <br />
&nbsp;&nbsp;&nbsp; 全局变量jiffies用于记录系统启动以来产生的节拍的总数。 <br />
&nbsp;&nbsp;&nbsp; 启动时，jiffies初始化为0，此后每次时钟中断处理程序都会增加该变量的值。 <br />
&nbsp;&nbsp;&nbsp; 这样，系统启动后的运行时间就是jiffies/HZ秒 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; jiffies定义于&lt;linux/jiffies.h&gt;中： <br />
&nbsp;&nbsp;&nbsp; extern unsigned long volatile jiffies; <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; jiffies变量总是为unsigned long型。 <br />
&nbsp;&nbsp;&nbsp; 因此在32位体系结构上是32位，而在64位体系上是64位。 <br />
&nbsp;&nbsp;&nbsp; 对于32位的jiffies，如果HZ为1000，49.7天后会溢出。 <br />
&nbsp;&nbsp;&nbsp; 虽然溢出的情况不常见，但程序在检测超时时仍然可能因为回绕而导致错误。 <br />
&nbsp;&nbsp;&nbsp; linux提供了4个宏来比较节拍计数，它们能正确地处理节拍计数回绕。&nbsp;<br />
&nbsp;<br />
&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  #include &lt;linux/jiffies.h&gt; 
  #define time_after(unknown, known)    // unknow &gt; known 
  #define time_before(unknown, known)   // unknow &lt; known 
  #define time_after_eq(unknown, known)  // unknow &gt;= known 
  #define time_before_eq(unknown, known)  // unknow &lt;= known 
 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; unknown通常是指jiffies，known是需要对比的值(常常是一个jiffies加减后计算出的相对值) <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; 例：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  unsigned long timeout = jiffies + HZ/2; /* 0.5秒后超时 */ 
  ... 
  if(time_before(jiffies, timeout)){ 
    /* 没有超时，很好 */ 
  }else{ 
    /* 超时了，发生错误 */ 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp; time_before可以理解为如果在超时(timeout)之前(before)完成 <br />
&nbsp;<br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; *系统中还声明了一个64位的值jiffies_64，在64位系统中jiffies_64和jiffies是一个值。 <br />
&nbsp;&nbsp;&nbsp; 可以通过get_jiffies_64()获得这个值。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; *使用&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  u64 j2; 
    j2 = get_jiffies_64(); 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;(4)获得当前时间 <br />
&nbsp;&nbsp;&nbsp; 驱动程序中一般不需要知道墙钟时间(也就是年月日的时间)。但驱动可能需要处理绝对时间。 <br />
&nbsp;&nbsp;&nbsp; 为此，内核提供了两个结构体，都定义在&lt;linux/time.h&gt;：&nbsp;<br />
</p>
<p style="text-align: left">a.</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  struct timeval { 
   time_t tv_sec; /* seconds */ 
   suseconds_t tv_usec; /* microseconds */ 
  }; 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 较老，但很流行。采用秒和毫秒值，保存了1970年1月1日0点以来的秒数&nbsp;</p>
<p style="text-align: left">b.<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  struct timespec { 
   time_t tv_sec; /* seconds */ 
   long tv_nsec; /* nanoseconds */ 
  }; 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 较新，采用秒和纳秒值保存时间。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; c.do_gettimeofday() <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该函数用通常的秒或微秒来填充一个指向struct timeval的指针变量，原型如下：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    #include &lt;linux/time.h&gt; 
    void do_gettimeofday(struct timeval *tv); 
 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; d.current_kernel_time() <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该函数可用于获得timespec&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
#include &lt;linux/time.h&gt; 
    struct timespec current_kernel_time(void);
</pre>
</div>
<p style="text-align: left"><br />
<strong>确定时间的延迟执行&nbsp;<br />
</strong>&nbsp;&nbsp;&nbsp; 设备驱动程序经常需要将某些特定代码延迟一段时间后执行，通常是为了让硬件能完成某些任务。 <br />
&nbsp;&nbsp;&nbsp; 长于定时器周期(也称为时钟嘀嗒)的延迟可以通过使用系统时钟完成，而非常短的延时则通过软件循环的方式完成 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />
&nbsp;<br />
(1)短延时 <br />
&nbsp;&nbsp;&nbsp; 对于那些最多几十个毫秒的延迟，无法借助系统定时器。 <br />
&nbsp;&nbsp;&nbsp; 系统通过软件循环提供了下面的延迟函数：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  #include &lt;linux/delay.h&gt; 
  /* 实际在&lt;asm/delay.h&gt; */ 
  void ndelay(unsigned long nsecs); /*延迟纳秒 */ 
  void udelay(unsigned long usecs); /*延迟微秒 */ 
  void mdelay(unsigned long msecs); /*延迟毫秒 */ 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp; 这三个延迟函数均是忙等待函数，在延迟过程中无法运行其他任务。 <br />
&nbsp;<br />
(2)长延时 <br />
&nbsp;&nbsp;&nbsp; a.在延迟到期前让出处理器&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    while(time_before(jiffies, j1)) 
      schedule(); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在等待期间可以让出处理器，但系统无法进入空闲模式(因为这个进程始终在进行调度)，不利于省电。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; b.超时函数&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    #include &lt;linux/sched.h&gt; 
    signed long schedule_timeout(signed long timeout); 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp; 使用方式：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  set_current_state(TASK_INTERRUPTIBLE); 
  schedule_timeout(2*HZ); /* 睡2秒 */ 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 进程经过2秒后会被唤醒。如果不希望被用户空间打断，可以将进程状态设置为TASK_UNINTERRUPTIBLE。</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
#include &lt;linux/init.h&gt; 
#include &lt;linux/module.h&gt; 
#include &lt;linux/time.h&gt; 
#include &lt;linux/sched.h&gt; 
#include &lt;linux/delay.h&gt; 
 
static int __init test_init(void) 
{ 
  set_current_state(TASK_INTERRUPTIBLE); 
  schedule_timeout(5 * HZ); 
  printk(KERN_INFO "Hello Micky\n"); 
  return 0; 
} 
 
static void __exit test_exit(void) 
{ 
} 
 
module_init(test_init); 
module_exit(test_exit); 
 
MODULE_LICENSE("GPL"); 
MODULE_AUTHOR("Micky Liu"); 
MODULE_DESCRIPTION("Test for delay"); 

</pre>
</div>
<p style="text-align: left"><br />
(3)等待队列 <br />
&nbsp;&nbsp;&nbsp; 使用等待队列也可以实现长延迟。 <br />
&nbsp;&nbsp;&nbsp; 在延迟期间，当前进程在等待队列中睡眠。 <br />
&nbsp;&nbsp;&nbsp; 进程在睡眠时，需要根据所等待的事件链接到某一个等待队列。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; a.声明等待队列 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 等待队列实际上就是一个进程链表，链表中包含了等待某个特定事件的所有进程。&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    #include &lt;linux/wait.h&gt; 
    struct __wait_queue_head { 
      spinlock_t lock; 
      struct list_head task_list; 
    }; 
    typedef struct __wait_queue_head wait_queue_head_t; 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要想把进程加入等待队列，驱动首先要在模块中声明一个等待队列头，并将它初始化。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 静态初始化&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    DECLARE_WAIT_QUEUE_HEAD(name); 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 动态初始化&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
      wait_queue_head_t my_queue; 
      init_waitqueue_head(&my_queue); 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp; b.等待函数 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 进程通过调用下面函数可以在某个等待队列中休眠固定的时间：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    #include &lt;linux/wait.h&gt; 
    long wait_event_timeout(wait_queue_head_t q,condition, long timeout); 
    long wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);</pre>
</div>
<p style="text-align: left"><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调用这两个函数后，进程会在给定的等待队列q上休眠，但会在超时(timeout)到期时返回。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果超时到期，则返回0，如果进程被其他事件唤醒，则返回剩余的时间数。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果没有等待条件，则将condition设为0 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用方式：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    wait_queue_head_t wait; 
    init_waitqueue_head(&wait); 
    wait_event_interruptible_timeout(wait, 0, 2*HZ); 
    /*当前进程在等待队列wait中睡2秒 */ 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;<br />
&nbsp;<br />
(4)内核定时器 <br />
&nbsp;&nbsp;&nbsp; 还有一种将任务延迟执行的方法是采用内核定时器。 <br />
&nbsp;&nbsp;&nbsp; 与前面几种延迟方法不同，内核定时器并不会阻塞当前进程， <br />
&nbsp;&nbsp;&nbsp; 启动一个内核定时器只是声明了要在未来的某个时刻执行一项任务，当前进程仍然继续执行。 <br />
&nbsp;&nbsp;&nbsp; 不要用定时器完成硬实时任务 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; 定时器由结构timer_list表示，定义在&lt;linux/timer.h&gt;&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  struct timer_list{ 
    struct list_head entry; /* 定时器链表 */ 
    unsigned long expires; /* 以jiffies为单位的定时值 */ 
    spinlock_t lock; 
    void(*function)(unsigned long); /* 定时器处理函数 */ 
    unsigned long data; /* 传给定时器处理函数的参数 */ 
  } 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp; 内核在&lt;linux/timer.h&gt;中提供了一系列管理定时器的接口。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; a.创建定时器&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    struct timer_list my_timer; 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp; b.初始化定时器&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    init_timer(&my_timer); 
    /* 填充数据结构 */ 
    my_timer.expires = jiffies + delay; 
    my_timer.data = 0; 
    my_timer.function = my_function; /*定时器到期时调用的函数*/ 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp; c.定时器的执行函数 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 超时处理函数的原型如下：&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    void my_timer_function(unsigned long data); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以利用data参数用一个处理函数处理多个定时器。可以将data设为0 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; d.激活定时器&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    add_timer(&my_timer); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定时器一旦激活就开始运行。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; e.更改已激活的定时器的超时时间&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    mod_timer(&my_timer, jiffies+ney_delay); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以用于那些已经初始化但还没激活的定时器， <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果调用时定时器未被激活则返回0，否则返回1。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一旦mod_timer返回，定时器将被激活。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; f.删除定时器&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
    del_timer(&my_timer); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 被激活或未被激活的定时器都可以使用，如果调用时定时器未被激活则返回0，否则返回1。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不需要为已经超时的定时器调用，它们被自动删除 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; g.同步删除&nbsp;<br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
  del_time_sync(&my_timer); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp; 在smp系统中，确保返回时，所有的定时器处理函数都退出。不能在中断上下文使用。&nbsp;<br />
&nbsp;&nbsp;&nbsp; <br />
</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
#include &lt;linux/init.h&gt; 
#include &lt;linux/module.h&gt; 
#include &lt;linux/time.h&gt; 
#include &lt;linux/sched.h&gt; 
#include &lt;linux/delay.h&gt; 
#include &lt;linux/timer.h&gt; 
 
struct timer_list my_timer; 
 
static void timer_handler(unsigned long arg) 
{ 
  printk(KERN_INFO "%s %d Hello Micky! arg=%lu\n",__func__, __LINE__, arg ); 
} 
 
static int __init test_init(void) 
{ 
  init_timer(&my_timer); 
 
  my_timer.expires = jiffies + 5 * HZ; 
  my_timer.function = timer_handler; 
  my_timer.data = 10; 
  add_timer(&my_timer); 
 
  return 0; 
} 
 
static void __exit test_exit(void) 
{ 
  del_timer(&my_timer); 
} 
 
module_init(test_init); 
module_exit(test_exit); 
 
MODULE_LICENSE("GPL"); 
MODULE_AUTHOR("Micky Liu"); 
MODULE_DESCRIPTION("Test for timer"); 

#include &lt;linux/init.h&gt; 
#include &lt;linux/module.h&gt; 
#include &lt;linux/time.h&gt; 
#include &lt;linux/sched.h&gt; 
#include &lt;linux/delay.h&gt; 
#include &lt;linux/timer.h&gt; 
 
struct timer_list my_timer; 
 
static void timer_handler(unsigned long arg) 
{ 
  printk(KERN_INFO "%s %d Hello Micky! arg=%lu\n",__func__, __LINE__, arg ); 
} 
 
static int __init test_init(void) 
{ 
  init_timer(&my_timer); 
 
  //my_timer.expires = jiffies + 5 * HZ; 
  my_timer.function = timer_handler; 
  my_timer.data = 10;  
  //add_timer(&my_timer); 
  mod_timer(&my_timer, jiffies + 5 * HZ); 
 
  return 0; 
} 
 
static void __exit test_exit(void) 
{ 
  del_timer(&my_timer); 
} 
 
module_init(test_init); 
module_exit(test_exit); 
 
MODULE_LICENSE("GPL"); 
MODULE_AUTHOR("Micky Liu"); 
MODULE_DESCRIPTION("Test for timer"); 

</pre>
</div>
<p style="text-align: left"><strong>&nbsp;<br />
不确定时间的延迟执行 <br />
</strong>(1)什么是不确定时间的延迟 <br />
&nbsp;&nbsp;&nbsp; 前面介绍的是确定时间的延迟执行，但在写驱动的过程中经常遇到这种情况： <br />
&nbsp;&nbsp;&nbsp; 用户空间程序调用read函数从设备读数据，但设备中当前没有产生数据。 <br />
&nbsp;&nbsp;&nbsp; 此时，驱动的read函数默认的操作是进入休眠，一直等待到设备中有了数据为止。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; 这种等待就是不定时的延迟，通常采用休眠机制来实现。 <br />
&nbsp;<br />
&nbsp;<br />
(2)休眠 <br />
&nbsp;&nbsp;&nbsp; 休眠是基于等待队列实现的，前面我们已经介绍过wait_event系列函数， <br />
&nbsp;&nbsp;&nbsp; 但现在我们将不会有确定的休眠时间。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; 当进程被置入休眠时，会被标记为特殊状态并从调度器的运行队列中移走。 <br />
&nbsp;&nbsp;&nbsp; 直到某些事件发生后，如设备接收到数据，则将进程重新设为运行态并进入运行队列进行调度。 <br />
&nbsp;&nbsp;&nbsp; 休眠函数的头文件是&lt;linux/wait.h&gt;，具体的实现函数在kernel/wait.c中。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; a.休眠的规则 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *永远不要在原子上下文中休眠 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *当被唤醒时，我们无法知道睡眠了多少时间，也不知道醒来后是否获得了我们需要的资源 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *除非知道有其他进程会在其他地方唤醒我们，否则进程不能休眠 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; b.等待队列的初始化 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 见前文 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; c.休眠函数 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; linux最简单的睡眠方式为wait_event宏。该宏在实现休眠的同时，检查进程等待的条件。 <br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A.&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
void wait_event( 
       wait_queue_head_t q, 
       int condition); 
 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B.&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
int wait_event_interruptible(wait_queue_head_t q, int condition); 
</pre>
</div>
<p style="text-align: left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q: 是等待队列头，注意是采用值传递。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition: 任意一个布尔表达式，在条件为真之前，进程会保持休眠。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意！进程需要通过唤醒函数才可能被唤醒，此时需要检测条件。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果条件满足，则被唤醒的进程真正醒来； <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果条件不满足，则进程继续睡眠。 <br />
&nbsp;<br />
&nbsp;<br />
&nbsp;&nbsp;&nbsp; d.唤醒函数 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们的进程睡眠后，需要由其他的某个执行线程(可能是另一个进程或中断处理例程)唤醒。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 唤醒函数： <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;linux/wait.h&gt; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1.</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
 void wake_up( 
        wait_queue_head_t *queue); 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;" style="text-align: left">
void wake_up_interruptible( 
        wait_queue_head_t *queue); 
</pre>
</div>
<p style="text-align: left">&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wake_up会唤醒等待在给定queue上的所有进程。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而wake_up_interruptible唤醒那些执行可中断休眠的进程。 <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实践中，约定做法是在使用wait_event时使用wake_up，而使用wait_event_interruptible时使用wake_up_interruptible。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/81461.html'>win8版qq怎么安装 qqwin8版本安装使用教程</a><a>下一篇</a><a href='/php/biji/81463.html'>浅谈javaSE 面向对象(Object类toString)</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>