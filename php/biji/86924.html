<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>如何优化SQL语句（全）_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="高性能的SQL语句会在软件运行中起到非常重要的作用，下面小编把最近整理的SQL语句优化资料分享给大家。<br />
第一： 选择最有效率的表名顺序(只在基于规则的seo/&#039; target=&#039;_blank&#039;&gt;" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">如何优化SQL语句（全）</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>高性能的SQL语句会在软件运行中起到非常重要的作用，下面小编把最近整理的SQL语句优化资料分享给大家。<br />
第一： 选择最有效率的表名顺序(只在基于规则的seo/&#039; target=&#039;_blank&#039;&gt;</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>高性能的SQL语句会在软件运行中起到非常重要的作用，下面小编把最近整理的SQL语句优化资料分享给大家。</p>
<p><strong>第一：</strong>&nbsp;选择最有效率的表名顺序(只在基于规则的seo/' target='_blank'&gt;优化器中有效)： ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.</p>
<p><strong>第二：</strong>&nbsp;WHERE子句中的连接顺序．： ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.</p>
<p><strong>第三：</strong>&nbsp;SELECT子句中避免使用 ‘ * ‘： ORACLE在解析的过程中, 会将'*' 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间</p>
<p><strong>第四：</strong>&nbsp;减少访问get='_blank'&gt;数据库的次数： ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等；</p>
<p><strong>第五：</strong>在SQL*Plus , SQL*Forms和Pro*C中重新设置ARRAYSIZE参数, 可以增加每次get='_blank'&gt;数据库访问的检索数据量 ,建议值为200</p>
<p><strong>第六：</strong>&nbsp;使用DECODE函数来减少处理时间： 使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表.</p>
<p><strong>第七：</strong>&nbsp;整合简单,无关联的get='_blank'&gt;数据库访问： 如果你有几个简单的get='_blank'&gt;数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)</p>
<p><strong>第八：</strong>&nbsp;删除重复记录： 最高效的删除重复记录方法 ( 因为使用了ROWID)例子： DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO);</p>
<p><strong>第九：</strong>&nbsp;用TRUNCATE替代DELETE： 当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML)</p>
<p><strong>第十：</strong>&nbsp;尽量多使用COMMIT： 只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少: COMMIT所释放的资源: a. 回滚段上用于恢复数据的信息. b. 被程序语句获得的锁 c. redo log buffer 中的空间 d. ORACLE为管理上述3种资源中的内部花费</p>
<p><strong>第十一：</strong>用Where子句替换HAVING子句： 避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销. (非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里</p>
<p><strong>第十二：</strong>&nbsp;减少对表的查询： 在含有子查询的SQL语句中,要特别注意减少对表的查询.例子： SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT TAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604)</p>
<p><strong>第十三：</strong>&nbsp;通过内部函数提高SQL效率.： 复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的</p>
<p><strong>第十四：</strong>使用表的别名(Alias)： 当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.</p>
<p><strong>第十五：</strong>&nbsp;用EXISTS替代IN、用NOT EXISTS替代NOT IN： 在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS. 例子：</p>
<p>（高效）SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND EXISTS (SELECT ‘X' FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB') (低效)SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB')</p>
<p><strong>第十六：</strong>&nbsp;识别'低效执行'的SQL语句： 虽然目前各种关于SQLseo/' target='_blank'&gt;优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法： SELECT EXECUTIONS , DISK_READS, BUFFER_GETS, ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio, ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run, SQL_TEXT FROM V$SQLAREA WHERE EXECUTIONS&gt;0 AND BUFFER_GETS &gt; 0 AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8 ORDER BY 4 DESC;</p>
<p><strong>第十七：</strong>用索引提高效率： 索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLEseo/' target='_blank'&gt;优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的.： ALTER INDEX REBUILD</p>
<p><strong>第十八：</strong>&nbsp;用EXISTS替换DISTINCT： 当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果. 例子： (低效): SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP E WHERE D.DEPT_NO = E.DEPT_NO (高效): SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X' FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO);</p>
<p><strong>第十九：</strong>&nbsp;server/' target='_blank'&gt;sql语句用大写的；因为oracle总是先解析server/' target='_blank'&gt;sql语句，把小写的字母转换成大写的再执行</p>
<p><strong>第二十：</strong>&nbsp;在java代码中尽量少用连接符“＋”连接字符串！</p>
<p><strong>第二十一：</strong>&nbsp;避免在索引列上使用NOT 通常，　 我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描.</p>
<p><strong>第二十二：</strong>&nbsp;避免在索引列上使用计算． WHERE子句中，如果索引列是函数的一部分．seo/' target='_blank'&gt;优化器将不使用索引而使用全表扫描． 举例: 低效： SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000; 高效: SELECT … FROM DEPT WHERE SAL &gt; 25000/12;</p>
<p><strong>第二十三：</strong>&nbsp;用&gt;=替代&gt; 高效: SELECT * FROM EMP WHERE DEPTNO &gt;=4 低效: SELECT * FROM EMP WHERE DEPTNO &gt;3 两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录. ======================================== 集成代码生成器 SpringMVC_mybatis or hibernate+ehcache二级缓存_shiro_druid_bootstrap_HTML5 java企业框架tab标签_maven非maven版本 http://my.oschina.net/u/2347562/blog/400728 ========================================</p>
<p><strong>第二十四：</strong>&nbsp;用UNION替换OR (适用于索引列) 通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引. 高效: SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 UNION SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE REGION = “MELBOURNE” 低效: SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.</p>
<p><strong>第二十五：</strong>用IN来替换OR 这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的．　 低效: SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 高效 SELECT… FROM LOCATION WHERE LOC_IN IN (10,20,30);</p>
<p><strong>第二十六：</strong>&nbsp;避免在索引列上使用IS NULL和IS NOT NULL 避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录.　如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空. 因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引. 低效: (索引失效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL; 高效: (索引有效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE &gt;=0;</p>
<p><strong>第二十七：</strong>&nbsp;总是使用索引的第一个列： 如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,seo/' target='_blank'&gt;优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,seo/' target='_blank'&gt;优化器使用了全表扫描而忽略了索引</p>
<p><strong>第二十八：</strong>&nbsp;用UNION-ALL 替换UNION ( 如果有可能的话)： 当SQL 语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序. 如果用UNION ALL替代UNION, 这样排序就不是必要了. 效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的seo/' target='_blank'&gt;优化也是相当重要的. 下面的SQL可以用来查询排序的消耗量 低效： SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = '31-DEC-95' UNION SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = '31-DEC-95' 高效: SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = '31-DEC-95' UNION ALL SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = '31-DEC-95'</p>
<p><strong>第二十九：</strong>&nbsp;用WHERE替代ORDER BY： ORDER BY 子句只在两种严格的条件下使用索引. ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序. ORDER BY中所有的列必须定义为非空. WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列. 例如: 表DEPT包含以下列: DEPT_CODE PK NOT NULL DEPT_DESC NOT NULL DEPT_TYPE NULL 低效: (索引不被使用) SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE 高效: (使用索引) SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0</p>
<p><strong>第三十：</strong>&nbsp;避免改变索引列的类型.: 当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换. 假设 EMPNO是一个数值类型的索引列. SELECT … FROM EMP WHERE EMPNO = ‘123' 实际上,经过ORACLE类型转换, 语句转化为: SELECT … FROM EMP WHERE EMPNO = TO_NUMBER(‘123') 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变. 现在,假设EMP_TYPE是一个字符类型的索引列. SELECT … FROM EMP WHERE EMP_TYPE = 123 这个语句被ORACLE转换为: SELECT … FROM EMP WHERETO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型</p>
<p><strong>第三十一：</strong>&nbsp;需要当心的WHERE子句: 某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子. 在下面的例子里, (1)‘!=' 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中. (2) ‘||'是字符连接函数. 就象其他函数那样, 停用了索引. (3) ‘+'是数学函数. 就象其他数学函数那样, 停用了索引. (4)相同的索引列不能互相比较,这将会启用全表扫描.</p>
<p><strong>第三十二：</strong>&nbsp;a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高. b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!</p>
<p><strong>第三十三：</strong>&nbsp;避免使用耗费资源的操作: 带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎 执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的get='_blank'&gt;数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强</p>
<p><strong>第三十四：</strong>&nbsp;seo/' target='_blank'&gt;优化GROUP BY: 提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多. 低效: SELECT JOB , AVG(SAL) FROM EMP GROUP by JOB HAVING JOB = ‘PRESIDENT' OR JOB = ‘MANAGER' 高效: SELECT JOB , AVG(SAL) FROM EMP WHERE JOB = ‘PRESIDENT' OR JOB = ‘MANAGER' GROUP by JOB</p>
<p>以上总结了三十四对如何优化SQL语句做了总结，希望大家喜欢。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/86923.html'>javascript判断网页是关闭还是刷新</a><a>下一篇</a><a href='/php/biji/86925.html'>PHP实现的oracle分页函数实例</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>