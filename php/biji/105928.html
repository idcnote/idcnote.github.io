<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>深入理解javascript动态插入技术_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="最近发现各大类库都能利用div.innerHTML=HTML片断来生成节点元素，再把它们插入到目标元素的各个位置上。这东西实际上就是insertAdjacentHTML，但是IE可恶的innerHTML把这优势" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">深入理解javascript动态插入技术</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>最近发现各大类库都能利用div.innerHTML=HTML片断来生成节点元素，再把它们插入到目标元素的各个位置上。这东西实际上就是insertAdjacentHTML，但是IE可恶的innerHTML把这优势</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P>最近发现各大类库都能利用div.innerHTML=HTML片断来生成节点元素，再把它们插入到目标元素的各个位置上。这东西实际上就是insertAdjacentHTML，但是IE可恶的innerHTML把这优势变成劣势。首先innerHTML会把里面的某些位置的空白去掉，见下面运行框的结果：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="32242" class="copybut" id="copybut32242" onclick="doCopy('code32242')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code32242"><br><br>&lt;!doctype html&gt;<BR>&lt;html dir="ltr" lang="zh-CN"&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;head&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;meta charset="utf-8" /&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;title&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IE的innerHTML By 司徒正美<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/title&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;script type="text/javascript"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window.onload = function() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var div = document.createElement("div");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.innerHTML = "&nbsp;&nbsp; &lt;td&gt;&nbsp;&nbsp;&nbsp; &lt;b&gt;司徒&lt;/b&gt;正美&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/td&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("|" + div.innerHTML + "|");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var c = div.childNodes;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("生成的节点个数&nbsp; " + c.length);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(var i=0,n=c.length;i&lt;n;i++){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(c[i].nodeType);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(c[i].nodeType === 1){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(":: "+c[i].childNodes.length);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/script&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/head&gt;<br><br>&nbsp;&nbsp;&nbsp; &lt;body&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;p id="p"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/p&gt;<BR>&nbsp;&nbsp;&nbsp; &lt;/body&gt;</P>
<P>&lt;/html&gt;</P>
<P></div></P>
<P>另一个可恶的地方是，在IE中以下元素的innerHTML是只读的：col、 colgroup、frameset、html、 head、style、table、tbody、 tfoot、 thead、title 与 tr。为了收拾它们，Ext特意弄了个insertIntoTable。insertIntoTable就是利用DOM的insertBefore与appendChild来添加，情况基本同jQuery。不过jQuery是完全依赖这两个方法，Ext还使用了insertAdjacentHTML。为了提高效率，所有类库都不约而同地使用了文档碎片。基本流程都是通过div.innerHTML提取出节点，然后转移到文档碎片上，然后用insertBefore与appendChild插入节点。对于火狐，Ext还使用了createContextualFragment解析文本，直接插入其目标位置上。显然，Ext的比jQuery是快许多的。不过jQuery的插入的不单是HTML片断，还有各种节点与jQuery对象。下面重温一下jQuery的工作流程吧。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="23957" class="copybut" id="copybut23957" onclick="doCopy('code23957')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code23957"><BR>append: function() { <BR>&nbsp; //传入arguments对象，true为要对表格进行特殊处理，回调函数 <BR>&nbsp; return this.domManip(arguments, true, function(elem){ <BR>&nbsp;&nbsp;&nbsp; if (this.nodeType == 1) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.appendChild( elem ); <BR>&nbsp; }); <BR>}, <BR>domManip: function( args, table, callback ) { <BR>&nbsp; if ( this[0] ) {//如果存在元素节点 <BR>&nbsp;&nbsp;&nbsp; var fragment = (this[0].ownerDocument || this[0]).createDocumentFragment(), <BR>&nbsp;&nbsp;&nbsp; //注意这里是传入三个参数 <BR>&nbsp;&nbsp;&nbsp; scripts = jQuery.clean( args, (this[0].ownerDocument || this[0]), fragment ), <BR>&nbsp;&nbsp;&nbsp; first = fragment.firstChild; <br><br>&nbsp;&nbsp;&nbsp; if ( first ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( var i = 0, l = this.length; i &lt; l; i++ ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback.call( root(this[i], first), this.length &gt; 1 || i &gt; 0 ? <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fragment.cloneNode(true) : fragment ); <br><br>&nbsp;&nbsp;&nbsp; if ( scripts ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jQuery.each( scripts, evalScript ); <BR>&nbsp; } <br><br>&nbsp; return this; <br><br>&nbsp; function root( elem, cur ) { <BR>&nbsp;&nbsp;&nbsp; return table && jQuery.nodeName(elem, "table") && jQuery.nodeName(cur, "tr") ? <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (elem.getElementsByTagName("tbody")[0] || <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elem.appendChild(elem.ownerDocument.createElement("tbody"))) : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elem; <BR>&nbsp; } <BR>} <BR>//elems为arguments对象，context为document对象，fragment为空的文档碎片 <BR>clean: function( elems, context, fragment ) { <BR>&nbsp; context = context || document; <br><br>&nbsp; // !context.createElement fails in IE with an error but returns typeof 'object' <BR>&nbsp; if ( typeof context.createElement === "undefined" ) <BR>&nbsp; //确保context为文档对象 <BR>&nbsp;&nbsp;&nbsp; context = context.ownerDocument || context[0] && context[0].ownerDocument || document; <br><br>&nbsp; // If a single string is passed in and it's a single tag <BR>&nbsp; // just do a createElement and skip the rest <BR>&nbsp; //如果文档对象里面只有一个标签，如&lt;div&gt; <BR>&nbsp; //我们大概可能是在外面这样调用它$(this).append("&lt;div&gt;") <BR>&nbsp; //这时就直接把它里面的元素名取出来，用document.createElement("div")创建后放进数组返回 <BR>&nbsp; if ( !fragment && elems.length === 1 && typeof elems[0] === "string" ) { <BR>&nbsp;&nbsp;&nbsp; var match = /^&lt;(\w+)\s*\/?&gt;$/.exec(elems[0]); <BR>&nbsp;&nbsp;&nbsp; if ( match ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [ context.createElement( match[1] ) ]; <BR>&nbsp; } <BR>&nbsp; //利用一个div的innerHTML创建众节点 <BR>&nbsp; var ret = [], scripts = [], div = context.createElement("div"); <BR>&nbsp; //如果我们是在外面这样添加$(this).append("&lt;td&gt;表格1&lt;/td&gt;"，"&lt;td&gt;表格1&lt;/td&gt;"，"&lt;td&gt;表格1&lt;/td&gt;") <BR>&nbsp; //jQuery.each按它的第四种支分方式（没有参数，有length）遍历aguments对象，callback.call( value, i, value ) <BR>&nbsp; jQuery.each(elems, function(i, elem){//i为索引，elem为arguments对象里的元素 <BR>&nbsp;&nbsp;&nbsp; if ( typeof elem === "number" ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elem += ''; <br><br>&nbsp;&nbsp;&nbsp; if ( !elem ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return; <br><br>&nbsp;&nbsp;&nbsp; // Convert html string into DOM nodes <BR>&nbsp;&nbsp;&nbsp; if ( typeof elem === "string" ) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fix "XHTML"-style tags in all browsers <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elem = elem.replace(/(&lt;(\w+)[^&gt;]*?)\/&gt;/g, function(all, front, tag){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tag.match(/^(abbr|br|col|img|input|link|meta|param|hr|area|embed)$/i) ? <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; front + "&gt;&lt;/" + tag + "&gt;"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Trim whitespace, otherwise indexOf won't work as expected <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var tags = elem.replace(/^\s+/, "").substring(0, 10).toLowerCase(); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var wrap = <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // option or optgroup <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !tags.indexOf("&lt;opt") && <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1, "&lt;select multiple='multiple'&gt;", "&lt;/select&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !tags.indexOf("&lt;leg") && <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1, "&lt;fieldset&gt;", "&lt;/fieldset&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tags.match(/^&lt;(thead|tbody|tfoot|colg|cap)/) && <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1, "&lt;table&gt;", "&lt;/table&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !tags.indexOf("&lt;tr") && <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 2, "&lt;table&gt;&lt;tbody&gt;", "&lt;/tbody&gt;&lt;/table&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;thead&gt; matched above <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (!tags.indexOf("&lt;td") || !tags.indexOf("&lt;th")) && <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 3, "&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;", "&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !tags.indexOf("&lt;col") && <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 2, "&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;", "&lt;/colgroup&gt;&lt;/table&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IE can't serialize &lt;link&gt; and &lt;script&gt; tags normally <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !jQuery.support.htmlSerialize &&//用于创建link元素 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 1, "div&lt;div&gt;", "&lt;/div&gt;" ] || <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 0, "", "" ]; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Go to html and back, then peel off extra wrappers <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.innerHTML = wrap[1] + elem + wrap[2];//比如"&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;" +&lt;td&gt;表格1&lt;/td&gt;+"&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Move to the right depth <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( wrap[0]-- ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div = div.lastChild; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //处理IE自动插入tbody，如我们使用$('&lt;thead&gt;&lt;/thead&gt;')创建HTML片断，它应该返回 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //'&lt;thead&gt;&lt;/thead&gt;',而IE会返回'&lt;thead&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;' <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( !jQuery.support.tbody ) { <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var hasBody = /&lt;tbody/i.test(elem), <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbody = !tags.indexOf("&lt;table") && !hasBody ? <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.firstChild && div.firstChild.childNodes : <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // String was a bare &lt;thead&gt; or &lt;tfoot&gt; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wrap[1] == "&lt;table&gt;" && !hasBody ? <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.childNodes : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; []; <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( var j = tbody.length - 1; j &gt;= 0 ; --j ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果是自动插入的里面肯定没有内容 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbody[ j ].parentNode.removeChild( tbody[ j ] ); <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IE completely kills leading whitespace when innerHTML is used <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( !jQuery.support.leadingWhitespace && /^\s/.test( elem ) ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.insertBefore( context.createTextNode( elem.match(/^\s*/)[0] ), div.firstChild ); <BR>&nbsp;&nbsp;&nbsp;&nbsp; //把所有节点做成纯数组 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elem = jQuery.makeArray( div.childNodes ); <BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; if ( elem.nodeType ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret.push( elem ); <BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp; //全并两个数组，merge方法会处理IE下object元素下消失了的param元素 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = jQuery.merge( ret, elem ); <br><br>&nbsp; }); <br><br>&nbsp; if ( fragment ) { <BR>&nbsp;&nbsp;&nbsp; for ( var i = 0; ret[i]; i++ ) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果第一层的childNodes就有script元素节点，就用scripts把它们收集起来，供后面用globalEval动态执行 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] ); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //遍历各层节点，收集script元素节点 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( ret[i].nodeType === 1 ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName("script"))) ); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fragment.appendChild( ret[i] ); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; return scripts;//由于动态插入是传入三个参数，因此这里就返回了 <BR>&nbsp; } <br><br>&nbsp; return ret; <BR>}, </P>
<P></div></P>
<P></P>
<P>真是复杂的让人掉眼泪！不过jQuery的实现并不太高明，它把插入的东西统统用clean转换为节点集合，再把它们放到一个文档碎片中，然后用appendChild与insertBefore插入它们。在除了火狐外，其他浏览器都支持insertAdjactentXXX家族的今日，应该好好利用这些原生API。下面是Ext利用insertAdjactentHTML等方法实现的DomHelper方法，官网给出的数据：</P>
<P></P>
<P>这数据有点老了，而且最新3.03早就解决了在IE table插入内容的诟病（table,tbody,tr等的innerHTML都是只读，insertAdjactentHTML,pasteHTML等方法都无法修改其内容，要用又慢又标准的DOM方法才行，Ext的早期版本就在这里遭遇滑铁卢了）。可以看出，结合insertAdjactentHTML与文档碎片后，IE6插入节点的速度也得到难以置信的提升，直逼火狐。基于它，Ext开发了四个分支方法insertBefore、insertAfter、insertFirst、append，分别对应jQuery的before、after、prepend与append。不过，jQuery还把这几个方法巧妙地调换了调用者与传入参数，衍生出insertBefore、insertAfter、prependTo与appendTo这几个方法。但不管怎么说，jQuery这样一刀切的做法实现令人不敢苛同。下面是在火狐中实现insertAdjactentXXX家族的一个版本：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="1930" class="copybut" id="copybut1930" onclick="doCopy('code1930')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code1930"><BR>(function() { <BR>&nbsp;&nbsp;&nbsp; if ('HTMLElement' in this) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if('insertAdjacentHTML' in HTMLElement.prototype) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; } else { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return<BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; function insert(w, n) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(w.toUpperCase()) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'BEFOREEND' : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.appendChild(n) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'BEFOREBEGIN' : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.parentNode.insertBefore(n, this) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'AFTERBEGIN' : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.insertBefore(n, this.childNodes[0]) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'AFTEREND' : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.parentNode.insertBefore(n, this.nextSibling) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; function insertAdjacentText(w, t) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert.call(this, w, document.createTextNode(t || '')) <BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; function insertAdjacentHTML(w, h) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var r = document.createRange() <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r.selectNode(this) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert.call(this, w, r.createContextualFragment(h)) <BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; function insertAdjacentElement(w, n) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert.call(this, w, n) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n <BR>&nbsp;&nbsp;&nbsp; } <br><br>&nbsp;&nbsp;&nbsp; HTMLElement.prototype.insertAdjacentText = insertAdjacentText <BR>&nbsp;&nbsp;&nbsp; HTMLElement.prototype.insertAdjacentHTML = insertAdjacentHTML <BR>&nbsp;&nbsp;&nbsp; HTMLElement.prototype.insertAdjacentElement = insertAdjacentElement <BR>})() </P>
<P></div></P>
<P>我们可以利用它设计出更快更合理的动态插入方法。下面是我的一些实现：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="41451" class="copybut" id="copybut41451" onclick="doCopy('code41451')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code41451"><BR>//四个插入方法，对应insertAdjactentHTML的四个插入位置，名字就套用jQuery的 <BR>//stuff可以为字符串，各种节点或dom对象（一个类数组对象，便于链式操作！） <BR>//代码比jQuery的实现简洁漂亮吧！ <BR>&nbsp;&nbsp;&nbsp; append:function(stuff){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; dom.batch(this,function(el){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom.insert(el,stuff,"beforeEnd"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }); <BR>&nbsp;&nbsp;&nbsp; }, <BR>&nbsp;&nbsp;&nbsp; prepend:function(stuff){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; dom.batch(this,function(el){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom.insert(el,stuff,"afterBegin"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }); <BR>&nbsp;&nbsp;&nbsp; }, <BR>&nbsp;&nbsp;&nbsp; before:function(stuff){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; dom.batch(this,function(el){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom.insert(el,stuff,"beforeBegin"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }); <BR>&nbsp;&nbsp;&nbsp; }, <BR>&nbsp;&nbsp;&nbsp; after:function(stuff){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; dom.batch(this,function(el){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom.insert(el,stuff,"afterEnd"); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }); <BR>&nbsp;&nbsp;&nbsp; } </P>
<P></div></P>
<P>它们里面都是调用了两个静态方法,batch与insert。由于dom对象是类数组对象，我仿效jQuery那样为它实现了几个重要迭代器，forEach、map与filter等。一个dom对象包含复数个DOM元素，我们就可以用forEach遍历它们，执行其中的回调方法。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="22888" class="copybut" id="copybut22888" onclick="doCopy('code22888')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code22888"><BR>batch:function(els,callback){ <BR>&nbsp;&nbsp;&nbsp; els.forEach(callback); <BR>&nbsp;&nbsp;&nbsp; return els;//链式操作 <BR>},<BR></div></P>
<P>insert方法执行jQuery的domManip方法相应的机能（dojo则为place方法），但insert方法每次处理一个元素节点，不像jQuery那样处理一组元素节点。群集处理已经由上面batch方法分离出去了。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="5135" class="copybut" id="copybut5135" onclick="doCopy('code5135')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code5135"><BR>insert : function(el,stuff,where){ <BR>&nbsp;&nbsp;&nbsp;&nbsp; //定义两个全局的东西，提供内部方法调用 <BR>&nbsp;&nbsp;&nbsp;&nbsp; var doc = el.ownerDocument || dom.doc, <BR>&nbsp;&nbsp;&nbsp;&nbsp; fragment = doc.createDocumentFragment(); <BR>&nbsp;&nbsp;&nbsp;&nbsp; if(stuff.version){//如果是dom对象，则把它里面的元素节点移到文档碎片中 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stuff.forEach(function(el){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fragment.appendChild(el); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stuff = fragment; <BR>&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp; //供火狐与IE部分元素调用 <BR>&nbsp;&nbsp;&nbsp;&nbsp; dom._insertAdjacentElement = function(el,node,where){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (where){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'beforeBegin': <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el.parentNode.insertBefore(node,el) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'afterBegin': <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el.insertBefore(node,el.firstChild); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'beforeEnd': <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el.appendChild(node); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'afterEnd': <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (el.nextSibling) el.parentNode.insertBefore(node,el.nextSibling); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else el.parentNode.appendChild(node); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp; }; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //供火狐调用 <BR>&nbsp;&nbsp;&nbsp;&nbsp; dom._insertAdjacentHTML = function(el,htmlStr,where){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var range = doc.createRange(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (where) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case "beforeBegin"://before <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.setStartBefore(el); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case "afterBegin"://after <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.selectNodeContents(el); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.collapse(true); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case "beforeEnd"://append <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.selectNodeContents(el); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.collapse(false); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case "afterEnd"://prepend <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range.setStartAfter(el); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var parsedHTML = range.createContextualFragment(htmlStr); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom._insertAdjacentElement(el,parsedHTML,where); <BR>&nbsp;&nbsp;&nbsp;&nbsp; }; <BR>&nbsp;&nbsp;&nbsp;&nbsp; //以下元素的innerHTML在IE中是只读的，调用insertAdjacentElement进行插入就会出错 <BR>&nbsp;&nbsp;&nbsp;&nbsp; // col, colgroup, frameset, html, head, style, title,table, tbody, tfoot, thead, 与tr; <BR>&nbsp;&nbsp;&nbsp;&nbsp; dom._insertAdjacentIEFix = function(el,htmlStr,where){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var parsedHTML = dom.parseHTML(htmlStr,fragment); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom._insertAdjacentElement(el,parsedHTML,where) <BR>&nbsp;&nbsp;&nbsp;&nbsp; }; <BR>&nbsp;&nbsp;&nbsp;&nbsp; //如果是节点则复制一份 <BR>&nbsp;&nbsp;&nbsp;&nbsp; stuff = stuff.nodeType ?&nbsp; stuff.cloneNode(true) : stuff; <BR>&nbsp;&nbsp;&nbsp;&nbsp; if (el.insertAdjacentHTML) {//ie,chrome,opera,safari都已实现insertAdjactentXXX家族 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try{//适合用于opera,safari,chrome与IE <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; el['insertAdjacent'+ (stuff.nodeType ? 'Element':'HTML')](where,stuff); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch(e){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //IE的某些元素调用insertAdjacentXXX可能出错，因此使用此补丁 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom._insertAdjacentIEFix(el,stuff,where); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp; }else{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //火狐专用 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dom['_insertAdjacent'+ (stuff.nodeType ? 'Element':'HTML')](el,stuff,where); <BR>&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;} </P>
<P></div></P>
<P>insert方法在实现火狐插入操作中，使用了W3C DOM Range对象的一些罕见方法，具体可到火狐官网查看。下面实现把字符串转换为节点，利用innerHTML这个伟大的方法。Prototype.js称之为_getContentFromAnonymousElement，但有许多问题，dojo称之为_toDom，mootools的Element.Properties.html，jQuery的clean。Ext没有这东西，它只支持传入HTML片断的insertAdjacentHTML方法，不支持传入元素节点的insertAdjacentElement。但有时，我们需要插入文本节点（并不包裹于元素节点之中），这时我们就需要用文档碎片做容器了，insert方法出场了。</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="31838" class="copybut" id="copybut31838" onclick="doCopy('code31838')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code31838"><BR>parseHTML : function(htmlStr, fragment){ <BR>&nbsp;&nbsp;&nbsp; var div = dom.doc.createElement("div"), <BR>&nbsp;&nbsp;&nbsp; reSingleTag =&nbsp; /^&lt;(\w+)\s*\/?&gt;$/;//匹配单个标签，如&lt;li&gt; <BR>&nbsp;&nbsp;&nbsp; htmlStr += ''; <BR>&nbsp;&nbsp;&nbsp; if(reSingleTag.test(htmlStr)){//如果str为单个标签 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; [dom.doc.createElement(RegExp.$1)] <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; var tagWrap = { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; option: ["select"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optgroup: ["select"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbody: ["table"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thead: ["table"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tfoot: ["table"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tr: ["table", "tbody"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; td: ["table", "tbody", "tr"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; th: ["table", "thead", "tr"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; legend: ["fieldset"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; caption: ["table"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colgroup: ["table"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col: ["table", "colgroup"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; li: ["ul"], <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link:["div"] <BR>&nbsp;&nbsp;&nbsp; }; <BR>&nbsp;&nbsp;&nbsp; for(var param in tagWrap){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var tw = tagWrap[param]; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (param) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case "option":tw.pre&nbsp; = '&lt;select multiple="multiple"&gt;'; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case "link": tw.pre&nbsp; = 'fixbug&lt;div&gt;';&nbsp; break; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default : tw.pre&nbsp; =&nbsp;&nbsp; "&lt;" + tw.join("&gt;&lt;") + "&gt;"; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tw.post = "&lt;/" + tw.reverse().join("&gt;&lt;/") + "&gt;"; <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; var reMultiTag = /&lt;\s*([\w\:]+)/,//匹配一对标签或多个标签，如&lt;li&gt;&lt;/li&gt;,li <BR>&nbsp;&nbsp;&nbsp; match = htmlStr.match(reMultiTag), <BR>&nbsp;&nbsp;&nbsp; tag = match ? match[1].toLowerCase() : "";//解析为&lt;li,li <BR>&nbsp;&nbsp;&nbsp; if(match && tagWrap[tag]){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var wrap = tagWrap[tag]; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.innerHTML = wrap.pre + htmlStr + wrap.post; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = wrap.length; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(--n &gt;= 0)//返回我们已经添加的内容 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div = div.lastChild; <BR>&nbsp;&nbsp;&nbsp; }else{ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.innerHTML = htmlStr; <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; //处理IE自动插入tbody，如我们使用dom.parseHTML('&lt;thead&gt;&lt;/thead&gt;')转换HTML片断，它应该返回 <BR>&nbsp;&nbsp;&nbsp; //'&lt;thead&gt;&lt;/thead&gt;',而IE会返回'&lt;thead&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;/tbody&gt;' <BR>&nbsp;&nbsp;&nbsp; //亦即，在标准浏览器中return div.children.length会返回1，IE会返回2 <BR>&nbsp;&nbsp;&nbsp; if(dom.feature.autoInsertTbody && !!tagWrap[tag]){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ownInsert = tagWrap[tag].join('').indexOf("tbody") !== -1,//我们插入的 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbody = div.getElementsByTagName("tbody"), <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; autoInsert = tbody.length &gt; 0;//IE插入的 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!ownInsert && autoInsert){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(var i=0,n=tbody.length;i&lt;n;i++){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!tbody[i].childNodes.length )//如果是自动插入的里面肯定没有内容 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tbody[i].parentNode.removeChild( tbody[i] ); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; if (dom.feature.autoRemoveBlank && /^\s/.test(htmlStr) ) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div.insertBefore( dom.doc.createTextNode(htmlStr.match(/^\s*/)[0] ), div.firstChild ); <BR>&nbsp;&nbsp;&nbsp; if (fragment) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var firstChild; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while((firstChild = div.firstChild)){ // 将div上的节点转移到文档碎片上！ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fragment.appendChild(firstChild); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fragment; <BR>&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp; return div.children; <BR>} </P>
<P></div></P>
<P>嘛，基本上就是这样，运行起来比jQuery快许多，代码实现也算优美，至少没有像jQuery那样乱成一团。jQuery还有四个反转方法。下面是jQuery的实现：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="51728" class="copybut" id="copybut51728" onclick="doCopy('code51728')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51728"><BR>jQuery.each({ <BR>&nbsp;&nbsp;&nbsp; appendTo: "append", <BR>&nbsp;&nbsp;&nbsp; prependTo: "prepend", <BR>&nbsp;&nbsp;&nbsp; insertBefore: "before", <BR>&nbsp;&nbsp;&nbsp; insertAfter: "after", <BR>&nbsp;&nbsp;&nbsp; replaceAll: "replaceWith"<BR>}, function(name, original){ <BR>&nbsp;&nbsp;&nbsp; jQuery.fn[ name ] = function( selector ) {//插入物（html,元素节点，jQuery对象） <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ret = [], insert = jQuery( selector );//将插入转变为jQuery对象 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( var i = 0, l = insert.length; i &lt; l; i++ ) { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var elems = (i &gt; 0 ? this.clone(true) : this).get(); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jQuery.fn[ original ].apply( jQuery(insert[i]), elems );//调用四个已实现的插入方法 <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = ret.concat( elems ); <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.pushStack( ret, name, selector );//由于没有把链式操作的代码分离出去，需要自行实现 <BR>&nbsp;&nbsp;&nbsp; }; <BR>}); </P>
<P></div></P>
<P>我的实现：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="18616" class="copybut" id="copybut18616" onclick="doCopy('code18616')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code18616"><BR>dom.each({ <BR>&nbsp;&nbsp;&nbsp; appendTo: 'append', <BR>&nbsp;&nbsp;&nbsp; prependTo: 'prepend', <BR>&nbsp;&nbsp;&nbsp; insertBefore: 'before', <BR>&nbsp;&nbsp;&nbsp; insertAfter: 'after'<BR>},function(method,name){ <BR>&nbsp;&nbsp;&nbsp; dom.prototype[name] = function(stuff){ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return dom(stuff)[method](this); <BR>&nbsp;&nbsp;&nbsp; }; <BR>}); </P>
<P></div></P>
<P>大致的代码都给出，大家可以各取所需。</P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/105927.html'>Javascript学习笔记之相等符号与严格相等符号</a><a>下一篇</a><a href='/php/biji/105929.html'>C# 判断字符为空的6种方法的效率实测对比</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>