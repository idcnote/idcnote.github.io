<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Cocos2d-x入门教程（详细的实例和讲解）_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="智能终端上的游戏目前风头正劲，试问哪个智能手机上没有几款企鹅公司出品的游戏呢！之前从未涉猎过游戏开发，但知道游戏开发前要挑选一款合适的游戏引擎，自己从头开始敲代码的时代" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Cocos2d-x入门教程（详细的实例和讲解）</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>智能终端上的游戏目前风头正劲，试问哪个智能手机上没有几款企鹅公司出品的游戏呢！之前从未涉猎过游戏开发，但知道游戏开发前要挑选一款合适的游戏引擎，自己从头开始敲代码的时代</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P>智能终端上的游戏目前风头正劲，试问哪个智能手机上没有几款企鹅公司出品的游戏呢！之前从未涉猎过游戏开发，但知道游戏开发前要挑选一款合适的游戏引擎，自己从头开始敲代码的时代已经out了。在寻觅游戏引擎之前，我需要回答三道摆在我面前的选择题：</P>
<P>&nbsp;&nbsp;&nbsp; 1、2D引擎还是3D引擎？<BR>&nbsp;&nbsp;&nbsp; 2、平台专用引擎还是跨平台引擎？<BR>&nbsp;&nbsp;&nbsp; 3、收费引擎还是开源引擎？</P>
<P>作为入门级选手，2D游戏显然更适合上手一些，另外适合果果这个年龄段的幼教类的游戏也多以2D游戏居多。3D游戏本身也太难了，不仅要 Programming能力，还要3D建模能力，这些学习起来周期就太长了；一直是Ubuntu Fans，手头没有Mac Book，这样开发iOS程序变成一件糟心的事，在Ubuntu下搭建iOS App开发环境繁杂的很，即便是虚拟机也懒得尝试。但从游戏体验来看，还是在iPad上玩更好一些，因此最好引擎能跨平台，以便后续迁移到iOS上；开源 和用开源惯了，收费的引擎目前不在考虑范围之内。综上，我要寻找的是一款开源的、跨平台的Mobile 2D Game Engine。</P>
<P>于是我找到了Cocos2d-x！Cocos2d-x是Cocos2d-iphone的C++跨平台分支，由于是国人创立的，在国内有着较大的用 户群，引擎资料也较多，社区十分活跃。国内已经出版了多本有关Cocos2d-x的中文书籍，比如《Cocos2d-x高级开发教程:制作自己的 “捕鱼达人”》 、《Cocos2d-x权威指南》 等都还不错。更重要的是Cocos2d-x自带了丰富的例子，供初学者“临摹学习”，其中cocos2d-x-2.2.2/samples/Cpp /TestCpp这个例子几乎涵盖了该引擎的绝大多数功能。下面就开启Cocos2d-x的入门之旅（For Android）。</P>
<P><STRONG>一、引擎安装</STRONG></P>
<P>试验环境：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="84801" class="copybut" id="copybut84801" onclick="doCopy('code84801')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84801">&nbsp;&nbsp; Ubuntu 12.04.1 x86_64<BR>&nbsp;&nbsp; gcc 4.6.3<BR>&nbsp;&nbsp; javac 1.7.0_21<BR>&nbsp;&nbsp; java "1.7.0_21" HotSpot 64-bit Server VM<BR>&nbsp;&nbsp; adt-bundle-linux-x86_64-20131030.zip<BR>&nbsp;&nbsp; android-ndk-r9d-linux-x86_64.tar.bz2<BR>&nbsp; </div></P>
<P>Cocos2d-x官网目前提供2.2.2稳定版以及3.0beta2版的下载（当然你也可以下载到更老的版本）。由于3.0改变较大，资料不 多，且对编译器等版本的要求较高(需要支持C++ 11标准)，因此这里依旧以2.2.2版本作为学习目标。Cocos2d-x-2.2.2下载后解压到某个目录：比如/home1/tonybai/android-dev/cocos2d-x-2.2.2。 如果仅是用Cocos2d-x开发Android版本游戏，则不需要做什么编译工作。Android Game Project会在Project build时自动用NDK的编译器编译C++代码，并与NDK链接。如果你想早点看看Cocos2d-x sample中的例子运行起来到底是什么样子的，你可以在Ubuntu下编译出Linux版本的游戏：在cocos2d-x-2.2.2下执行make-all-linux-project.sh即可。编译需要一段时间，编译成 功后，我们可以进入到“cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.linux/bin/release” 下执行“HelloCpp”这个可执行文件，一个最简单的Cocos2d-x游戏就会展现在你的面前了。</P>
<P>Android sample project的构建稍微复杂些：</P>
<P>首先在Eclipse中添加libcocos2dx Library project from existed code（注意：不Copy到workspace，原地建立）。该Project的代码路径为cocos2d-x-2.2.2/cocos2dx/platform /android/java。在project.properties和AndroidManifest.xml适当修改你所使用的api版本， 以让编译通过。我这里用的是 target=android-19。</P>
<P>然后，设置NDK_ROOT环境变量(比如export NDK_ROOT='/home1/tonybai/android-dev/adt-bundle-linux-x86_64/android-ndk-r9c')， 供build_native.sh使用。</P>
<P>最后添加游戏project。在Eclipse中添加HelloCpp project from existed code，位置cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android（注 意：不Copy到Workspace中，原地建立）。在HelloCpp的project.properties中添加“android.library.reference.1=../../../../cocos2dx/platform/android /java”。同样别忘了在project.properties和AndroidManifest.xml适当修改你所使用 的api版本，以让编译通过。</P>
<P>如果一切顺利的话，你会在Console窗口看到“**** Build Finished ****”。Problems窗口显示“0 errors“。 启动Android模拟器，Run Application，同样的HelloCpp画面会呈现在模拟器上。</P>
<P>Cocos2d-x是建构在OpenGL技术之上的。对于Android平台而言，Android SDK已经完全封装了opengl es 1.1/2.0的API（android.opengl.*;javax.microedition.khronos.egl.*;javax.microedition.khronos.opengles.*）， 引擎完全可以建立在这个之上，无需C++代码。但Cocos2d-x是一个跨平台的2D游戏引擎，核心选择了用C++代码实现(iOS提供的C绑 定，不提供Java绑定；Android则提供了Java和C绑定)，因此 在开发Android平台的2D游戏时，引擎部分是SDK与NDK交相互应，比如GLThread的创建和管理用的是SDK的 GLSurfaceView和GLThread，但真正的Surface绘制部分则是回调Cocos2d-x用C++编写的绘制实现（链接NDK 中的库）。</P>
<P><STRONG>二、Cocos2d-x Android工程代码组织结构</STRONG></P>
<P>以samples/Cpp/HelloApp的Android工程为例，Android版的Cocos2d-x工程与普通android应用程序 差别 不大，核心部分只是多了一个jni目录和一个build_native.sh脚本文件。其中jni目录下存放的是Java和C++调用转换的“胶 水”代码；build_native.sh则是用于编译jni下C++代码以及 cocos2dx_static library代码的构建脚本。</P>
<P>HelloCpp的构建过程摘要如下：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="76515" class="copybut" id="copybut76515" onclick="doCopy('code76515')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76515"><BR>**** Build of configuration Default for project HelloCpp ****</P>
<P>bash /home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/build_native.sh<BR>NDK_ROOT = /home1/tonybai/android-dev/adt-bundle-linux-x86_64/android-ndk-r9c<BR>COCOS2DX_ROOT = /home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/../../../..<BR>APP_ROOT = /home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/..<BR>APP_ANDROID_ROOT = /home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android<BR>+ /home1/tonybai/android-dev/adt-bundle-linux-x86_64/android-ndk-r9c/ndk-build -C /home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.androidNDK_MODULE_PATH=/home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/../../../..:/home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/../../../../cocos2dx/platform/third_party/android/prebuilt<BR>Using prebuilt externals<BR>Android NDK: WARNING:/home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/../../../../cocos2dx/Android.mk:cocos2dx_static: LOCAL_LDLIBS is always ignored for static libraries&nbsp; <BR>make: Entering directory `/home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android'<BR>[armeabi] Compile++ thumb: hellocpp_shared &lt;= main.cpp<BR>[armeabi] Compile++ thumb: hellocpp_shared &lt;= AppDelegate.cpp<BR>[armeabi] Compile++ thumb: hellocpp_shared &lt;= HelloWorldScene.cpp<BR>[armeabi] Compile++ thumb: cocos2dx_static &lt;= CCConfiguration.cpp<BR>[armeabi] Compile++ thumb: cocos2dx_static &lt;= CCScheduler.cpp<BR>&nbsp;… …<BR>[armeabi] Compile++ thumb: cocos2dx_static &lt;= CCTouch.cpp<BR>[armeabi] StaticLibrary&nbsp; : libcocos2d.a<BR>[armeabi] Compile thumb&nbsp; : cpufeatures &lt;= cpu-features.c<BR>[armeabi] StaticLibrary&nbsp; : libcpufeatures.a<BR>[armeabi] SharedLibrary&nbsp; : libhellocpp.so<BR>[armeabi] Install&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : libhellocpp.so =&gt; libs/armeabi/libhellocpp.so<BR>make: Leaving directory `/home1/tonybai/android-dev/cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android'</P>
<P>**** Build Finished ****<BR></div><BR>指挥NDK编译的则是jni下的Android.mk文件，其角色类似于Makefile。</P>
<P><STRONG>三、Cocos2d-x Android工程代码阅读</STRONG></P>
<P>单独将如何阅读代码拿出来，是为了后面分析引擎的驱动流程做准备工作。学习类似Cocos2d-x这样的游戏引擎，仅仅停留在游戏逻辑层代码是不 能很好的把握引擎本质的，因此适当的挖掘引擎实现实际上对于理解和使用 引擎都是大有裨益的。</P>
<P>以一个Cocos2d-x Android工程为例，它的游戏逻辑代码以及涉及的引擎代码涵盖在一下路径下（还是以HelloCpp的Android工程为例）：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="54489" class="copybut" id="copybut54489" onclick="doCopy('code54489')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code54489"><BR>&nbsp;&nbsp;&nbsp; 项目层：<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/src&nbsp; 主Activity的实现；<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cocos2d-x-2.2.2/samples/Cpp/HelloCpp/proj.android/jni/hellocpp&nbsp; Cocos2dxRenderer类的nativeInit实现，用于引出Application的入口；<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cocos2d-x-2.2.2/samples/Cpp/HelloCpp/Classes 你的游戏逻辑，以C++代码形式呈现；<br><br>&nbsp;&nbsp;&nbsp; 引擎层：<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cocos2d-x-2.2.2/cocos2dx/platform/android/java/src 引擎层对Android Activity、GLSurfaceView以及Render的封装<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cocos2d-x-2.2.2/cocos2dx/platform/android/jni 对应上面封装的native method实现<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * cocos2d-x-2.2.2/cocos2dx、cocos2d-x-2.2.2/cocos2dx/platform、cocos2d-x- 2.2.2/cocos2dx/platform/android&nbsp;&nbsp; cocos2dx引擎的核心实现(针对android平台)<BR></div><BR>后续的代码分析也将从这两个层次、六处位置出发。</P>
<P><STRONG>四、从Activity开始</STRONG></P>
<P>之前多少了解了一些Android App开发的知识，Android App都是始于Activity的。游戏也是App的一种，因此在Android平台上，Cocos2d-x游戏也是从Activity开始的。于是 Activity，确切的说是Cocos2dxActivity是我们这次引擎驱动机制分析的出发点。</P>
<P>回顾Android Activity的Lifecycle，Activity启动的顺序是：Activity.onCreate -&gt; Activity.onStart() -&gt; Activity.onResume()。接下来我们将按照 这条主线进行引擎驱动机制的分析。</P>
<P>HelloCpp.java中的HelloCpp这个Activity完全无所作为，仅仅是继承其父类Cocos2dxActivity的实现罢 了。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="94010" class="copybut" id="copybut94010" onclick="doCopy('code94010')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code94010"><BR>// HelloCpp.java<BR>public class HelloCpp extends Cocos2dxActivity{<BR>&nbsp;&nbsp;&nbsp; protected void onCreate(Bundle savedInstanceState){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.onCreate(savedInstanceState);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; … …<BR>}<BR></div><BR>我们来看Cocos2dxActivity类。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="75447" class="copybut" id="copybut75447" onclick="doCopy('code75447')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code75447"><BR>// Cocos2dxActivity.java</P>
<P>@Override<BR>protected void onCreate(final Bundle savedInstanceState) {<BR>&nbsp;&nbsp;&nbsp; super.onCreate(savedInstanceState);<BR>&nbsp;&nbsp;&nbsp; sContext = this;<BR>&nbsp;&nbsp;&nbsp; this.mHandler = new Cocos2dxHandler(this);<BR>&nbsp;&nbsp;&nbsp; this.init();<BR>&nbsp;&nbsp;&nbsp; Cocos2dxHelper.init(this, this);<BR>} </P>
<P>public void init() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // FrameLayout<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ViewGroup.LayoutParams framelayout_params =<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ViewGroup.LayoutParams.FILL_PARENT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FrameLayout framelayout = new FrameLayout(this);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framelayout.setLayoutParams(framelayout_params);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … …<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Cocos2dxGLSurfaceView<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mGLSurfaceView = this.onCreateView();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // …add to FrameLayout<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; framelayout.addView(this.mGLSurfaceView);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … …<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mGLSurfaceView.setCocos2dxRenderer(new Cocos2dxRenderer());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; … …</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set framelayout as the content view<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setContentView(framelayout);<BR>}</div></P>
<P>从上面代码可以看出，onCreate调用的init方法才是Cocos2dxActivity初始化的核心。在init方法 中，Cocos2dxActivity创建了一个Framelayout实例，并将该实例作为content View赋给了Cocos2dxActivity的实例。Framelayout实例也并不孤单，一个设置了Cocos2dxRenderer实例的 GLSurfaceView被Added to it。而Cocos2d-x引擎的初始化已经悄悄地在这几行代码间完成了，至于初始化的细节我们后续再做分析。</P>
<P>接下来是onResume方法，它的实现如下：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="57694" class="copybut" id="copybut57694" onclick="doCopy('code57694')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code57694"><BR>&nbsp;&nbsp;&nbsp; @Override<BR>&nbsp;&nbsp;&nbsp; protected void onResume() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.onResume();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cocos2dxHelper.onResume();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mGLSurfaceView.onResume();<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>onResume调用了View的onResume()。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="84397" class="copybut" id="copybut84397" onclick="doCopy('code84397')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84397"><BR>// Cocos2dxGLSurfaceView：<BR>&nbsp;&nbsp;&nbsp; @Override<BR>&nbsp;&nbsp;&nbsp; public void onResume() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.onResume();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.queueEvent(new Runnable() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void run() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleOnResume();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>Cocos2dxGLSurfaceView将该事件打包放到队列里，扔给了另外一个线程去执行（后续会详细说明这个线程），对应的方法在 Cocos2dxRenderer class中。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="4287" class="copybut" id="copybut4287" onclick="doCopy('code4287')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code4287"><BR>&nbsp;&nbsp;&nbsp; public void handleOnResume() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cocos2dxRenderer.nativeOnResume();<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>Render实际上调用的是native方法。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="71175" class="copybut" id="copybut71175" onclick="doCopy('code71175')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code71175"><BR>&nbsp;JNIEXPORT void JNICALL Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeOnResume() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (CCDirector::sharedDirector()-&gt;getOpenGLView()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCApplication::sharedApplication()-&gt;applicationWillEnterForeground();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>applicationWillEnterForeground方法在你的AppDelegate.cpp中；</P>
<P>void AppDelegate::applicationWillEnterForeground() {<BR>&nbsp;&nbsp;&nbsp; CCDirector::sharedDirector()-&gt;startAnimation();//</P>
<P>&nbsp;&nbsp;&nbsp; // if you use SimpleAudioEngine, it must resume here<BR>&nbsp;&nbsp;&nbsp; // SimpleAudioEngine::sharedEngine()-&gt;resumeBackgroundMusic();<BR>}</div></P>
<P>这里仅是重新获得了一下时间罢了。</P>
<P><STRONG>五、Render Thread(渲染线程) - GLThread</STRONG></P>
<P>游戏引擎要兼顾UI事件和屏幕帧刷新。Android的OpenGL应用采用了UI线程(Main Thread) +&nbsp; 渲染线程(Render Thread)的模式。Activity活在Main Thread(主线程)中，也叫做UI线程。该线程负责捕获与用户交互的信息和事件，并与渲染(Render)线程交互。比如当用户接听电话、切换到其他 程序时，渲染线程必须知道发生了 这些事件，并作出即时的处理，而这些事件及处理方式都是由主线程中的Activity以及其装载的View传递给渲染线程的。我们在Cocos2dx的框 架代码中看不到渲染线程的诞生过程，这是因为这一过程是在Android SDK层实现的。</P>
<P>我们回顾一下Cocos2dxActivity.init方法的关键代码：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="70511" class="copybut" id="copybut70511" onclick="doCopy('code70511')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code70511"><BR>&nbsp;&nbsp;&nbsp; // Cocos2dxGLSurfaceView<BR>&nbsp;&nbsp;&nbsp; this.mGLSurfaceView = this.onCreateView();</P>
<P>&nbsp;&nbsp;&nbsp; // …add to FrameLayout<BR>&nbsp;&nbsp;&nbsp; framelayout.addView(this.mGLSurfaceView);<BR>&nbsp;&nbsp;&nbsp; this.mGLSurfaceView.setCocos2dxRenderer(new Cocos2dxRenderer());<br><br>&nbsp;&nbsp;&nbsp; // Set framelayout as the content view<BR>&nbsp;&nbsp;&nbsp; setContentView(framelayout);<BR></div></P>
<P>Cocos2dxGLSurfaceView是 android.opengl.GLSurfaceView的子类。在android 上做原生opengl es 2.0编程的人应该都清楚GLSurfaceView的重要性。但渲染线程并非是在Cocos2dxGLSurfaceView实例化时被创建的，而是在 setRenderer的时候。</P>
<P>我们来看Cocos2dxGLSurfaceView.setCocos2dxRenderer的实现：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="45944" class="copybut" id="copybut45944" onclick="doCopy('code45944')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code45944"><BR>&nbsp;&nbsp;&nbsp; public void setCocos2dxRenderer(final Cocos2dxRenderer renderer) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mCocos2dxRenderer = renderer;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.setRenderer(this.mCocos2dxRenderer);<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>setRender是Cocos2dxGLSurfaceView父类GLSurfaceView实现的方法。在Android SDK GLSurfaceView.java文件中，我们看到：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="19645" class="copybut" id="copybut19645" onclick="doCopy('code19645')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code19645"><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void setRenderer(Renderer renderer) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; checkRenderThreadState();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mEGLConfigChooser == null) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mEGLConfigChooser = new SimpleEGLConfigChooser(true);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mEGLContextFactory == null) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mEGLContextFactory = new DefaultContextFactory();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mEGLWindowSurfaceFactory == null) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mRenderer = renderer;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mGLThread = new GLThread(mThisWeakRef);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mGLThread.start();<BR>&nbsp;&nbsp;&nbsp; }<BR></div></P>
<P>GLThread的实例是在这里被创建并开始执行的。至于渲染线程都干了些什么，我们可以通过其run方法看到：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="71984" class="copybut" id="copybut71984" onclick="doCopy('code71984')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code71984"><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void run() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setName("GLThread " + getId());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (LOG_THREADS) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Log.i("GLThread", "starting tid=" + getId());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; guardedRun();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (InterruptedException e) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fall thru and exit normally<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } finally {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sGLThreadManager.threadExiting(this);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR></div></P>
<P>run方法并没有给我们带来太多有价值的东西，真正有价值的信息藏在guardedRun方法中。guardedRun是这个源文件中规模最为庞 大的方法，但抽取其核心结构后，我们发现它大致就是一个死循环，以下是摘要式的伪代码：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="14968" class="copybut" id="copybut14968" onclick="doCopy('code14968')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code14968"><BR>while (true) {<BR>&nbsp;&nbsp; synchronized (sGLThreadManager) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …. …<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! mEventQueue.isEmpty()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event = mEventQueue.remove(0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; <BR>&nbsp;&nbsp; }//end of synchronized (sGLThreadManager)</P>
<P>&nbsp;&nbsp;&nbsp; if (event != null) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.run();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event = null;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp; }&nbsp; </P>
<P>&nbsp;&nbsp; if needed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);</P>
<P>&nbsp;&nbsp; if needed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view.mRenderer.onSurfaceChanged(gl, w, h);</P>
<P>&nbsp;&nbsp; if needed<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view.mRenderer.onDrawFrame(gl);<BR>}<BR></div><BR>在这里我们看到了event、Renderer的三个回调方法onSurfaceCreated、onSurfaceChanged以及 onDrawFrame，后续我们会对这三个函数做详细分析的。</P>
<P><STRONG>六、游戏逻辑的入口</STRONG></P>
<P>在HelloCpp的Classes下有好多C++代码文件（涉及具体的游戏逻辑），在HelloCpp的android project jni目录下也有Jni胶水代码，那么这些代码是如何和引擎一起互动生效的呢？</P>
<P>上面讲到过，涉及到画面的一些渲染都是在GLThread中进行的，这涉及到onSurfaceCreated、 onSurfaceChanged以及onDrawFrame三个方法。我们看看 Cocos2dxRenderer.onSurfaceCreated方法的实现，该方法会在Surface被首次渲染时调用：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="39131" class="copybut" id="copybut39131" onclick="doCopy('code39131')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code39131"><BR>&nbsp;&nbsp;&nbsp; public void onSurfaceCreated(final GL10 pGL10, final EGLConfig pEGLConfig) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cocos2dxRenderer.nativeInit(this.mScreenWidth, this.mScreenHeight);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mLastTickInNanoSeconds = System.nanoTime();<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>该方法继续调用HelloCpp工程jni目录下的nativeInit代码:<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="66643" class="copybut" id="copybut66643" onclick="doCopy('code66643')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code66643"><BR>void Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeInit(JNIEnv*&nbsp; env, jobject thiz, jint w, jint h)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (!CCDirector::sharedDirector()-&gt;getOpenGLView())<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCEGLView *view = CCEGLView::sharedOpenGLView();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view-&gt;setFrameSize(w, h);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppDelegate *pAppDelegate = new AppDelegate();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCApplication::sharedApplication()-&gt;run();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ccGLInvalidateStateCache();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCShaderCache::sharedShaderCache()-&gt;reloadDefaultShaders();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ccDrawInit();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCTextureCache::reloadAllTextures();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCNotificationCenter::sharedNotificationCenter()-&gt;postNotification(EVENT_COME_TO_FOREGROUND, NULL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCDirector::sharedDirector()-&gt;setGLDefaultValues();<BR>&nbsp;&nbsp;&nbsp; }<BR>}</div></P>
<P>这似乎让我们看到了游戏逻辑的入口了：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="30990" class="copybut" id="copybut30990" onclick="doCopy('code30990')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code30990"><BR>&nbsp;&nbsp;&nbsp; CCEGLView *view = CCEGLView::sharedOpenGLView();<BR>&nbsp;&nbsp;&nbsp; view-&gt;setFrameSize(w, h);</P>
<P>&nbsp;&nbsp;&nbsp; AppDelegate *pAppDelegate = new AppDelegate();<BR>&nbsp;&nbsp;&nbsp; CCApplication::sharedApplication()-&gt;run();<BR></div><BR>继续追踪CCApplication::run方法：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="64507" class="copybut" id="copybut64507" onclick="doCopy('code64507')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code64507"><BR>int CCApplication::run()<BR>{<BR>&nbsp;&nbsp;&nbsp; // Initialize instance and cocos2d.<BR>&nbsp;&nbsp;&nbsp; if (! applicationDidFinishLaunching())<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; return -1;<BR>}</div></P>
<P>applicationDidFinishLaunching，没错这就是游戏逻辑的入口了。我们得回到Samples代码目录中去找到对应方法 的实现。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="37399" class="copybut" id="copybut37399" onclick="doCopy('code37399')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code37399"><BR>//cocos2d-x-2.2.2/samples/Cpp/HelloCpp/Classes/AppDelegate.cpp</P>
<P>bool AppDelegate::applicationDidFinishLaunching() {<BR>&nbsp;&nbsp;&nbsp; // initialize director<BR>&nbsp;&nbsp;&nbsp; CCDirector* pDirector = CCDirector::sharedDirector();<BR>&nbsp;&nbsp;&nbsp; CCEGLView* pEGLView = CCEGLView::sharedOpenGLView();</P>
<P>&nbsp;&nbsp;&nbsp; pDirector-&gt;setOpenGLView(pEGLView);<BR>&nbsp;&nbsp;&nbsp; CCSize frameSize = pEGLView-&gt;getFrameSize();<BR>&nbsp;&nbsp;&nbsp; … …</P>
<P>&nbsp;&nbsp;&nbsp; // turn on display FPS<BR>&nbsp;&nbsp;&nbsp; pDirector-&gt;setDisplayStats(true);</P>
<P>&nbsp;&nbsp;&nbsp; // set FPS. the default value is 1.0/60 if you don't call this<BR>&nbsp;&nbsp;&nbsp; pDirector-&gt;setAnimationInterval(1.0 / 60);</P>
<P>&nbsp;&nbsp;&nbsp; // create a scene. it's an autorelease object<BR>&nbsp;&nbsp;&nbsp; CCScene *pScene = HelloWorld::scene();</P>
<P>&nbsp;&nbsp;&nbsp; // run<BR>&nbsp;&nbsp;&nbsp; pDirector-&gt;runWithScene(pScene);</P>
<P>&nbsp;&nbsp;&nbsp; return true;<BR>}</div></P>
<P>的确，在applicationDidFinishLaunching中我们做了很多引擎参 数的设置。接下来大管家CCDirector实例登场，并运行了HelloWorld Scene的实例。但这依旧是初始化的一部分，虽然方法名让人听起来像是某种持续连贯行为：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="45280" class="copybut" id="copybut45280" onclick="doCopy('code45280')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code45280"><BR>//cocos2d-x-2.2.2/cocos2dx/CCDirector.cpp</P>
<P>void CCDirector::runWithScene(CCScene *pScene)<BR>{<BR>&nbsp;&nbsp;&nbsp; … …<BR>&nbsp;&nbsp;&nbsp; pushScene(pScene);<BR>&nbsp;&nbsp;&nbsp; startAnimation();<BR>}</P>
<P>void CCDisplayLinkDirector::startAnimation(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (CCTime::gettimeofdayCocos2d(m_pLastUpdate, NULL) != 0)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCLOG("cocos2d: DisplayLinkDirector: Error on gettimeofday");<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; m_bInvalid = false;<BR>}<BR></div><BR>两个方法均只是初始化了某些数据成员变量，并未真正将引擎驱动起来。</P>
<P><BR><STRONG>七、驱动引擎</STRONG></P>
<P>之所以游戏画面是运动的，那是因为屏幕以较高的帧数刷新的缘故，这样人眼就会看到连续的动作，就和电影的放映原理是一样的。在Cocos2d-x 引擎中这些驱动屏幕刷新的代码在哪里呢？</P>
<P>我们回顾一下之前谈到的GLThread线程，我们说过画面渲染的工作都是由它来完成的。GLThread的核心是guardedRun函数，该 函数以“死循环”的方式调用Cocos2dxRender.onDrawFrame方法对画面进行持续渲染。</P>
<P>我们来看看引擎实现的Cocos2dxRender.onDrawFrame方法：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="95078" class="copybut" id="copybut95078" onclick="doCopy('code95078')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code95078"><BR>public void onDrawFrame(final GL10 gl) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * FPS controlling algorithm is not accurate, and it will slow down FPS<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * on some devices. So comment FPS controlling code.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final long nowInNanoSeconds = System.nanoTime();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final long interval = nowInNanoSeconds – this.mLastTickInNanoSeconds;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // should render a frame when onDrawFrame() is called or there is a<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // "ghost"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cocos2dxRenderer.nativeRender();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // fps controlling<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (interval &lt; Cocos2dxRenderer.sAnimationInterval) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // because we render it before, so we should sleep twice time interval<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep((Cocos2dxRenderer.sAnimationInterval – interval) / Cocos2dxRenderer.NANOSECONDSPERMICROSECOND);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (final Exception e) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.mLastTickInNanoSeconds = nowInNanoSeconds;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>这个方法实现得比较奇怪，似乎修改过多次，但最后还是决定只保留了一个方法调用： Cocos2dxRenderer.nativeRender()。从注释掉的代码来看，似乎是想在这个方法中通过Thread.sleep来控制 Render Thread渲染的帧率。但由于控制的不理想，索性就不控制了，让guardedRun真正变成了dead loop。但从HelloCpp Sample运行时的状态显示，画面始终保持在60帧左右，让人十分诧异。据说Cocos2d-x 3.0版本重新设计了渲染这块的机制。(后记：在Android上虽然没有帧数控制，但真正的渲染帧率实际上还受到"垂直同步"信号 – vertical sync的影响。在游戏中，也许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，显卡无法绘制下一屏，只有等vsync信号到达，才可以绘制。这样fps实际上要要受到操作系统刷新率值的制约）。</P>
<P>nativeRender从命名来看，这显然是一个C++编写的函数实现。我们只能到jni目录下寻找。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="72243" class="copybut" id="copybut72243" onclick="doCopy('code72243')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code72243"><BR>cocos2d-x-2.2.2/cocos2dx/platform/android/jni/ Java_org_cocos2dx_lib_Cocos2dxRenderer.cpp</P>
<P>&nbsp;&nbsp;&nbsp; JNIEXPORT void JNICALL Java_org_cocos2dx_lib_Cocos2dxRenderer_nativeRender(JNIEnv* env) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cocos2d::CCDirector::sharedDirector()-&gt;mainLoop();<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>nativeRender也很简洁，直接调用了CCDirector的mainLoop，也就是说每帧渲染过程中真正干活地是 CCDirector::mainLoop。到此我们终于找到了引擎渲染的驱动器：GLThead::guardedRun，以“死循环”的方式刷新着画面，让我们感受到“动”的魅力。</P>
<P><STRONG>八、mainLoop</STRONG></P>
<P>进一步我们来看看mainLoop所做的工作。mainLoop是CCDirector类的一个纯虚函数，CCDirector的子类CCDisplayLinkDirector真正实现了 它：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="67307" class="copybut" id="copybut67307" onclick="doCopy('code67307')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code67307"><BR>//CCDirector.cpp<BR>void CCDisplayLinkDirector::mainLoop(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; if (m_bPurgeDirecotorInNextLoop)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bPurgeDirecotorInNextLoop = false;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; purgeDirector();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; else if (! m_bInvalid)<BR>&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawScene();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // release the objects<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCPoolManager::sharedPoolManager()-&gt;pop();<BR>&nbsp;&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>void CCDirector::drawScene(void)<BR>{<BR>&nbsp;&nbsp;&nbsp; // calculate "global" dt<BR>&nbsp;&nbsp;&nbsp; calculateDeltaTime();</P>
<P>&nbsp;&nbsp;&nbsp; //tick before glClear: issue #533<BR>&nbsp;&nbsp;&nbsp; if (! m_bPaused)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pScheduler-&gt;update(m_fDeltaTime);<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</P>
<P>&nbsp;&nbsp;&nbsp; /* to avoid flickr, nextScene MUST be here: after tick and before draw.<BR>&nbsp;&nbsp;&nbsp;&nbsp; XXX: Which bug is this one. It seems that it can't be reproduced with v0.9 */<BR>&nbsp;&nbsp;&nbsp; if (m_pNextScene)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setNextScene();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; kmGLPushMatrix();</P>
<P>&nbsp;&nbsp;&nbsp; // draw the scene<BR>&nbsp;&nbsp;&nbsp; if (m_pRunningScene)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pRunningScene-&gt;visit();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; // draw the notifications node<BR>&nbsp;&nbsp;&nbsp; if (m_pNotificationNode)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pNotificationNode-&gt;visit();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (m_bDisplayStats)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; showStats();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; kmGLPopMatrix();</P>
<P>&nbsp;&nbsp;&nbsp; m_uTotalFrames++;</P>
<P>&nbsp;&nbsp;&nbsp; // swap buffers<BR>&nbsp;&nbsp;&nbsp; if (m_pobOpenGLView)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pobOpenGLView-&gt;swapBuffers();<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; if (m_bDisplayStats)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; calculateMPF();<BR>&nbsp;&nbsp;&nbsp; }<BR>}<BR></div><BR>帧渲染由mainLoop调用的drawScene()完成，drawScene方法根据Scene下的渲染树，根据node的最新属性逐个渲染 node，并调整各个Node的调度定时器数据，细节这里就不详细说明了。</P>
<P><STRONG>九、UI线程与GLThread的交互</STRONG></P>
<P>用户的屏幕触控动作由UI线程捕捉到，该类事件需要传递给引擎，并由GLThread根据各个画面元素的最新状态重新绘制画面。UI线程负责处理用户交互 事件，并将特定的事件通知GLThread处理。UI线程通过Cocos2dxGLSurfaceView的queueEvent方法，将事件以及处理方 法传递给GLThread执行的。</P>
<P>Cocos2dxGLSurfaceView的queueEvent方法继承自其父类GLSurfaceView：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="55557" class="copybut" id="copybut55557" onclick="doCopy('code55557')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code55557"><BR>&nbsp;&nbsp;&nbsp; public void queueEvent(Runnable r) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mGLThread.queueEvent(r);<BR>&nbsp;&nbsp;&nbsp; }<BR></div><BR>而GLThread的queueEvent方法实现如下：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="90806" class="copybut" id="copybut90806" onclick="doCopy('code90806')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code90806"><BR>public void queueEvent(Runnable r) {<BR>&nbsp;&nbsp;&nbsp; if (r == null) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new IllegalArgumentException("r must not be null");<BR>&nbsp;&nbsp;&nbsp; }&nbsp; <BR>&nbsp;&nbsp;&nbsp; synchronized(sGLThreadManager) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mEventQueue.add(r);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sGLThreadManager.notifyAll();<BR>&nbsp;&nbsp;&nbsp; }&nbsp; <BR>}<BR></div><BR>该方法将event互斥地放入EventQueue，并通知阻塞在Queue上的线程取货。</P>
<P>运行着的GLThread实例在guardedRun中会从event队列中取出runnable event并run的。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="85060" class="copybut" id="copybut85060" onclick="doCopy('code85060')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code85060">&nbsp; <BR>while (true) {<BR>&nbsp;&nbsp;&nbsp; synchronized (sGLThreadManager) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mShouldExit) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! mEventQueue.isEmpty()) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event = mEventQueue.remove(0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …….<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; … …<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (event != null) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.run();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event = null;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<BR>&nbsp;&nbsp;&nbsp; }&nbsp; <BR>&nbsp;&nbsp;&nbsp; …<BR>}</div></P>
<P>Activity的各种事件Pause、Resume、Stop以及View的各种屏幕触控事件都是通过queueEvent传递给GLThread执行的，比如：View的onKeyDown方法：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="28854" class="copybut" id="copybut28854" onclick="doCopy('code28854')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code28854"><BR>&nbsp;&nbsp;&nbsp; //Cocos2dxGLSurfaceView.java<BR>&nbsp;&nbsp;&nbsp; @Override<BR>&nbsp;&nbsp;&nbsp; public boolean onKeyDown(final int pKeyCode, final KeyEvent pKeyEvent) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (pKeyCode) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case KeyEvent.KEYCODE_BACK:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case KeyEvent.KEYCODE_MENU:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.queueEvent(new Runnable() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void run() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleKeyDown(pKeyCode);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return super.onKeyDown(pKeyCode, pKeyEvent);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR></div></P>
<P><STRONG>十、小结</STRONG></P>
<P>有了以上的对Cocos2d-x引擎的理解后，再编写游戏代码就更加游刃有余了，至少出现问题时，我们知道应该在哪里查找了。就像对汽车的发动机了如指掌 后，一旦发生动力故障，我们基本知道排除的方法。但对发动机了解的再透彻，也不能代表就能设计和生产出好车，游戏也是这样，对引擎了解是一码事，设计和实现出好游戏是另外一码事。学习引擎只是编写游戏的起点而已。</P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/102444.html'>使用Get方式提交数据到Tomcat服务器的方法</a><a>下一篇</a><a href='/php/biji/102446.html'>PHP使用Memcache时模拟命名空间及缓存失效问题的解决</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>