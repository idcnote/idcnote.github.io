<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>你所不了解的javascript操作DOM的细节知识点(一)_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="一：Node类型<br />
DOM1级定义了一个Node接口，该接口是由DOM中的所有节点类型实现。每个节点都有一个nodeType属性，用于表明节点的类型，节点类型在Node类型中有以下几种：<br />
Node.ELEMENT_" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">你所不了解的javascript操作DOM的细节知识点(一)</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>一：Node类型<br />
DOM1级定义了一个Node接口，该接口是由DOM中的所有节点类型实现。每个节点都有一个nodeType属性，用于表明节点的类型，节点类型在Node类型中有以下几种：<br />
Node.ELEMENT_</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>一：Node类型</strong></p>
<p>DOM1级定义了一个Node接口，该接口是由DOM中的所有节点类型实现。每个节点都有一个nodeType属性，用于表明节点的类型，节点类型在Node类型中有以下几种：</p>
<p>Node.ELEMENT_NODE(1); 元素节点<br />
Node.ATTRIBUTE_NODE(2); 属性节点<br />
Node.TEXT_NODE(3); 文本节点<br />
Node.DOCUMENT_NODE(9); 文档节点</p>
<p>其实还有很多种，但是那些都不是很常用，所以就来理解这其中4种就可以了，我们先来看看节点类型，比如如下代码：</p>
<p>HTML代码如下：<br />
</p>
<div class="phpstudycode">
<pre class="brush:xhtml;">
&lt;div id="test"&gt;
 &lt;p&gt;aaaaaa&lt;/p&gt;
 &lt;p&gt;bbbbbb&lt;/p&gt;
 &lt;p&gt;cccccc&lt;/p&gt;
&lt;/div&gt;</pre>
</div>
<p>JS如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
if(test.nodeType === Node.ELEMENT_NODE) {
 alert(1)
}</pre>
</div>
<p>如上代码在IE8及以下下是不行的，会报错，如下：</p>
<p></p>
<p>因为IE没有公开Node类型的构造函数，因此在IE8-下会有错误，但是我们可以通过数值来比较，比如上面的要比较元素节点的话，我们可以使用1来比较，同理属性节点是2，文本节点是3；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
// 下面的所有的浏览器都支持
if(test.nodeType == 1) { 
  alert(1)
}</pre>
</div>
<p><strong>理解nodeName与nodeValue</strong></p>
<p>nodeName保存的是元素的标签名，而nodeValue一般都是null；我们可以看如下代码，没有特殊的说明，HTML代码都是上面的，因此这边就不贴代码了；如下JS代码测试：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
if(test.nodeType == 1) {
 console.log(test.nodeName); // 打印DIV
 console.log(test.nodeValue); // 打印null
}</pre>
</div>
<p>理解节点关系</p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
 &lt;head&gt;
 &lt;meta charset="UTF-8"&gt;
 &lt;title&gt;Document&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>如上代码，我们可以把head和body是html的子元素，同理html是他们的父级元素，那么head和body就是兄弟元素了，那么head及body里面的就是子元素了，我们需要明白的是每个节点都有一个childNodes属性，其保存的是类似数组的元素，其也有length属性，但是他不是数组Array的实例，比如我们可以看看如下测试代码即可：</p>
<div class="phpstudycode">
<pre class="brush:xhtml;">
&lt;div id="test"&gt;
 &lt;p&gt;aaaaaa&lt;/p&gt;
 &lt;p&gt;bbbbbb&lt;/p&gt;
 &lt;p&gt;cccccc&lt;/p&gt;
&lt;/div&gt;</pre>
</div>
<p>JS代码如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
if(test.nodeType == 1) {
 console.log(test.childNodes);
 console.log(test.childNodes.length);
}</pre>
</div>
<p>如上代码，在标准浏览器下及IE9+下 第一行打印如下：</p>
<p>[text, p, text, p, text, p, text, item: function]</p>
<p>第二行打印7 长度为7，因为他们把文本节点那个空格也包括进去了，但是在IE8及以下，长度为3，他们不包括文本空格的节点，因此想要统一的话，我们可以编写HTML代码去掉空格，如下HTML代码即可；</p>
<p>&lt;div id="test"&gt;&lt;p&gt;aaaaaa&lt;/p&gt;&lt;p&gt;bbbbbb&lt;/p&gt;&lt;p&gt;cccccc&lt;/p&gt;&lt;/div&gt;</p>
<p>这个问题稍后在仔细考虑，我们现在来看看如何取得子元素，我们可以使用2种方法，第一种是使用中括号[index]索引，第二种是使用item[index]索引，如下代码：</p>
<p>console.log(test.childNodes[1]); // &lt;p&gt;bbbbbb&lt;/p&gt;<br />
console.log(test.childNodes.item(1)); // &lt;p&gt;bbbbbb&lt;/p&gt;</p>
<p>但是他们并不是数组，我们可以测试下代码即可，如下代码：</p>
<p>console.log(Object.prototype.toString.call(test.childNodes) === "[object Array]"); <br />
// false但是我们使其转换为数组，如下代码：</p>
<p>//在IE8 及之前版本中无效<br />
var arrayOfNodes = Array.prototype.slice.call(test.childNodes,0);<br />
console.log(arrayOfNodes instanceof Array);</p>
<p>// true不过在IE8及之前不生效；由于IE8及更早版本将NodeList实现为一个COM对象，而我们不能像使用JScript对象那样使用对象，要想在IE低版本中转换为Array的形式，我们可以像下面一样封装一个方法即可；<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
function convertToArray(nodes){
 var array = null;
 try {
  array = Array.prototype.slice.call(nodes, 0); //针对非IE 浏览器
 } catch (ex) {
  array = new Array();
  for (var i=0, len=nodes.length; i &lt; len; i++){
   array.push(nodes[i]);
  }
 }
 return array;
}
var test = document.getElementById("test");
var testArray = convertToArray(test.childNodes);
console.log(testArray instanceof Array); // true</pre>
</div>
<p>理解parentNode（父节点），previousSibling(上一个兄弟节点)，nextSibling（下一个兄弟节点）;</p>
<p>每个节点都有一个parentNode属性，该属性指向文档中父节点，previousSibling是指当前节点的上一个同胞节点，nextSibling是指当前节点的下一个同胞节点，比如如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;div id="test"&gt;&lt;p&gt;aaaaaa&lt;/p&gt;&lt;p&gt;bbbbbb&lt;/p&gt;&lt;p&gt;cccccc&lt;/p&gt;&lt;/div&gt;
var test = document.getElementById("test");
if(test.nodeType == 1) {
 var secodeChild = test.childNodes[1];
 console.log(secodeChild); // &lt;p&gt;bbbbbb&lt;/p&gt;
 console.log(secodeChild.previousSibling); // &lt;p&gt;aaaaaa&lt;/p&gt;
 console.log(secodeChild.nextSibling); // &lt;p&gt;cccccc&lt;/p&gt;
}</pre>
</div>
<p>如果该节点列表中只有一个节点的话，那么该节点的previousSibling和nextSibling都为null；父节点的firstChild指向了父节点中第一个节点；如下代码：</p>
<p>&lt;div id="test"&gt;&lt;p class="a"&gt;aaaaaa&lt;/p&gt;&lt;p class="b"&gt;bbbbbb&lt;/p&gt;&lt;p class="c"&gt;cccccc&lt;/p&gt;&lt;/div&gt;</p>
<p>JS如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
if(test.nodeType == 1) { 
 console.log(test.firstChild); // &lt;p class="a"&gt;aaaaaa&lt;/p&gt;
 console.log(test.lastChild); // &lt;p class="c"&gt;cccccc&lt;/p&gt;
}</pre>
</div>
<p>父节点的firstChild始终等于父节点的.childNodes[0],父节点的lastChild始终等于父节点的.childNodes[父节点的.childNodes.length - 1]; 如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
console.log(test.firstChild === test.childNodes[0]); // true
console.log(test.lastChild === test.childNodes[test.childNodes.length - 1]); // true</pre>
</div>
<p>如果没有子节点的话，那么firstChild和lastChild都指向为空null;</p>
<p>hasChildNodes()：如果需要判断该父节点有没有子节点的话，可以使用该方法判断，返回的是一个布尔型，有返回true，没有返回false，如下代码：</p>
<p>&lt;div id="test"&gt;&lt;p class="a"&gt;aaaaaa&lt;/p&gt;&lt;p class="b"&gt;bbbbbb&lt;/p&gt;&lt;p class="c"&gt;cccccc&lt;/p&gt;&lt;/div&gt;</p>
<p>JS代码如下：</p>
<p>var test = document.getElementById("test");<br />
console.log(test.hasChildNodes());</p>
<p>// true如果是如下的 就返回false；如下代码：</p>
<p>&lt;div id="test"&gt;&lt;/div&gt;<br />
var test = document.getElementById("test");<br />
console.log(test.hasChildNodes()); // false</p>
<p>ownerDocument: 所有节点都有最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点，这种关系表示的任何节点都属于它所在的文档，任何节点都不能同时存在两个或更多文档中，通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点；如下测试代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;div id="test"&gt;
 &lt;p class="a"&gt;11&lt;/p&gt;
&lt;/div&gt;
var test = document.getElementById("test");
console.log(test.ownerDocument); // document
var p = test.ownerDocument.getElementsByTagName("p");
console.log(p); // &lt;p class="a"&gt;11&lt;/p&gt;</pre>
</div>
<p>appendChild(): 用于向childNodes列表的末尾添加一个节点；返回的是新增加的节点；如下代码：</p>
<p>&lt;div id="test"&gt;<br />
&lt;p class="a"&gt;11&lt;/p&gt;<br />
&lt;/div&gt;</p>
<p>JS代码如下：<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
var newNode = document.createElement("p");
var returnNode = test.appendChild(newNode);
console.log(returnNode); // &lt;p&gt;&lt;/p&gt;
console.log(returnNode === newNode); // true
console.log(test.lastChild === newNode); // true</pre>
</div>
<p><strong>insertBefore(): </strong>该方法是将新节点插入到指定的节点的前面去，该方法接收2个参数，要插入的节点和作为参照的节点；插入节点后，被插入的节点会变成参照节点的前一个同胞节点，同时被方法返回，如下代码：</p>
<p>&lt;div id="test"&gt;<br />
&lt;p class="a"&gt;11&lt;/p&gt;<br />
&lt;/div&gt;</p>
<p>JS代码如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
var newNode = document.createElement("div");
var returnNode = test.insertBefore(newNode,test.childNodes[0]);
console.log(returnNode); // &lt;div&gt;&lt;/div&gt;
console.log(returnNode === newNode); // true</pre>
</div>
<p>插入节点后，结构变成如下：</p>
<p><div class="codetitle"><span>http://127.0.0.1/dom/dom.html</p>
<p>domain: 该属性包含页面的域名；如下测试代码：</p>
<p>console.log(document.domain); // 127.0.0.1</p>
<p>域名也可以设置的，比如常见的跨子域的情况下，我们需要设置相同的父域即可完成跨域；</p>
<p>namedItem(): 该方法可以通过元素的name特性取得集合中的项，比如现在页面上有很多input的框，我想通过他们的name属性取得自己想要的哪一项，测试代码如下：</p>
<p><strong>HTML代码如下：</strong></p>
<p>&lt;input name="aa"/&gt;<br />
&lt;input name="bb"/&gt;</p>
<p>JS代码如下：</p>
<p>var inputs = document.getElementsByTagName("input");<br />
console.log(inputs.namedItem("aa")); // &lt;input name="aa"/&gt;</p>
<p>我们还可以通过方括号的语法来访问，如下代码：</p>
<p>console.log(inputs["aa"]); // &lt;input name="aa"/&gt;</p>
<p>要想取得文档中所有的元素，可以向getElementsByTagName()中传入”*”; 星号表示全部的意思；</p>
<p>getElementsByName(); 该方法也是HTMLDocument类型才有的方法，这个方法会返回带有给定name特性的所有元素，如下测试代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;input name="aa" type="radio"/&gt;
&lt;input name="aa" type="radio"/&gt;
var aa = document.getElementsByName("aa");
console.log(aa); // object
console.log(aa.length); // 2</pre>
</div>
<p>该方法也会返回一个HTMLCollection.</p>
<p>浏览器支持程度IE，firefox，chrome都支持；</p>
<p>Element类型</p>
<p>Element节点有以下特征：</p>
<p>nodeType的值为1；</p>
<p>nodeName的值为元素的标签名；</p>
<p>nodeValue的值为null；</p>
<p>parentNode可能是Document或Element</p>
<p>要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性，这两个属性会返回相同的值，如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;div id="test"&gt;&lt;/div&gt;
var test = document.getElementById("test");
console.log(test.tagName); // DIV
console.log(test.nodeName); // DIV
console.log(test.nodeValue); // null;
console.log(test.parentNode); // body
console.log(test.nodeType); // 1</pre>
</div>
<p><strong>理解HTML元素中的获取属性的方法</strong></p>
<p>所有HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承Element；如果想要取得HTML元素的特性的话，有下面几个方法：</p>
<p><strong>getAttribute(); 获取元素的属性的方法；如下测试代码：</strong></p>
<p></p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;div id="test" class="testName" title="aa"&gt;&lt;/div&gt;
var test = document.getElementById("test");
console.log(test.getAttribute("id")); // test
console.log(test.getAttribute("class")); // testName
console.log(test.getAttribute("title")); // aa</pre>
</div>
<p>注意：上面的获取类名在IE8+及标准浏览器下都是使用获取属性class来取得类名，上面的如果在IE7下会返回null, 但是在IE7及以下是使用className这个属性来获取的；如下代码：在IE7下测试：</p>
<p>console.log(test.getAttribute("className")); // testName</p>
<p>当然也可以取得自定义的属性；如下代码：</p>
<p>&lt;div id="test" data-value="test1"&gt;&lt;/div&gt;</p>
<p>console.log(test.getAttribute("data-value")); // test1</p>
<p>setAttribute() 设置元素的属性；该方法接收2个参数，第一个参数是属性名称，第二个参数是对应的值；如果该值存在，则会以现在的值替换之前的值，如果属性名不存在，则会创建该属性，并指定该属性的值；如下代码：<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
&lt;div id="test"&gt;&lt;/div&gt;
// JS代码如下：
var test = document.getElementById("test");
test.setAttribute("id",'test');
test.setAttribute("class","testName");
test.setAttribute("title","aa");
test.setAttribute("data-value","test1");</pre>
</div>
<p>生成HTML结构如下：</p>
<p>&lt;div id="test" class="testName" title="aa" data-value="test1"&gt;&lt;/div&gt;</p>
<p>removeAttribute(); 删除元素的特性；如下代码：</p>
<p>&lt;div id="test" class="testName" title="aa" data-value="test1"&gt;&lt;/div&gt;</p>
<p><strong>JS代码如下：</strong></p>
<div class="phpstudycode">
<pre class="brush:js;">
var test = document.getElementById("test");
test.removeAttribute("id");
test.removeAttribute("class");
test.removeAttribute("title");
test.removeAttribute("data-value");</pre>
</div>
<p>IE7及以下删除类名需要使用className;</p>
<p>attributes属性</p>
<p>Element类型是使用attributes属性的唯一一个dom节点类型，attributes属性包含一个NamedNodeMap集合；该对象有以下方法：</p>
<p>getNamedItem(name): 返回nodeName属性等于name的节点；</p>
<p>attributes属性中包含一系列节点，每个节点的nodeName就是特性的名称，而节点的nodeValue就是节点值，要取得元素id的特性，如下代码：</p>
<p>&lt;div id="test" class="testName" title="aa" data-value="test1"&gt;&lt;/div&gt;JS代码如下：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="58700" class="copybut" id="copybut58700" onclick="doCopy('code58700')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code58700"><br />
var div = document.getElementById("test");<br />
var id = div.attributes.getNamedItem("id").nodeValue;<br />
console.log(id);&nbsp; // test<br />
</div></p>
<p>我们也可以通过中括号的语法来获取的，如下代码：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="40137" class="copybut" id="copybut40137" onclick="doCopy('code40137')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code40137"><br />
var id = div.attributes['id'].nodeValue;<br />
console.log(id); // test<br />
</div></p>
<p>同样我们也可以通过上面介绍的getAttribute(“id”)方法来获取元素，如下代码：</p>
<p>console.log(div.getAttribute("id")); // test</p>
<p>也可以通过以下方法给元素设置id，如下方法：</p>
<p>div.attributes["id"].nodeValue = "aa";</p>
<p>removeNamedItem(name): 从列表中移除nodeName属性等于name的节点;</p>
<p>调用removeNamedItem()方法与在元素上调用removeAttribute()方法的效果相同，是直接删除具有给定名称的特性。他们之间的区别是：removeNamedItem()方法返回表示被删除特性的节点；</p>
<p>如下代码：</p>
<p>&lt;div id="test" class="testName" title="aa" data-value="test1"&gt;&lt;/div&gt;</p>
<p>JS代码如下：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="22383" class="copybut" id="copybut22383" onclick="doCopy('code22383')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code22383"><br />
var div = document.getElementById("test");<br />
var oldAttr = div.attributes.removeNamedItem("id");<br />
console.log(oldAttr); // 返回是被删除的节点&nbsp; id="test"<br />
</div></p>
<p>现在的html结构变成如下：</p>
<p>&lt;div class="testName" title="aa" data-value="test1"&gt;&lt;/div&gt;</p>
<p>如上方法：目前IE，firefox，chrome浏览器都支持；</p>
<p>但是上面我们有getAttribute,setAttribute(),removeAttribute()方法，我们可以使用这些方法足够代替上面介绍的几个方法，但是如果想遍历一个元素上有多少个属性时，attributes这个就可以派上用上了，如下代码：</p>
<p>HTML代码如下：</p>
<p>&lt;div id="test" class="testName" title="aa" data-value="test1"&gt;&lt;/div&gt;</p>
<p>JS代码如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var div = document.getElementById("test");
function outputAttributes(element) {
 var arrs = new Array();
 var attrName,
   attrValue,
  i,
  len;
 for(i = 0, len = element.attributes.length; i &lt; len; i++) {
  attrName = element.attributes[i].nodeName;
  attrValue = element.attributes[i].nodeValue;
  arrs.push(attrName + "='" + attrValue + "'");
 }
 return arrs.join(" ");
}
console.log(outputAttributes(div));</pre>
</div>
<p>结果打印如下：</p>
<p>id='test' class='testName' title='aa' data-value='test1'</p>
<p>上面的函数使用一个数组来保存名值对，最后再以空格为分隔符将它们拼接起来，但是上面的代码我们需要注意两点：</p>
<p>1.针对attributes对象中的特性，不同的浏览器返回的顺序不同。<br />
2.IE7及更早的版本会返回HTML元素中所有可能的特性，包括没有指定的特性；<br />
针对IE7的问题我们可以进行改进，我们都知道，每个特性节点都有一个名为specified的属性，这个属性值如果为true，则意味着要么在HTML中指定了相应的特性，要么通过setAttribute方法设置了该特性，在IE中，所有为设置过的特性该属性的之都为false；如下代码：<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
var div = document.getElementById("test");
function outputAttributes(element) {
 var arrs = new Array();
 var attrName,
  attrValue,
 i,
 len;
 for(i = 0, len = element.attributes.length; i &lt; len; i++) {
  attrName = element.attributes[i].nodeName;
  attrValue = element.attributes[i].nodeValue;
  if(element.attributes[i].specified) {
    arrs.push(attrName + "='" + attrValue + "'");
  }
 }
 return arrs.join(" ");
}
console.log(outputAttributes(div));</pre>
</div>
<p><strong>理解元素的子节点</strong></p>
<p>元素可以有任意数目的子节点和后代节点，元素的childNodes属性中它包含了它的所有子节点，这些子节点可能是元素，文本节点，注释或处理指令；不同的浏览器子节点的个数不一样，下面我们来看看demo如下：</p>
<div class="phpstudycode">
<pre class="brush:xhtml;">
&lt;ul id="list"&gt;
 &lt;li&gt;11&lt;/li&gt;
 &lt;li&gt;22&lt;/li&gt;
 &lt;li&gt;33&lt;/li&gt;
&lt;/ul&gt;</pre>
</div>
<p>JS代码如下：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="49087" class="copybut" id="copybut49087" onclick="doCopy('code49087')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49087"><br />
var list = document.getElementById("list");<br />
console.log(list.childNodes);<br />
console.log(list.childNodes.length);<br />
</div></p>
<p>我们之前在上面讲过，在标准浏览器下(IE9+,firefox,chrome)下，打印的长度是7个，因为他们把空格也包含上去，在IE8-及以下的浏览器返回的是3个子元素，这是表现的正常情况下，但是如果我现在把html元素的空格都去掉的话，那么所有的浏览器都会返回3个子元素，如下代码：<br />
</p>
<p>&lt;ul id="list"&gt;&lt;li&gt;11&lt;/li&gt;&lt;li&gt;22&lt;/li&gt;&lt;li&gt;33&lt;/li&gt;&lt;/ul&gt;</p>
<p>JS代码如下：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="49087" class="copybut" id="copybut49087" onclick="doCopy('code49087')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49087"><br />
var list = document.getElementById("list");<br />
console.log(list.childNodes);<br />
console.log(list.childNodes.length);<br />
</div></p>
<p>那么平时我们不可能都这样小心小意的编写html代码的，因为一步小心就有一个空格产生，因此我们可以如下判断下是不是元素节点；如下代码演示：</p>
<div class="phpstudycode">
<pre class="brush:xhtml;">
&lt;ul id="list"&gt;
 &lt;li&gt;11&lt;/li&gt;
 &lt;li&gt;22&lt;/li&gt;
 &lt;li&gt;33&lt;/li&gt;
&lt;/ul&gt;</pre>
</div>
<p>JS代码如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var list = document.getElementById("list");
var arrs = [];
for(var i = 0, ilen = list.childNodes.length; i &lt; ilen; i++) {
 var curElement = list.childNodes[i];
 if(curElement.nodeType === 1){
   arrs.push(curElement);
 }
}
console.log(arrs); 
console.log(arrs.length); // 3</pre>
</div>
<p>如上代码在所有的浏览器都支持，通过判断该元素是不是元素节点，然后在执行后续操作；不是元素节点都会过滤掉，因此返回的长度都为3；</p>
<p><strong>理解Text类型</strong></p>
<p>Text节点具有以下特征：</p>
<p>nodeType的值为3；<br />
nodeName的值为”#text”;<br />
nodeValue的值为节点所包含的文本；<br />
parentNode是一个Element；</p>
<p>没有子节点；</p>
<p>1.创建文本节点；<br />
可以使用document.createTextNode()创建新文本节点，这个方法需要一个参数，即要插入的文本，如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var element = document.createElement("div");
var text = document.createTextNode("aa");
element.appendChild(text); 
document.body.appendChild(element); </pre>
</div>
<p>2. 分割文本节点splitText(offset); 从offset指定的位置将当前的文本节点分成2个文本节点；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var element = document.createElement("div");
var text = document.createTextNode("aabbbccc");
element.appendChild(text);
document.body.appendChild(element);

var newNode = element.firstChild.splitText(5);
console.log(element.firstChild.nodeValue); // aabbb
console.log(newNode.nodeValue); // ccc 
console.log(element.childNodes.length); // 2</pre>
</div>
<p>浏览器支持的程度有IE，firefox,chrome都支持；</p>
<p>理解DOM操作—动态插入脚本</p>
<p>我们动态插入JS脚本，常见的写法有如下代码即可插入：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var script = document.createElement("script");
script.type ="text/javascript";
script.src = 'a.js';
document.body.appendChild(script);</pre>
</div>
<p>即可在body最后面动态插如a.js，此动态插入不会堵塞浏览器加载；我们为了更加扩张性，我们也可以封装一个函数，如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
function loadScript(url) {
 var script = document.createElement("script");
 script.type = "text/javascript";
 script.src = url;
 document.body.appendChild(script);
}
loadScript("a.js");</pre>
</div>
<p>当页面有多个js需要动态插入的话，可以依次调用loadScript函数即可；<br />
但是假如我们现在有这么一个需求，动态加载JS完后，我想在这后面做点事情，我们都知道，动态加载也可以理解为异步加载，不会堵塞浏览器，但是我们需要如何知道动态JS已经加载完了呢？</p>
<p>我们之前讲过一篇文章是 “Javascript事件总结”中有判断JS动态加载完后使用load事件来监听js是否动态加载完，现在我们再来复习下load事件；<br />
Javascript中最常用的一个事件是load，当页面加载完后(包括所有的图片，javascript文件，css文件等外部资源)。就会触发window上面的load事件；目前可以有2种触发load事件，一种是直接放在body上面触发；比如如下代码：</p>
<p>&lt;body onload=”a()”&gt;&lt;/body&gt;</p>
<p>第二种是通过JS来触发，如下代码：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="35864" class="copybut" id="copybut35864" onclick="doCopy('code35864')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code35864"><br />
EventUtil.addHandler(window,'load',function(event){<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(1);<br />
});<br />
</div></p>
<p>上面的EventUtil.addHandler 是我们之前在javascript事件总结中封装的JS函数，现在我们直接拿过来使用，如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var EventUtil = {
 addHandler: function(element,type,handler) {
  if(element.addEventListener) {
    element.addEventListener(type,handler,false);
  }else if(element.attachEvent) {
   element.attachEvent("on"+type,handler);
  }else {
   element["on" +type] = handler;
  }
 },
 removeHandler: function(element,type,handler){
  if(element.removeEventListener) {
    element.removeEventListener(type,handler,false);
  }else if(element.detachEvent) {
   element.detachEvent("on"+type,handler);
  }else {
   element["on" +type] = null;
  }
 },
 getEvent: function(event) {
  return event &#63; event : window.event;
 },
 getTarget: function(event) {
  return event.target || event.srcElement;
 },
 preventDefault: function(event){
  if(event.preventDefault) {
   event.preventDefault();
  }else {
   event.returnValue = false;
  }
 },
 stopPropagation: function(event) {
  if(event.stopPropagation) {
   event.stopPropagation();
  }else {
   event.cancelBubble = true;
  }
 }
};</pre>
</div>
<p>下面我们来看看如何使用JS事件来判断JS是否加载完成的代码，我们可以使用load事件来监听，如下代码：</p>
<p></p>
<div class="phpstudycode">
<pre class="brush:js;">
EventUtil.addHandler(window,'load',function(){
 var script = document.createElement("script");
 EventUtil.addHandler(script,'load',function(event){
  console.log(script.src);
 });
 script.src = 'a.js';
 document.body.appendChild(script);
});</pre>
</div>
<p>如上代码，script元素也会触发load事件，以便可以确定动态加载jS是否加载完成，上面的代码指定src属性和指定的事件处理程序的事件可以调换位置，先后顺序不重要，如上代码，我们也可以这样写，如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
EventUtil.addHandler(window,'load',function(){
 var script = document.createElement("script");
 script.src = 'a.js';
 document.body.appendChild(script);
 EventUtil.addHandler(script,'load',function(event){
  console.log(script.src);
 });  
});</pre>
</div>
<p>目前只有IE9+，Firefox，opera，chrome和safari3+支持，IE8及以下不支持该load事件，因此我们需要针对IE8及以下做处理；</p>
<p><strong>理解readystatechange事件</strong></p>
<p>IE为DOM文档中的某些部分提供了readystatechange事件，这个事件的目的提供与文档或元素的加载的状态有关信息，此事件提供了下面5个值中的一个；</p>
<p>uninitialized（未初始化）：对象存在但尚未初始化；<br />
loading(正在加载)：对象正在加载数据；<br />
loaded(加载完毕): 对象加载数据完成；<br />
interactive(交互)： 可以操作对象了，但没有完全加载；<br />
complete(完成)：对象已经加载完成；</p>
<p>&lt;script&gt;（在IE和opera）中和&lt;link&gt;(仅IE中)元素也会触发readystatechange事件，可以用来确定外部的javascript和css文件是否已经加载完成，基于元素触发的readystatechange事件，即readyState属性无论等于”loaded”还是”complete”都可以表示资源已经可用；如下针对IE的判断javascript是否已经加载完成的方案：</p>
<div class="phpstudycode">
<pre class="brush:js;">
EventUtil.addHandler(window,'load',function(){
 var script = document.createElement("script");
 EventUtil.addHandler(script,'readystatechange',function(event){
  event = EventUtil.getEvent(event);
  var target = EventUtil.getTarget(event);
  if (target.readyState == "loaded" || target.readyState == "complete"){
   EventUtil.removeHandler(target, "readystatechange", arguments. callee);
   alert(script.src);
  }
 });
 script.src = 'a.js';
 document.body.appendChild(script); 
});</pre>
</div>
<p>下面我们可以使用javascript客户端检测技术来判断是否是IE和其他标准浏览器做一个简单的封装；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var ua = navigator.userAgent.toLowerCase();
EventUtil.addHandler(window,'load',function(){
 var script = document.createElement("script");
 if(/msie ([^;]+)/.test(ua) || "ActiveXObject" in window) {
  // IE 浏览器
  EventUtil.addHandler(script,'readystatechange',function(event){
   event = EventUtil.getEvent(event);
   var target = EventUtil.getTarget(event);
   if (target.readyState == "loaded" || target.readyState == "complete"){
    EventUtil.removeHandler(target, "readystatechange", arguments. callee);
    console.log("javascript已经加载完成");
   }
  });
 }else {
  // 除IE之外的标准浏览器
  EventUtil.addHandler(script,'load',function(event){
   console.log("javascript已经加载完成");
  });
 }
 script.src = 'a.js';
 document.body.appendChild(script);
});</pre>
</div>
<p>上面的是针对所有的主要的浏览器进行封装来判断动态加载的JS是否已经加载完成！</p>
<p>理解动态加载行内JS方式</p>
<p>另一种加载javascript代码的方式是行内方式，如下代码：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="35201" class="copybut" id="copybut35201" onclick="doCopy('code35201')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code35201"><br />
&lt;script src=”text/javascript”&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function sayHi(){alert(1);}<br />
&lt;/script&gt;<br />
</div></p>
<p>从理论来讲，下面的代码应该是有效的；</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="10634" class="copybut" id="copybut10634" onclick="doCopy('code10634')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code10634"><br />
var script = document.createElement('script');<br />
script.type = 'text/javascript';<br />
script.appendChild(document.createTextNode("function sayHi(){alert(1);} sayHi()"));<br />
document.body.appendChild(script);<br />
</div></p>
<p>如上代码在firefox，IE9+，chrome和opera中，都是正常的，可以运行的，但是在IE8及以下会报错，如下：</p>
<p></p>
<p>IE8及以下将script视为一个特殊的元素，不允许dom访问其子节点；但是我们可以使用script元素的text属性来指定javascript代码，如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var script = document.createElement('script');
script.type = 'text/javascript';
script.text = "function sayHi(){alert(1);} sayHi()";
document.body.appendChild(script);</pre>
</div>
<p>现在在所有的主流的浏览器都是正常的，在IE8及以下也是正常的；但是在safari3.0之前的版本不能正确的支持text属性，但可以允许使用文本节点来指定代码；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var script = document.createElement('script');
script.type = 'text/javascript';
var code = "function sayHi(){alert(1);} sayHi()";
try{
 script.appendChild(document.createTextNode(code));
}catch(e){
 script.text = code;
}
document.body.appendChild(script);</pre>
</div>
<p>下面我们可以使用一个函数来封装下；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
function loadScriptString(code) {
 var script = document.createElement('script');
 script.type = 'text/javascript';
 try{
  script.appendChild(document.createTextNode(code));
 }catch(e){
  script.text = code;
 }
 document.body.appendChild(script);
}
loadScriptString("function sayHi(){alert(1);} sayHi()");</pre>
</div>
<p><strong>理解动态加载css样式</strong></p>
<p>与动态脚本类似，所谓动态样式是指在页面刚载入时不存在的样式，动态样式是在页面加载完成后动态添加到页面中的；</p>
<p>动态加载样式如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var link = document.createElement("link");
link.rel = "stylesheet";
link.type = "text/css";
link.href = "style.css";
var head = document.getElementsByTagName("head")[0];
head.appendChild(link);</pre>
</div>
<p>如上代码即可动态生成css样式；</p>
<p>我们也可以像JS一样先封装一个函数，为了调用更加方便；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
function loadStyles(url) {
 var link = document.createElement("link");
 link.rel = "stylesheet";
 link.type = "text/css";
 link.href = url;
 var head = document.getElementsByTagName("head")[0];
 head.appendChild(link);
}
loadStyles("style.css");</pre>
</div>
<p>我们也可以使用事件的方式来判断css动态加载是否已经加载完成~</p>
<div class="phpstudycode">
<pre class="brush:js;">
EventUtil.addHandler(window,'load',function(){
 var link = document.createElement("link");
 link.rel = "stylesheet";
 link.type = "text/css";
 EventUtil.addHandler(link, "load", function(event){
  console.log("css loaded");
 });
 link.href = "style.css";
 document.getElementsByTagName("head")[0].appendChild(link);
});</pre>
</div>
<p>注意：如上代码：不仅在标准浏览器下chrome，firefox，opera下支持，而且IE7-10都支持这种加载；但是safari不支持这种加载；</p>
<p>或者和javascript一样，我们也可以针对IE下做一种这样的处理；代码如下，也可以支持所有的IE下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
EventUtil.addHandler(window, "load", function(){
 var link = document.createElement("link");
 link.type = "text/css";
 link.rel= "stylesheet";
 EventUtil.addHandler(link, "readystatechange", function(event){
  event = EventUtil.getEvent(event);
  var target = EventUtil.getTarget(event);
  if (target.readyState == "loaded" || target.readyState == "complete"){
   EventUtil.removeHandler(target, "readystatechange", arguments. callee);
   alert("CSS Loaded");
  }
 });
 link.href = "style.css";
 document.getElementsByTagName("head")[0].appendChild(link);
});</pre>
</div>
<p>我们也可以像Javascript一样，为了判断所有的浏览器下支持可以封装一个所有都支持的代码；当然除safari浏览器除外，好像safari浏览器没有生效；</p>
<p>如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var ua = navigator.userAgent.toLowerCase();
EventUtil.addHandler(window,'load',function(){
 var link = document.createElement("link");
 link.type = "text/css";
 link.rel= "stylesheet";
 if(/msie ([^;]+)/.test(ua) || "ActiveXObject" in window) {
  // IE 浏览器
  EventUtil.addHandler(link,'readystatechange',function(event){
   event = EventUtil.getEvent(event);
   var target = EventUtil.getTarget(event);
   if (target.readyState == "loaded" || target.readyState == "complete"){
   EventUtil.removeHandler(target, "readystatechange", arguments. callee);
    alert("css已经加载完成");
   }
  });
 }else {
  // 除IE之外的标准浏览器
  EventUtil.addHandler(link,'load',function(event){
   alert("css已经加载完成");
  });
 }
 link.href = "style.css";
 document.getElementsByTagName("head")[0].appendChild(link);
});</pre>
</div>
<p>另一种定义样式的方式是使用&lt;style&gt;元素来包含嵌入式的css</p>
<p>如下所示代码：</p>
<p>&lt;style&gt;</p>
<p>body {background-color:red;}</p>
<p>&lt;/style&gt;</p>
<p>按照相同的原理，下面的代码除了IE8及以下不支持，其他浏览器下都支持；如下代码：<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
var style = document.createElement("style");
style.type = "text/css";
style.appendChild(document.createTextNode("body{background-color:red}"));
var head = document.getElementsByTagName("head")[0];
head.appendChild(style);</pre>
</div>
<p>因此我们也可以像JS一样封装一个全兼容的css样式；如下代码所示：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var style = document.createElement("style");
style.type = "text/css";
try{
 style.appendChild(document.createTextNode("body{background-color:red}"));
} catch (ex){
 style.styleSheet.cssText = "body{background-color:red}";
}
var head = document.getElementsByTagName("head")[0];
head.appendChild(style);</pre>
</div>
<p>为了更方便调用，因此我们也可以封装一个函数来；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
function loadStyleString(css) {
 var style = document.createElement("style");
 style.type = "text/css";
 try{
  style.appendChild(document.createTextNode(css));
 } catch (ex){
  style.styleSheet.cssText = css;
 }
 var head = document.getElementsByTagName("head")[0];
 head.appendChild(style);
}
// 调用方式如下：
loadStyleString("body{background-color:red}");</pre>
</div>
<p><strong>DOM的扩展</strong></p>
<p>1. querySelector()方法</p>
<p>querySelector()方法接收一个css选择符，返回与该模式匹配的第一个元素，如果没有找到匹配元素，则返回null；如下代码：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="84335" class="copybut" id="copybut84335" onclick="doCopy('code84335')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84335"><br />
&lt;div id="test"&gt;test&lt;/div&gt;<br />
&lt;div class="cls"&gt;1111&lt;/div&gt;<br />
&lt;div class="cls"&gt;2222&lt;/div&gt;<br />
&lt;div class="cls"&gt;2222&lt;/div&gt;<br />
</div></p>
<p>JS代码如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
// 取得body
var body = document.querySelector('body');
console.log(body); // body的引用
// 取得id为test的元素
var test = document.querySelector("#test");
console.log(test); // &lt;div id="test"&gt;test&lt;/div&gt;
// 取得类为cls的第一个元素
var cls = document.querySelector(".cls");
console.log(cls); // &lt;div class="cls"&gt;1111&lt;/div&gt;</pre>
</div>
<p>同理我们也可以通过Element类型调用querySelector()方法时，只会在该元素后代范围内查找匹配的元素，如下代码：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="36673" class="copybut" id="copybut36673" onclick="doCopy('code36673')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code36673"><br />
&lt;div class="testParent"&gt;<br />
&lt;p&gt;1111&lt;/p&gt;<br />
&lt;p&gt;2222&lt;/p&gt;<br />
&lt;/div&gt;<br />
</div></p>
<p>我想通过先取得div中的testParent，然后再取得p元素(通过querySelector方法)；如下代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var testParent = document.querySelector('.testParent');
var pfirst = testParent.querySelector("p");
console.log(pfirst); // &lt;p&gt;1111&lt;/p&gt;</pre>
</div>
<p>浏览器支持程度：IE8+，firefox，chrome，safari3.1+，opera10+</p>
<p><strong>2. querySelectorAll()方法</strong></p>
<p>querySelectorAll()方法接收的参数与querySelector()方法一样，都是一个css选择符，但是返回的是所有匹配的元素，这个方法返回的是一个NodeList的实例。</p>
<p>如下代码演示：</p>
<div class="phpstudycode">
<pre class="brush:xhtml;">
&lt;div id="test"&gt;
 &lt;em class="selected"&gt;11111&lt;/em&gt;
 &lt;em class="selected"&gt;22222&lt;/em&gt;
 &lt;em&gt;33333&lt;/em&gt;
 &lt;em&gt;44444&lt;/em&gt;
&lt;/div&gt;</pre>
</div>
<p>JS代码如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
// 取得div中所有em元素
var em = document.getElementById("test").querySelectorAll('em');
console.log(em); // NodeList
console.log(em.length); // 4

// 第二种方式 也可以先使用querySelector
var test = document.querySelector("#test");
var em2 = test.querySelectorAll('em');
console.log(em2); // NodeList
console.log(em2.length); // 4

// 取得类为selected的所有元素
var selected = document.querySelectorAll('.selected');
console.log(selected); // &lt;em class="selected"&gt;11111&lt;/em&gt;
    // &lt;em class="selected"&gt;22222&lt;/em&gt;
// 也可以通过以下的方式获得所有的em元素
var em = document.querySelectorAll('div em');
console.log(em); // NodeList
console.log(em.length); // 4</pre>
</div>
<p>要取得返回的NodeList中的每一个元素，可以使用item()方法，也可以使用方括号的语法；</p>
<div class="phpstudycode">
<pre class="brush:js;">
var ems = document.querySelectorAll('#test em');
for(var i = 0, ilen = ems.length; i &lt; ilen; i++) {
 console.log(ems[i]); // 取得每一项em
 console.log(ems.item(i)); // 取得每一项em
}</pre>
</div>
<p>浏览器支持程度：IE8+，firefox，chrome，safari3.1+，opera10+</p>
<p><strong>3. matchesSelector()方法</strong></p>
<p>这个方法接收一个参数，即css选择符，如果调用元素与该选择符匹配，返回true，否则，返回false；</p>
<p>如下代码：</p>
<p>console.log(document.body.webkitMatchesSelector("body")); // true<br />
<br />
IE9+通过msMatchesSelector()支持该方法，Firefox3.6+通过mozMatchesSelector()支持该方法；safari5+和chrome通过webkitMatchesSelector()支持该方法；因此我们可以包装一个函数，如下代码：<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
function matchesSelector(element,selector) {
if(element.MatchesSelector) {
 return element.MatchesSelector(selector);
}else if(element.msMatchesSelector) {
 return element.msMatchesSelector(selector);
}else if(element.webkitMatchesSelector) {
 return element.webkitMatchesSelector(selector);
}else if(element.mozMatchesSelector) {
 return element.mozMatchesSelector(selector);
}else {
  throw new Error("Not supported");
 }
}
console.log(matchesSelector(document.body,'body')); // true
var test = document.querySelector('#test');
console.log(matchesSelector(test,'#test')); // true</pre>
</div>
<p><strong>4. getElementsByClassName() 方法</strong></p>
<p>该方法接收一个参数，即包含一个或者多个类名的字符串，返回带有指定类的所有元素的NodeList；传入多个类名时，类名的先后顺序不重要。</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="79658" class="copybut" id="copybut79658" onclick="doCopy('code79658')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code79658"><br />
&lt;p class="p1"&gt;111&lt;/p&gt;<br />
&lt;p class="p1"&gt;222&lt;/p&gt;<br />
&lt;p class="p1"&gt;333&lt;/p&gt;<br />
</div></p>
<p>console.log(document.getElementsByClassName("p1")); // 返回NodeList</p>
<p>支持getElementsByClassName()方法的浏览器有IE9+，firefox3+，safari3.1+,chrome和opera9.5+；</p>
<p><strong>5. classList属性</strong></p>
<p>如下代码：</p>
<p>&lt;div class="aa bb cc" id="div"&gt;aaa&lt;/div&gt;</p>
<p>我想删除aa这个类名的时候，以前需要如下写代码：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var div = document.getElementById("div");
// 首先，取得类名字符串并拆分成数组
var classNames = div.className.split(/\s+/);
var pos = -1,
  i, 
 len;
for(i = 0,len = classNames.length; i &lt; len; i+=1) {
 if(classNames[i] == 'aa') {
  pos = i;
  break;
 }
}
// 删除类名
classNames.splice(i,1);
// 把剩下的类名拼成字符串并重新设置
div.className = classNames.join(" "); 
// &lt;div class="bb cc" id="div"&gt;aaa&lt;/div&gt;</pre>
</div>
<p>但是现在HTML5新增了一种操作类名的方式，可以让操作更简单也更方便，那就是所有元素添加classList属性。这个classList属性是新集合类型DOMTokenList的实例；DOMTokenList有一个表示自己包含多少元素的length属性，而要取得每个元素可以使用item()方法，也可以使用中括号；</p>
<p><strong>还有以下方法：</strong></p>
<p>add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。<br />
contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。<br />
remove(value)：从列表中删除给定的字符串。<br />
toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。<br />
现在我们可以来看看使用上面的方法的优点如下，我们可以来做个demo，代码如下：</p>
<p>&lt;div class="aa bb cc" id="div"&gt;aaa&lt;/div&gt;</p>
<p>JS如下：</p>
<div class="phpstudycode">
<pre class="brush:js;">
var div = document.getElementById("div");
// 删除类名aa，如下方法即可
div.classList.remove("aa");
// html结构如下： &lt;div class="bb cc" id="div"&gt;aaa&lt;/div&gt;
// 添加类名current，如下方法即可
div.classList.add("current");
// html结构变为如下 &lt;div class="bb cc current" id="div"&gt;aaa&lt;/div&gt;

// 切换aa类名
div.classList.toggle("aa");
// html结构变为如下 &lt;div class="aa bb cc current" id="div"&gt;aaa&lt;/div&gt;
// 确定元素是否包含类名；
console.log(div.classList.contains("aa")); // true</pre>
</div>
<p>支持classList属性的浏览器有IE10+，firefox3.6+和chrome</p>
<p><strong>HTML5新增自定义数据属性</strong></p>
<p>HTML5中规定可以为元素添加非标准的属性，但要添加前缀data-,比如如下代码：</p>
<p>&lt;div id="myDiv" data-appId="12345" data-myname="Nicholas"&gt;&lt;/div&gt;</p>
<p>添加了自定义属性之后，可以通过元素的dataset属性来访问自定义属性的值，dataset属性的值是DOMStringMap的一个实例，也就是一个名值对的映射；比如如下代码：<br />
</p>
<div class="phpstudycode">
<pre class="brush:js;">
//本例中使用的方法仅用于演示
var div = document.getElementById("myDiv");
console.log(div.dataset); // DOMStringMap {value: "12345", name: "Nicholas"}
//取得自定义属性的值
var value1 = div.dataset.value;
console.log(value1); // 12345
var name1 = div.dataset.name;
console.log(name1); // Nicholas
//设置值
div.dataset.value = 23456;
div.dataset.name = "Michael";
//有没有"myname"值呢？
if (div.dataset.name){
 console.log("Hello, " + div.dataset.name); // Hello, Michael
}</pre>
</div>
<p></p>
<p>浏览器支持的程度有；firefox6+和chrome浏览器；</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/88864.html'>JSONP获取Twitter和Facebook文章数的具体步骤</a><a>下一篇</a><a href='/php/biji/88867.html'>jQuery.extend()、jQuery.fn.extend()扩展方法示例详解</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>