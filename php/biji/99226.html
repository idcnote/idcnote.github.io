<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>ABP框架的基础配置及依赖注入讲解_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="配置ABP<br />
<br />
配置是通过在自己模块的PreInitialize方法中来实现的<br />
<br />
代码示例如下：<br />
<br />
<br />
public class SimpleTaskSystemModule : AbpModule<br />
{<br />
  public override void PreInitializ" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">ABP框架的基础配置及依赖注入讲解</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>配置ABP<br />
<br />
配置是通过在自己模块的PreInitialize方法中来实现的<br />
<br />
代码示例如下：<br />
<br />
<br />
public class SimpleTaskSystemModule : AbpModule<br />
{<br />
  public override void PreInitializ</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>配置ABP<br />
</strong>配置是通过在自己模块的PreInitialize方法中来实现的<br />
代码示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class SimpleTaskSystemModule : AbpModule
{
  public override void PreInitialize()
  {
    //在你的应用中添加语言包，这个是英语和作者的土耳其语。
    Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));
    Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türk&ccedil;e", "famfamfam-flag-tr"));

    Configuration.Localization.Sources.Add(
      new XmlLocalizationSource(
        "SimpleTaskSystem",
        HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")
        )
      );

    //配置导航和菜单
    Configuration.Navigation.Providers.Add&lt;SimpleTaskSystemNavigationProvider&gt;();
  }

  public override void Initialize()
  {
    IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
  }
}

</pre>
</div>
<p>和orchard类似，abp框架一开始就被设计成模块化的，不同的模块可以通过abp框架来进行配置。举个例子吧，不同的模块都可以添加导航，通过导航添加菜单项到自己定义的主菜单，具体的细节大家可以参照：</p>
<p>本地化：http://www.aspnetboilerplate.com/Pages/Documents/Localization<br />
导航：http://www.aspnetboilerplate.com/Pages/Documents/Navigation<br />
</p>
<p><strong>配置模块<br />
</strong>和.net框架原生的启动配置相比较，abp有哪些不一样呢？abp框架的模块可以通过IAbpModuleConfigurations接口进行个性化的扩展，这样的话，模块配置更加简单、方便。<br />
示例代码如下：<br />
</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
...
using Abp.Web.Configuration;
...
public override void PreInitialize() 
{
  Configuration.Modules.AbpWeb().SendAllExceptionsToClients = true;
}
...
</pre>
</div>
<p>在上面这个例子中，我们通过配置AbpWeb模块，发送异常到客户端。当然了，不是每一个模块都需要这种配置，通常情况下我们需要，是当一个模块需要在多个不同的应用中重复使用，我们才进行这样的配置。</p>
<p><strong>为一个模块创建配置<br />
</strong>如下代码，假如我们有一个命名为MyModule的模块，并且这各模块有一些自己的配置。那么我们首先要创建一些类，这些类定义为属性（译者注：属性有自动的get和set访问器。），代表了不同的配置。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class MyModuleConfig
{
  public bool SampleConfig1 { get; set; }

  public string SampleConfig2 { get; set; }
}

</pre>
</div>
<p>接下来，我们通过依赖注入，注册这个类。</p>
<p>IocManager.Register&lt;MyModuleConfig&gt;(); //译者注：在IocManager中注册了一个类，换句话说，我们通过IocManager可以得到这个类MyModuleConfig的实例。至于IOC的原理这里就不在详细说了，总之，就是可以得到一个类的实例。</p>
<p>最后，我们通过创建一个扩展的方法IModuleConfigurations来得到配置的引用。如下代码:<br />
</p>
<p></p>
<p>译者注：模块配置是一个静态类，因为我们需要重复使用它。静态方法Mymodule返回的是一个配置接口，参数是ImoduleConfigurations接口。</p>
<p>现在，在其他模块中也可以配置我们自定义的这个MyModule模块了。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
Configuration.Modules.MyModule().SampleConfig1 = false;
Configuration.Modules.MyModule().SampleConfig2 = "test";
</pre>
</div>
<p>在某种意义上，MyModule需要这些配置，你能注射MyModuleConfig并且可以使用这些值。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class MyService : ITransientDependency
{
  private readonly MyModuleConfig _configuration;

  public MyService(MyModuleConfig configuration)
  {
    _configuration = configuration;
  }

  
  public void DoIt()
  {
    if (_configuration.SampleConfig2 == "test")
    {
      //...
    }
  }
}

</pre>
</div>
<p>这意味着，在abp框架的系统中，所有的模块都可以集中配置。</p>
<p><br />
<strong>ABP依赖注入<br />
什么是依赖注入<br />
</strong>如果你已经知道依赖注入的概念，构造函数和属性注入模式，你可以跳过这一节。</p>
<p>维基百科说:“依赖注入是一种软件设计模式的一个或多个依赖项注入(或服务)，或通过引用传递，为依赖对象(或客户)和客户端状态的一部分。模式之间建立一个客户的依赖关系的行为，它允许程序设计是松散耦合的，依赖倒置和单一职责原则。它直接对比service locator模式，它允许客户了解他们所使用的系统找到依赖。”。</p>
<p>如果不使用依赖注入技术，很难进行依赖管理、模块化开发和应用程序模块化。</p>
<p><strong>传统方式的问题</strong></p>
<p>在一个应用程序中，类之间相互依赖。假设我们有一个应用程序服务，使用仓储（repository）类插入实体到数据库。在这种情况下，应用程序服务类依赖于仓储（repository）类。看下例子:</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  public class PersonAppService
  {
    private IPersonRepository _personRepository;
  
    public PersonAppService()
    {
      _personRepository = new PersonRepository();      
    }
  
    public void CreatePerson(string name, int age)
    {
      var person = new Person { Name = name, Age = age };
      _personRepository.Insert(person);
    }
  }
</pre>
</div>
<p>PersonAppService使用PersonRepository插入Person到数据库。这段代码的问题:</p>
<p>PersonAppService通过IPersonRepository调用CreatePerson方法，所以这方法依赖于IPersonRepository，代替了PersonRepository具体类。但PersonAppService（的构造函数）仍然依赖于PersonRepository。组件应该依赖于接口而不是实现。这就是所谓的依赖性倒置原则。<br />
如果PersonAppService创建PersonRepository本身，它成为依赖IPersonRepository接口的具体实现，不能使用另一个实现。因此，此方式的将接口与实现分离变得毫无意义。硬依赖（hard-dependency）使得代码紧密耦合和较低的可重用。<br />
我们可能需要在未来改变创建PersonRepository的方式。即，我们可能想让它创建为单例(单一共享实例而不是为每个使用创建一个对象)。或者我们可能想要创建多个类实现IPersonRepository并根据条件创建对象。在这种情况下，我们需要修改所有依赖于IPersonRepository的类。<br />
有了这样的依赖，很难(或不可能)对PersonAppService进行单元测试。<br />
为了克服这些问题，可以使用工厂模式。因此，创建的仓储类是抽象的。看下面的代码:<br />
&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  public class PersonAppService
  {
    private IPersonRepository _personRepository;
  
    public PersonAppService()
    {
      _personRepository = PersonRepositoryFactory.Create();      
    }
  
    public void CreatePerson(string name, int age)
    {
      var person = new Person { Name = name, Age = age };
      _personRepository.Insert(person);
    }
  }
</pre>
</div>
<p>PersonRepositoryFactory是一个静态类，创建并返回一个IPersonRepository。这就是所谓的服务定位器模式。以上依赖问题得到解决，因为PersonAppService不需要创建一个IPersonRepository的实现的对象，这个对象取决于PersonRepositoryFactory的Create方法。但是，仍然存在一些问题：</p>
<p>此时，PersonAppService取决于PersonRepositoryFactory。这是更容易接受，但仍有一个硬依赖（hard-dependency）。<br />
为每个库或每个依赖项乏味的写一个工厂类/方法。<br />
测试性依然不好，由于很难使得PersonAppService使用mock实现IPersonRepository。<br />
解决方案：</p>
<p>有一些最佳实践(模式)用于类依赖。</p>
<p><strong>构造函数注入</strong></p>
<p>重写上面的例子，如下所示:</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
 public class PersonAppService
  {
    private IPersonRepository _personRepository;
  
    public PersonAppService(IPersonRepository personRepository)
    {
      _personRepository = personRepository;
    }
  
    public void CreatePerson(string name, int age)
    {
      var person = new Person { Name = name, Age = age };
      _personRepository.Insert(person);
    }
  }
</pre>
</div>
<p>这被称为构造函数注入。现在，PersonAppService不知道哪些类实现IPersonRepository以及如何创建它。谁需要使用PersonAppService，首先创建一个IPersonRepository PersonAppService并将其传递给构造函数，如下所示：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  var repository = new PersonRepository();
  var personService = new PersonAppService(repository);
  personService.CreatePerson("Yunus Emre"， 19);
</pre>
</div>
<p>构造函数注入是一个完美的方法，使一个类独立创建依赖对象。但是，上面的代码有一些问题：</p>
<p>创建一个PersonAppService变得困难。想想如果它有4个依赖，我们必须创建这四个依赖对象，并将它们传递到构造函数PersonAppService。<br />
从属类可能有其他依赖项(在这里，PersonRepository可能有依赖关系)。所以，我们必须创建PersonAppService的所有依赖项，所有依赖项的依赖关系等等. .如此，依赖关系使得我们创建一个对象变得过于复杂了。<br />
幸运的是，依赖注入框架自动化管理依赖关系。</p>
<p><strong>属性注入</strong></p>
<p>构造函数注入模式是一个完美的提供类的依赖关系的方式。通过这种方式，您不能创建类的实例，而不提供依赖项。它也是一个强大的方式显式地声明是什么类的需求正确地工作。</p>
<p>但是，在某些情况下，该类依赖于另一个类，但也可以没有它。这通常是适用于横切关注点(如日志记录)。一个类可以没有工作日志，但它可以写日志如果你提供一个日志对象。在这种情况下，您可以定义依赖为公共属性，而不是让他们放在构造函数。想想，如果我们想在PersonAppService写日志。我们可以重写类如下:&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class PersonAppService
  {
    public ILogger Logger { get; set; }
  
    private IPersonRepository _personRepository;
  
    public PersonAppService(IPersonRepository personRepository)
    {
      _personRepository = personRepository;
      Logger = NullLogger.Instance;
    }
  
    public void CreatePerson(string name, int age)
    {
      Logger.Debug("Inserting a new person to database with name = " + name);
      var person = new Person { Name = name, Age = age };
      _personRepository.Insert(person);
      Logger.Debug("Successfully inserted!");
    }
  }
</pre>
</div>
<p>NullLogger.Instance 是一个单例对象，实现了ILogger接口，但实际上什么都没做(不写日志。它实现了ILogger实例，且方法体为空)。现在，PersonAppService可以写日志了，如果你为PersonAppService实例设置了Logger，如下面:</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  var personService = new PersonAppService(new PersonRepository());
  personService.Logger = new Log4NetLogger();
  personService.CreatePerson("Yunus Emre", 19);
</pre>
</div>
<p>假设Log4NetLogger实现ILogger实例，使得我们可以使用Log4Net库写日志。因此，PersonAppService可以写日志。如果我们不设置Logger，PersonAppService就不写日志。因此，我们可以说PersonAppService ILogger实例是一个可选的依赖。</p>
<p>几乎所有的依赖注入框架都支持属性注入模式</p>
<p><strong>依赖注入框架</strong></p>
<p>有许多依赖注入框架，都可以自动解决依赖关系。他们可以创建所有依赖项(递归地依赖和依赖关系)。所以你只需要根据注入模式写类和类构造函数&属性，其他的交给DI框架处理！在良好的应用程序中，类甚至独立于DI框架。整个应用程序只会有几行代码或类，显示的与DI框架交互。</p>
<p>ABP的依赖注入基于 Castle Windsor框架。Castle Windsor最成熟的DI框架之一。还有很多这样的框架，如Unity，Ninject，StructureMap，Autofac等等。</p>
<p>在使用一个依赖注入框架时，首先注册您的接口/类到依赖注入框架中，然后你就可以resolve一个对象。在Castle Windsor，它是这样的：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  var container = new WindsorContainer();

  container.Register(
      Component.For&lt;IPersonRepository&gt;().ImplementedBy&lt;PersonRepository&gt;().LifestyleTransient(),
      Component.For&lt;IPersonAppService&gt;().ImplementedBy&lt;PersonAppService&gt;().LifestyleTransient()
    );
  
  var personService = container.Resolve&lt;IPersonAppService&gt;();
  personService.CreatePerson("Yunus Emre", 19);

</pre>
</div>
<p>我们首先创建了WindsorContainer。然后注册PersonRepository 和 PersonAppService及它们的接口。然后我们要求容器创建一个IPersonAppService实例。它创建PersonAppService对象及其依赖项并返回。在这个简单的示例中，使用DI框架也许不是那么简洁，但想象下，在实际的企业应用程序中你会有很多类和依赖关系。当然，注册的依赖项只在程序启动的某个地方创建一次。</p>
<p>请注意，我们只是讲对象声明为临时对象(transient)。这意味着每当我们创建这些类型的一个对象时，就会创建一个新的实例。有许多不同的生命周期(如Singletion)。</p>
<p><strong>ABP依赖注入的基础结构<br />
</strong>在编写应用程序时遵循最佳实践和一些约定，ABP几乎让依赖注入框架使用变得无形。</p>
<p>注册：</p>
<p>在ABP中，有很多种不同的方法来注册你的类到依赖注入系统。大部分时间，常规方法就足够了。</p>
<p>常规注册：</p>
<p>按照约定，ABP自动注册所有 Repositories， Domain Services， Application Services， MVC 控制器和Web API控制器。例如，您可能有一个IPersonAppService 接口和实现类PersonAppService：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  public interface IPersonAppService : IApplicationService
  {
    //...
  }
  
  public class PersonAppService : IPersonAppService
  {
    //...
  }

</pre>
</div>
<p>ABP会自动注册它，因为它实现IApplicationService接口(它只是一个空的接口)。它会被注册为transient (每次使用都创建实例)。当你注入(使用构造函数注入)IPersonAppService接口成一个类，PersonAppService对象会被自动创建并传递给构造函数。</p>
<p>命名约定在这里非常重要。例如你可以将名字PersonAppService改为 MyPersonAppService或另一个包含“PersonAppService”后缀的名称，由于IPersonAppService包含这个后缀。但是你可以不遵循PeopleService命名您的服务类。如果你这样做，它将不会为IPersonAppService自动注册(它需要自注册（self-registration）到DI框架，而不是接口)，所以，如果你想要你应该手动注册它。</p>
<p>ABP按照约定注册程序集。所以，你应该告诉ABP按照约定注册您的程序集。这很容易:</p>
<p>&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
</pre>
</div>
<p>Assembly.GetExecutingAssembly()得到一个对包括此代码的程序集的引用。你可以通过RegisterAssemblyByConvention方法注册其他程序集。这同在你的模块初始化（AbpModule.Initialize()）时完成。请查看ABP的模块系统获得更多信息。</p>
<p>您可以通过实现IConventionalRegisterer接口和调用IocManager。AddConventionalRegisterer方法编写自己的约定注册类。你应该将它添加到模块的pre-initialize方法中。</p>
<p><strong>帮助接口</strong></p>
<p>你可以注册一个特定的类，不遵循传统的约定制度规则。ABP提供了ITransientDependency和ISingletonDependency接口的快捷方法。例如：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  public interface IPersonManager
  {
    //...
  }
  
  public class MyPersonManager : IPersonManager, ISingletonDependency
  {
    //...
  }
</pre>
</div>
<p>以这种方式，您可以很容易地注册MyPersonManager为transient。当需要注入IPersonManager时，MyPersonManager会被使用。注意，依赖被声明为单例。因此，创建的MyPersonManager同一个对象被传递给所有需要的类。只是在第一次使用时创建，那么应用程序的整生命周期使用的是同一实例。</p>
<p><strong>自定义/直接 注册</strong></p>
<p>如果之前描述的方法还是不足以应对你的情况，你可以使用Castle Windsor注册类和及依赖项。因此，您将拥有Castle Windsor注册的所有能力。</p>
<p>可以实现IWindsorInstaller接口进行注册。您可以在应用程序中创建一个实现IWindsorInstaller接口的类：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  public class MyInstaller : IWindsorInstaller
  {
    public void Install(IWindsorContainer container, IConfigurationStore store)
    {
      container.Register(Classes.FromThisAssembly().BasedOn&lt;IMySpecialInterface&gt;().LifestylePerThread().WithServiceSelf());
    }
  }

</pre>
</div>
<p>Abp自动发现和执行这个类。最后，你可以通过使用IIocManager.IocContainer属性得到WindsorContainer。有关更多信息，阅读Windsor的文档。</p>
<p><strong>解析（Resolving）</strong></p>
<p>注册通知IOC(控制反转)容器关于你的类，它们的依赖项和生命周期。在您的应用程序需要使用IOC容器创建对象时，ASP.NET提供了一些方法解决依赖关系。</p>
<p><strong>构造函数 & 属性注入</strong></p>
<p>作为最佳实践，你可以使用构造函数和属性注入去获取你的类的依赖。任何可能的地方，你都应该这样做。例子：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
  public class PersonAppService
  {
    public ILogger Logger { get; set; }
  
    private IPersonRepository _personRepository;
  
    public PersonAppService(IPersonRepository personRepository)
    {
      _personRepository = personRepository;
      Logger = NullLogger.Instance;
    }
  
    public void CreatePerson(string name， int age)
    {
      Logger.Debug("Inserting a new person to database with name = " + name);
      var person = new Person { Name = name, Age = age };
      _personRepository.Insert(person);
      Logger.Debug("Successfully inserted!");
    }
  }

</pre>
</div>
<p>IPersonRepository从构造函数注入，ILogger实例从公共属性注入。这样，您的代码不会体现依赖注入系统。这是使用DI系统最适当的方式。</p>
<p><strong>IIocResolver 和 IIocManager</strong></p>
<p>有时你可能需要直接创建你的依赖项，而不是构造函数和属性注入。应该尽可能避免这种情况，但它可能无法避免。Abp提供一些服务使得这样的注入很容易实现。例子：</p>
<p>&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
 public class MySampleClass : ITransientDependency
  {
    private readonly IIocResolver _iocResolver;
  
    public MySampleClass(IIocResolver iocResolver)
    {
      _iocResolver = iocResolver;
    }
  
    public void DoIt()
    {
      //Resolving， using and releasing manually
      var personService1 = _iocResolver.Resolve&lt;PersonAppService&gt;();
      personService1.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
      _iocResolver.Release(personService1);
  
      //Resolving and using in a safe way
      using (var personService2 = _iocResolver.ResolveAsDisposable&lt;PersonAppService&gt;())
      {
        personService2.Object.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
      }
    }
  }
</pre>
</div>
<p>MySampleClass是一个应用程序的示例类。IIcResolver通过构造函数注入，然后用它来创建和释放对象。有几个解决方法的重载可以根据需要使用。Release方法用于释放组件(对象)。如果你是手动创建一个对象，调用Release方法释放对象非常重要。否则，您的应用程序会有内存泄漏问题。为了保证对象被释放，尽可能使用ResolveAsDisposable(就像上面的例子所示)。它会在using代码块结束的时候自动调用Release方法。</p>
<p>如果你想直接使用IOC容器(Castle Windsor)来处理依赖关系项，可以通过构造函数注入 IIocManager并使用它IIocManager.IocContainer 属性。如果你是在一个静态上下文或不能注入IIocManager，还有最后一个方法，你可以使用单例对象IocManager.Instance，你可以在任何地方获取到，它无处不在。但是，在这种情况下你的代码将变得不易容测试。</p>
<p><strong>附加</strong></p>
<p><strong>IShouldInitialize 接口：</strong></p>
<p>有些类在第一次使用前需要初始化。IShouldInitialize有Initialize()方法。如果你实现它，那么你的Initialize()方法自动会被自动调用在创建对象之后(在使用之前)。当然，为了使用这个特性，你应该注入/创建此对象。</p>
<p><strong>ASP.NET MVC & ASP.NET Web API 集成：</strong></p>
<p>当然，我们必须调用依赖注入系统处理依赖关系图的根对象。在一个ASP.NET MVC应用程序，通常是一个控制器类。我们可以使用构造函数注入模式注入控制器。当一个请求来到我们的应用程序中，控制器和所有依赖项被IOC容器递归创建。所以，谁做了这些？这是被Abp扩展的ASP.NET MVC默认控制器工厂自动完成的。ASP.NET Web API 也是相似的。你不用关心对象的创建和释放。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/99225.html'>Oracle数据库中外键的相关操作整理</a><a>下一篇</a><a href='/php/biji/99227.html'>linux怎么显示并拷贝当前文件路径?</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>