<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Android中FoldingLayout折叠布局的用法及实战全攻略_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="一、概述<br />
<br />
无意中翻到的FoldingLayout的介绍的博客，以及github地址。感觉很nice呀，于是花了点时间研究以及编写，本篇博客将带大家从最基本的原理分析，一步一步的实现我们的Foldi" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Android中FoldingLayout折叠布局的用法及实战全攻略</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>一、概述<br />
<br />
无意中翻到的FoldingLayout的介绍的博客，以及github地址。感觉很nice呀，于是花了点时间研究以及编写，本篇博客将带大家从最基本的原理分析，一步一步的实现我们的Foldi</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>一、概述<br />
</strong>无意中翻到的FoldingLayout的介绍的博客，以及github地址。感觉很nice呀，于是花了点时间研究以及编写，本篇博客将带大家从最基本的原理分析，一步一步的实现我们的FoldingLayout，当然了，如果你能力过硬，可以直接下载github上的代码进行学习。<br />
博客基本分为以下几个部分：<br />
1、Matrix的setPolyToPoly使用<br />
2、在图片上使用渐变和阴影<br />
3、初步的FoldingLayout的实现，完成图片的折叠显示（可控制折叠次数、包含阴影的绘制）<br />
4、引入手势，手指可以可以FoldingLayout的折叠<br />
5、结合DrawerLayout实现折叠式侧滑<br />
6、结合SlidingPaneLayout实现折叠式侧滑<br />
ok，贴下部分的效果图：<br />
</p>
<p></p>
<p>改图对应上述3，妹子不错吧~<br />
</p>
<p></p>
<p>ok，对应上述4.<br />
</p>
<p></p>
<p>对应上述5。<br />
ok，挑选了部分图，不然太占篇幅了。<br />
那么接下来，我们就按照顺序往下学习了~~~</p>
<p><strong>二、Matrix的setPolyToPoly使用<br />
</strong>想要实现折叠，最重要的就是其核心的原理了，那么第一步我们要了解的就是，如何能把一张正常显示的图片，让它能够进行偏移显示。<br />
其实精髓就在于Matrix的setPolyToPoly的方法。</p>
<p>public boolean setPolyToPoly(float[] src, int srcIndex,&nbsp; float[] dst, int dstIndex,int pointCount)&nbsp;&nbsp; <br />
简单看一下该方法的参数，src代表变换前的坐标；dst代表变换后的坐标；从src到dst的变换，可以通过srcIndex和dstIndex来制定第一个变换的点，一般可能都设置位0。pointCount代表支持的转换坐标的点数，最多支持4个。<br />
如果不明白没事，下面通过一个简单的例子，带大家了解：</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.sample.folderlayout; 
 
import android.app.Activity; 
import android.content.Context; 
import android.graphics.Bitmap; 
import android.graphics.BitmapFactory; 
import android.graphics.Canvas; 
import android.graphics.Matrix; 
import android.os.Bundle; 
import android.view.View; 
 
public class MatrixPolyToPolyActivity extends Activity 
{ 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) 
  { 
    super.onCreate(savedInstanceState); 
    setContentView(new PolyToPolyView(this)); 
  } 
 
  class PolyToPolyView extends View 
  { 
 
    private Bitmap mBitmap; 
    private Matrix mMatrix; 
 
    public PolyToPolyView(Context context) 
    { 
      super(context); 
      mBitmap = BitmapFactory.decodeResource(getResources(), 
          R.drawable.tanyan); 
      mMatrix = new Matrix(); 
      float[] src = { 0, 0,// 
          mBitmap.getWidth(), 0,// 
          mBitmap.getWidth(), mBitmap.getHeight(),// 
          0, mBitmap.getHeight() }; 
      float[] dst = { 0, 0,// 
          mBitmap.getWidth(), 100,// 
          mBitmap.getWidth(), mBitmap.getHeight() - 100,// 
          0, mBitmap.getHeight() }; 
      mMatrix.setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); 
    } 
 
    @Override 
    protected void onDraw(Canvas canvas) 
    { 
      super.onDraw(canvas); 
      canvas.drawBitmap(mBitmap, mMatrix, null); 
    } 
 
  } 
 
} 
</pre>
</div>
<p>我们编写了一个PolyToPolyView作为我们的Activity的主视图。<br />
在PolyToPolyView中，我们加载了一张图片，初始化我们的Matrix，注意src和dst两个数组，src就是正常情况下图片的4个顶点。dst将图片右侧两个点的y坐标做了些许的修改。<br />
大家可以在纸上稍微标一下src和dst的四个点的位置。<br />
最后我们在onDraw的时候进行图像的绘制，效果为：</p>
<p></p>
<p>如果你已经在纸上稍微的画了dst的四个点，那么这个结果你一定不陌生。<br />
可以看到我们通过matrix.setPolyToPoly实现了图片的倾斜，那么引入到折叠的情况，假设折叠两次，大家有思路么，考虑一下，没有的话，继续往下看。</p>
<p><strong>三、引入阴影<br />
</strong>其实阴影应该在实现初步的折叠以后来说，这样演示其实比较方便，但是为了降低其理解的简单性，我们先把阴影抽取出来说。<br />
假设我们现在要给上图加上阴影，希望的效果图是这样的：</p>
<p></p>
<p>可以看到我们左侧加入了一点阴影，怎么实现呢？<br />
主要还是利用LinearGradient，我们从左到右添加一层从黑色到透明的渐变即可。<br />
</p>
<div class="phpstudycode">
<pre class="brush:java;">
public class MatrixPolyToPolyWithShadowActivity extends Activity 
{ 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) 
  { 
    super.onCreate(savedInstanceState); 
    setContentView(new PolyToPolyView(this)); 
 
  } 
 
  class PolyToPolyView extends View 
  { 
 
    private Bitmap mBitmap; 
    private Matrix mMatrix; 
     
    private Paint mShadowPaint; 
    private Matrix mShadowGradientMatrix; 
    private LinearGradient mShadowGradientShader; 
 
    public PolyToPolyView(Context context) 
    { 
      super(context); 
      mBitmap = BitmapFactory.decodeResource(getResources(), 
          R.drawable.tanyan); 
      mMatrix = new Matrix(); 
 
      mShadowPaint = new Paint(); 
      mShadowPaint.setStyle(Style.FILL); 
      mShadowGradientShader = new LinearGradient(0, 0, 0.5f, 0, 
          Color.BLACK, Color.TRANSPARENT, TileMode.CLAMP); 
      mShadowPaint.setShader(mShadowGradientShader); 
 
      mShadowGradientMatrix = new Matrix(); 
      mShadowGradientMatrix.setScale(mBitmap.getWidth(), 1); 
      mShadowGradientShader.setLocalMatrix(mShadowGradientMatrix); 
      mShadowPaint.setAlpha((int) (0.9*255)); 
 
    } 
 
    @Override 
    protected void onDraw(Canvas canvas) 
    { 
      super.onDraw(canvas); 
      canvas.save(); 
      float[] src = //...; 
      float[] dst = //...; 
      mMatrix.setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); 
 
      canvas.concat(mMatrix); 
      canvas.drawBitmap(mBitmap, 0, 0, null); 
      //绘制阴影                                                            canvas.drawRect(0, 0, mBitmap.getWidth(), mBitmap.getHeight(), 
          mShadowPaint); 
      canvas.restore(); 
 
    } 
 
  } 
 
} 
</pre>
</div>
<p>重点看mShadowPaint，mShadowGradientShader，mShadowGradientMatrix一个是画笔，我们为画笔设置了一个渐变的Shader，这个Shader的参数为<br />
new LinearGradient(0, 0, 0.5f, 0,Color.BLACK, Color.TRANSPARENT, TileMode.CLAMP);<br />
起点（0，0）、终点（0.5f，0）；颜色从和BLACK到透明；模式为CLAMP，也就是拉伸最后一个像素。<br />
这里你可能会问，这才为0.5个像素的区域设置了渐变，不对呀，恩，是的，继续看接下来我们使用了setLocalMatrix(mShadowGradientMatrix);，而这个<br />
mShadowGradientMatrix将和坐标扩大了mBitmap.getWidth()倍，也就是说现在设置渐变的区域为（0.5f*mBitmap.getWidth()，0）半张图的大小，那么后半张图呢？<br />
后半张应用CLAMP模式，拉伸的透明。<br />
关于Shader、setLocalMatrix等用法也可以参考：Android BitmapShader 实战 实现圆形、圆角图片</p>
<p><strong>四、初步实现折叠<br />
</strong>了解了原理以及阴影的绘制以后，接下来要开始学习真正的去折叠了，我们的目标效果为：<br />
</p>
<p></p>
<p>妹子折叠成了8份，且阴影的范围为：每个沉下去夹缝的左右两侧，左侧黑色半透明遮盖，右侧短距离的黑色到透明阴影（大家可以仔细看）。<br />
现在其实大家以及会将图片简单倾斜和添加阴影了，那么唯一的难点就是怎么将一张图分成很多快，我相信每块的折叠大家都会。<br />
其实我们可以通过绘制该图多次，比如第一次绘制往下倾斜；第二次绘制网上倾斜；这样就和我们标题2的实现类似了，只需要利用setPolyToPoly。<br />
那么绘制多次，每次显示肯定不是一整张图，比如第一次，我只想显示第一块，所以我们还需要clipRect的配合，说到这，应该以及揭秘了~~~</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.sample.folderlayout; 
 
import android.app.Activity; 
import android.content.Context; 
import android.graphics.Bitmap; 
import android.graphics.BitmapFactory; 
import android.graphics.Canvas; 
import android.graphics.Color; 
import android.graphics.LinearGradient; 
import android.graphics.Matrix; 
import android.graphics.Paint; 
import android.graphics.Paint.Style; 
import android.graphics.Shader.TileMode; 
import android.os.Bundle; 
import android.view.View; 
 
public class SimpleUseActivity extends Activity 
{ 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) 
  { 
    super.onCreate(savedInstanceState); 
    setContentView(new PolyToPolyView(this)); 
 
  } 
 
  class PolyToPolyView extends View 
  { 
 
    private static final int NUM_OF_POINT = 8; 
    /** 
     * 图片的折叠后的总宽度 
     */ 
    private int mTranslateDis; 
 
    /** 
     * 折叠后的总宽度与原图宽度的比例 
     */ 
    private float mFactor = 0.8f; 
    /** 
     * 折叠块的个数 
     */ 
    private int mNumOfFolds = 8; 
 
    private Matrix[] mMatrices = new Matrix[mNumOfFolds]; 
     
    private Bitmap mBitmap; 
 
    /** 
     * 绘制黑色透明区域 
     */ 
    private Paint mSolidPaint; 
 
    /** 
     * 绘制阴影 
     */ 
    private Paint mShadowPaint; 
    private Matrix mShadowGradientMatrix; 
    private LinearGradient mShadowGradientShader; 
 
    /*** 
     * 原图每块的宽度 
     */ 
    private int mFlodWidth; 
    /** 
     * 折叠时，每块的宽度 
     */ 
    private int mTranslateDisPerFlod; 
 
    public PolyToPolyView(Context context) 
    { 
      super(context); 
      mBitmap = BitmapFactory.decodeResource(getResources(), 
          R.drawable.tanyan); 
       
      //折叠后的总宽度 
      mTranslateDis = (int) (mBitmap.getWidth() * mFactor); 
      //原图每块的宽度 
      mFlodWidth = mBitmap.getWidth() / mNumOfFolds; 
      //折叠时，每块的宽度 
      mTranslateDisPerFlod = mTranslateDis / mNumOfFolds; 
       
      //初始化matrix 
      for (int i = 0; i &lt; mNumOfFolds; i++) 
      { 
        mMatrices[i] = new Matrix(); 
      } 
 
      mSolidPaint = new Paint(); 
      int alpha = (int) (255 * mFactor * 0.8f) ; 
      mSolidPaint 
          .setColor(Color.argb((int) (alpha*0.8F), 0, 0, 0)); 
 
      mShadowPaint = new Paint(); 
      mShadowPaint.setStyle(Style.FILL); 
      mShadowGradientShader = new LinearGradient(0, 0, 0.5f, 0, 
          Color.BLACK, Color.TRANSPARENT, TileMode.CLAMP); 
      mShadowPaint.setShader(mShadowGradientShader); 
      mShadowGradientMatrix = new Matrix(); 
      mShadowGradientMatrix.setScale(mFlodWidth, 1); 
      mShadowGradientShader.setLocalMatrix(mShadowGradientMatrix); 
      mShadowPaint.setAlpha(alpha); 
 
      //纵轴减小的那个高度，用勾股定理计算下 
      int depth = (int) Math.sqrt(mFlodWidth * mFlodWidth 
          - mTranslateDisPerFlod * mTranslateDisPerFlod)/2; 
 
      //转换点 
      float[] src = new float[NUM_OF_POINT]; 
      float[] dst = new float[NUM_OF_POINT]; 
 
      /** 
       * 原图的每一块，对应折叠后的每一块，方向为左上、右上、右下、左下，大家在纸上自己画下 
       */ 
      for (int i = 0; i &lt; mNumOfFolds; i++) 
      { 
        src[0] = i * mFlodWidth; 
        src[1] = 0; 
        src[2] = src[0] + mFlodWidth; 
        src[3] = 0; 
        src[4] = src[2]; 
        src[5] = mBitmap.getHeight(); 
        src[6] = src[0]; 
        src[7] = src[5]; 
 
        boolean isEven = i % 2 == 0; 
 
        dst[0] = i * mTranslateDisPerFlod; 
        dst[1] = isEven &#63; 0 : depth; 
        dst[2] = dst[0] + mTranslateDisPerFlod; 
        dst[3] = isEven &#63; depth : 0; 
        dst[4] = dst[2]; 
        dst[5] = isEven &#63; mBitmap.getHeight() - depth : mBitmap 
            .getHeight(); 
        dst[6] = dst[0]; 
        dst[7] = isEven &#63; mBitmap.getHeight() : mBitmap.getHeight() 
            - depth; 
 
        //setPolyToPoly 
        mMatrices[i].setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); 
      } 
 
    } 
 
    @Override 
    protected void onDraw(Canvas canvas) 
    { 
      super.onDraw(canvas); 
      //绘制mNumOfFolds次 
      for (int i = 0; i &lt; mNumOfFolds; i++) 
      { 
         
        canvas.save(); 
        //将matrix应用到canvas 
        canvas.concat(mMatrices[i]); 
        //控制显示的大小 
        canvas.clipRect(mFlodWidth * i, 0, mFlodWidth * i + mFlodWidth, 
            mBitmap.getHeight()); 
        //绘制图片 
        canvas.drawBitmap(mBitmap, 0, 0, null); 
        //移动绘制阴影 
        canvas.translate(mFlodWidth * i, 0); 
        if (i % 2 == 0) 
        { 
          //绘制黑色遮盖 
          canvas.drawRect(0, 0, mFlodWidth, mBitmap.getHeight(), 
              mSolidPaint); 
        }else 
        { 
          //绘制阴影 
          canvas.drawRect(0, 0, mFlodWidth, mBitmap.getHeight(), 
              mShadowPaint); 
        } 
        canvas.restore(); 
      } 
 
    } 
 
  } 
 
} 

</pre>
</div>
<p>简单讲解下，不去管绘制阴影的部分，其实折叠就是：<br />
1、初始化转换点，这里注释说的很清楚，大家最好在纸上绘制下，标一下每个变量。<br />
2、为matrix.setPolyToPoly<br />
3、绘制时使用该matrix，且clipRect控制显示区域（这个区域也很简单，原图的第一块到最后一块），最好就是绘制bitmap了。<br />
阴影这里大家可以换个明亮点的图片去看看~~</p>
<p><strong>五、FoldLayout的实现<br />
1、实现<br />
</strong>我们的想法是这样的，我们的FoldLayout只能有一个直接子元素，当然这个子元素可以是RelativeLayout什么的，可以很复杂。然后只要外层套了我们的FoldLayout，就能实现折叠效果。<br />
那么也就是说，我们的FoldLayout折叠效果展示的是它的子元素的“样子”，那么如何或者这个“样子”呢？<br />
大家都知道，我们的ViewGroup有个方法叫做：dispatchDraw(Canvas)主要用来绘制子元素，我们可以对这个canvas进行设置matrix，以及重复调用dispatchDraw(Canvas)来实现类似上篇博客最后的效果，这样就完成了我们的可行性的分析。</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.view; 
 
import android.content.Context; 
import android.graphics.Bitmap; 
import android.graphics.Bitmap.Config; 
import android.graphics.Canvas; 
import android.graphics.Color; 
import android.graphics.LinearGradient; 
import android.graphics.Matrix; 
import android.graphics.Paint; 
import android.graphics.Paint.Style; 
import android.graphics.Shader.TileMode; 
import android.util.AttributeSet; 
import android.view.View; 
import android.view.ViewGroup; 
 
public class FoldLayout extends ViewGroup 
{ 
 
  private static final int NUM_OF_POINT = 8; 
  /** 
   * 图片的折叠后的总宽度 
   */ 
  private float mTranslateDis; 
 
  protected float mFactor = 0.6f; 
 
  private int mNumOfFolds = 8; 
 
  private Matrix[] mMatrices = new Matrix[mNumOfFolds]; 
 
  private Paint mSolidPaint; 
 
  private Paint mShadowPaint; 
  private Matrix mShadowGradientMatrix; 
  private LinearGradient mShadowGradientShader; 
 
  private float mFlodWidth; 
  private float mTranslateDisPerFlod; 
 
  public FoldLayout(Context context) 
  { 
    this(context, null); 
  } 
 
  public FoldLayout(Context context, AttributeSet attrs) 
  { 
    super(context, attrs); 
 
    for (int i = 0; i &lt; mNumOfFolds; i++) 
    { 
      mMatrices[i] = new Matrix(); 
    } 
 
    mSolidPaint = new Paint(); 
    mShadowPaint = new Paint(); 
    mShadowPaint.setStyle(Style.FILL); 
    mShadowGradientShader = new LinearGradient(0, 0, 0.5f, 0, Color.BLACK, 
        Color.TRANSPARENT, TileMode.CLAMP); 
    mShadowPaint.setShader(mShadowGradientShader); 
    mShadowGradientMatrix = new Matrix(); 
    this.setWillNotDraw(false); 
 
  } 
 
  @Override 
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) 
  { 
    View child = getChildAt(0); 
    measureChild(child, widthMeasureSpec, heightMeasureSpec); 
    setMeasuredDimension(child.getMeasuredWidth(), 
        child.getMeasuredHeight()); 
 
  } 
 
  @Override 
  protected void onLayout(boolean changed, int l, int t, int r, int b) 
  { 
    View child = getChildAt(0); 
    child.layout(0, 0, child.getMeasuredWidth(), child.getMeasuredHeight()); 
 
    mBitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), 
        Config.ARGB_8888); 
    mCanvas.setBitmap(mBitmap); 
    updateFold(); 
 
  } 
 
  private void updateFold() 
  { 
    int w = getMeasuredWidth(); 
    int h = getMeasuredHeight(); 
 
    mTranslateDis = w * mFactor; 
    mFlodWidth = w / mNumOfFolds; 
    mTranslateDisPerFlod = mTranslateDis / mNumOfFolds; 
 
    int alpha = (int) (255 * (1 - mFactor)); 
    mSolidPaint.setColor(Color.argb((int) (alpha * 0.8F), 0, 0, 0)); 
 
    mShadowGradientMatrix.setScale(mFlodWidth, 1); 
    mShadowGradientShader.setLocalMatrix(mShadowGradientMatrix); 
    mShadowPaint.setAlpha(alpha); 
 
    float depth = (float) (Math.sqrt(mFlodWidth * mFlodWidth 
        - mTranslateDisPerFlod * mTranslateDisPerFlod) / 2); 
 
    float[] src = new float[NUM_OF_POINT]; 
    float[] dst = new float[NUM_OF_POINT]; 
 
    for (int i = 0; i &lt; mNumOfFolds; i++) 
    { 
      mMatrices[i].reset(); 
      src[0] = i * mFlodWidth; 
      src[1] = 0; 
      src[2] = src[0] + mFlodWidth; 
      src[3] = 0; 
      src[4] = src[2]; 
      src[5] = h; 
      src[6] = src[0]; 
      src[7] = src[5]; 
 
      boolean isEven = i % 2 == 0; 
 
      dst[0] = i * mTranslateDisPerFlod; 
      dst[1] = isEven &#63; 0 : depth; 
 
      dst[2] = dst[0] + mTranslateDisPerFlod; 
      dst[3] = isEven &#63; depth : 0; 
      dst[4] = dst[2]; 
      dst[5] = isEven &#63; h - depth : h; 
      dst[6] = dst[0]; 
      dst[7] = isEven &#63; h : h - depth; 
 
      for (int y = 0; y &lt; 8; y++) 
      { 
        dst[y] = Math.round(dst[y]); 
      } 
 
      mMatrices[i].setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); 
    } 
  } 
 
  private Canvas mCanvas = new Canvas(); 
  private Bitmap mBitmap; 
  private boolean isReady; 
 
  @Override 
  protected void dispatchDraw(Canvas canvas) 
  { 
 
    if (mFactor == 0) 
      return; 
    if (mFactor == 1) 
    { 
      super.dispatchDraw(canvas); 
      return; 
    } 
    for (int i = 0; i &lt; mNumOfFolds; i++) 
    { 
      canvas.save(); 
 
      canvas.concat(mMatrices[i]); 
      canvas.clipRect(mFlodWidth * i, 0, mFlodWidth * i + mFlodWidth, 
          getHeight()); 
      if (isReady) 
      { 
        canvas.drawBitmap(mBitmap, 0, 0, null); 
      } else 
      { 
        // super.dispatchDraw(canvas); 
        super.dispatchDraw(mCanvas); 
        canvas.drawBitmap(mBitmap, 0, 0, null); 
        isReady = true; 
      } 
      canvas.translate(mFlodWidth * i, 0); 
      if (i % 2 == 0) 
      { 
        canvas.drawRect(0, 0, mFlodWidth, getHeight(), mSolidPaint); 
      } else 
      { 
        canvas.drawRect(0, 0, mFlodWidth, getHeight(), mShadowPaint); 
      } 
      canvas.restore(); 
    } 
  } 
    //...dispatchDraw 
 
  public void setFactor(float factor) 
  { 
    this.mFactor = factor; 
    updateFold(); 
    invalidate(); 
  } 
 
  public float getFactor() 
  { 
    return mFactor; 
  } 
 
} 

</pre>
</div>
<p>上述代码大家应该不陌生，只是把从View对单个图片进行绘制的修改为了ViewGroup。<br />
既然是ViewGroup少不了onMeasure,onLayout等。测量和布局完全依赖于它的子View。<br />
然后将需要初始化的一些东西，不依赖于宽度的，比如画笔什么的都放在构造中；依赖宽高的，都在onLayout之后，调用了updateFold();进行初始化相关代码。<br />
updateFold中的代码，我们也不陌生，因为和上篇博客基本一致。主要就是计算mFlodWidth，mTranslateDisPerFlod以及根据设置的mNumOfFolds去循环初始化我们的matrix.<br />
matrix完成setPolyToPoly以后，我们就可以去绘制了：</p>
<div class="phpstudycode">
<pre class="brush:java;">
private Canvas mCanvas = new Canvas(); 
  private Bitmap mBitmap; 
  private boolean isReady; 
 
  @Override 
  protected void dispatchDraw(Canvas canvas) 
  { 
 
    if (mFactor == 0) 
      return; 
    if (mFactor == 1) 
    { 
      super.dispatchDraw(canvas); 
      return; 
    } 
    for (int i = 0; i &lt; mNumOfFolds; i++) 
    { 
      canvas.save(); 
 
      canvas.concat(mMatrices[i]); 
      canvas.clipRect(mFlodWidth * i, 0, mFlodWidth * i + mFlodWidth, 
          getHeight()); 
      if (isReady) 
      { 
        canvas.drawBitmap(mBitmap, 0, 0, null); 
      } else 
      { 
        // super.dispatchDraw(canvas); 
        super.dispatchDraw(mCanvas); 
        canvas.drawBitmap(mBitmap, 0, 0, null); 
        isReady = true; 
      } 
      canvas.translate(mFlodWidth * i, 0); 
      if (i % 2 == 0) 
      { 
        canvas.drawRect(0, 0, mFlodWidth, getHeight(), mSolidPaint); 
      } else 
      { 
        canvas.drawRect(0, 0, mFlodWidth, getHeight(), mShadowPaint); 
      } 
      canvas.restore(); 
    } 
  } 
</pre>
</div>
<p>mFactor主要代表折叠后的总宽度与原宽度的比值，默认不折叠时为1，所以直接调用super.dispatchDraw(canvas);<br />
那么如果为0，说明全部折起来了，我们直接if (mFactor == 0)return;就不要绘制了。<br />
如果(0,1)之间就是正常情况了，如果还记得上一篇博客内容，无非就是根据mNumOfFolds循环绘制多次，每次绘制的时候设置matrix,利用clipRect就可以实现我们的折叠。<br />
这里大家注意看，我在第一次绘制的时候，调用了：</p>
<div class="phpstudycode">
<pre class="brush:java;">
super.dispatchDraw(mCanvas); 
canvas.drawBitmap(mBitmap, 0, 0, null); 
isReady = true; 

</pre>
</div>
<p>在我们自己new的mBitmap中也绘制了一份图片，因为我不希望每次都是调用super.dispatchDraw，所以只要isReady=true，我们就可以去调用绘制mBitmap而避免调用super.dispatchDraw()。<br />
绘制完成图片，就是绘制黑色的遮盖和阴影了~~，就是两个Rect的绘制。<br />
完成这些以后，我们可以简单的坐下测试，使用我们的布局。</p>
<p><strong>2、测试<br />
</strong>布局文件:<br />
</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;com.zhy.view.FoldLayout xmlns:android="http://schemas.android.com/apk/res/android" 
  xmlns:tools="http://schemas.android.com/tools" 
  android:id="@+id/id_fold_layout" 
  android:layout_width="match_parent" 
  android:layout_height="match_parent" &gt; 
 
  &lt;ImageView 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    android:scaleType="fitXY" 
    android:src="@drawable/xueshan" /&gt; 
 
&lt;/com.zhy.view.FoldLayout&gt; 
</pre>
</div>
<p>Activity</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.sample.folderlayout; 
 
import com.zhy.view.FoldLayout; 
 
import android.animation.ObjectAnimator; 
import android.annotation.SuppressLint; 
import android.app.Activity; 
import android.os.Bundle; 
 
public class FoldLayoutActivity extends Activity 
{ 
  private FoldLayout mFoldLayout; 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) 
  { 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.activity_fold); 
 
    mFoldLayout = (FoldLayout) findViewById(R.id.id_fold_layout); 
   
    /*mFoldLayout.post(new Runnable() 
    { 
 
      @SuppressLint("NewApi") 
      @Override 
      public void run() 
      { 
        ObjectAnimator.ofFloat(mFoldLayout, "factor", 1, 0, 1) 
            .setDuration(5000).start(); 
      } 
    });*/ 
 
  } 
} 

</pre>
</div>
<p>现在的效果是，我们把mFactor改为0.6f:<br />
</p>
<p></p>
<p>当然了，此时只是静态的，但是我们成功的完成了绘制一个静态图到FlodLayout。<br />
接下来我们为其增加手指的触摸折叠功能。</p>
<p><strong>六、TouchFoldLayout<br />
</strong>1、实现<br />
增加触摸功能其实很简单，我们的绘制依赖mFactor这个值，我们只要在onTouchEvent里面去累加手指移动距离，然后动态更新这个值就可以了。<br />
</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.view; 
 
import android.content.Context; 
import android.graphics.Canvas; 
import android.util.AttributeSet; 
import android.view.GestureDetector; 
import android.view.MotionEvent; 
 
public class TouchFoldLayout extends FoldLayout 
{ 
 
  private GestureDetector mScrollGestureDetector; 
 
  public TouchFoldLayout(Context context, AttributeSet attrs) 
  { 
    super(context, attrs); 
    init(context, attrs); 
  } 
 
  public void init(Context context, AttributeSet attrs) 
  { 
    mScrollGestureDetector = new GestureDetector(context, 
        new ScrollGestureDetector()); 
 
  } 
 
  @Override 
  public boolean onTouchEvent(MotionEvent event) 
  { 
    return mScrollGestureDetector.onTouchEvent(event); 
  } 
 
  private int mTranslation = -1; 
 
  @Override 
  protected void dispatchDraw(Canvas canvas) 
  { 
    if (mTranslation == -1) 
      mTranslation = getWidth(); 
    super.dispatchDraw(canvas); 
  } 
 
  class ScrollGestureDetector extends GestureDetector.SimpleOnGestureListener 
  { 
    @Override 
    public boolean onDown(MotionEvent e) 
    { 
      return true; 
    } 
 
    @Override 
    public boolean onScroll(MotionEvent e1, MotionEvent e2, 
        float distanceX, float distanceY) 
    { 
      mTranslation -= distanceX; 
 
      if (mTranslation &lt; 0) 
      { 
        mTranslation = 0; 
      } 
      if (mTranslation &gt; getWidth()) 
      { 
        mTranslation = getWidth(); 
      } 
 
      float factor = Math.abs(((float) mTranslation) 
          / ((float) getWidth())); 
 
      setFactor(factor); 
 
      return true; 
    } 
  } 
 
} 
</pre>
</div>
<p>我们选择继承FoldLayout，重写其onTouchEvent，然后通过mScrollGestureDetector获取移动的距离，最终和width做比值得到我们的factor，然后调用setFactor进行改变。<br />
</p>
<div class="phpstudycode">
<pre class="brush:java;">
public void setFactor(float factor) 
{ 
  this.mFactor = factor; 
  updateFold(); 
  invalidate(); 
} 
</pre>
</div>
<p>ok,这样就完成了引入手指的控制。</p>
<p>2、测试<br />
现在改变下布局文件里面的类：<br />
</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;com.zhy.view.TouchFoldLayout xmlns:android="http://schemas.android.com/apk/res/android" 
  xmlns:tools="http://schemas.android.com/tools" 
  android:id="@+id/id_fold_layout" 
  android:layout_width="match_parent" 
  android:layout_height="match_parent" &gt; 
 
  &lt;ImageView 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    android:scaleType="fitXY" 
    android:src="@drawable/xueshan" /&gt; 
 
&lt;/com.zhy.view.TouchFoldLayout&gt; 
</pre>
</div>
<p>Activity不变，看一下测试效果：（测试前记得把mFactor改为默认值1.0f）<br />
</p>
<p></p>
<p></p>
<p>至此我们完成了炫酷的效果，但是我们还需要应用到具体的案例上，否则就是特技，有必要duang一下。<br />
于是我们首先考虑增加到侧滑菜单中去，侧滑菜单有很多选择，google也提供了两个，一个是DrawerLayout，另一个是SlidingPaneLayout。<br />
下面分别展示如何整合入这两个布局。<br />
首先看SlidingPaneLayout，因为DrawerLayout还有些地方需要修改。</p>
<p><strong>八、FoldSlidingPanelLayout</strong></p>
<p>1、实现<br />
对于SlidingPaneLayout的使用，应该没什么问题吧，就是把布局文件的根布局设置为SlidingPaneLayout，然后里面放两个子布局，一个代表侧滑菜单，一个代表内容区域。<br />
那么，我们怎么整合到SlidingPaneLayout种去呢？大致两种方法：<br />
1、把我们的折叠菜单作为侧滑布局的根布局，然后在Activity种去监听setPanelSlideListener做出改变。<br />
2、直接继承SlidingPaneLayout，再其内部将child(0)用FoldLayout包起来，然后监听setPanelSlideListener。<br />
这里我们选择后者，因为后者封装好了，就能直接按照SlidingPaneLayout原本的方式去使用了，不需要做多余的操作。<br />
下面看代码：<br />
</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.view; 
 
import android.content.Context; 
import android.support.v4.widget.SlidingPaneLayout; 
import android.util.AttributeSet; 
import android.view.View; 
import android.view.ViewGroup; 
 
public class FoldSlidingPanelLayout extends SlidingPaneLayout 
{ 
  public FoldSlidingPanelLayout(Context context, AttributeSet attrs) 
  { 
    super(context, attrs); 
  } 
  @Override 
  protected void onAttachedToWindow() 
  { 
    super.onAttachedToWindow(); 
     
    View child = getChildAt(0); 
    if (child != null) { 
 
      removeView(child); 
      final FoldLayout foldLayout = new FoldLayout(getContext()); 
      //foldLayout.setAnchor(0); 
      foldLayout.addView(child); 
      ViewGroup.LayoutParams layPar = child.getLayoutParams(); 
      addView(foldLayout, 0, layPar); 
       
      setPanelSlideListener(new PanelSlideListener() 
      { 
         
        @Override 
        public void onPanelSlide(View arg0, float arg1) 
        { 
          foldLayout.setFactor(arg1); 
        } 
         
        @Override 
        public void onPanelOpened(View arg0) 
        { 
          // TODO Auto-generated method stub 
           
        } 
         
        @Override 
        public void onPanelClosed(View arg0) 
        { 
           
        } 
      }); 
       
    } 
  } 
} 
</pre>
</div>
<p>我们继承了SlidingPaneLayout，然后在onAttachedToWindow中，取出侧滑的布局，在外层包上一个FoldLayout；并且在内部去监听setPanelSlideListener，在onPanelSlide种根据参数，去动态设置FoldLayout的factor.<br />
2、测试<br />
（1）、布局文件<br />
</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;com.zhy.view.FoldSlidingPanelLayout xmlns:android="http://schemas.android.com/apk/res/android" 
  xmlns:tools="http://schemas.android.com/tools" 
  android:id="@+id/id_drawerLayout" 
  android:layout_width="match_parent" 
  android:layout_height="match_parent" &gt; 
 
  &lt;fragment 
    android:id="@+id/id_left_menu" 
    android:name="com.zhy.sample.folderlayout.LeftMenuFragment" 
    android:layout_width="240dp" 
    android:layout_height="match_parent" /&gt; 
 
  &lt;RelativeLayout 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" &gt; 
 
    &lt;ImageView 
      android:layout_width="match_parent" 
      android:layout_height="match_parent" 
      android:scaleType="fitCenter" 
      android:src="@drawable/xueshan" /&gt; 
  &lt;/RelativeLayout&gt; 
 
&lt;/com.zhy.view.FoldSlidingPanelLayout&gt; 
</pre>
</div>
<p>我们的菜单使用的是一个fragment。<br />
（2）、菜单布局</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.sample.folderlayout; 
 
import android.os.Bundle; 
import android.support.v4.app.Fragment; 
import android.view.LayoutInflater; 
import android.view.View; 
import android.view.ViewGroup; 
import android.widget.ArrayAdapter; 
import android.widget.ListView; 
 
public class LeftMenuFragment extends Fragment 
{ 
  private ListView mMenus; 
  private String[] mMenuItemStr = { "Bear", "Bird", "Cat", "Tigers", "Panda" }; 
 
  @Override 
  public View onCreateView(LayoutInflater inflater, ViewGroup container, 
      Bundle savedInstanceState) 
  { 
 
    View view = inflater.inflate(R.layout.fragment_left_menu, container, 
        false); 
    mMenus = (ListView) view.findViewById(R.id.id_left_menu_lv); 
    mMenus.setAdapter(new ArrayAdapter&lt;String&gt;(getActivity(), 
        R.layout.item_left_menu, mMenuItemStr)); 
    return view; 
  } 
} 

</pre>
</div>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;ListView xmlns:android="http://schemas.android.com/apk/res/android" 
  xmlns:tools="http://schemas.android.com/tools" 
  android:id="@+id/id_left_menu_lv" 
  android:layout_width="240dp" 
  android:layout_height="match_parent" 
  android:layout_gravity="start" 
  android:background="#FFF" 
  android:choiceMode="singleChoice" /&gt; 

</pre>
</div>
<p>Item就是一个TextView，就不贴了~~<br />
3、Activity</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.sample.folderlayout; 
 
import android.os.Bundle; 
import android.support.v4.app.FragmentActivity; 
 
public class SlidingPanelLayoutSampleActivity extends FragmentActivity 
{ 
  @Override 
  protected void onCreate(Bundle arg0) 
  { 
    super.onCreate(arg0); 
    setContentView(R.layout.activity_slidingpanellayout); 
  } 
} 
</pre>
</div>
<p>恩，Activity里面什么都不用做，引入布局文件就行了。<br />
最好看看效果图。<br />
3、效果图<br />
</p>
<p></p>
<p>这里菜单块数比较多，大家可以自行修改运行。<br />
ok，到此我们将FoldLayout与SlidingPaneLayout进行了整合，构造了这么个个性的侧滑。<br />
最好还剩下与Drawerlayout的整合。</p>
<p><strong>九、FoldDrawerLayout<br />
</strong>1、实现<br />
关于DrawerLayout的使用，与上面的SlidingPaneLayout类似，写写布局文件，引入Activity就好了。我们依然使用上述的方法2，去实现一个DrawerLayout的子类。</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.zhy.view; 
 
import android.content.Context; 
import android.support.v4.view.GravityCompat; 
import android.support.v4.view.ViewCompat; 
import android.support.v4.widget.DrawerLayout; 
import android.util.AttributeSet; 
import android.util.Log; 
import android.view.Gravity; 
import android.view.View; 
import android.view.ViewGroup; 
 
public class FoldDrawerLayout extends DrawerLayout 
{ 
  private static final String TAG = "DrawerFoldLayout"; 
 
  public FoldDrawerLayout(Context context, AttributeSet attrs) 
  { 
    super(context, attrs); 
  } 
 
  @Override 
  protected void onAttachedToWindow() 
  { 
    super.onAttachedToWindow(); 
 
    final int childCount = getChildCount(); 
    for (int i = 0; i &lt; childCount; i++) 
    { 
      final View child = getChildAt(i); 
      if (isDrawerView2(child)) 
      { 
        Log.e(TAG, "at" + i); 
        FoldLayout foldlayout = new FoldLayout( 
            getContext()); 
        //&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;foldlayout&lt;/span&gt;&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;.setAnchor(1);&lt;/span&gt; 
        removeView(child); 
        foldlayout.addView(child); 
        ViewGroup.LayoutParams layPar = child.getLayoutParams(); 
        addView(foldlayout, i, layPar); 
      } 
 
    } 
    setDrawerListener(new DrawerListener() 
    { 
 
      @Override 
      public void onDrawerStateChanged(int arg0) 
      { 
        // TODO Auto-generated method stub 
 
      } 
 
      @Override 
      public void onDrawerSlide(View drawerView, float slideOffset) 
      { 
 
        if (drawerView instanceof FoldLayout) 
        { 
          FoldLayout foldLayout = ((FoldLayout) drawerView); 
          Log.e(TAG, "slideOffset = " + slideOffset); 
          foldLayout.setFactor(slideOffset); 
        } 
 
      } 
 
      @Override 
      public void onDrawerOpened(View arg0) 
      { 
 
      } 
 
      @Override 
      public void onDrawerClosed(View arg0) 
      { 
 
      } 
    }); 
 
  } 
 
  boolean isDrawerView2(View child) 
  { 
    final int gravity = ((LayoutParams) child.getLayoutParams()).gravity; 
    final int absGravity = GravityCompat.getAbsoluteGravity(gravity, 
        ViewCompat.getLayoutDirection(child)); 
    return (absGravity & (Gravity.LEFT | Gravity.RIGHT)) != 0; 
  } 
 
} 

</pre>
</div>
<p>看到这，大家可能会想，然后就和SlidingPaneLayout一样，写写布局文件就好了？其实不是的，如果你这么做了，你会发现侧滑很难拉出来，因为是这样的：<br />
DraweLayout的侧滑菜单，比如我们拉出来50%，那么正常来说显示的时侧滑布局右侧的50%，但是这个0.5如果设置给我们的factor，它会把布局缩小到50%且在左边。<br />
导致，你拉了50%其实还是上面都看不到，因为折叠到左侧的50%去了。这里依然有两种解决方案：<br />
（1）、结合属性动画，做偏移，具体可参考：Android DrawerLayout 高仿QQ5.2双向侧滑菜单<br />
（2）、让我们的折叠，收缩到最终的位置可以控制，我们现在统统往最坐标收缩，如果可以设置为最右边，那么本例就没有问题了。<br />
2、引入anchor<br />
我们引入一个mAnchor变量，值范围[0，1]，控制FoldLayout最终折叠到的位置。其实修改的代码比较少，我贴一下修改的代码：</p>
<div class="phpstudycode">
<pre class="brush:java;">
private void updateFold() 
  { 
     
    //... 
    float anchorPoint = mAnchor * w; 
    float midFold = (anchorPoint / mFlodWidth); 
 
    for (int i = 0; i &lt; mNumOfFolds; i++) 
    { 
      //引入anchor 
      dst[0] = (anchorPoint &gt; i * mFlodWidth) &#63; anchorPoint 
          + (i - midFold) * mTranslateDisPerFlod : anchorPoint 
          - (midFold - i) * mTranslateDisPerFlod; 
      dst[2] = (anchorPoint &gt; (i + 1) * mFlodWidth) &#63; anchorPoint 
          + (i + 1 - midFold) * mTranslateDisPerFlod : anchorPoint 
          - (midFold - i - 1) * mTranslateDisPerFlod;                               }         </pre>
</div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>唯一改变的就是dst[0]和dst[2]的坐标，当然了，anchor引入以后，你需要判断原始的坐标是否小于anchorPoint，如果小于需要加一些偏移量，大于则反之。<br />
记得：<br />
</p>
<div class="phpstudycode">
<pre class="brush:java;">
public void setAnchor(float anchor) 
  { 
    this.mAnchor = anchor; 
    updateFold(); 
    invalidate(); 
  } 
</pre>
</div>
<p>打开上述的FoldDrawerLayout的这行代码：foldlayout.setAnchor(1);让其最后合并位置为右侧。<br />
使用方式，现在就是写好布局文件，大家直接使用SlidingPaneLayout那个布局文件，改一个根布局类就行。<br />
3、效果图<br />
</p>
<p></p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/97693.html'>解析PL/SQL Developer导入导出数据库的方法以及说明</a><a>下一篇</a><a href='/php/biji/97695.html'>jquery获取tagName再进行判断</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>