<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>PHP类的精髓归纳解析_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了PHP类的精髓归纳解析，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！一：结构和调用(实例化)：class className{" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/122.html"></a></li><li><a href="/php/phpbiji/123.html"></a></li><li><a href="/php/phpbiji/124.html"></a></li><li><a href="/php/phpbiji/125.html"></a></li><li><a href="/php/phpbiji/126.html"></a></li><li><a href="/php/phpbiji/127.html"></a></li><li><a href="/php/phpbiji/128.html"></a></li><li><a href="/php/phpbiji/129.html"></a></li><li><a href="/php/phpbiji/130.html"></a></li><li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">PHP类的精髓归纳解析</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了PHP类的精髓归纳解析，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！一：结构和调用(实例化)：class className{</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了PHP类的精髓归纳解析，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p><strong>一：结构和调用(实例化)：</strong>class className{} ，调用：$obj = new className();当类有构造函数时，还应传入参数。如$obj = new className($v,$v2...);
<p><strong>二：构造函数和析构函数</strong>：1、构造函数用于初始化：使用__construct()，可带参数。2、但析构函数不能带参数（用于在销去一个类之前执行一些操作或功能）。析构函数用__destruct()做名称。在脚本执行结束时，PHP会销掉内存中的对象，因此可不用析造函数，但有些比如COOKIE等，就应当要用此函数销掉。知识点：在PHP4中也提供了构造函数，但使用的是与类同名的类方法，在PHP5仍能兼容这种做法，当一个类中没有包含__construct时，会查找与类同名的方法，如果找到，就认为是构造函数，如下：class test{ var $b;function test() { $this-&gt;b=5; }function addab($c) { return $this-&gt;b+$c; }}$a = new test(); echo $a-&gt;addab(4); // 返回 93、PHP不会自动调用父类的构造函数(不支持构造函数重载)，必须使用parent关键字显式地调用。class employee{ function __construct()....}class Manager extents Employee{ function __construct(){ parent::_construct(); echo &#39;这个子类的父类构造函数调用了！&#39;; }}当然也可以调用与该实例没有任何关系的其它类的构造函数。只需在__construct()前加上类名即可。如：otherClassName::__construct();</p>
<p>类的主家庭成员：属性、方法、常量、静态成员</p>
<p><strong>三、类的属性：</strong>有两种方法对类的属性赋值或取值。1、使用公共作用域public关键词。2、使用__set()和__get()来分别赋值和取值，前者称为设置方法（setter）或修改方法(mutator)，后者称为访问方法(accessor)或获取方法(getter)。建议使用这种方法：优点：A、可在__set（）统一进行数据验证。B、便于统一管理属性。注意：第一：__set()和__get()只对私有属性起作用，对于用public定义的属性，它们两个都懒理搭理，如下：class test{protected $a=9,$b=2,$c; public $d; function __set($n,$v) { $this-&gt;$n = $v+2; } function __get($name) { return $this-&gt;$name+2; }}$a = new test();$a-&gt;b =5; echo &quot;&lt;br /&gt;&quot;; echo $a-&gt;b;实例只对$a,$b,$c的设置会经过__set和__get过滤与返回，对于$d，就不会起作用。如$a-&gt;d=5,再返回还是5。第二：__set($n,$v)要带两个参数。而__get($n)只能有一个参数。实例：class test{ private $a=5,$b=6,$c; function __set($n,$v) { if($n==&#39;a&#39;&amp;&amp;$n&gt;0) $this-&gt;$n = $v; else $this-&gt;$n = $v+2; } function __get($name) { return $this-&gt;$name; //如果改为return $this-&gt;$name + $this-&gt;addab(); 如调用a的值，实际返回的是a+a+b的值。默认为5+5+6=16。 } function addab() { return $this-&gt;a + $this-&gt;b; }}$e=new test();$e-&gt;a = 11; //注意写法：类的内部用$this-&gt;$n即变量的写法，但外部实例要用$e-&gt;a的方式。$e-&gt;b = 12; //get 14$e-&gt;k = 22;</p>
<p>类的属性可自由扩展，如上例的k，不管是否用__set，当一个实例建立起来后，可以用$e-&gt;newProperty = xx;直接来创造一个属性，但不建议这么做。</p>
<p><strong>四、类的方法：</strong>理解成类当中的函数即可。调用：1、内部调用：可使用$this-&gt;Fanname();或$this-&gt;addab()或test::addab();2、实例化调用时，用$e-&gt;addab();即可。对于在该方法中没有使用$this关键字的，如上例中的：function addab() { return $this-&gt;a+$this-&gt;b; }改为： function addab() { return 25; }那在在外部实例调用该方法，也可用&ldquo;$e::addab();&rdquo;或&ldquo;test::addab();&rdquo;</p>
<p><strong>五、类的常量：</strong>如果类的属性理解成类中的变量，那么类的常量和变量是不一样的，其定义方法为：class test{ private $a; const PI = &#39;3.14&#39;; ..... //在类中调用上面的常量用两种方法，&ldquo;$this::PI&rdquo;,或 &ldquo;类名::PI&rdquo;,这里就是test::PI,如下： function getvalue(){ return $this-&gt;a * $this::PI; //或$this-&gt;a * test::PI,用this关键字或类名均可，但都要用双冒号。 }}$e= new test();$e-&gt;PI =5; //注意，这里用 -&gt;只是创造了一个也是名为PI的属性，而不是改变类中的PI常量的值。echo $e::PI; //这个才是调用类的常量。常量只能用双冒号::来调用。并且不能更改其值。在类外部实例化后调用类常量同样也有两种方法。方法为：&ldquo;$e::PI&rdquo; 或 &ldquo;test::PI&rdquo;，共同点是都要用冒号，不同点是外部不能用this关键字，只能用实例名，但类名::PI是通用的。</p>
<p><strong>六、类的静态成员（静态属性或静态方法）：</strong>如果需要创建供所有类的实例共享的字段或方法。就得用静态成员。有两个特征：1、静态成员是共产主义者，它让脚本上的所有该类的实例调用，但不能借助类的特定实例名调用，而是在类的外部，统一使用&ldquo;类名::$成员名&rdquo;的方式调用。而类的内部则统一使用 &ldquo;self::$成员名&rdquo;来调用。2、当每一次新创建实例时，静态成员会从上次创建的实例最后值开始重新计算，而不是类中初始的值开始计算。3、对于用public定义的静态成员，可以在外部更改它的值。private等则不行。class test{ public static $v = 0; function __construct(){ self::$v++; } static function getV(){ return self::$v; }}$a = new test();echo test::getV(); // 返回 1$b = new test();echo test::getV(); // 返回 2test::$v=8; //由于public定义的成员，改变静态成员的值。$c = new test();echo test::getV(); // 返回 9</p>
<p><strong>七、关键字：</strong>（一）this关键字：用于类的内部指代类的本身。来访问属性或方法或常量，如$this-&gt;属性名或方法名。$this::常量名。this还可以用在该类的子类中，来指代本身的属性或方法。（二）双冒号&ldquo;::&rdquo;关键字：用于调用常量、静态成员。（三）self关键字:在类的内部与双冒号配合调用静态成员，如 self::$staticVar.，在类的内部，不能用$this来调用静态成员。（四）__toString()：在类中使用__toString()，用于将类转成字串并打印类，用处不大：如：class test{ public $p; public function __toString(){ return var_export($this,TRUE); }}$a=new test();echo $a; //输出：test::__set_state(array( &#39;p&#39; =&gt; NULL, ))，或写成：echo $a-&gt;__toString();（五）__clone() ：当克隆对象时，这个关键字才会发生作用，用于更改克隆时某些值。（六）__call()：方法重载，参下面示例：class cB{function __call($method,$n){ if($method==&#39;showVarType&#39;){ if(is_numeric($n[0])){ //不能用$n。要用$n[0]; $this-&gt;displayNum(); }else if (is_array($n[0])){ $this-&gt;displayArr(); }else{ $this-&gt;displayOther(); } }}function displayNum() { echo &#39;&lt;h3&gt;这是数字!&lt;/h3&gt;&#39;;}function displayArr() { echo &#39;&lt;h3&gt;这是数组!&lt;/h3&gt;&#39;;}function displayOther() { echo &#39;&lt;h3&gt;不是数组也不是数字!&lt;/h3&gt;&#39;;}}</p>
<p>$x=&#39;a&#39;;$y=array(&#39;a&#39;,&#39;b&#39;);$b=new cB;$b-&gt;showVarType($x); //不是数组也不是数字$b-&gt;showVarType($y); //这是数组注意，不能在类中定义showVarType（）方法，否则代码不能用。<strong>（七）extends:继承: 如class a{} class b extends a{} 类b继承了类a</strong></p>
<p>附：记忆：以后统一在调用方法或属性时用 &quot;-&gt; &quot;,调用常量则用双冒号&ldquo;::&rdquo;，不会搞晕。</p>
<p><strong>八、方法和属性的作用域：</strong>共有6种：public(默认，可省略，也等同于php6的var声明),private（私有，也不能由子类使用），protected(私有，但可由子类使用) ，abstract(抽象，参下文)，final(阻止在子类中覆盖&mdash;也称重载，阻止被继承，用于修饰类名及方法，如final class test{ final function fun(){}} ，但不能用于属性),static(静态)</p>
<p><strong>九：抽象类和抽象方法（abstract&mdash;&mdash;注意：没有所谓抽象属性）:</strong>抽象可以理解成父类为子类定义了一个模板或基类。作用域abstract只在父类中声明，但在子类中实现。注意事项：1、抽象类不能被实例化，只能被子类（具体类）继承后实现。2、抽象类必须在其子类中实现该抽象类的所有抽象方法。否则会出错。3、在抽象方法中，只是声明，但不能具体实现：如abstract function gettow(){ return $this-&gt;p; }是错的，只能声明这个方法：abstract function gettow();（连方括号{}都不要出现）,抽象方法和抽象类主要用于复杂的类层次关系中。该层次关系需要确保每一个子类都包含并重载了某些特定的方法。这也可以通过接口实现4、属性不能被命名为抽象属性，如abstract $p = 5是错的。5、只有声明为抽象的类可以声明抽象方法，但如果方法声明为抽象，就不能具体实现。如：abstract class Employee{ abstract function a(...); abstract function b(...);}以后再对这个父类扩展，组成各种子类（如经理，员工，出纳）。6、抽象类中，如果要实现具体的方法，不能声明为抽象。这样可能实际意义更大。可以把几个类库中共同的部分提取到抽象类中，其它的类继承抽象类即可。如下：abstract class BaseShop{ Const TAX=0.06; // 在抽象类中定义常量 public function buy($gid) { // 如果定义为抽象方法abstract function buy（）就不能在这里实现主体。 echo(&#39;你购买了ID为 :&#39;.$gid.&#39;的商品&#39;); } public function sell($gid) { echo(&#39;你卖了ID为 :&#39;.$gid.&#39;的商品&#39;); } public function view($gid) { echo(&#39;你查看了ID为 :&#39;.$gid.&#39;的商品&#39;); }}class BallShop extends BaseShop{ var $itme_id = null; public function __construct() { $this-&gt;itme_id = 2314; } public function open() { $this-&gt;sell($this-&gt;itme_id); } public function getTax() { echo printf(&#39;&lt;h3&gt;平均税率是 %d%%。&lt;/h3&gt;&#39;,$this::TAX*100); }}$s = new BallShop;$s-&gt;open(); //你卖了ID为 :2314的商品$shop-&gt;getTax();</p>
<div class="pagenum tc"><strong>12下一页阅读全文 </strong>
<p><strong>对此感兴趣的朋友，看看idc笔记做的技术笔记！</strong></p><strong><strong>十：类型提示：</strong>注意，类型提示功能只能用于参数为对象的提示，而无法用于为整数，字串，浮点等类型提示。有些类的方法需要传入的参数为所期望的对象类型，可以用下面的方法达到强制实施此替则。要达到类型提示，只要在方法的对象型参数前加一个已存在的类的名称，如：function funname(OtherClassName $otherclassINSName,$c....)，注意，OtherClassName必须是存在的类。如下：class em{ var $k=56; }class test{function __construct(){ echo $this-&gt;addab(new em(),2); } </strong>
<p></p><strong> </strong>
<p></p><strong> </strong>
<p><strong>function addab(em $j,$c) //这个方法，即可以在内部调用，也可以在外部调用。只要作用域许可。{ return $j-&gt;k+$c; }}$a = new test();$b = new em();echo $a-&gt;addab($b,2); //或 $a-&gt;addab(new em(),2);</strong></p><strong> </strong>
<p><strong><strong>十一、类的管理：</strong>1、instanceof关键字：用于分析一个对象是否是某一个类的实例或子类或是实现了某个特定的接口：如下例，但要注意： 类名没有任何引号等定界符，否则会出错。如test不能用&#39;test&#39;class test2{}class test{}class testChilern Extends test{}$a = new test2();$m = new test();$i = ($m instanceof test);if($i)echo &#39;$m是类test的实例！&lt;br /&gt;&#39;; // get this valueswitch ($a instanceof test){ case true : echo &#39;YES&lt;br /&gt;&#39;; break; case false : echo &#39;No&lt;br /&gt;&#39;; //get this value break;}$d=new testChilern();if($d instanceof test)echo &#39;$d是类test的子类！&lt;br /&gt;&#39;; // get this value2、确定类是否存在：boolean class_exists(string class_name): class_exists(&#39;test&#39;);3、返回类名：string get_class(object)，成功时返回实例的类名，失败则返回FALSE：$a = new test2(); echo get_class($a); //返回 test24、了解类的公用属性：array get_class_vars(&#39;className&#39;) ,返回关键数组：包含所有定义的public属性名及其相应的值。这个函数不能用实例名做变量5、返回类方法：get_class_methods(&#39;test&#39;); //或： get_class_methods($a);可用实例名做参数，返回包括构造函数在内的所有非私有方法。6、print_r(get_declared_classes())了解当前PHP版本中所有的类名。PHP5有149个。7、get_object_vars($a)返回实例中所有公用的属性及其值的关联数组。注意它和get_class_vars()的区别：/* (1) get_object_vars($a)是用实例名做参数，而get_class_vars(&#39;test&#39;)是用类名做参数。* (2) get_object_vars($a)获得的属性值是实例运行后的值，而get_class_vars(&#39;test&#39;)获得的属性值是类中的初始定义。* (3) 两者均返回关联数组，且均对未赋值的属性返回NULL的值。如类test中有定义了public $q;则返回Array ( [v] =&gt; 5 [q]=&gt;) ,*/8、返回父类的名称：get_parent_class($b);//或get_parent_class(&#39;test2&#39;); 返回test9、确定接口是否存在：boolean interface_exists($string interface[,boolean autoload])10、确定对象类型： boolean is_a($obj,&#39;className&#39;)，当$obj属于CLASSNAME类时，或属于其子类时，返回TRUE，如果$obj与class类型无关则返回FALSE。如：is_a($a,&#39;test&#39;)11、确定是否是某类的子对象：当$b是继承自TEST类时，返回TRUE，否则FALSE。boolean is_subclass_of($b,&#39;test&#39;);12、确定类或实例中，是否存在某方法。method_exists($a,&#39;getv&#39;) //或用method_exists(&#39;test&#39;,&#39;getv&#39;)，此函数适用于非public定义的作用域的方法。以上函数实例：class test{public $v=2;private $c=5;function __construct(){ $this-&gt;v=5;}private function getv(){ return $this-&gt;v;}}class test2 extends test{}</strong></p><strong> </strong>
<p><strong>$a=new test();$b=new test2();print_r( get_class_methods(&#39;test&#39;)); //或：print_r( get_class_methods($a)); 均返回：Array ( [0] =&gt; __construct [1] =&gt; getv )echo &#39;&lt;br /&gt;&#39;;print_r( get_class_vars(&#39;test&#39;)); //返回：Array ( [v] =&gt; 2 )，和上面不一样，不能用print_r( get_class_methods($a));echo &#39;&lt;br /&gt;&#39;;echo get_parent_class($b);//或get_parent_class(&#39;test2&#39;); 返回testecho &#39;&lt;br /&gt;&#39;;echo is_a($b,&#39;test&#39;);// 返回1echo &#39;&lt;br /&gt;&#39;;if(is_subclass_of(&#39;test2&#39;,&#39;test&#39;))echo &#39;是子类！&#39;; //或(is_subclass_of($b,&#39;test&#39;)),返回1，当参数1为$a时则返回false,echo &#39;&lt;br /&gt;&#39;;echo method_exists($a,&#39;getv&#39;) //或用method_exists(&#39;test&#39;,&#39;getv&#39;)返回1,本函数也适用于用private等定义域的方法。</strong></p><strong> </strong>
<p><strong><strong>十一、自动加载类库文件：</strong>当类多了以后，比如要在一个文件中载入3个类库文件：a.class.php,b.class.php,c.class.php要用三个require_once(&#39;classes/a.class.php);require_once(&#39;classes/b.class.php);require_once(&#39;classes/c.class.php);可以用PHP5自动加载的功能来处理：在全局应用配置文件中，定义一个特殊的函数__autoload($class)函数（__autoload并不是一个类的方法，只是单独的函数，和类没有关系）：function __autoload($class){ require_once(&quot;classes/$class)}该函数放哪没有关系，在创建类实例时，也不必去调用这个autoload函数。PHP会自动完成。但务必注意一点：&ldquo;在调用页面上创建实例所使用的类名称&rdquo;、和&ldquo;被调用的文件名&rdquo;、以及&ldquo;该文件中的类的名称&rdquo;3个必须是一样的。这样就不需要去调用__autoload();如果不一样则必须单独调用__autoload(&#39;c&#39;);并给它一个文件名前缀。如：c.class.php文件的代码是：&lt;?phpclass c{public $m=7;}?&gt;这里代码的类名称是c,而文件名也是c，现在要在index.php调用：&lt;?phpfunction __autoload($class){require_once &quot;$class.class.php&quot;;}</strong></p><strong> </strong>
<p><strong>$m = new c(); //创建实例调用的类也是cecho $m-&gt;m;?&gt;此时PHP会自动调用根目录下的c.class.php中的类C。</strong></p><strong> </strong>
<p><strong>但如果c.class.php中的代码是：&lt;?phpclass mm{public $m=7;}?&gt;而调用页index.php代码是：&lt;?phpfunction __autoload($class){require_once &quot;$class.class.php&quot;;}# __autoload(&#39;c&#39;); //如果不加这一行就会出错。$m = new mm();echo $m-&gt;m;?&gt;会出错，提示找不到mm.class.php文件。这时可以加一行__autoload(&#39;c&#39;);但这样就达不到简化代码的目的。</strong></p><strong> </strong>
<p><strong>类的家族化扩展：类的高级功能：</strong></p><strong> </strong>
<p></p><strong> </strong>
<p><strong><strong>一、对象克隆：</strong>当克隆一个对象的实例时，其属性初始值继承了被克隆对象的当前值。class test{public $p=5;function __clone(){ //只在克隆发生时起作用。用于改变在克隆时某些值 $this-&gt;p=15; }}$a=new test();echo $a-&gt;p;$a-&gt;p=8; //如果没有__clone()方法影响，$b的P值将为8$b = clone $a;echo $b-&gt;p; //15</strong></p><strong> </strong>
<p><strong><strong>二、对象继承：</strong></strong></p><strong> </strong>
<p><strong>没有被声明为final的类可以被继承，没有被final和private界定的方法也可以继承，没有被private界定的属性也可以继承。当子类继承了父类或超类后，可以直接使用父类或超类（祖父类以及祖父的祖父）的所有允许的方法，属性。关键：理解构造函数和重载在继承中的特性！（一）构造函数在继承中的特性：1、当父类有构造函数而子类没有：则子类会在实例化时会自动执行父类的构造函数。这时如果要创建子类的实例，需要引入父类构造函数中所需的参数，否则出错。即使是&ldquo;子类的子类&rdquo;如果没有构造函数，也要在创建实例时输入其父类的父类的构造函数所需参数。PHP会从实例所在的子类会向上搜索合造的构造函数，一旦找到就停止，使用该构造函数。而不会再向上搜索，因此：子类本身如果没有构造函数，则以其最靠近的一个超类并且有构造函数的为准。class cA{public $name,$age; function __construct($n) { $this-&gt;name = $n; $this-&gt;age = 25;}function __set($n,$v) { $this-&gt;$n = $v; }function __get($n) { return $this-&gt;$n; }}</strong></p><strong> </strong>
<p><strong>class cB extends cA{ function funB1() { echo &#39;&lt;h3&gt;Class cB execute success!&lt;/h3&gt;&#39;; }}</strong></p><strong> </strong>
<p><strong>class cC extends cB {function funC1() { echo &#39;&lt;h3&gt;Class cC FunC1!&lt;/h3&gt;&#39;; }}$b=new cB(&#39;Jack&#39;);$b-&gt;name=&#39;John&#39;;echo &quot;$b-&gt;name : $b-&gt;age&quot;;$b-&gt;funB1();$c=new cC(); //这里会出错，由于cB也没有构造函数，因此再向上以cA为准，需要一个参数。改为$c=new cC(&#39;David&#39;);即可。echo $c-&gt;name(); //David2、当子类也有构造函数时：这时，不管父类是否有构造函数，都会执行子类自己的构造函数。如上：class cB extends cA{function __construct() { echo &#39;&lt;h3&gt;this is Class cB \&#39;s __construct!&lt;/h3&gt;&#39;;}function funB1() { echo &#39;&lt;h3&gt;Class cB execute success!&lt;/h3&gt;&#39;;}}现在类CB有自己的构造函数时，这时创建实例$b=new cB(&#39;Jack&#39;);参数JACK不会起作用，因为父类CA的构造函数没有得到执行。因此$b-&gt;name和$-&gt;age就不会初始化值。需要另外赋值$b-&gt;name=&#39;Jack&#39;,$b-&gt;age=25;如果这时要执行父类CA的构造函数，可以这样：function __construct($n) { parent::__construct($n); // 或：cA::__construct($n); echo &#39;&lt;h3&gt;this is Class cB \&#39;s __construct!&lt;/h3&gt;&#39;;}由于parent::__construct($n); 只会向上搜索父类的构造函数，一找到就停止且执行当前找到的构造函数，因此在上面例子中，如果parent::__construct($n)是用在最后一层的类cC中，并且类CB,CA都有构造函数，那么cC的实例只会执行cB的构造函数。不会执行cA。这时，如果CC的实例想都调用CA和CB的构造函数，有两种方法：A、在CB中也加入parent::__construct($n)B、在CC中把构造函数改为：function __construct($n) { cA::__construct($n); //即：类名::构造函数。 cB::__construct();echo &#39;&lt;h3&gt;this is Class cB \&#39;s __construct!&lt;/h3&gt;&#39;;}（二）在子类中调用父类的属性或方法：1、调用父类方法：在子类中调用父类的方法，有3种方法： $this-&gt;ParentFunction(); 或 父类名::ParentFunction(); 或 parent::parentFun();2、调用父类属性：只能用$this-&gt;ParentProperty;（三）重载：在子类中，可以定义与父类相同属性或方法，改变父类该属性或方法的值或操作，称做重载。如：calss ParClass{ function pfun(){ ....}}class ChildrenClass extends ParClass{function pfun(){ ....}}} //重载了父类的pfun的方法。在子类中重载后，优先执行自己重载后的新定义的方法或属性。也可以在子类中用parent::parentFun();调用父类的方法，但所得到的值是子类自己输入的参数运算值。而不是该方法在父类中运算的值。</strong></p><strong> </strong>
<p><strong><strong>三、接口：</strong></strong></p><strong> </strong>
<p><strong>接口：interface，可以理解成一组功能的共同规范，最大意义可能就是在多人协作时，为各自的开发规定一个共同的方法名称。和抽象类中的抽象方法一样：1、不能在接口中对方法具体实现进行定义。而是由具体类来实现（而抽象类中的非抽象方法可以不必再定义，只有抽象方法和接口是一样要求要在具体类中实现）。2、和抽象类一样，可以在接口中定义常量，并由具体类直接继承。3、具体类必须实现抽象类的所有抽象方法（非抽象方法除外），同样，具体类如通过implements实现了接口后，必须完成接口中的所有方法。</strong></p><strong> </strong>
<p><strong>接口实现过程：1、定义接口，2、用..implement X,Y,...和具体类对接。interface Info{ //定义接口 const N=22; public function getage(); public function getname();}</strong></p><strong> </strong>
<p><strong>class age implements Info //如要多个接口 class age （extends emJob） implements Info,interB...{ public $age=15; public $name=&#39;Join&#39;; function getage() { echo &quot;年级是$this-&gt;age&quot;; } function getname() { echo &quot;姓名是$this-&gt;name&quot;; } function getN(){ echo &#39;&lt;h3&gt;在接口中定义的常量N的值是：&#39;.$this::N.&#39; &lt;/h3&gt;&#39;; //直接继承接口中的常量值。 }}</strong></p><strong> </strong>
<p><strong>$age=new age;echo $age::N; //22，直接调用接口中的常量值。$age-&gt;getN();关于抽象类和接口类的使用区分：何时用接口，何时用抽象？1、相关性：当创建的模型由一些紧密相关的对象采用时，用抽象。对于不相关对象采用的功能，用接口。2、多重继承：PHP类可以继承多个接口，但不能扩展多个抽象类。3、公共行为实现：抽象类可在其中实现公共的方法，但接口不行。</strong></p><strong> </strong>
<p><strong><strong>四、命名空间（PHP6）</strong></strong></p><strong> </strong>
<p><strong>类库脚本A.inc.php和脚本B.inc.php中都一个类的名称为 class CNAME，并且这两个文件要在同一个文件如index.php中被调用。这时要用到命名空间。步聚：1、打开上面的A和B两个文件，分别在上面的最前面各加一行：namespace SPACEA; 和 namespace SPACEB; 名字自定。2、在index.php中实例化类时，在类的前面添加命名空间和双冒号做为前缀：include &#39;a.inc.php&#39;;include &#39;b.inc.php&#39;;$a=new SPACEA::CNAME();$b=new SPACEB::CNAME();这样就不会冲突了。但在PHP6正式发布前，这个功能还未定下来。</strong></p><strong> </strong>
<p><strong><strong>五、实现迭代器和迭代。</strong>参《PHP圣经》P142；</strong></p><strong> </strong>
<p><strong><strong>六、使用Reflection(反射)API 。</strong>简易实例：class a{ .... }$c = new ReflectionClass(&#39;a&#39;); //PHP 内置类。echo &#39;&lt;pre&gt;&#39;.$c.&#39;&lt;/pre&gt;&#39;;输出类a的结构和内容。参《PHP圣经》P145;<strong></strong></strong></p><strong> </strong>
<div class="pagenum tc"><strong>上一页1<strong>2阅读全文 </strong></strong></div></div>

<p>注：关于PHP类的精髓归纳解析的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/111305.html'>PHP获取网络文件的解决办法</a><a>下一篇</a><a href='/php/biji/111334.html'>Windows安装PHP运行环境入门实例</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>