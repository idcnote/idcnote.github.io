<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>详解Android中实现ListView左右滑动删除条目的方法_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="使用Scroller实现绚丽的ListView左右滑动删除Item效果<br />
<br />
这里来给大家带来使用Scroller的小例子，同时也能用来帮助初步解除的读者更加熟悉的掌握Scroller的使用，掌握好了Scroll" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">详解Android中实现ListView左右滑动删除条目的方法</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>使用Scroller实现绚丽的ListView左右滑动删除Item效果<br />
<br />
这里来给大家带来使用Scroller的小例子，同时也能用来帮助初步解除的读者更加熟悉的掌握Scroller的使用，掌握好了Scroll</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>使用Scroller实现绚丽的ListView左右滑动删除Item效果<br />
</strong>这里来给大家带来使用Scroller的小例子，同时也能用来帮助初步解除的读者更加熟悉的掌握Scroller的使用，掌握好了Scroller的使用我们就能实现很多滑动的效果。例如侧滑菜单，launcher，ListView的下拉刷新等等效果，我今天实现的是ListView的item的左右滑动删除item的效果，现在很多朋友看到这个效果应该是在Android的通知栏下拉中看到这个滑动删除的效果吧，我看到这个效果是在我之前的三星手机上左右滑动打电话发短信的效果，感觉很棒，不过现在很多手机联系人滑动都不是我之前那台手机的效果啦，网上很多朋友也写了关于滑动删除ListView的item的例子，有些是滑动手指离开之后然后给item加向左或者向右的移动动画，我觉得这样子的用户体验不是很好，所以今天自己也写了一个关于ListView左右滑动删除Item的小例子,ListView的item会随着手指在屏幕上的滑动而滑动，手指离开屏幕的时候item会根据判断向左或者向右划出屏幕，就是跟通知栏的效果差不多，接下来就带大家来实现这个效果。<br />
先说下实现该效果的主要思路<br />
先根据手指触摸的点来获取点击的是ListView的哪一个item<br />
手指在屏幕中滑动我们利用scrollBy()来使该item跟随手指一起滑动<br />
手指放开的时候，我们判断手指拖动的距离来判断item到底是滑出屏幕还是回到开始位置<br />
主要思路就是上面这三步，接下来我们就用代码来实现吧，首先我们新建一个项目，叫SlideCutListView<br />
根据需求我们需要自己自定义一个ListView来实现该功能，接下来先贴出代码再讲解具体的实现</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.example.slidecutlistview; 
 
import android.content.Context; 
import android.util.AttributeSet; 
import android.view.MotionEvent; 
import android.view.VelocityTracker; 
import android.view.View; 
import android.view.ViewConfiguration; 
import android.view.WindowManager; 
import android.widget.AdapterView; 
import android.widget.ListView; 
import android.widget.Scroller; 

public class SlideCutListView extends ListView { 
  /** 
   * 当前滑动的ListView　position 
   */ 
  private int slidePosition; 
  /** 
   * 手指按下X的坐标 
   */ 
  private int downY; 
  /** 
   * 手指按下Y的坐标 
   */ 
  private int downX; 
  /** 
   * 屏幕宽度 
   */ 
  private int screenWidth; 
  /** 
   * ListView的item 
   */ 
  private View itemView; 
  /** 
   * 滑动类 
   */ 
  private Scroller scroller; 
  private static final int SNAP_VELOCITY = 600; 
  /** 
   * 速度追踪对象 
   */ 
  private VelocityTracker velocityTracker; 
  /** 
   * 是否响应滑动，默认为不响应 
   */ 
  private boolean isSlide = false; 
  /** 
   * 认为是用户滑动的最小距离 
   */ 
  private int mTouchSlop; 
  /** 
   * 移除item后的回调接口 
   */ 
  private RemoveListener mRemoveListener; 
  /** 
   * 用来指示item滑出屏幕的方向,向左或者向右,用一个枚举值来标记 
   */ 
  private RemoveDirection removeDirection; 
 
  // 滑动删除方向的枚举值 
  public enum RemoveDirection { 
    RIGHT, LEFT; 
  } 
 
 
  public SlideCutListView(Context context) { 
    this(context, null); 
  } 
 
  public SlideCutListView(Context context, AttributeSet attrs) { 
    this(context, attrs, 0); 
  } 
 
  public SlideCutListView(Context context, AttributeSet attrs, int defStyle) { 
    super(context, attrs, defStyle); 
    screenWidth = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getWidth(); 
    scroller = new Scroller(context); 
    mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop(); 
  } 
   
  /** 
   * 设置滑动删除的回调接口 
   * @param removeListener 
   */ 
  public void setRemoveListener(RemoveListener removeListener) { 
    this.mRemoveListener = removeListener; 
  } 
 
  /** 
   * 分发事件，主要做的是判断点击的是那个item, 以及通过postDelayed来设置响应左右滑动事件 
   */ 
  @Override 
  public boolean dispatchTouchEvent(MotionEvent event) { 
    switch (event.getAction()) { 
    case MotionEvent.ACTION_DOWN: { 
      addVelocityTracker(event); 
 
      // 假如scroller滚动还没有结束，我们直接返回 
      if (!scroller.isFinished()) { 
        return super.dispatchTouchEvent(event); 
      } 
      downX = (int) event.getX(); 
      downY = (int) event.getY(); 
 
      slidePosition = pointToPosition(downX, downY); 
 
      // 无效的position, 不做任何处理 
      if (slidePosition == AdapterView.INVALID_POSITION) { 
        return super.dispatchTouchEvent(event); 
      } 
 
      // 获取我们点击的item view 
      itemView = getChildAt(slidePosition - getFirstVisiblePosition()); 
      break; 
    } 
    case MotionEvent.ACTION_MOVE: { 
      if (Math.abs(getScrollVelocity()) &gt; SNAP_VELOCITY 
          || (Math.abs(event.getX() - downX) &gt; mTouchSlop && Math 
              .abs(event.getY() - downY) &lt; mTouchSlop)) { 
        isSlide = true; 
         
      } 
      break; 
    } 
    case MotionEvent.ACTION_UP: 
      recycleVelocityTracker(); 
      break; 
    } 
 
    return super.dispatchTouchEvent(event); 
  } 
 
  /** 
   * 往右滑动，getScrollX()返回的是左边缘的距离，就是以View左边缘为原点到开始滑动的距离，所以向右边滑动为负值 
   */ 
  private void scrollRight() { 
    removeDirection = RemoveDirection.RIGHT; 
    final int delta = (screenWidth + itemView.getScrollX()); 
    // 调用startScroll方法来设置一些滚动的参数，我们在computeScroll()方法中调用scrollTo来滚动item 
    scroller.startScroll(itemView.getScrollX(), 0, -delta, 0, 
        Math.abs(delta)); 
    postInvalidate(); // 刷新itemView 
  } 
 
  /** 
   * 向左滑动，根据上面我们知道向左滑动为正值 
   */ 
  private void scrollLeft() { 
    removeDirection = RemoveDirection.LEFT; 
    final int delta = (screenWidth - itemView.getScrollX()); 
    // 调用startScroll方法来设置一些滚动的参数，我们在computeScroll()方法中调用scrollTo来滚动item 
    scroller.startScroll(itemView.getScrollX(), 0, delta, 0, 
        Math.abs(delta)); 
    postInvalidate(); // 刷新itemView 
  } 
 
  /** 
   * 根据手指滚动itemView的距离来判断是滚动到开始位置还是向左或者向右滚动 
   */ 
  private void scrollByDistanceX() { 
    // 如果向左滚动的距离大于屏幕的二分之一，就让其删除 
    if (itemView.getScrollX() &gt;= screenWidth / 2) { 
      scrollLeft(); 
    } else if (itemView.getScrollX() &lt;= -screenWidth / 2) { 
      scrollRight(); 
    } else { 
      // 滚回到原始位置,为了偷下懒这里是直接调用scrollTo滚动 
      itemView.scrollTo(0, 0); 
    } 
 
  } 
 
  /** 
   * 处理我们拖动ListView item的逻辑 
   */ 
  @Override 
  public boolean onTouchEvent(MotionEvent ev) { 
    if (isSlide && slidePosition != AdapterView.INVALID_POSITION) { 
      requestDisallowInterceptTouchEvent(true); 
      addVelocityTracker(ev); 
      final int action = ev.getAction(); 
      int x = (int) ev.getX(); 
      switch (action) { 
      case MotionEvent.ACTION_DOWN: 
        break; 
      case MotionEvent.ACTION_MOVE: 
         
        MotionEvent cancelEvent = MotionEvent.obtain(ev); 
        cancelEvent.setAction(MotionEvent.ACTION_CANCEL | 
              (ev.getActionIndex()&lt;&lt; MotionEvent.ACTION_POINTER_INDEX_SHIFT)); 
        onTouchEvent(cancelEvent); 
         
        int deltaX = downX - x; 
        downX = x; 
 
        // 手指拖动itemView滚动, deltaX大于0向左滚动，小于0向右滚 
        itemView.scrollBy(deltaX, 0); 
         
        return true; //拖动的时候ListView不滚动 
      case MotionEvent.ACTION_UP: 
        int velocityX = getScrollVelocity(); 
        if (velocityX &gt; SNAP_VELOCITY) { 
          scrollRight(); 
        } else if (velocityX &lt; -SNAP_VELOCITY) { 
          scrollLeft(); 
        } else { 
          scrollByDistanceX(); 
        } 
         
        recycleVelocityTracker(); 
        // 手指离开的时候就不响应左右滚动 
        isSlide = false; 
        break; 
      } 
    } 
 
    //否则直接交给ListView来处理onTouchEvent事件 
    return super.onTouchEvent(ev); 
  } 
 
  @Override 
  public void computeScroll() { 
    // 调用startScroll的时候scroller.computeScrollOffset()返回true， 
    if (scroller.computeScrollOffset()) { 
      // 让ListView item根据当前的滚动偏移量进行滚动 
      itemView.scrollTo(scroller.getCurrX(), scroller.getCurrY()); 
       
      postInvalidate(); 
 
      // 滚动动画结束的时候调用回调接口 
      if (scroller.isFinished()) { 
        if (mRemoveListener == null) { 
          throw new NullPointerException("RemoveListener is null, we should called setRemoveListener()"); 
        } 
         
        itemView.scrollTo(0, 0); 
        mRemoveListener.removeItem(removeDirection, slidePosition); 
      } 
    } 
  } 
 
  /** 
   * 添加用户的速度跟踪器 
   * 
   * @param event 
   */ 
  private void addVelocityTracker(MotionEvent event) { 
    if (velocityTracker == null) { 
      velocityTracker = VelocityTracker.obtain(); 
    } 
 
    velocityTracker.addMovement(event); 
  } 
 
  /** 
   * 移除用户速度跟踪器 
   */ 
  private void recycleVelocityTracker() { 
    if (velocityTracker != null) { 
      velocityTracker.recycle(); 
      velocityTracker = null; 
    } 
  } 
 
  /** 
   * 获取X方向的滑动速度,大于0向右滑动，反之向左 
   * 
   * @return 
   */ 
  private int getScrollVelocity() { 
    velocityTracker.computeCurrentVelocity(1000); 
    int velocity = (int) velocityTracker.getXVelocity(); 
    return velocity; 
  } 
 
  /** 
   * 
   * 当ListView item滑出屏幕，回调这个接口 
   * 我们需要在回调方法removeItem()中移除该Item,然后刷新ListView 
   * 
   * @author xiaanming 
   * 
   */ 
  public interface RemoveListener { 
    public void removeItem(RemoveDirection direction, int position); 
  } 
 
} 

</pre>
</div>
<p>首先我们重写dispatchTouchEvent（）方法，该方法是事件的分发方法，我们在里面只做了一些简单的步骤，我们按下屏幕的时候，如果某个item正在进行滚动，我们直接交给SlideCutListView的父类处理分发事件，否则根据点击的X,Y坐标利用pointToPosition(int x, int y)来获取点击的是ListView的哪一个position，从而获取到我们需要滑动的item的View，我们还在该方法加入了滑动速度的检测，并且在ACTION_MOVE的时候来判断是否响应item的左右移动，用isSlide来记录是否响应左右滑动<br />
然后就是重写onTouchEvent()方法，我们先判断isSlide为true,并且我们点击的是ListView上面的有效的position,否则直接交给SlideCutListView的父类也就是ListView来处理，在ACTION_MOVE中调用scrollBy()来移动item,scrollBy()是相对item的上一个位置进行移动的，所以我们每次都要用现在移动的距离减去上一个位置的距离然后赋给scrollBy()方法，这样子我们就实现了item的平滑移动，当我们将手指抬起的时候，我们先根据手指滑动的速度来确定是item是滑出屏幕还是滑动至原始位置，如果向右的速度大于我们设置的SNAP_VELOCITY，item就调用scrollRight()方法滚出屏幕，如果向左的速度小于-SNAP_VELOCITY，则调用scrollLeft()向左滚出屏幕，如果我们是缓慢的移动item，则调用scrollByDistanceX（）方法来判断是滚到那个位置<br />
在scrollRight()和scrollLeft()方法中我们使用Scroller类的startScroll()方法先设置滚动的参数，然后调用postInvalidate()来刷新界面，界面刷新就会调用computeScroll()方法，我们在里面处理滚动逻辑就行了，值得一提的是computeScroll()里面的这段代码</p>
<div class="phpstudycode">
<pre class="brush:java;">
itemView.scrollTo(0, 0); 
</pre>
</div>
<p>我们需要将该item滚动在（0, 0 ）这个点，因为我们只是将ListView的Item滚动出屏幕而已，并没有将该item移除，而且我们不能手动调用removeView()来从ListView中移除该item，我们只能通过改变ListView的数据，然后通过notifyDataSetChanged()来刷新ListView,所以我们需要将其滚动至(0, 0),这里比较关键。<br />
定义好了我们左右滑动的ListView,接下来就来使用它，布局很简单，一个RelativeLayout包裹我们自定义的ListView</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" 
  xmlns:tools="http://schemas.android.com/tools" 
  android:layout_width="match_parent" 
  android:layout_height="match_parent" 
  android:background="@android:color/darker_gray"&gt; 
 
  &lt;com.example.slidecutlistview.SlideCutListView 
    android:id="@+id/slideCutListView" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent"  
    android:listSelector="@android:color/transparent" 
    android:divider="@drawable/reader_item_divider" 
    android:cacheColorHint="@android:color/transparent"&gt; 
  &lt;/com.example.slidecutlistview.SlideCutListView&gt; 
 
&lt;/RelativeLayout&gt; 

</pre>
</div>
<p>接下来我们来看看ListView的item的布局</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8"&#63;&gt; 
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" 
  android:layout_width="fill_parent" 
  android:layout_height="wrap_content" &gt; 
 
  &lt;LinearLayout 
    android:layout_width="fill_parent" 
    android:layout_height="wrap_content" 
    android:background="@drawable/friendactivity_comment_detail_list2" &gt; 
 
    &lt;TextView 
      android:id="@+id/list_item" 
      android:layout_width="match_parent" 
      android:layout_height="wrap_content" 
      android:layout_margin="15dip" /&gt; 
  &lt;/LinearLayout&gt; 
 
&lt;/LinearLayout&gt; 
</pre>
</div>
<p>还记得我在上一篇文章中提到过调用scrollTo()方法是对里面的子View进行滚动的，而不是对整个布局进行滚动的，所以我们用LinearLayout来套住我们的item的布局，这点需要注意一下，不然滚动的只是TextView。<br />
主页面MainActivity里面的代码比较简单,里面使用的也是ArrayAdapter，相信大家都能看懂</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.example.slidecutlistview; 
 
import java.util.ArrayList; 
import java.util.List; 
 
import android.app.Activity; 
import android.os.Bundle; 
import android.view.View; 
import android.widget.AdapterView; 
import android.widget.AdapterView.OnItemClickListener; 
import android.widget.ArrayAdapter; 
import android.widget.Toast; 
 
import com.example.slidecutlistview.SlideCutListView.RemoveDirection; 
import com.example.slidecutlistview.SlideCutListView.RemoveListener; 
 
public class MainActivity extends Activity implements RemoveListener{ 
  private SlideCutListView slideCutListView ; 
  private ArrayAdapter&lt;String&gt; adapter; 
  private List&lt;String&gt; dataSourceList = new ArrayList&lt;String&gt;(); 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) { 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.activity_main); 
    init(); 
  } 
 
  private void init() { 
    slideCutListView = (SlideCutListView) findViewById(R.id.slideCutListView); 
    slideCutListView.setRemoveListener(this); 
     
    for(int i=0; i&lt;20; i++){ 
      dataSourceList.add("滑动删除" + i);  
    } 
     
    adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.listview_item, R.id.list_item, dataSourceList); 
    slideCutListView.setAdapter(adapter); 
     
    slideCutListView.setOnItemClickListener(new OnItemClickListener() { 
 
      @Override 
      public void onItemClick(AdapterView&lt;&#63;&gt; parent, View view, 
          int position, long id) { 
        Toast.makeText(MainActivity.this, dataSourceList.get(position), Toast.LENGTH_SHORT).show(); 
      } 
    }); 
  } 
 
   
  //滑动删除之后的回调方法 
  @Override 
  public void removeItem(RemoveDirection direction, int position) { 
    adapter.remove(adapter.getItem(position)); 
    switch (direction) { 
    case RIGHT: 
      Toast.makeText(this, "向右删除 "+ position, Toast.LENGTH_SHORT).show(); 
      break; 
    case LEFT: 
      Toast.makeText(this, "向左删除 "+ position, Toast.LENGTH_SHORT).show(); 
      break; 
 
    default: 
      break; 
    } 
     
  }   
 
 
} 
</pre>
</div>
<p>这里面需要对SlideCutListView设置RemoveListener，然后我们在回调方法removeItem(RemoveDirection direction, int position)中删除该position的数据，在调用notifyDataSetChanged()刷新ListView,我这里用的是ArrayAdatper,直接调用remove()就可以了。<br />
所有的代码就编写完了，我们来运行下程序看看效果吧<br />
</p>
<p></p>
<p></p>
<p><strong>使用NineOldAndroids实现绚丽的ListView左右滑动删除Item效果<br />
</strong>再给大家来一个ListView左右滑动删除Item效果的例子，上面使用的是滑动类Scroller来实现的，但是看了下通知栏的左右滑动删除效果，确实很棒，当我们滑动Item超过一半的时候，item的透明度就变成了0，我们就知道抬起手指的时候item就被删除了，当item的透明度不为0的时候，我们抬起手指Item会回到起始位置，这样我们就知道拖动到什么位置item会删除，什么位置Item不删除，用户体验更好了，还有一个效果，就是我们滑动删除了item的时候，ListView的其他item会出现向上或者向下滚动的效果，感觉效果很棒，所以在GitHub上面搜索了下，发现很多开源库都有这个效果，比如ListViewAnimations, android-swipelistview等等，我看了下实现原理，使用的是Jake Wharton的动画开源库NineOldAndroids，这个库究竟是干嘛的呢？在API3.0（Honeycomb）, SDK新增了一个android.animation包，里面的类是实现动画效果相关的类，通过Honeycomb API，能够实现非常复杂的动画效果，但是如果开发者想在3.0以下使用这一套API, 则需要使用开源框架Nine Old Androids，在这个库中会根据我们运行的机器判断其SDK版本，如果是API3.0以上则使用Android自带的动画类，否则就使用Nine Old Androids库中，这是一个兼容库，接下来我们就来看看这个效果的具体实现吧<br />
实现该效果的主要思路<br />
先根据手指触摸的点来获取点击的是ListView的哪一个Item<br />
当手指在屏幕上面滑动的时候，我们要使得Item跟随手指的滑动而滑动<br />
当我们抬起手指的时候，我们根据滑动的距离或者手指在屏幕上面的速度来判断Item是滑出屏幕还是滑动至其实位置<br />
Item滑出屏幕时，使ListView的其他item产生向上挤压或者向下挤压的效果<br />
大致的思路这是这四步，其中的一些细节接下来我会一一为大家解答的，接下来我们就用代码来实现这种效果吧<br />
首先我们新建一个工程，叫Swipedismisslistview,我们需要将Nine Old Androids这个库引入到工程，大家可以去https://github.com/JakeWharton/NineOldAndroids下载,可以使用Jar包，也可以使用工程库的形式引入到我们自己的工程，我们还需要自定义一个ListView，我们先看代码然后给大家讲解下具体的功能实现</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.example.swipedismisslistview; 
 
import static com.nineoldandroids.view.ViewHelper.setAlpha; 
import static com.nineoldandroids.view.ViewHelper.setTranslationX; 
import android.content.Context; 
import android.util.AttributeSet; 
import android.view.MotionEvent; 
import android.view.VelocityTracker; 
import android.view.View; 
import android.view.ViewConfiguration; 
import android.view.ViewGroup; 
import android.widget.AdapterView; 
import android.widget.ListView; 
 
import com.nineoldandroids.animation.Animator; 
import com.nineoldandroids.animation.AnimatorListenerAdapter; 
import com.nineoldandroids.animation.ValueAnimator; 
import com.nineoldandroids.view.ViewHelper; 
import com.nineoldandroids.view.ViewPropertyAnimator; 

public class SwipeDismissListView extends ListView { 
  /** 
   * 认为是用户滑动的最小距离 
   */ 
  private int mSlop; 
  /** 
   * 滑动的最小速度 
   */ 
  private int mMinFlingVelocity; 
  /** 
   * 滑动的最大速度 
   */ 
  private int mMaxFlingVelocity; 
  /** 
   * 执行动画的时间 
   */ 
  protected long mAnimationTime = 150; 
  /** 
   * 用来标记用户是否正在滑动中 
   */ 
  private boolean mSwiping; 
  /** 
   * 滑动速度检测类 
   */ 
  private VelocityTracker mVelocityTracker; 
  /** 
   * 手指按下的position 
   */ 
  private int mDownPosition; 
  /** 
   * 按下的item对应的View 
   */ 
  private View mDownView; 
  private float mDownX; 
  private float mDownY; 
  /** 
   * item的宽度 
   */ 
  private int mViewWidth; 
  /** 
   * 当ListView的Item滑出界面回调的接口 
   */ 
  private OnDismissCallback onDismissCallback; 
 
  /** 
   * 设置动画时间 
   * 
   * @param mAnimationTime 
   */ 
  public void setmAnimationTime(long mAnimationTime) { 
    this.mAnimationTime = mAnimationTime; 
  } 
 
  /** 
   * 设置删除回调接口 
   * 
   * @param onDismissCallback 
   */ 
  public void setOnDismissCallback(OnDismissCallback onDismissCallback) { 
    this.onDismissCallback = onDismissCallback; 
  } 
 
  public SwipeDismissListView(Context context) { 
    this(context, null); 
  } 
 
  public SwipeDismissListView(Context context, AttributeSet attrs) { 
    this(context, attrs, 0); 
  } 
 
  public SwipeDismissListView(Context context, AttributeSet attrs, 
      int defStyle) { 
    super(context, attrs, defStyle); 
 
    ViewConfiguration vc = ViewConfiguration.get(context); 
    mSlop = vc.getScaledTouchSlop(); 
    mMinFlingVelocity = vc.getScaledMinimumFlingVelocity() * 8; //获取滑动的最小速度 
    mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity(); //获取滑动的最大速度 
  } 
 
   
  @Override 
  public boolean onTouchEvent(MotionEvent ev) { 
    switch (ev.getAction()) { 
    case MotionEvent.ACTION_DOWN: 
      handleActionDown(ev); 
      break; 
    case MotionEvent.ACTION_MOVE: 
      return handleActionMove(ev); 
    case MotionEvent.ACTION_UP: 
      handleActionUp(ev); 
      break; 
    } 
    return super.onTouchEvent(ev); 
  } 
 
  /** 
   * 按下事件处理 
   * 
   * @param ev 
   * @return 
   */ 
  private void handleActionDown(MotionEvent ev) { 
    mDownX = ev.getX(); 
    mDownY = ev.getY(); 
     
    mDownPosition = pointToPosition((int) mDownX, (int) mDownY); 
 
    if (mDownPosition == AdapterView.INVALID_POSITION) { 
      return; 
    } 
 
    mDownView = getChildAt(mDownPosition - getFirstVisiblePosition()); 
 
    if (mDownView != null) { 
      mViewWidth = mDownView.getWidth(); 
    } 
 
    //加入速度检测 
    mVelocityTracker = VelocityTracker.obtain(); 
    mVelocityTracker.addMovement(ev); 
  } 
   
 
  /** 
   * 处理手指滑动的方法 
   * 
   * @param ev 
   * @return 
   */ 
  private boolean handleActionMove(MotionEvent ev) { 
    if (mVelocityTracker == null || mDownView == null) { 
      return super.onTouchEvent(ev); 
    } 
 
    // 获取X方向滑动的距离 
    float deltaX = ev.getX() - mDownX; 
    float deltaY = ev.getY() - mDownY; 
 
    // X方向滑动的距离大于mSlop并且Y方向滑动的距离小于mSlop，表示可以滑动 
    if (Math.abs(deltaX) &gt; mSlop && Math.abs(deltaY) &lt; mSlop) { 
      mSwiping = true; 
       
      //当手指滑动item,取消item的点击事件，不然我们滑动Item也伴随着item点击事件的发生 
      MotionEvent cancelEvent = MotionEvent.obtain(ev); 
      cancelEvent.setAction(MotionEvent.ACTION_CANCEL | 
            (ev.getActionIndex()&lt;&lt; MotionEvent.ACTION_POINTER_INDEX_SHIFT)); 
      onTouchEvent(cancelEvent); 
    } 
 
    if (mSwiping) { 
      // 跟谁手指移动item 
      ViewHelper.setTranslationX(mDownView, deltaX); 
      // 透明度渐变 
      ViewHelper.setAlpha(mDownView, Math.max(0f, Math.min(1f, 1f - 2f * Math.abs(deltaX)/ mViewWidth))); 
 
      // 手指滑动的时候,返回true，表示SwipeDismissListView自己处理onTouchEvent,其他的就交给父类来处理 
      return true; 
    } 
 
    return super.onTouchEvent(ev); 
 
  } 
 
  /** 
   * 手指抬起的事件处理 
   * @param ev 
   */ 
  private void handleActionUp(MotionEvent ev) { 
    if (mVelocityTracker == null || mDownView == null|| !mSwiping) { 
      return; 
    } 
 
    float deltaX = ev.getX() - mDownX; 
     
    //通过滑动的距离计算出X,Y方向的速度 
    mVelocityTracker.computeCurrentVelocity(1000); 
    float velocityX = Math.abs(mVelocityTracker.getXVelocity()); 
    float velocityY = Math.abs(mVelocityTracker.getYVelocity()); 
     
    boolean dismiss = false; //item是否要滑出屏幕 
    boolean dismissRight = false;//是否往右边删除 
     
    //当拖动item的距离大于item的一半，item滑出屏幕 
    if (Math.abs(deltaX) &gt; mViewWidth / 2) { 
      dismiss = true; 
      dismissRight = deltaX &gt; 0; 
       
      //手指在屏幕滑动的速度在某个范围内，也使得item滑出屏幕 
    } else if (mMinFlingVelocity &lt;= velocityX 
        && velocityX &lt;= mMaxFlingVelocity && velocityY &lt; velocityX) { 
      dismiss = true; 
      dismissRight = mVelocityTracker.getXVelocity() &gt; 0; 
    } 
 
    if (dismiss) { 
      ViewPropertyAnimator.animate(mDownView) 
          .translationX(dismissRight &#63; mViewWidth : -mViewWidth)//X轴方向的移动距离 
          .alpha(0) 
          .setDuration(mAnimationTime) 
          .setListener(new AnimatorListenerAdapter() { 
            @Override 
            public void onAnimationEnd(Animator animation) { 
              //Item滑出界面之后执行删除 
              performDismiss(mDownView, mDownPosition); 
            } 
          }); 
    } else { 
      //将item滑动至开始位置 
      ViewPropertyAnimator.animate(mDownView) 
      .translationX(0) 
      .alpha(1)   
      .setDuration(mAnimationTime).setListener(null); 
    } 
     
    //移除速度检测 
    if(mVelocityTracker != null){ 
      mVelocityTracker.recycle(); 
      mVelocityTracker = null; 
    } 
     
    mSwiping = false; 
  } 
   
 
   
  /** 
   * 在此方法中执行item删除之后，其他的item向上或者向下滚动的动画，并且将position回调到方法onDismiss()中 
   * @param dismissView 
   * @param dismissPosition 
   */ 
  private void performDismiss(final View dismissView, final int dismissPosition) { 
    final ViewGroup.LayoutParams lp = dismissView.getLayoutParams();//获取item的布局参数 
    final int originalHeight = dismissView.getHeight();//item的高度 
 
    ValueAnimator animator = ValueAnimator.ofInt(originalHeight, 0).setDuration(mAnimationTime); 
    animator.start(); 
 
    animator.addListener(new AnimatorListenerAdapter() { 
      @Override 
      public void onAnimationEnd(Animator animation) { 
        if (onDismissCallback != null) { 
          onDismissCallback.onDismiss(dismissPosition); 
        } 
 
        //这段代码很重要，因为我们并没有将item从ListView中移除，而是将item的高度设置为0 
        //所以我们在动画执行完毕之后将item设置回来 
        ViewHelper.setAlpha(dismissView, 1f); 
        ViewHelper.setTranslationX(dismissView, 0); 
        ViewGroup.LayoutParams lp = dismissView.getLayoutParams(); 
        lp.height = originalHeight; 
        dismissView.setLayoutParams(lp); 
 
      } 
    }); 
 
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { 
      @Override 
      public void onAnimationUpdate(ValueAnimator valueAnimator) { 
        //这段代码的效果是ListView删除某item之后，其他的item向上滑动的效果 
        lp.height = (Integer) valueAnimator.getAnimatedValue(); 
        dismissView.setLayoutParams(lp); 
      } 
    }); 
 
  } 
 
  /** 
   * 删除的回调接口 
   * 
   * @author xiaanming 
   * 
   */ 
  public interface OnDismissCallback { 
    public void onDismiss(int dismissPosition); 
  } 
 
} 

</pre>
</div>
<p>看过Android 使用Scroller实现绚丽的ListView左右滑动删除Item效果你会发现，这个自定义的SwipeDismissListView只重写了onTouchEvent()方法，其实我们重写这一个方法就能实现我们需要的效果<br />
1. 我们先看手指按下屏幕的处理方法handleActionDown();该方法里面根据我们手指按下的点根据pointToPosition()方法来获取我们点击的position,然后利用getChildAt()来获取我们按下的item的View对象，并且加入手指在屏幕滑动的速度检查，这一步相对来说还是比较简单</p>
<p>2. 接下来就是手指在屏幕上面滑动的处理方法handleActionMove(),这个方法就稍微的复杂些，我们需要根据手指在X轴的滑动距离和Y轴的滑动距离来判断是ListView item的水平滑动还是ListView的上下滑动，当满足Math.abs(deltaX) &gt; mSlop && Math.abs(deltaY) &lt; mSlop这个条件时候，我们用一个布尔值mSwiping来标记Item现在处于水平滑动的状态，这时候我们需要处理Item跟随手指的滑动而滑动的逻辑，我们使用ViewHelper来处理Item的滑动逻辑，这个类会根据机器的SDK版本来判断使用Android系统的API还是NineOldandroids中自己实现的API使得View滑动的效果，NineOldandroids中主要使用Camera（可以实现各种复杂动画效果的类），我们直接使用ViewHelper的setTranslationX()和setAlpha()就实现了item滑动和透明度渐变的效果，为了使得我们在滑动item的时候，ListView不上下滚动，我们必须返回true来屏蔽ListView的上下滚动，这里需要我们要非常熟悉Android的事件分发机制，这里我就不说明了，大家不了解的去网上找找相关的文章看看<br />
还有一个问题，就是当我们滑动ListView的item的时候，会伴随着item的点击事件，这不是我们想要的效果，所以当Item滑动的时候我们需要取消ListView Item的点击事件</p>
<p>3. 在看手指抬起的时候的处理方法handleActionUp(),这里面需要根据手指的滑动速度或者Item移动的距离来判断Item是滑出屏幕还是滑动至起始位置，并且要判断item向左还是向右滑出屏幕等等逻辑，具体的逻辑可以看代码，相信大家都看得懂.<br />
我这里要说说ViewPropertyAnimator类,这个类能更好的实现一个View同时进行多个动画的功能，当然我们也可以使用ObjectAnimator利用AnimatorSet来实现一个View上的多个同时进行的动画效果，例如我们可以将</p>
<div class="phpstudycode">
<pre class="brush:java;">
ViewPropertyAnimator.animate(mDownView) 
    .translationX(dismissRight &#63; mViewWidth : -mViewWidth)//X轴方向的移动距离 
    .alpha(0) 
    .setDuration(mAnimationTime) 
    .setListener(new AnimatorListenerAdapter() { 
      @Override 
      public void onAnimationEnd(Animator animation) { 
        //Item滑出界面之后执行删除 
        performDismiss(mDownView, mDownPosition); 
      } 
    }); 
</pre>
</div>
<p>替换成</p>
<div class="phpstudycode">
<pre class="brush:java;">
AnimatorSet set = new AnimatorSet(); 
      set.playTogether(ObjectAnimator.ofFloat(mDownView, "translationX", dismissRight &#63; mViewWidth : -mViewWidth),  
              ObjectAnimator.ofFloat(mDownView, "alpha", 0)); 
      set.setDuration(mAnimationTime).start(); 
      set.addListener(new AnimatorListenerAdapter() { 
            @Override 
            public void onAnimationEnd(Animator animation) { 
              //Item滑出界面之后执行删除 
              performDismiss(mDownView, mDownPosition); 
            } 
          }); 
</pre>
</div>
<p>在效果上面是一样的，但是ViewPropertyAnimator在性能上要比使用ObjectAnimator来实现多个同时进行的动画要高的多，举个例子，假如要对View使用移动和透明度的动画，使用ViewPropertyAnimator的话，某个时间点上我们只需要调用一次invalidate()方法刷新界面就行了，而使用ObjectAnimator的话，移动的动画需要调用invalidate(),透明度的动画也需要调用invalidate()方法，在性能上使用AnimationSet比ViewPropertyAnimator要低，但是有的时候我们还是需要使用ObjectAnimator，比如，在某个时间内，我们需要将View先变大在变小在变大等复杂情况，这时候ObjectAnimator就派上用场了，例如</p>
<p>ObjectAnimator.ofInt(mDownView, "scaleX", 0 ,100 ,0, 100).setDuration(100).start()&nbsp; <br />
通过上面的几步我们就实现了ListView的左右滑动删除item的效果啦，但是还有一个效果，item删除之后，ListView的其他item向上或者向下缓缓滑动的效果，实现这个也很容易，就是动态设置item的高度，item高度逐渐变小，这样其他的item就会出现向上或者向下挤压的效果啦!</p>
<p>4. 这里我们使用的是ValueAnimator这个类，这个类并不是针对View作用的动画，而是对某个值作用的动画，他默认使用的Interpolator(插补器)是AccelerateDecelerateInterpolator(开始和结束的时候慢，中间快) ， 举个很简单的例子，我们在10秒内使用ValueAnimator将某个值从0变化到100，如果使用LinearInterpolator（线性插补器，匀速变化）在第2秒的时候，这个值变成了20，而是用AccelerateDecelerateInterpolator，可能在第二秒的时候这个值为15或者13，所以我们在ValueAnimator变化的时候设置值动画变化的监听器AnimatorUpdateListener就知道某个时间这个值变成了多少，从而对View的某个属性进行设置（例如大小），所以ValueAnimator是间接的对View设置动画的<br />
了解了ValueAnimator的使用原理，我们就可以现实上面的动画效果了，我们使用ValueAnimator将item的高度变成0,设置ValueAnimator变化的监听，我们在回调函数onAnimationUpdate()中动态的设置item的高度， 然后添加AnimatorListener监听动画的状态（例如动画开始，结束，重复等）监听，在动画结束的回调函数onAnimationEnd()中删除该item的数据，调用notifyDataSetChanged刷新ListView,看看下面这段代码</p>
<div class="phpstudycode">
<pre class="brush:java;">
ViewHelper.setAlpha(dismissView, 1f); 
        ViewHelper.setTranslationX(dismissView, 0); 
        ViewGroup.LayoutParams lp = dismissView.getLayoutParams(); 
        lp.height = originalHeight; 
        dismissView.setLayoutParams(lp); 
</pre>
</div>
<p>我们使用动画只是将item移动出了屏幕，并且将item的高度设置为了0，并没有将item的View从ListView中Remove掉，况且ListView也不能直接Remove掉Item的，只能将数据源删除，在调用notifyDataSetChanged()刷新，所以我们需要将刚刚滑出屏幕高度设置为0的Item恢复回来</p>
<p>自定义控件的代码我们已经编写完了，接下来我们就要使用它了，先看界面的布局代码</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"  
  xmlns:tools="http://schemas.android.com/tools"  
  android:layout_width="match_parent"  
  android:layout_height="match_parent"&gt;  
  
  &lt;com.example.swipedismisslistview.SwipeDismissListView 
    android:id="@+id/swipeDismissListView"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent"  
    android:listSelector="@android:color/transparent" 
    android:cacheColorHint="@android:color/transparent"&gt;  
  &lt;/com.example.swipedismisslistview.SwipeDismissListView&gt; 
  
&lt;/RelativeLayout&gt;  
</pre>
</div>
<p>很简单，一个RelativeLayout包裹我们自定义的ListView控件，接下来就是主界面的代码编写，跟平常的ListView使用一样，但是我们需要设置OnDismissCallback()监听，在<br />
onDismiss()中删除该位置对于的数据，刷新ListView</p>
<div class="phpstudycode">
<pre class="brush:java;">
package com.example.swipedismisslistview; 
 
import java.util.ArrayList; 
import java.util.List; 
 
import android.app.Activity; 
import android.os.Bundle; 
import android.view.View; 
import android.widget.AdapterView; 
import android.widget.AdapterView.OnItemClickListener; 
import android.widget.ArrayAdapter; 
import android.widget.Toast; 
 
import com.example.swipedismisslistview.SwipeDismissListView.OnDismissCallback; 
 
public class SwipeActivity extends Activity { 
  private SwipeDismissListView swipeDismissListView; 
  private ArrayAdapter&lt;String&gt; adapter; 
  private List&lt;String&gt; dataSourceList = new ArrayList&lt;String&gt;(); 
 
  @Override 
  protected void onCreate(Bundle savedInstanceState) { 
    super.onCreate(savedInstanceState); 
    setContentView(R.layout.activity_swipe); 
    init(); 
  } 
 
  private void init() { 
    swipeDismissListView = (SwipeDismissListView) findViewById(R.id.swipeDismissListView); 
    for (int i = 0; i &lt; 20; i++) { 
      dataSourceList.add("滑动删除" + i); 
    } 
 
    adapter = new ArrayAdapter&lt;String&gt;(this, 
        android.R.layout.simple_list_item_1, 
        android.R.id.text1, dataSourceList); 
     
    swipeDismissListView.setAdapter(adapter); 
     
    swipeDismissListView.setOnDismissCallback(new OnDismissCallback() { 
       
      @Override 
      public void onDismiss(int dismissPosition) { 
         adapter.remove(adapter.getItem(dismissPosition));  
      } 
    }); 
     
     
    swipeDismissListView.setOnItemClickListener(new OnItemClickListener() { 
 
      @Override 
      public void onItemClick(AdapterView&lt;&#63;&gt; parent, View view, 
          int position, long id) { 
        Toast.makeText(SwipeActivity.this, adapter.getItem(position), Toast.LENGTH_SHORT).show(); 
      } 
    }); 
 
  } 
 
} 
</pre>
</div>
<p>所有的代码都已经编写完毕了，接下来就是运行工程，看看具体的效果是不是我们想要的<br />
</p>
<p></p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/83952.html'>高性能PHP框架Symfony2经典入门教程</a><a>下一篇</a><a href='/php/biji/83954.html'>JSP中使用JSTL按不同条件输出内容的方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>