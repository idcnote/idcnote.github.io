<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>node.js入门教程迷你书、node.js入门web应用开发完全示例_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="本书状态<br />
你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。<br />
本书中的代码案例都在Node.js 0.6.11版本" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">node.js入门教程迷你书、node.js入门web应用开发完全示例</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>本书状态<br />
你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。<br />
本书中的代码案例都在Node.js 0.6.11版本</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P><STRONG>本书状态</STRONG></P>
<P>你正在阅读的已经是本书的最终版。因此，只有当进行错误更正以及针对新版本Node.js的改动进行对应的修正时，才会进行更新。</P>
<P>本书中的代码案例都在Node.js 0.6.11版本中测试过，可以正确工作。</P>
<P><STRONG>读者对象</STRONG></P>
<P>本书最适合与我有相似技术背景的读者： 至少对一门诸如Ruby、Python、PHP或者Java这样面向对象的语言有一定的经验；对JavaScript处于初学阶段，并且完全是一个Node.js的新手。</P>
<P>这里指的适合对其他编程语言有一定经验的开发者，意思是说，本书不会对诸如数据类型、变量、控制结构等等之类非常基础的概念作介绍。要读懂本书，这些基础的概念我都默认你已经会了。</P>
<P>然而，本书还是会对JavaScript中的函数和对象作详细介绍，因为它们与其他同类编程语言中的函数和对象有很大的不同。</P>
<P><STRONG>本书结构</STRONG></P>
<P>读完本书之后，你将完成一个完整的web应用，该应用允许用户浏览页面以及上传文件。</P>
<P>当然了，应用本身并没有什么了不起的，相比为了实现该功能书写的代码本身，我们更关注的是如何创建一个框架来对我们应用的不同模块进行干净地剥离。 是不是很玄乎？稍后你就明白了。</P>
<P>本书先从介绍在Node.js环境中进行JavaScript开发和在浏览器环境中进行JavaScript开发的差异开始。</P>
<P>紧接着，会带领大家完成一个最传统的“Hello World”应用，这也是最基础的Node.js应用。</P>
<P>最后，会和大家讨论如何设计一个“真正”完整的应用，剖析要完成该应用需要实现的不同模块，并一步一步介绍如何来实现这些模块。</P>
<P>可以确保的是，在这过程中，大家会学到JavaScript中一些高级的概念、如何使用它们以及为什么使用这些概念就可以实现而其他编程语言中同类的概念就无法实现。</P>
<P>该应用所有的源代码都可以通过 本书Github代码仓库:https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application.</P>
<P><STRONG>JavaScript与Node.js</STRONG></P>
<P><STRONG>JavaScript与你</STRONG></P>
<P>抛开技术，我们先来聊聊你以及你和JavaScript的关系。本章的主要目的是想让你看看，对你而言是否有必要继续阅读后续章节的内容。</P>
<P>如果你和我一样，那么你很早就开始利用HTML进行“开发”，正因如此，你接触到了这个叫JavaScript有趣的东西，而对于JavaScript，你只会基本的操作——为web页面添加交互。</P>
<P>而你真正想要的是“干货”，你想要知道如何构建复杂的web站点 —— 于是，你学习了一种诸如PHP、Ruby、Java这样的编程语言，并开始书写“后端”代码。</P>
<P>与此同时，你还始终关注着JavaScript，随着通过一些对jQuery，Prototype之类技术的介绍，你慢慢了解到了很多JavaScript中的进阶技能，同时也感受到了JavaScript绝非仅仅是window.open() 那么简单。 .</P>
<P>不过，这些毕竟都是前端技术，尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。</P>
<P>然后，出现了Node.js，服务端的JavaScript，这有多酷啊？</P>
<P>于是，你觉得是时候该重新拾起既熟悉又陌生的JavaScript了。但是别急，写Node.js应用是一件事情；理解为什么它们要以它们书写的这种方式来书写则意味着——你要懂JavaScript。这次是玩真的了。</P>
<P>问题来了： 由于JavaScript真正意义上以两种，甚至可以说是三种形态存在（从中世纪90年代的作为对DHTML进行增强的小玩具，到像jQuery那样严格意义上的前端技术，一直到现在的服务端技术），因此，很难找到一个“正确”的方式来学习JavaScript，使得让你书写Node.js应用的时候感觉自己是在真正开发它而不仅仅是使用它。</P>
<P>因为这就是关键： 你本身已经是个有经验的开发者，你不想通过到处寻找各种解决方案（其中可能还有不正确的）来学习新的技术，你要确保自己是通过正确的方式来学习这项技术。</P>
<P>当然了，外面不乏很优秀的学习JavaScript的文章。但是，有的时候光靠那些文章是远远不够的。你需要的是指导。</P>
<P>本书的目标就是给你提供指导。</P>
<P><STRONG>简短申明</STRONG></P>
<P>业界有非常优秀的JavaScript程序员。而我并非其中一员。</P>
<P>我就是上一节中描述的那个我。我熟悉如何开发后端web应用，但是对“真正”的JavaScript以及Node.js，我都只是新手。我也只是最近学习了一些JavaScript的高级概念，并没有实践经验。</P>
<P>因此，本书并不是一本“从入门到精通”的书，更像是一本“从初级入门到高级入门”的书。</P>
<P>如果成功的话，那么本书就是我当初开始学习Node.js最希望拥有的教程。</P>
<P><STRONG>服务端JavaScript</STRONG></P>
<P>JavaScript最早是运行在浏览器中，然而浏览器只是提供了一个上下文，它定义了使用JavaScript可以做什么，但并没有“说”太多关于JavaScript语言本身可以做什么。事实上，JavaScript是一门“完整”的语言： 它可以使用在不同的上下文中，其能力与其他同类语言相比有过之而无不及。</P>
<P>Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。</P>
<P>要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。</P>
<P>除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。</P>
<P>因此，Node.js事实上既是一个运行时环境，同时又是一个库。</P>
<P>要使用Node.js,首先需要进行安装。关于如何安装Node.js，这里就不赘述了，可以直接参考官方的安装指南。安装完成后，继续回来阅读本书下面的内容。</P>
<P>“Hello World”</P>
<P>好了，“废话”不多说了，马上开始我们第一个Node.js应用：“Hello World”。</P>
<P>打开你最喜欢的编辑器，创建一个helloworld.js文件。我们要做就是向STDOUT输出“Hello World”，如下是实现该功能的代码：</P>
<P><div class="codetitle"><span>http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。</P>
<P><STRONG>更有用的场景</STRONG></P>
<P>到目前为止，我们做的已经很好了，但是，我们的应用没有实际用途。</P>
<P>服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。</P>
<P>好，下面就一步步来实现，鉴于此前已经对JavaScript原理性技术性的内容做过大量介绍了，这次我们加快点速度。</P>
<P>要实现该功能，分为如下两步： 首先，让我们来看看如何处理POST请求（非文件上传），之后，我们使用Node.js的一个用于文件上传的外部模块。之所以采用这种实现方式有两个理由。</P>
<P>第一，尽管在Node.js中处理基础的POST请求相对比较简单，但在这过程中还是能学到很多。 <BR>第二，用Node.js来处理文件上传（multipart POST请求）是比较复杂的，它不在本书的范畴，但，如何使用外部模块却是在本书涉猎内容之内。</P>
<P><STRONG>处理POST请求</STRONG></P>
<P>考虑这样一个简单的例子：我们显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。</P>
<P>/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：</P>
<P>function start(response) {<BR>&nbsp; console.log("Request handler 'start' was called.");</P>
<P>&nbsp; var body = '&lt;html&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;meta http-equiv="Content-Type" content="text/html; '+<BR>&nbsp;&nbsp;&nbsp; 'charset=UTF-8" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Submit text" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/html&gt;';</P>
<P>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write(body);<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>}</P>
<P>function upload(response) {<BR>&nbsp; console.log("Request handler 'upload' was called.");<BR>&nbsp; response.writeHead(200, {"Content-Type": "text/plain"});<BR>&nbsp; response.write("Hello Upload");<BR>&nbsp; response.end();<BR>}</P>
<P>exports.start = start;<BR>exports.upload = upload;<BR>好了，现在我们的应用已经很完善了，都可以获得威比奖（Webby Awards）了，哈哈。（译者注：威比奖是由国际数字艺术与科学学院主办的评选全球最佳网站的奖项，具体参见详细说明）通过在浏览器中访问http://localhost:8888/start就可以看到简单的表单了，要记得重启服务器哦！</P>
<P>你可能会说：这种直接将视觉元素放在请求处理程序中的方式太丑陋了。说的没错，但是，我并不想在本书中介绍诸如MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。</P>
<P>余下的篇幅，我们来探讨一个更有趣的问题： 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。</P>
<P>现在，我们已经是新手中的专家了，很自然会想到采用异步回调来实现非阻塞地处理POST请求的数据。</P>
<P>这里采用非阻塞方式处理是明智的，因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。</P>
<P>为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。</P>
<P>我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。<BR>如下所示：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="19728" class="copybut" id="copybut19728" onclick="doCopy('code19728')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code19728"><BR>request.addListener("data", function(chunk) {<BR>&nbsp; // called when a new chunk of data was received<BR>});</P>
<P>request.addListener("end", function() {<BR>&nbsp; // called when all chunks of data have been received<BR>});</div><BR>问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。</P>
<P>在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。</P>
<P>因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。</P>
<P>还等什么，马上来实现。先从server.js开始：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="22527" class="copybut" id="copybut22527" onclick="doCopy('code22527')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code22527"><BR>var http = require("http");<BR>var url = require("url");</P>
<P>function start(route, handle) {<BR>&nbsp; function onRequest(request, response) {<BR>&nbsp;&nbsp;&nbsp; var postData = "";<BR>&nbsp;&nbsp;&nbsp; var pathname = url.parse(request.url).pathname;<BR>&nbsp;&nbsp;&nbsp; console.log("Request for " + pathname + " received.");</P>
<P>&nbsp;&nbsp;&nbsp; request.setEncoding("utf8");</P>
<P>&nbsp;&nbsp;&nbsp; request.addListener("data", function(postDataChunk) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postData += postDataChunk;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log("Received POST data chunk '"+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; postDataChunk + "'.");<BR>&nbsp;&nbsp;&nbsp; });</P>
<P>&nbsp;&nbsp;&nbsp; request.addListener("end", function() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; route(handle, pathname, response, postData);<BR>&nbsp;&nbsp;&nbsp; });</P>
<P>&nbsp; }</P>
<P>&nbsp; http.createServer(onRequest).listen(8888);<BR>&nbsp; console.log("Server has started.");<BR>}</P>
<P>exports.start = start;</div><BR>上述代码做了三件事情： 首先，我们设置了接收数据的编码格式为UTF-8，然后注册了“data”事件的监听器，用于收集每次接收到的新数据块，并将其赋值给postData 变量，最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。</P>
<P>上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。</P>
<P>我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。</P>
<P>再来点酷的。我们接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="40686" class="copybut" id="copybut40686" onclick="doCopy('code40686')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code40686"><BR>function route(handle, pathname, response, postData) {<BR>&nbsp; console.log("About to route a request for " + pathname);<BR>&nbsp; if (typeof handle[pathname] === 'function') {<BR>&nbsp;&nbsp;&nbsp; handle[pathname](response, postData);<BR>&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp; console.log("No request handler found for " + pathname);<BR>&nbsp;&nbsp;&nbsp; response.writeHead(404, {"Content-Type": "text/plain"});<BR>&nbsp;&nbsp;&nbsp; response.write("404 Not found");<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp; }<BR>}</P>
<P>exports.route = route;</div><BR>然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="59653" class="copybut" id="copybut59653" onclick="doCopy('code59653')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code59653"><BR>function start(response, postData) {<BR>&nbsp; console.log("Request handler 'start' was called.");</P>
<P>&nbsp; var body = '&lt;html&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;meta http-equiv="Content-Type" content="text/html; '+<BR>&nbsp;&nbsp;&nbsp; 'charset=UTF-8" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Submit text" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/html&gt;';</P>
<P>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write(body);<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>}</P>
<P>function upload(response, postData) {<BR>&nbsp; console.log("Request handler 'upload' was called.");<BR>&nbsp; response.writeHead(200, {"Content-Type": "text/plain"});<BR>&nbsp; response.write("You've sent: " + postData);<BR>&nbsp; response.end();<BR>}</P>
<P>exports.start = start;<BR>exports.upload = upload;</div><BR>好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。</P>
<P>我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。</P>
<P>我们可以使用此前介绍过的querystring模块来实现：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="49635" class="copybut" id="copybut49635" onclick="doCopy('code49635')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49635"><BR>var querystring = require("querystring");</P>
<P>function start(response, postData) {<BR>&nbsp; console.log("Request handler 'start' was called.");</P>
<P>&nbsp; var body = '&lt;html&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;meta http-equiv="Content-Type" content="text/html; '+<BR>&nbsp;&nbsp;&nbsp; 'charset=UTF-8" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Submit text" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/html&gt;';</P>
<P>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write(body);<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>}</P>
<P>function upload(response, postData) {<BR>&nbsp; console.log("Request handler 'upload' was called.");<BR>&nbsp; response.writeHead(200, {"Content-Type": "text/plain"});<BR>&nbsp; response.write("You've sent the text: "+<BR>&nbsp; querystring.parse(postData).text);<BR>&nbsp; response.end();<BR>}</P>
<P>exports.start = start;<BR>exports.upload = upload;</div><BR>好了，以上就是关于处理POST数据的全部内容。</P>
<P><STRONG>处理文件上传</STRONG></P>
<P>最后，我们来实现我们最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。</P>
<P>回到90年代，这个用例完全可以满足用于IPO的商业模型了，如今，我们通过它能学到这样两件事情： 如何安装外部Node.js模块，以及如何将它们应用到我们的应用中。</P>
<P>这里我们要用到的外部模块是Felix Geisend&ouml;rfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。</P>
<P>使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="6246" class="copybut" id="copybut6246" onclick="doCopy('code6246')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code6246"><BR>npm install formidable</div><BR>如果终端输出如下内容：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="36413" class="copybut" id="copybut36413" onclick="doCopy('code36413')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code36413"><BR>npm info build Success: formidable@1.0.9<BR>npm ok</div><BR>就说明模块已经安装成功了。</P>
<P>现在我们就可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="72471" class="copybut" id="copybut72471" onclick="doCopy('code72471')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code72471"><BR>var formidable = require("formidable");</div><BR>这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。</P>
<P>node-formidable官方的例子展示了这两部分是如何融合在一起工作的：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="11182" class="copybut" id="copybut11182" onclick="doCopy('code11182')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code11182"><BR>var formidable = require('formidable'),<BR>&nbsp;&nbsp;&nbsp; http = require('http'),<BR>&nbsp;&nbsp;&nbsp; sys = require('sys');</P>
<P>http.createServer(function(req, res) {<BR>&nbsp; if (req.url == '/upload' && req.method.toLowerCase() == 'post') {<BR>&nbsp;&nbsp;&nbsp; // parse a file upload<BR>&nbsp;&nbsp;&nbsp; var form = new formidable.IncomingForm();<BR>&nbsp;&nbsp;&nbsp; form.parse(req, function(err, fields, files) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.writeHead(200, {'content-type': 'text/plain'});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.write('received upload:\n\n');<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; res.end(sys.inspect({fields: fields, files: files}));<BR>&nbsp;&nbsp;&nbsp; });<BR>&nbsp;&nbsp;&nbsp; return;<BR>&nbsp; }</P>
<P>&nbsp; // show a file upload form<BR>&nbsp; res.writeHead(200, {'content-type': 'text/html'});<BR>&nbsp; res.end(<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" enctype="multipart/form-data" '+<BR>&nbsp;&nbsp;&nbsp; 'method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="text" name="title"&gt;&lt;br&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="file" name="upload" multiple="multiple"&gt;&lt;br&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Upload"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'<BR>&nbsp; );<BR>}).listen(8888);</div><BR>如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="48163" class="copybut" id="copybut48163" onclick="doCopy('code48163')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code48163"><BR>received upload:</P>
<P>{ fields: { title: 'Hello World' },<BR>&nbsp; files:<BR>&nbsp;&nbsp; { upload:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { size: 1558,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path: '/tmp/1c747974a27a6292743669e91f29350b',<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name: 'us-flag.png',<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type: 'image/png',<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _writeStream: [Object],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length: [Getter],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filename: [Getter],<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mime: [Getter] } } }</div><BR>为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。</P>
<P>我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？</P>
<P>显然，我们需要将该文件读取到我们的服务器中，使用一个叫fs的模块。</P>
<P>我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。</P>
<P>将requestHandlers.js修改为如下形式：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="37222" class="copybut" id="copybut37222" onclick="doCopy('code37222')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code37222"><BR>var querystring = require("querystring"),<BR>&nbsp;&nbsp;&nbsp; fs = require("fs");</P>
<P>function start(response, postData) {<BR>&nbsp; console.log("Request handler 'start' was called.");</P>
<P>&nbsp; var body = '&lt;html&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;meta http-equiv="Content-Type" '+<BR>&nbsp;&nbsp;&nbsp; 'content="text/html; charset=UTF-8" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Submit text" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/html&gt;';</P>
<P>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write(body);<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>}</P>
<P>function upload(response, postData) {<BR>&nbsp; console.log("Request handler 'upload' was called.");<BR>&nbsp; response.writeHead(200, {"Content-Type": "text/plain"});<BR>&nbsp; response.write("You've sent the text: "+<BR>&nbsp; querystring.parse(postData).text);<BR>&nbsp; response.end();<BR>}</P>
<P>function show(response, postData) {<BR>&nbsp; console.log("Request handler 'show' was called.");<BR>&nbsp; fs.readFile("/tmp/test.png", "binary", function(error, file) {<BR>&nbsp;&nbsp;&nbsp; if(error) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.writeHead(500, {"Content-Type": "text/plain"});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.write(error + "\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "image/png"});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.write(file, "binary");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; });<BR>}</P>
<P>exports.start = start;<BR>exports.upload = upload;<BR>exports.show = show;</div><BR>我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="16928" class="copybut" id="copybut16928" onclick="doCopy('code16928')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16928"><BR>var server = require("./server");<BR>var router = require("./router");<BR>var requestHandlers = require("./requestHandlers");</P>
<P>var handle = {}<BR>handle["/"] = requestHandlers.start;<BR>handle["/start"] = requestHandlers.start;<BR>handle["/upload"] = requestHandlers.upload;<BR>handle["/show"] = requestHandlers.show;</P>
<P>server.start(router.route, handle);</div><BR>重启服务器之后，通过访问http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。</P>
<P>好，最后我们要的就是：</P>
<P>在/start表单中添加一个文件上传元素<BR>将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png<BR>将上传的图片内嵌到/uploadURL输出的HTML中<BR>第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="77811" class="copybut" id="copybut77811" onclick="doCopy('code77811')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code77811"><BR>var querystring = require("querystring"),<BR>&nbsp;&nbsp;&nbsp; fs = require("fs");</P>
<P>function start(response, postData) {<BR>&nbsp; console.log("Request handler 'start' was called.");</P>
<P>&nbsp; var body = '&lt;html&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;meta http-equiv="Content-Type" '+<BR>&nbsp;&nbsp;&nbsp; 'content="text/html; charset=UTF-8" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" enctype="multipart/form-data" '+<BR>&nbsp;&nbsp;&nbsp; 'method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="file" name="upload"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Upload file" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/html&gt;';</P>
<P>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write(body);<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>}</P>
<P>function upload(response, postData) {<BR>&nbsp; console.log("Request handler 'upload' was called.");<BR>&nbsp; response.writeHead(200, {"Content-Type": "text/plain"});<BR>&nbsp; response.write("You've sent the text: "+<BR>&nbsp; querystring.parse(postData).text);<BR>&nbsp; response.end();<BR>}</P>
<P>function show(response, postData) {<BR>&nbsp; console.log("Request handler 'show' was called.");<BR>&nbsp; fs.readFile("/tmp/test.png", "binary", function(error, file) {<BR>&nbsp;&nbsp;&nbsp; if(error) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.writeHead(500, {"Content-Type": "text/plain"});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.write(error + "\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "image/png"});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.write(file, "binary");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; });<BR>}</P>
<P>exports.start = start;<BR>exports.upload = upload;<BR>exports.show = show;</div><BR>很好。下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。</P>
<P>但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。</P>
<P>到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）</P>
<P>我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="95160" class="copybut" id="copybut95160" onclick="doCopy('code95160')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code95160"><BR>var http = require("http");<BR>var url = require("url");</P>
<P>function start(route, handle) {<BR>&nbsp; function onRequest(request, response) {<BR>&nbsp;&nbsp;&nbsp; var pathname = url.parse(request.url).pathname;<BR>&nbsp;&nbsp;&nbsp; console.log("Request for " + pathname + " received.");<BR>&nbsp;&nbsp;&nbsp; route(handle, pathname, response, request);<BR>&nbsp; }</P>
<P>&nbsp; http.createServer(onRequest).listen(8888);<BR>&nbsp; console.log("Server has started.");<BR>}</P>
<P>exports.start = start;<BR>接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：</P>
<P>function route(handle, pathname, response, request) {<BR>&nbsp; console.log("About to route a request for " + pathname);<BR>&nbsp; if (typeof handle[pathname] === 'function') {<BR>&nbsp;&nbsp;&nbsp; handle[pathname](response, request);<BR>&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp; console.log("No request handler found for " + pathname);<BR>&nbsp;&nbsp;&nbsp; response.writeHead(404, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write("404 Not found");<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp; }<BR>}</P>
<P>exports.route = route;</div><BR>现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。</P>
<P>这里采用fs.renameSync(path1,path2)来实现。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。</P>
<P>接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="96229" class="copybut" id="copybut96229" onclick="doCopy('code96229')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code96229"><BR>var querystring = require("querystring"),<BR>&nbsp;&nbsp;&nbsp; fs = require("fs"),<BR>&nbsp;&nbsp;&nbsp; formidable = require("formidable");</P>
<P>function start(response) {<BR>&nbsp; console.log("Request handler 'start' was called.");</P>
<P>&nbsp; var body = '&lt;html&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;meta http-equiv="Content-Type" content="text/html; '+<BR>&nbsp;&nbsp;&nbsp; 'charset=UTF-8" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/head&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;form action="/upload" enctype="multipart/form-data" '+<BR>&nbsp;&nbsp;&nbsp; 'method="post"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="file" name="upload" multiple="multiple"&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;input type="submit" value="Upload file" /&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/form&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/body&gt;'+<BR>&nbsp;&nbsp;&nbsp; '&lt;/html&gt;';</P>
<P>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write(body);<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>}</P>
<P>function upload(response, request) {<BR>&nbsp; console.log("Request handler 'upload' was called.");</P>
<P>&nbsp; var form = new formidable.IncomingForm();<BR>&nbsp; console.log("about to parse");<BR>&nbsp; form.parse(request, function(error, fields, files) {<BR>&nbsp;&nbsp;&nbsp; console.log("parsing done");<BR>&nbsp;&nbsp;&nbsp; fs.renameSync(files.upload.path, "/tmp/test.png");<BR>&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "text/html"});<BR>&nbsp;&nbsp;&nbsp; response.write("received image:&lt;br/&gt;");<BR>&nbsp;&nbsp;&nbsp; response.write("&lt;img src='/show' /&gt;");<BR>&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp; });<BR>}</P>
<P>function show(response) {<BR>&nbsp; console.log("Request handler 'show' was called.");<BR>&nbsp; fs.readFile("/tmp/test.png", "binary", function(error, file) {<BR>&nbsp;&nbsp;&nbsp; if(error) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.writeHead(500, {"Content-Type": "text/plain"});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.write(error + "\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.writeHead(200, {"Content-Type": "image/png"});<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.write(file, "binary");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; response.end();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp; });<BR>}</P>
<P>exports.start = start;<BR>exports.upload = upload;<BR>exports.show = show;</div><BR>好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。</P>
<P><STRONG>总结与展望</STRONG></P>
<P>恭喜，我们的任务已经完成了！我们开发完了一个Node.js的web应用，应用虽小，但却“五脏俱全”。 期间，我们介绍了很多技术点：服务端JavaScript、函数式编程、阻塞与非阻塞、回调、事件、内部和外部模块等等。</P>
<P>当然了，还有许多本书没有介绍到的： 如何操作数据库、如何进行单元测试、如何开发Node.js的外部模块以及一些简单的诸如如何获取GET请求之类的方法。</P>
<P>但本书毕竟只是一本给初学者的教程 —— 不可能覆盖到所有的内容。</P>
<P>幸运的是，Node.js社区非常活跃（作个不恰当的比喻就是犹如一群有多动症小孩子在一起，能不活跃吗？）， 这意味着，有许多关于Node.js的资源，有什么问题都可以向社区寻求解答。 其中Node.js社区的wiki以及 NodeCloud就是最好的资源。</P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/90137.html'>Mac系统下快速关闭safari标签的方法图解</a><a>下一篇</a><a href='/php/biji/90139.html'>WINxp解决机箱前置面板没声音图文教程</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>