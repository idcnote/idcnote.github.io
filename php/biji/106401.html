<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Android NDK 开发教程_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。<br />
<br />
<br />
众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Android NDK 开发教程</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。<br />
<br />
<br />
众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>Android NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为“NDK”。<br />
</p>
<p>众所周知，Android程序运行在Dalvik虚拟机中，NDK允许用户使用类似C / C++之类的原生代码语言执行部分程序。</p>
<p><strong>NDK包括了：</strong></p>
<p>从C / C++生成原生代码库所需要的工具和build files。<br />
</p>
<p>将一致的原生库嵌入可以在Android设备上部署的应用程序包文件（application packages files ，即.apk文件）中。<br />
支持所有未来Android平台的一些列原生系统头文件和库<br />
</p>
<p><span style="color: #0000ff">&nbsp;一、NDK产生的背景</span></p>
<p>　　Android平台从诞生起，就已经支持C、C++开发。众所周知，Android的SDK基于Java实现，这意味着基于Android SDK进行开发的第三方应用都必须使用Java语言。但这并不等同于“第三方应用只能使用Java”。在Android SDK首次发布时，Google就宣称其虚拟机Dalvik支持JNI编程方式，也就是第三方应用完全可以通过JNI调用自己的C动态库，即在Android平台上，“Java+C”的编程方式是一直都可以实现的。</p>
<p>　　不过，Google也表示，使用原生SDK编程相比Dalvik虚拟机也有一些劣势，Android SDK文档里，找不到任何JNI方面的帮助。即使第三方应用开发者使用JNI完成了自己的C动态链接库（so）开发，但是so如何和应用程序一起打包成apk并发布？这里面也存在技术障碍。比如程序更加复杂，兼容性难以保障，无法访问Framework API，Debug难度更大等。开发者需要自行斟酌使用。</p>
<p>　　于是NDK就应运而生了。NDK全称是Native Development Kit。</p>
<p>　　NDK的发布，使“Java+C”的开发方式终于转正，成为官方支持的开发方式。NDK将是Android平台支持C开发的开端。</p>
<p><span style="color: #0000ff">二、为什么使用NDK</span></p>
<p>　　1.代码的保护。由于apk的java层代码很容易被反编译，而C/C++库反汇难度较大。</p>
<p>　　2.可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的。</p>
<p>　　3.提高程序的执行效率。将要求高性能的应用逻辑使用C开发，从而提高应用程序的执行效率。</p>
<p>　　4.便于移植。用C/C++写得库可以方便在其他的嵌入式平台上再次使用。</p>
<p><span style="color: #0000ff">三、NDK简介</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1.NDK是一系列工具的集合</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。</p>
<p>NDK集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。</p>
<p>NDK可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong> 2.NDK提供了一份稳定、功能有限的API头文件声明</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Google明确声明该API是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API支持的功能非常有限，包含有：C标准库（libc）、标准数学库（libm）、压缩库（libz）、Log库（liblog）。</p>
<p><span style="color: #0000ff">四、NDK开发环境的搭建</span></p>
<p><strong>1.下载安装Android NDK</strong></p>
<p>　　地址：http://developer.android.com/sdk/ndk/index.html</p>
<p><strong>2.下载安装cygwin</strong></p>
<p>　　由于NDK编译代码时必须要用到make和gcc，所以你必须先搭建一个linux环境， cygwin是一个在windows平台上运行的unix模拟环境,它对于学习unix/linux操作环境，或者从unix到windows的应用程序移植，非常有用。通过它，你就可以在不安装linux的情况下使用NDK来编译C、C++代码了。下载地址：http://www.cygwin.com</p>
<p>　　1）然后双击运行吧，运行后你将看到安装向导界面。</p>
<p>　　2）点击下一步,此时让你选择安装方式：</p>
<p>Install from Internet：直接从Internet上下载并立即安装（安装完成后，下载好的安装文件并不会被删除，而是仍然被保留，以便下次再安装）。<br />
Download Without Installing：只是将安装文件下载到本地，但暂时不安装。<br />
Install from Local Directory：不下载安装文件，直接从本地某个含有安装文件的目录进行安装。<br />
　　3）选择第一项，然后点击下一步。</p>
<p>　　4）选择要安装的目录，注意，最好不要放到有中文和空格的目录里，似乎会造成安装出问题，其它选项不用变，之后点下一步：</p>
<p>　　5）上一步是选择安装cygwin的目录，这个是选择你下载的安装包所在的目录，默认是你运行setup.exe的目录，直接点下一步就可以：</p>
<p>　　6）此时你共有三种连接方式选择：</p>
<p>Direct Connection：直接连接。<br />
Use IE5 Settings：使用IE的连接参数设置进行连接。<br />
Use HTTP/FTP Proxy：使用HTTP或FTP代理服务器进行连接（需要输入服务器地址、端口号）。<br />
　　用户可根据自己的网络连接的实情情况进行选择，一般正常情况下，均选择第一种，也就是直接连接方式。然后再点击“下一步”。</p>
<p>　　7）这是选择要下载的站点，选择后点下一步。</p>
<p>　　8）此时会下载加载安装包列表</p>
<p>　　9）Search是可以输入你要下载的包的名称，能够快速筛选出你要下载的包。那四个单选按钮是选择下边树的样式，默认就行，不用动。View默认是Category，建议改成full显示全部包再查，省的一些包被隐藏掉。左下角那个复选框是是否隐藏过期包，默认打钩，不用管它就行，下边开始下载我们要安装的包吧，为了避免全部下载，这里列出了后面开发NDK用得着的包：autoconf2.1、automake1.10、binutils、gcc-core、gcc- g++、gcc4-core、gcc4-g++、gdb、pcre、pcre-devel、gawk、make共12个包</p>
<p>　　10）然后开始选择安装这些包吧，点skip，把它变成数字版本格式，要确保Bin项变成叉号，而Src项是源码，这个就没必要选了。</p>
<p>　　11）下面测试一下cygwin是不是已经安装好了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行cygwin，在弹出的命令行窗口输入：cygcheck -c cygwin命令，会打印出当前cygwin的版本和运行状 态，如果status是ok的话，则cygwin运行正常。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然后依次输入gcc –version，g++ --version，make –version，gdb –version进行测试，如果都打印出版本信息和一些描述信息，则cygwin安装成功！</p>
<p><strong>3.配置 NDK 环境变量</strong></p>
<p>　　a．首先找到 cygwin 的安装目录，找到一个 home\&lt; 你的用户名 &gt;\.bash_profile 文件，我的是：E:\cygwin\home\Administrator\.bash_profile ， ( 注意：我安装的时候我的 home 文件夹下面什么都没有，解决 的办法：首先打开环境变量，把里面的用户变量中的 HOME 变量删掉，在 E:\cygwin\home 文件夹下建立名为Administrator 的文件夹（是用户名），然后把 E:\cygwin\etc\skel\.bash_profile 拷贝到该文件夹下 ) 。</p>
<p>　　b．打开 bash_profile 文件，添加 NDK=/cygdrive/&lt; 你的盘符 &gt;/&lt;android ndk 目录 &gt; 例如：</p>
<p>　　　　　　NDK=/cygdrive/e/android-ndk-r5</p>
<p>　　　　　　export NDK</p>
<p>　　NDK 这个名字是随便取的，为了方面以后使用方便，选个简短的名字，然后保存</p>
<p>　　c．打开 cygwin ，输入 cd $NDK ，如果输出上面配置的 /cygdrive/e/android-ndk-r5 信息，则表明环境变量设置成功了。</p>
<p><strong>4.用 NDK 来编译程序&nbsp;&nbsp;</strong></p>
<p>　　a．现在我们用安装好的 NDK 来编译一个简单的程序吧，我们选择 ndk 自带的例子 hello-jni ，我的位于E:\android-ndk-r5\samples\hello-jni( 根据你具体的安装位置而定 ) ，</p>
<p>　　b．运行 cygwin ，输入命令 cd /cygdrive/e/android-ndk-r5/samples/hello-jni ，进入到 E:\android-ndk-r5\samples\hello-jni 目录。</p>
<p>　　c．输入 $NDK/ndk-build ，执行成功后，它会自动生成一个 libs 目录，把编译生成的 .so 文件放在里面。 ($NDK是调用我们之前配置好的环境变量， ndk-build 是调用 ndk 的编译程序 )</p>
<p>　　d．此时去 hello-jni 的 libs 目录下看有没有生成的 .so 文件，如果有，你的 ndk 就运行正常啦！</p>
<p><strong>5.在 eclipse 中集成 c/c++ 开发环境</strong></p>
<p>　　a．装 Eclipse 的 C/C++ 环境插件： CDT ，这里选择在线安装。　　首先登录 http://www.eclipse.org/cdt/downloads.php ，找到对应你 Eclipse 版本的 CDT 插件 的在线安装地址。</p>
<p>　　b．然后点 Help 菜单，找到 Install New Software 菜单</p>
<p>　　c．点击 Add 按钮，把取的地址填进去，出来插件列表后，选 Select All ，然后选择下一步即可完成安装。</p>
<p>　　d．安装完成后，在 eclispe 中右击新建一个项目，如果出现了 c/c++ 项目，则表明你的 CDT 插件安装成功啦！</p>
<p><strong>6.配置 C/C++ 的编译器</strong></p>
<p>　　a．打开 eclipse ，导入ndk 自带的hello-jni 例子，右键单击项目名称，点击 Properties ，弹出配置界面，之后再点击 Builders ，弹出项目的编译工具列表，之后点击 New，新添加一个编译器，点击后出现添加界面，选择 Program ，点击 OK。</p>
<p>　　b．出现了添加界面，首先给编译配置起个名字，如： C_Builder，设置 Location 为 &lt; 你 cygwin 安装路径 &gt;\bin\bash.exe 程序，例：E:\cygwin\bin\bash.exe ，设置Working Directory为&lt;你 cygwin 安装路径 &gt;\bin 目录，例如： E:\cygwin\bin，设置 Arguments 为 --login -c "cd /cygdrive/e/android-ndk-r5/samples/hello-jni && $NDK /ndk-build"</p>
<p>　　上面的配置中 /cygdrive/e/android-ndk-r5/samples/hello-jni 是你当前要编译的程序的目录， $NDK 是之前配置&nbsp; 的 ndk 的环境变量，这两个根据你具体的安装目录进行配置，其他的不用变， Arguments 这串参数实际是&nbsp; 给 bash.exe 命令行程序传参数，进入要编译的程序目录，然后运行 ndk-build 编译程序</p>
<p>　　c．接着切换到 Refresh 选项卡，给 Refresh resources upon completion 打上钩</p>
<p>　　d．然后切换到 Build Options 选项卡，勾选上最后三项</p>
<p>　　e．之后点击 Specify Resources 按钮，选择资源目录，勾选你的项目目录即可</p>
<p>　　f．最后点击 Finish，点击 OK 一路把刚才的配置都保存下来，注意：如果你配置的编译器在其它编译器下边，记得一定要点 Up 按钮，把它排到第一位，否则 C 代码的编译晚于Java代码的编译，会造成你的 C 代码要编译两次才能看到最新的修改。</p>
<p>　　g．编译配置也配置完成啦，现在来测试一下是否可以自动编译呢，打开项目 jni 目录里的 hello-jni.c 文件把提示 Hello from JNI! 改成其他的文字：如： Hello ， My name is alex. ，然后再模 拟器中运行你的程序，如果模拟器中显示了你最新修改的文字，那么 Congratulations ！你已经全部配置成功啦！</p>
<p><span style="color: #0000ff">五、开发自己的NDK程序</span></p>
<p>　　入门的最好办法就是学习Android自带的例子， 这里就通过学习Android的NDK自带的demo程序：hello-jni来达到这个目的。</p>
<p><strong>1、 开发环境的搭建</strong></p>
<p>　　1)android的NDK开发需要在linux下进行： 因为需要把C/C++编写的代码生成能在arm上运行的.so文件，这就需要用到交叉编译环境，而交叉编译需要在linux系统下才能完成。</p>
<p>　　2)安装android-ndk开发包，这个开发包可以在google android 官网下载： 通过这个开发包的工具才能将android jni 的C/C++的代码编译成库</p>
<p>　　3)android应用程序开发环境： 包括eclipse、java、 android sdk、 adt等。</p>
<p>　　如何下载和安装android-ndk我这里就不啰嗦了，安装完之后，需要将android-ndk的路劲加到环境变量PATH中：</p>
<p>　　　　sudo gedit /etc/environment</p>
<p>　　在environment的PATH环境变量中添加你的android-ndk的安装路劲，然后再让这个更改的环境变量立即生效：</p>
<p>　　　　 source&nbsp; /etc/environment</p>
<p>　　经过了上述步骤，在命令行下敲：</p>
<p>　　　　ndk-bulid</p>
<p>　　弹出如下的错误，而不是说ndk-build not found，就说明ndk环境已经安装成功了。</p>
<p>　　　　Android NDK: Could not find application project directory !&nbsp;&nbsp;&nbsp; <br />
　　　　Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.&nbsp;&nbsp;&nbsp; <br />
　　　　/home/braincol/workspace/android/android-ndk-r5/build/core/build-local.mk:85: *** Android NDK: Aborting&nbsp;&nbsp;&nbsp; .&nbsp; Stop.</p>
<p><strong>&nbsp;2.代码的编写</strong></p>
<p>　　1)首先是写java代码</p>
<p>　　建立一个Android应用工程HelloJni，创建HelloJni.java文件：</p>
<p>　　HelloJni.java :</p>
<div class="phpstudycode">
<pre class="brush:java;">
import android.app.Activity;
import android.widget.TextView;
import android.os.Bundle;
public class HelloJni extends Activity
{
  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState)
  {
    super.onCreate(savedInstanceState);
    TextView tv = new TextView(this);
    tv.setText( stringFromJNI() );
    setContentView(tv);
  }
  /* A native method that is implemented by the 'hello-jni' native library, which is packaged with this application. */
  public native String stringFromJNI();
  public native String unimplementedStringFromJNI();
  /* this is used to load the 'hello-jni' library on application startup. The library has already been unpacked into
   /data/data/com.example.HelloJni/lib/libhello-jni.so at installation time by the package manager. */
  static {
    System.loadLibrary("hello-jni");
  }
}

</pre>
</div>
<p>　　这段代码很简单，注释也很清晰，这里只提两点：:</p>
<div class="phpstudycode">
<pre class="brush:java;">
static{ 
System.loadLibrary("hello-jni"); 
}</pre>
<br />
</div>
<p>　　表明程序开始运行的时候会加载hello-jni, static区声明的代码会先于onCreate方法执行。如果你的程序中有多个类，而且如果HelloJni这个类不是你应用程序的入口，那么hello-jni（完整的名字是libhello-jni.so）这个库会在第一次使用HelloJni这个类的时候加载。</p>
<div class="phpstudycode">
<pre class="brush:java;">
public native String stringFromJNI(); 
public native String unimplementedStringFromJNI();</pre>
<br />
</div>
<p>　　可以看到这两个方法的声明中有 native 关键字， 这个关键字表示这两个方法是本地方法，也就是说这两个方法是通过本地代码（C/C++）实现的，在java代码中仅仅是声明。</p>
<p>　　用eclipse编译该工程，生成相应的.class文件，这步必须在下一步之前完成，因为生成.h文件需要用到相应的.class文件。</p>
<p>2)编写相应的C/C++代码</p>
<p>　　刚开始学的时候，有个问题会让人很困惑，相应的C/C++代码如何编写，函数名如何定义？ 这里讲一个方法，利用javah这个工具生成相应的.h文件，然后根据这个.h文件编写相应的C/C++代码。</p>
<p>　　a. 生成相应.h文件：</p>
<p>　　就拿我这的环境来说，首先在终端下进入刚刚建立的HelloJni工程的目录：</p>
<p>braincol@ubuntu:~$ cd workspace/android/NDK/hello-jni/<br />
　　ls查看工程文件　　</p>
<p>braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls <br />
AndroidManifest.xml&nbsp; assets&nbsp; bin&nbsp; default.properties&nbsp; gen&nbsp; res&nbsp; src <br />
　　可以看到目前仅仅有几个标准的android应用程序的文件（夹）。</p>
<p>　　首先我们在工程目录下建立一个jni文件夹：</p>
<p>braincol@ubuntu:~/workspace/android/NDK/hello-jni$ mkdir jni <br />
braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls <br />
AndroidManifest.xml&nbsp; assets&nbsp; bin&nbsp; default.properties&nbsp; gen&nbsp; jni&nbsp; res&nbsp; src <br />
　　下面就可以生成相应的.h文件了：</p>
<p>braincol@ubuntu:~/workspace/android/NDK/hello-jni$ javah -classpath bin -d jni com.example.hellojni.HelloJni <br />
　　-classpath bin：表示类的路劲</p>
<p>　　-d jni: 表示生成的头文件存放的目录</p>
<p>　　com.example.hellojni.HelloJni 则是完整类名</p>
<p>　　这一步的成功要建立在已经在 bin/com/example/hellojni/&nbsp; 目录下生成了 HelloJni.class的基础之上。现在可以看到jni目录下多了个.h文件：</p>
<p>braincol@ubuntu:~/workspace/android/NDK/hello-jni$ cd jni/ <br />
braincol@ubuntu:~/workspace/android/NDK/hello-jni/jni$ ls <br />
com_example_hellojni_HelloJni.h</p>
<p>　　我们来看看com_example_hellojni_HelloJni.h的内容：</p>
<p>　　com_example_hellojni_HelloJni.h :</p>
<div class="phpstudycode">
<pre class="brush:java;">
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_example_hellojni_HelloJni */
#ifndef _Included_com_example_hellojni_HelloJni
#define _Included_com_example_hellojni_HelloJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:   com_example_hellojni_HelloJni
 * Method:  stringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
 (JNIEnv *, jobject);
/*
 * Class:   com_example_hellojni_HelloJni
 * Method:  unimplementedStringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI
 (JNIEnv *, jobject);
#ifdef __cplusplus
}
#endif
#endif

</pre>
</div>
<p>　　上面代码中的JNIEXPORT 和 JNICALL 是jni的宏，在android的jni中不需要，当然写上去也不会有错。从上面的源码中可以看出这个函数名那是相当的长啊。。。。 不过还是很有规律的， 完全按照：java_pacakege_class_mathod 形式来命名。</p>
<p>　　也就是说：</p>
<p>　　Hello.java中 stringFromJNI() 方法对应于 C/C++中的 Java_com_example_hellojni_HelloJni_stringFromJNI() 方法</p>
<p>　　HelloJni.java中的 unimplementedStringFromJNI() 方法对应于 C/C++中的</p>
<p>Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI() 方法</p>
<p>　　注意下其中的注释：</p>
<p>　　Signature: ()Ljava/lang/String;</p>
<p>　　()Ljava/lang/String;()表示函数的参数为空（这里为空是指除了JNIEnv *, jobject 这两个参数之外没有其他参数，JNIEnv*, jobject是所有jni函数必有的两个参数，分别表示jni环境和对应的java类（或对象）本身），Ljava/lang/String; 表示函数的返回值是java的String对象。</p>
<p>b. 编写相应的.c文件：</p>
<p>　　hello-jni.c :</p>
<div class="phpstudycode">
<pre class="brush:java;">
#include &lt;string.h&gt;
#include &lt;jni.h&gt;
/* This is a trivial JNI example where we use a native method
 * to return a new VM String. See the corresponding Java source
 * file located at:
 *  apps/samples/hello-jni/project/src/com/example/HelloJni/HelloJni.java
 */
jstring Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )
{
  return (*env)-&gt;NewStringUTF(env, "Hello from JNI !");
}</pre>
</div>
<p>　　这里只是实现了Java_com_example_hellojni_HelloJni_stringFromJNI方法，而 Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI 方法并没有实现，因为在HelloJni.java中只调用了stringFromJNI()方法，所以unimplementedStringFromJNI()方法没有实现也没关系，不过建议最好还是把所有java中定义的本地方法都实现了，写个空函数也行啊。。。有总比没有好。</p>
<p>　　Java_com_example_hellojni_HelloJni_stringFromJNI() 函数只是简单的返回了一个内容为 "Hello from JNI !" 的jstring对象（对应于java中的String对象）。hello-jni.c文件已经编写好了，现在可以把com_example_hellojni_HelloJni.h文件给删了，当然留着也行，只是我还是习惯把不需要的文件给清理干净了。</p>
<p>3)编译hello-jni.c 生成相应的库</p>
<p>a 编写Android.mk文件</p>
<p>　　在jni目录下（即hello-jni.c 同级目录下）新建一个Android.mk文件，Android.mk 文件是Android 的 makefile文件，内容如下：</p>
<div class="phpstudycode">
<pre class="brush:java;">
# Copyright (C) The Android Open Source Project
#
# Licensed under the Apache License, Version . (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE  := hello-jni
LOCAL_SRC_FILES := hello-jni.c
include $(BUILD_SHARED_LIBRARY)</pre>
</div>
<p>　　这个Androd.mk文件很短，下面我们来逐行解释下：</p>
<p>　　　　LOCAL_PATH := $(call my-dir)</p>
<p>　　一个Android.mk 文件首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数'my-dir', 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。</p>
<p>　　　　include $( CLEAR_VARS)</p>
<p>　　CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等...), 除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。</p>
<p>　　　　LOCAL_MODULE := hello-jni</p>
<p>　　编译的目标对象，LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。</p>
<p>注意：编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为'hello-jni'的共享库模块，将会生成'libhello-jni.so'文件。</p>
<p>　　重要注意事项：如果你把库命名为‘libhello-jni'，编译系统将不会添加任何的lib前缀，也会生成 'libhello-jni.so'，这是为了支持来源于Android平台的源代码的Android.mk文件，如果你确实需要这么做的话。</p>
<p>　　　　LOCAL_SRC_FILES := hello-jni.c</p>
<p>　　LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。</p>
<p>　　注意，默认的C++源码文件的扩展名是'.cpp'. 指定一个不同的扩展名也是可能的，只要定义LOCAL_DEFAULT_CPP_EXTENSION变量，不要忘记开始的小圆点（也就是'.cxx',而不是'cxx'）</p>
<p>　　　　include $(BUILD_SHARED_LIBRARY)</p>
<p>　　BUILD_SHARED_LIBRARY表示编译生成共享库，是编译系统提供的变量，指向一个GNU Makefile脚本，负责收集自从上次调用'include $(CLEAR_VARS)'以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。还有 BUILD_STATIC_LIBRARY变量表示生成静态库：lib$(LOCAL_MODULE).a， BUILD_EXECUTABLE 表示生成可执行文件。</p>
<p>b. 生成.so共享库文件</p>
<p>　　Andro文件已经编写好了，现在可以用android NDK开发包中的 ndk-build脚本生成对应的.so共享库了，方法如下：</p>
<p>　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni/jni$ cd .. <br />
　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ls <br />
　　　　AndroidManifest.xml&nbsp; assets&nbsp; bin&nbsp; default.properties&nbsp; gen&nbsp; jni&nbsp; libs&nbsp; obj&nbsp; res&nbsp; src <br />
　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni$ ndk-build <br />
　　　　Gdbserver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : [arm-linux-androideabi-4.4.3] libs/armeabi/gdbserver <br />
　　　　Gdbsetup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : libs/armeabi/gdb.setup <br />
　　　　Install&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : libhello-jni.so =&gt; libs/armeabi/libhello-jni.so</p>
<p>　　可以看到已经正确的生成了libhello-jni.so共享库了， 我们去 libs/armeabi/ 目录下看看：</p>
<p>　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni$ cd libs/ <br />
　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs$ ls <br />
　　　　armeabi <br />
　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs$ cd armeabi/ <br />
　　　　braincol@ubuntu:~/workspace/android/NDK/hello-jni/libs/armeabi$ ls <br />
　　　　gdbserver&nbsp; gdb.setup&nbsp; libhello-jni.so</p>
<p>4)在eclipse重新编译HelloJni工程，生成apk</p>
<p>　　eclipse中刷新下HelloJni工程，重新编译生成apk，libhello-jni.so共享库会一起打包在apk文件内。在模拟器中看看运行结果。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/106400.html'>JS实现图片局部放大或缩小的方法</a><a>下一篇</a><a href='/php/biji/106402.html'>C++入门之基础语法学习教程</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>