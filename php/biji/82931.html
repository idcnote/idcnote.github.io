<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>基于C++实现的各种内部排序算法汇总_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="提起排序算法相信大家都不陌生，或许很多人已经把它们记得滚瓜烂熟，甚至随时可以写出来。是的，这些都是最基本的算法。这里就把各种内部排序算法总结归纳了一下，包括插入排序（直接" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">基于C++实现的各种内部排序算法汇总</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>提起排序算法相信大家都不陌生，或许很多人已经把它们记得滚瓜烂熟，甚至随时可以写出来。是的，这些都是最基本的算法。这里就把各种内部排序算法总结归纳了一下，包括插入排序（直接</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>提起排序算法相信大家都不陌生，或许很多人已经把它们记得滚瓜烂熟，甚至随时可以写出来。是的，这些都是最基本的算法。这里就把各种内部排序算法总结归纳了一下，包括插入排序（直接插入排序，折半插入排序，希尔排序）、交换排序（冒泡排序，快速排序）、选择排序（简单选择排序，堆排序）、2-路归并排序。（另：至于堆排序算法，前面已经有一篇文章针对堆排序的算法实现做了详细的描述）</p>
<p>C++实现代码如下：</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
/*************************************************************************
 &gt; File Name: sort.cpp
 &gt; Author: SongLee
 ************************************************************************/
#include&lt;iostream&gt;
using namespace std;

typedef int ElementType;

/*
 *&lt;&lt;直接插入排序&gt;&gt;
 * 为了实现N个数的排序，将后面N-1个数依次插入到前面已排好的子序列中，
 *假定刚开始第1个数是一个已排好序的子序列。经过N-1趟就能得到一个有序序列。
 *****时间复杂度：最好情况O(n)，最坏情况O(n^2)，平均情况O(n^2).
 *****空间复杂度：O(1)
 *****稳定性：稳定
 */
void InsertSort(ElementType A[], int n)
{
 int i,j;
 ElementType temp; // 临时变量

 for(i=1; i&lt;n; ++i)
 {
 temp = A[i]; 
 for(j = i; j&gt;0 && A[j-1]&gt;temp; --j)
 A[j] = A[j-1];
 A[j] = temp;
 }
}

/*
 *&lt;&lt;折半插入排序&gt;&gt;
 * 与直接插入排序不同的是，折半插入排序不是边比较边移动，而是将比较和移
 *动操作分离出来，即先折半查找出元素的待插入位置，然后再统一地移动待插入位
 *置之后的所有元素。不难看出折半插入排序仅仅是减少了比较的次数。
 *****时间复杂度：O(n^2)
 *****空间复杂度：O(1)
 *****稳定性：稳定
 */
void BinaryInsertSort(ElementType A[], int n)
{
 int i, j, low, high, mid;
 ElementType temp;
 for(i=1; i&lt;n; ++i)
 {
 temp = A[i];
 low = 0; high = i-1; // 设置折半查找的范围
 while(low &lt;= high)
 {
 mid = (low+high)/2; // 取中间点
 if(A[mid] &gt; temp)
 high = mid-1;
 else
 low = mid+1;
 }

 for(j=i-1; j&gt;=high+1; --j) // 统一后移
 A[j+1] = A[j];
 A[high+1] = temp; // 插入
 }
}

/*
 *&lt;&lt;希尔排序&gt;&gt;
 * 希尔排序通过比较相距一定间隔的元素，即形如L[i,i+d,i+2d,...i+kd]的序列
 *然后缩小间距，再对各分组序列进行排序。直到只比较相邻元素的最后一趟排序为
 *止，即最后的间距为1。希尔排序有时也叫做*缩小增量排序*
 *****时间复杂度：依赖于增量序列的选择，但最坏情况才为O(N^2)
 *****空间复杂度：O(1)
 *****稳定性：不稳定
 */
void ShellSort(ElementType A[], int n)
{
 int i, j, dk; // dk是增量
 ElementType temp;
 
 for(dk=n/2; dk&gt;0; dk/=2) // 增量变化
 {
 for(i=dk; i&lt;n; ++i) // 每个分组序列进行直接插入排序
 {
 temp = A[i];
 for(j=i-dk; j&gt;=0 && A[j]&gt;temp; j-=dk)
 A[j+dk] = A[j]; // 后移
 A[j+dk] = temp;
 }
 }
}

/*
 *&lt;&lt;冒泡排序&gt;&gt;
 * 冒泡排序的基本思想是从后往前（或从前往后）两两比较相邻元素的值，若为
 *逆序，则交换它们，直到序列比较完。我们称它为一趟冒泡。每一趟冒泡都会将一
 *个元素放置到其最终位置上。
 *****时间复杂度：最好情况O(n)，最坏情况O(n^2)，平均情况O(n^2)
 *****空间复杂度：O(1)
 *****稳定性：稳定
 */
void BubbleSort(ElementType A[], int n)
{
 for(int i=0; i&lt;n-1; ++i)
 {
 bool flag = false; // 表示本次冒泡是否发生交换的标志
 for(int j=n-1; j&gt;i; --j) // 从后往前
 {
 if(A[j-1] &gt; A[j]) 
 {
 flag = true;
 // 交换
 A[j-1] = A[j-1]^A[j];
 A[j] = A[j-1]^A[j];
 A[j-1] = A[j-1]^A[j];
 }
 }

 if(flag == false)
 return;
 }
}

/*
 *&lt;&lt;快速排序&gt;&gt;
 * 快速排序是对冒泡排序的一种改进。其基本思想是基于分治法：在待排序表L[n]
 *中任取一个元素pivot作为基准，通过一趟排序将序列划分为两部分L[1...K-1]和
 *L[k+1...n]，是的L[1...k-1]中的所有元素都小于pivot，而L[k+1...n]中所有元素
 *都大于或等于pivot。则pivot放在了其最终位置L(k)上。然后，分别递归地对两个子
 *序列重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终
 *位置上。
 *****时间复杂度：快排的运行时间与划分是否对称有关，最坏情况O(n^2),最好情况
 *O(nlogn),平均情况为O(nlogn)
 *****空间复杂度：由于需要递归工作栈，最坏情况为O(n)，平均情况为O(logn)
 *****稳定性：不稳定
 */
int Partition(ElementType A[], int low, int high)
{
 // 划分操作有很多版本，这里就总以当前表中第一个元素作为枢纽/基准
 ElementType pivot = A[low];
 while(low &lt; high)
 {
 while(low&lt;high && A[high]&gt;=pivot)
 --high;
 A[low] = A[high]; // 将比枢纽值小的元素移到左端
 while(low&lt;high && A[low]&lt;=pivot)
 ++low;
 A[high] = A[low]; // 将比枢纽值大的元素移到右端
 }

 A[low] = pivot; // 枢纽元素放到最终位置
 return low;  // 返回枢纽元素的位置
}

void QuickSort(ElementType A[], int low, int high)
{
 if(low &lt; high) // 递归跳出的条件
 {
 int pivotPos = Partition(A, low, high); // 划分操作，返回基准元素的最终位置
 QuickSort(A, low, pivotPos-1); // 递归
 QuickSort(A, pivotPos+1, high);
 }
}

/*
 *&lt;&lt;简单选择排序&gt;&gt;
 * 选择排序的算法思想很简单，假设序列为L[n]，第i趟排序即从L[i...n]中选择
 *关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置。经过n-1
 *趟排序就可以使得序列有序了。
 *****时间复杂度：始终是O(n^2)
 *****空间复杂度：O(1)
 *****稳定性：不稳定
 */
void SelectedSort(ElementType A[], int n)
{
 for(int i=0; i&lt;n-1; ++i) // 一共进行n-1趟
 {
 int minPos = i; // 记录最小元素的位置

 for(int j=i+1; j&lt;n; ++j)
 if(A[j] &lt; A[minPos])
 minPos = j;

 if(minPos != i) // 与第i个位置交换
 {
 A[i] = A[i]^A[minPos];
 A[minPos] = A[i]^A[minPos];
 A[i] = A[i]^A[minPos];
 }
 }
}

/*
 *&lt;&lt;堆排序&gt;&gt;
 * 堆排序是一种树形选择排序方法，在排序过程中，将L[n]看成是一棵完全二叉
 *树的顺序存储结构，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当
 *前无序区中选择关键字最大（或最小）的元素。堆排序的思路是：首先将序列L[n]
 *的n个元素建成初始堆，由于堆本身的特点（以大根堆为例），堆顶元素就是最大
 *值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大根堆的性
 *质，堆被破坏，将堆顶元素向下调整使其继续保持大根堆的性质，再输出堆顶元素。
 *如此重复，直到堆中仅剩下一个元素为止。
 *****时间复杂度：O(nlogn)
 *****空间复杂度：O(1)
 *****稳定性：不稳定
 */

void AdjustDown(ElementType A[], int i, int len)
{
 ElementType temp = A[i]; // 暂存A[i]
 
 for(int largest=2*i+1; largest&lt;len; largest=2*largest+1)
 {
 if(largest!=len-1 && A[largest+1]&gt;A[largest])
 ++largest;   // 如果右子结点大
 if(temp &lt; A[largest])
 {
 A[i] = A[largest];
 i = largest;   // 记录交换后的位置
 }
 else
 break;
 }
 A[i] = temp; // 被筛选结点的值放入最终位置
}
void BuildMaxHeap(ElementType A[], int len)
{
 for(int i=len/2-1; i&gt;=0; --i) // 从i=[n/2]~1，反复调整堆
 AdjustDown(A, i, len);
}
void HeapSort(ElementType A[], int n)
{
 BuildMaxHeap(A, n);  // 初始建堆
 for(int i=n-1; i&gt;0; --i) // n-1趟的交换和建堆过程 
 {
 // 输出最大的堆顶元素（和堆底元素交换）
 A[0] = A[0]^A[i];
 A[i] = A[0]^A[i];
 A[0] = A[0]^A[i];
 // 调整，把剩余的n-1个元素整理成堆
 AdjustDown(A, 0, i); 
 }
}

/*
 *&lt;&lt;2-路归并排序&gt;&gt;
 * 顾名思义，2-路归并就是将2个有序表组合成一个新的有序表。假定待排序表
 *有n个元素，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并...不
 *停重复，直到合成一个长度为n的有序序列为止。Merge()函数是将前后相邻的两个
 *有序表归并为一个有序表，设A[low...mid]和A[mid+1...high]存放在同一顺序表的
 *相邻位置上，先将它们复制到辅助数组B中。每次从对应B中的两个段取出一个元素
 *进行比较，将较小者放入A中。
 *****时间复杂度：每一趟归并为O(n),共log2n趟，所以时间为O(nlog2n)
 *****空间复杂度：O(n)
 *****稳定性：稳定
 */
ElementType *B = new ElementType[13]; // 和数组A一样大
void Merge(ElementType A[], int low, int mid, int high)
{
 int i, j, k;
 for(k=low; k&lt;=high; ++k)
 B[k] = A[k];    // 将A中所有元素复制到B
 for(i=low,j=mid+1,k=i; i&lt;=mid&&j&lt;=high; ++k)
 {
 if(B[i] &lt;= B[j])  // 比较B的左右两段序列中的元素
 A[k] = B[i++]; // 将较小值复制到A中
 else
 A[k] = B[j++];
 }
 while(i&lt;=mid) A[k++] = B[i++]; // 若第一个表未检测完，复制
 while(j&lt;=high) A[k++] = B[j++]; // 若第二个表未检测完，复制
}

void MergeSort(ElementType A[], int low, int high)
{
 if(low &lt; high)
 {
 int mid = (low + high)/2;
 MergeSort(A, low, mid);  // 对左侧子序列进行递归排序
 MergeSort(A, mid+1, high); // 对右侧子序列进行递归排序
 Merge(A, low, mid, high);  // 归并
 }
}

/*
 * 输出函数
 */
void print(ElementType A[], int n)
{
 for(int i=0; i&lt;n; ++i)
 {
 cout &lt;&lt; A[i] &lt;&lt; " ";
 }
 cout &lt;&lt; endl;
}

/*
 * 主函数
 */
int main()
{
 ElementType Arr[13] = {5,2,1,8,3,6,4,7,0,9,12,10,11};
 //InsertSort(Arr, 13);
 //BinaryInsertSort(Arr, 13);
 //ShellSort(Arr, 13);
 //BubbleSort(Arr, 13);
 //QuickSort(Arr, 0, 12);
 //SelectedSort(Arr, 13);
 //HeapSort(Arr, 13);
 //MergeSort(Arr, 0, 12);
 print(Arr, 13);
 return 0;
}

</pre>
</div>
<p>相信本文所述实例代码对大家复习和巩固各类排序算法能起到一定的帮助作用。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/82930.html'>PHP循环输出指定目录下的所有文件和文件夹路径例子（简单实用）</a><a>下一篇</a><a href='/php/biji/82932.html'>Oracle行级锁的特殊用法简析</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>