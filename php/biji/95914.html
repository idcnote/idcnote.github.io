<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>总结在前端排序中遇到的问题_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="貌似前端圈一直以来流传着一种误解：前端用不到算法知识。长久以来，大家或许都曾受这种说法的影响。直到前阵子遇到一个产品需求，回过头来看，发现事实并非如此。<br />
前端排序<br />
前端排" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">总结在前端排序中遇到的问题</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>貌似前端圈一直以来流传着一种误解：前端用不到算法知识。长久以来，大家或许都曾受这种说法的影响。直到前阵子遇到一个产品需求，回过头来看，发现事实并非如此。<br />
前端排序<br />
前端排</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>貌似前端圈一直以来流传着一种误解：前端用不到算法知识。长久以来，大家或许都曾受这种说法的影响。直到前阵子遇到一个产品需求，回过头来看，发现事实并非如此。</p>
<p><strong>前端排序</strong></p>
<p><strong>前端排序的场景</strong></p>
<p>前端将排序条件作为请求参数传递给后端，后端将排序结果作为请求响应返回前端，这是一种常见设计。但是对于有些产品则不是那么适用。</p>
<p>试想一个场景：你在使用美食类APP时，是否会经常切换排序方式，一会儿按照价格排序，一会儿按照评分排序。</p>
<p>实际生产中，受限于服务器成本等因素，当单次数据查询成为整体性能瓶颈时，也会考虑通过将排序在前端完成的方式来优化性能。</p>
<p><strong>排序算法</strong></p>
<p>感觉这个没什么介绍的必要，作为计算机科学的一种基础算法，描述就直接照搬 <code>Wikipedia</code>。</p>
<p>这里存在这一段内容纯粹是为了承(cou)上(man)启(zi)下(shu)。</p>
<p><strong>JavaScript的排序</strong></p>
<p>既然说到前端排序，自然首先会想到JavaScript的原生接口 <code>Array.prototype.sort</code>。</p>
<p>这个接口自 <code>ECMAScript 1st Edition</code> 起就存在。让我们看看最新的规范中关于它的描述是什么样的。</p>
<p><strong>Array.prototype.sort规范</strong></p>
<p><code>Array.prototype.sort(compareFn)</code></p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="14402" class="copybut" id="copybut14402" onclick="doCopy('code14402')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code14402"><br />
The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x &lt; y, zero if x = y, or a positive value if x &gt; y.<br />
</div></p>
<p>显然，规范并没有限定 <code>sort</code> 内部实现的排序算法是什么。甚至接口的实现都不需要是 <strong>稳定排序</strong> 的。这一点很关键，接下来会多次涉及。</p>
<p>在这样的背景下，前端排序这件事其实取决于各家浏览器的具体实现。那么，当今主流的浏览器关于排序是怎么实现的呢？接下来，我们分别简单对比一下 <strong>Chrome</strong>、<strong>Firefox</strong> 和 <strong>Microsoft Edge</strong>。</p>
<p><strong>Chrome中的实现</strong></p>
<p>Chrome 的JavaScript引擎是 v8。由于它是开源的，所以可以直接看源代码。</p>
<p>整个 array.js 都是用 JavaScript 语言实现的。排序方法部分很明显比曾经看到过的快速排序要复杂得多，但显然核心算法还是 快速排序。算法复杂的原因在于 v8 出于性能考虑进行了很多优化。(接下来会展开说)</p>
<p><strong>Firefox中的实现</strong></p>
<p>暂时无法确定Firefox的JavaScript引擎即将使用的数组排序算法会是什么。[3]</p>
<p>按照现有的信息，SpiderMoney 内部实现了 归并排序。</p>
<p><strong>Microsoft Edge中的实现</strong></p>
<p>Microsoft Edge 的JavaScript引擎 Chakra 的核心部分代码已经于2016年初在Github开源。</p>
<p>通过看源代码可以发现，Chakra 的数组排序算法实现的也是 快速排序。而且相比较于 v8，它就只是实现了纯粹的快速排序，完全没有 v8 中的那些性能优化的踪影。</p>
<p><strong>JavaScript数组排序的问题</strong></p>
<p>众所周知，快速排序 是一种不稳定的排序算法，而 归并排序 是一种稳定的排序算法。由于不同引擎在算法选择上的差异，导致前端依赖 Array.prototype.sort 接口实现的JavaScript代码，在浏览器中实际执行的排序效果是不一致的。</p>
<p>排序稳定性的差异需要有特定的场景触发才会存在问题；在很多情况下，不稳定的排序也不会造成影响。</p>
<p>假如实际项目开发中，对于数组的排序没有稳定性的需求，那么其实看到这里为止即可，浏览器之间的实现差异不那么重要。</p>
<p>但是若项目要求排序必须是稳定的，那么这些差异的存在将无法满足需求。我们需要为此进行一些额外的工作。</p>
<p>举个例子：</p>
<p>某市的机动车牌照拍卖系统，最终中标的规则为：</p>
<p>&nbsp;&nbsp;&nbsp; 1. 按价格进行倒排序；</p>
<p>&nbsp;&nbsp;&nbsp; 2. 相同价格则按照竞标顺位（即价格提交时间）进行正排序。</p>
<p>排序若是在前端进行，那么采用快速排序的浏览器中显示的中标者很可能是不符合预期的<br />
</p>
<p><strong>探究差异的背后</strong></p>
<p>寻找解决办法之前，我们有必要先探究一下出现问题的原因。</p>
<p>Chrome为什么采用快速排序</p>
<p>其实这个情况从一开始便存在。</p>
<p>Chrome测试版 于2008年9月2日发布，然而发布后不久，就有开发者向 Chromium 开发组提交#90 Bug反馈v8的数组排序实现不是稳定排序的。</p>
<p>这个Bug ISSUE讨论的时间跨度很大。一直到2015年11月10日，仍然有开发者对v8的数组排序实现问题提出评论。</p>
<p>同时我们还注意到，该ISSUE曾经已被关闭。但是于2013年6月被开发组成员重新打开，作为 ECMAScript Next 规范讨论的参考。</p>
<p>而es-discuss的最后结论是这样的</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="6116" class="copybut" id="copybut6116" onclick="doCopy('code6116')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code6116"><br />
It does not change. Stable is a subset of unstable. And vice versa, every unstable algorithm returns a stable result for some inputs. Mark's point is that requiring “always unstable” has no meaning, no matter what language you chose.<br />
/Andreas<br />
</div></p>
<p>正如本文前段所引用的已定稿 ECMAScript 2015 规范中的描述。</p>
<p><strong>时代特点</strong></p>
<p>IMHO，Chrome发布之初即被报告出这个问题可能是有其特殊的时代特点。</p>
<p>上文已经说到，Chrome第一版 是 2008年9月 发布的。根据statcounter的统计数据，那个时期市场占有率最高的两款浏览器分别是 IE(那时候只有IE6和IE7) 和 Firefox，市场占有率分别达到了67.16%和25.77%。也就是说，两个浏览器加起来的市场占有率超过了90%。</p>
<p>而根据另一份浏览器排序算法稳定性的统计数据显示，这两款超过了90%市场占有率的浏览器都采用了稳定的数组排序。所以Chrome发布之初被开发者质疑也是合情合理的。</p>
<p><strong>符合规范</strong></p>
<p>从Bug ISSUE讨论的过程中，可以大概理解开发组成员对于引擎实现采用快速排序的一些考量。</p>
<p>其中一点，他们认为引擎必须遵守ECMAScript规范。由于规范不要求稳定排序的描述，故他们认为 v8 的实现是完全符合规范的。</p>
<p><strong>性能考虑</strong></p>
<p>另外，他们认为 v8 设计的一个重要考量在于引擎的性能。</p>
<p>快速排序 相比较于 归并排序，在整体性能上表现更好：</p>
<p>更高的计算效率。快速排序 在实际计算机执行环境中比同等时间复杂度的其他排序算法更快（不命中最差组合的情况下）<br />
更低的空间成本。前者仅有O(㏒n)的空间复杂度，相比较后者O(n)的空间复杂度在运行时的内存消耗更少<br />
v8在数组排序算法中的性能优化</p>
<p>既然说 v8 非常看中引擎的性能，那么在数组排序中它做了哪些事呢？</p>
<p>通过阅读源代码，还是粗浅地学习了一些皮毛。</p>
<p>混合插入排序<br />
快速排序 是分治的思想，将大数组分解，逐层往下递归。但是若递归深度太大，为了维持递归调用栈的内存资源消耗也会很大。优化不好甚至可能造成栈溢出。</p>
<p>目前v8的实现是设定一个阈值，对最下层的10个及以下长度的小数组使用 插入排序。</p>
<p>根据代码注释以及 Wikipedia 中的描述，虽然插入排序的平均时间复杂度为 O(n&sup2;) 差于快速排序的 O(n㏒n)。但是在运行环境，小数组使用插入排序的效率反而比快速排序会更高，这里不再展开。</p>
<p>v8代码示例</p>
<div class="phpstudycode">
<pre class="brush:js;">
var QuickSort = function QuickSort(a, from, to) {
  ......
  while (true) {
    // Insertion sort is faster for short arrays.
    if (to - from &lt;= 10) {
      InsertionSort(a, from, to);
      return;
    }
    ......
  }
  ......
};</pre>
</div>
<p>三数取中<br />
</p>
<p>正如已知的，快速排序的阿克琉斯之踵在于，最差数组组合情况下会算法退化。</p>
<p>快速排序的算法核心在于选择一个基准 (pivot)，将经过比较交换的数组按基准分解为两个数区进行后续递归。试想如果对一个已经有序的数组，每次选择基准元素时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到 n，最后导致算法的时间复杂度退化为 O(n&sup2;)。因此 pivot 的选择非常重要。</p>
<p>v8采用的是 三数取中(<code>median-of-three</code>) 的优化：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。</p>
<p>第三个元素的选取策略大致为：</p>
<p>当数组长度小于等于1000时，选择折半位置的元素作为目标元素。<br />
当数组长度超过1000时，每隔200-215个(非固定，跟着数组长度而变化)左右选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素<br />
最后取三个元素的中位值作为 pivot。</p>
<p>v8代码示例</p>
<div class="phpstudycode">
<pre class="brush:js;">
var GetThirdIndex = function(a, from, to) {
  var t_array = new InternalArray();
  // Use both 'from' and 'to' to determine the pivot candidates.
  var increment = 200 + ((to - from) & 15);
  var j = 0;
  from += 1;
  to -= 1;
  for (var i = from; i &lt; to; i += increment) {
    t_array[j] = [i, a[i]];
    j++;
  }
  t_array.sort(function(a, b) {
    return comparefn(a[1], b[1]);
  });
  var third_index = t_array[t_array.length &gt;&gt; 1][0];
  return third_index;
};

var QuickSort = function QuickSort(a, from, to) {
  ......
  while (true) {
    ......
    if (to - from &gt; 1000) {
      third_index = GetThirdIndex(a, from, to);
    } else {
      third_index = from + ((to - from) &gt;&gt; 1);
    }
  }
  ......
};</pre>
</div>
<p><strong>原地排序</strong><br />
</p>
<p>在温习快速排序算法时，我在网上看到了很多用JavaScript实现的例子。</p>
<p>但是发现一大部分的代码实现如下所示</p>
<div class="phpstudycode">
<pre class="brush:js;">
var quickSort = function(arr) {
　　if (arr.length &lt;= 1) { return arr; }
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1)[0];
　　var left = [];
　　var right = [];
　　for (var i = 0; i &lt; arr.length; i++){
　　　　if (arr[i] &lt; pivot) {
　　　　　　left.push(arr[i]);
　　　　} else {
　　　　　　right.push(arr[i]);
　　　　}
　　}
　　return quickSort(left).concat([pivot], quickSort(right));
};</pre>
</div>
<p>以上代码的主要问题在于：利用 <strong>left</strong> 和 <strong>right</strong> 两个数区存储递归的子数组，因此它需要 O(n) 的额外存储空间。这与理论上的平均空间复杂度 O(㏒n) 相比差距较大。</p>
<p>额外的空间开销，同样会影响实际运行时的整体速度。这也是快速排序在实际运行时的表现可以超过同等时间复杂度级别的其他排序算法的其中一个原因。所以一般来说，性能较好的快速排序会采用原地 (in-place) 排序的方式。</p>
<p>v8 源代码中的实现是对原数组进行元素交换。</p>
<p><strong>Firefox为什么采用归并排序</strong></p>
<p>它的背后也是有故事的。</p>
<p>Firefox其实在一开始发布的时候对于数组排序的实现并不是采用稳定的排序算法，这块有据可考。</p>
<p>Firefox(Firebird)最初版本 实现的数组排序算法是 堆排序，这也是一种不稳定的排序算法。因此，后来有人对此提交了一个Bug。</p>
<p>Mozilla开发组内部针对这个问题进行了一系列讨论。</p>
<p>从讨论的过程我们能够得出几点</p>
<p>1.同时期 Mozilla 的竞争对手是 IE6，从上文的统计数据可知IE6是稳定排序的<br />
</p>
<p>2.JavaScript之父 Brendan Eich 觉得 Stability is good<br />
</p>
<p>3.Firefox在采用 堆排序 之前采用的是 快速排序<br />
</p>
<p>基于开发组成员倾向于实现稳定的排序算法为主要前提，Firefox3 将 归并排序 作为了数组排序的新实现。</p>
<p><strong>解决排序稳定性的差异</strong></p>
<p>以上说了这么多，主要是为了讲述各个浏览器对于排序实现的差异，以及解释为什么存在这些差异的一些比较表层的原因。</p>
<p>但是读到这里，读者可能还是会有疑问：如果我的项目就是需要依赖稳定排序，那该怎么办呢？</p>
<p><strong>解决方案</strong></p>
<p>其实解决这个问题的思路比较简单。</p>
<p>浏览器出于不同考虑选择不同排序算法。可能某些偏向于追求极致的性能，某些偏向于提供良好的开发体验，但是有规律可循。</p>
<p>从目前已知的情况来看，所有主流浏览器（包括IE6，7，8）对于数组排序算法的实现基本可以枚举：</p>
<p><strong>1.归并排序 / Timsort</strong><br />
</p>
<p><strong>2.快速排序</strong><br />
</p>
<p>所以，我们将快速排序经过定制改造，变成稳定排序的是不是就可以了？</p>
<p>一般来说，针对对象数组使用不稳定排序会影响结果。而其他类型数组本身使用稳定排序或不稳定排序的结果是相等的。因此方案大致如下：</p>
<p>将待排序数组进行预处理，为每个待排序的对象增加自然序属性，不与对象的其他属性冲突即可。<br />
自定义排序比较方法compareFn，总是将自然序作为前置判断相等时的第二判断维度。<br />
</p>
<p>面对归并排序这类实现时由于算法本身就是稳定的，额外增加的自然序比较并不会改变排序结果，所以方案兼容性比较好。</p>
<p>但是涉及修改待排序数组，而且需要开辟额外空间用于存储自然序属性，可想而知 v8 这类引擎应该不会采用类似手段。不过作为开发者自行定制的排序方案是可行的。</p>
<p>方案代码示例</p>
<div class="phpstudycode">
<pre class="brush:js;">
'use strict';

const INDEX = Symbol('index');

function getComparer(compare) {
  return function (left, right) {
    let result = compare(left, right);

    return result === 0 &#63; left[INDEX] - right[INDEX] : result;
  };
}

function sort(array, compare) {
  array = array.map(
    (item, index) =&gt; {
      if (typeof item === 'object') {
        item[INDEX] = index;
      }

      return item;
    }
  );

  return array.sort(getComparer(compare));
}</pre>
</div>
<p>以上只是一个简单的满足稳定排序的算法改造示例。</p>
<p>之所以说简单，是因为实际生产环境中作为数组输入的数据结构冗杂，需要根据实际情况判断是否需要进行更多样的排序前类型检测。</p>
<p><strong>标注</strong></p>
<p>1.前端现在已经是一个比较宽泛的概念。本文中的前端主要指的是以浏览器作为载体，以 JavaScript 作为编程语言的环境<br />
</p>
<p>2.本文无意于涉及算法整体，谨以常见的排序算法作为切入点<br />
</p>
<p>3.在确认 Firefox 数组排序实现的算法时，搜到了 SpiderMoney 的一篇排序相关的Bug。大致意思是讨论过程中有人建议用极端情况下性能更好的 Timsort 算法替换 归并排序，但是 Mozilla 的工程师表示由于 Timsort 算法存在License授权问题，没办法在 Mozilla 的软件中直接使用算法，等待对方的后续回复</p>
<p><strong>总结</strong></p>
<p>以上就是大家在前端排序中遇到的问题总结和解决方案，这几年越来越多的项目正在往富客户端应用方向转变，前端在项目中的占比变大。随着未来浏览器计算能力的进一步提升，它允许进行一些更复杂的计算。伴随职责的变更，前端的形态也可能会发生一些重大变化。行走江湖，总要有一技傍身。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/95913.html'>Android重写View并自定义属性实例分析</a><a>下一篇</a><a href='/php/biji/95915.html'>ASP.NET生成两个日期范围内随机时间的实现方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>