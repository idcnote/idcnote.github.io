<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>初步理解Swift中的泛型_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="如果你已经动手写过Swift的程序，相信你已经了解了Swift语言的知识，比如如何写类(class)和结构体(struct)。但Swift可没这么简单，呵呵呵。这篇教程主要讲述Swift的一个强力的特" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">初步理解Swift中的泛型</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>如果你已经动手写过Swift的程序，相信你已经了解了Swift语言的知识，比如如何写类(class)和结构体(struct)。但Swift可没这么简单，呵呵呵。这篇教程主要讲述Swift的一个强力的特</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>如果你已经动手写过Swift的程序，相信你已经了解了Swift语言的知识，比如如何写类(class)和结构体(struct)。但Swift可没这么简单，呵呵呵。这篇教程主要讲述Swift的一个强力的特性：泛型。这个特性在很多程序设计语言里都非常受欢迎。</p>
<p>对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。</p>
<p>在强类型语言中，你需要去定义诸如addInts, addFloats, addDoubles 等方法来正确地处理参数及返回值。</p>
<p>许多编程语言已经解决了这个问题。例如，在C++中，使用Template来解决。而Swift，Java和C#则采用了泛型来解决这个问题。泛型，也是这篇文章要重点介绍的。</p>
<p>在这篇文章中，你将会学到Swift中如何使用泛型，也许你已经接触过，也许没有，不过没关系，我们会来一一探索。然后，我们会创建一个Flicker图片搜索应用，这个应用使用了自定义的泛型数据结构来保存用户搜索的内容。</p>
<p>备注：本文假设你已经对Swift有基本的了解或者有过Swift开发经验。如果你第一次接触Swift或者对Swift不是太了解，建议你首先阅读下other Swift tutorials。</p>
<p><strong>泛型介绍</strong></p>
<p>也许你不知道这个术语，但相信你已经在Swift中见到它了。Swift中的数组和字典类型就是使用泛型的经典例子。</p>
<p>Object-C开发者已经习惯使用数组和字典去保存多种数据类型。这种方式提供了很大的灵活性，但是谁又能知道一个API返回的数组里面到底是啥（数据类型）呢？你唯一能做的就是查看文档或者查看（方法的）变量命令（这也是另外一种文档哟！）。即使你查看了文档，你也不能保证程序在运行期不产生bug或者其他异常。</p>
<p>相比Object-C,Swift中的数组和字典都是类型安全的。一个Int型数组只可以保存Int而不可以保存String。这意味着你不用再查看文档啦，编译器就可以帮你做类型检查，然后你就就快可以愉快地coding了！</p>
<p><br />
例如，在Object-C的UIKit中， 在自定义的View里面处理触摸事件可以这么写：<br />
&nbsp;<br />
<div class="codetitle"><span>程序雏形，并尽快熟悉里面主要的类。其中Flickr类用于和Flickr的API交互。请注意这个类里面包含了一个API key(通常用于用户授权—译者注)，但如果你想要扩展这个应用的话可能需要用自己的key，注册请点我。</p>
<p><br />
构造并运行这个应用，你会看到这个：<br />
</p>
<p></p>
<p>好像什么都没有？别急，用不了多久你就可以让它帮你抓取可爱的喵图了！<br />
有序字典(原文Ordered Dictionaries)</p>
<p>你的应用会根据每个用户的查询情况下载图片，按照图片被搜索到的频率由高到低排序并显示。</p>
<p>但如果用户对同样的关键字搜索了两次会怎样？如果这个应用能显示上次搜索的结果就好了。</p>
<p>或许用数组来实现这个功能也行得通，但为了学习泛型，你将会使用一个全新的数据结构：有序字典。</p>
<p><br />
和数组不同的是，包括Swift在内地很多编程语言和框架都不保证集合(sets)和字典(dictionaries)的数据存储顺序。有序字典和普通的字典类似，不同之处在于它的key是有序的。你将会用这个特性，根据搜索关键字按顺序存储搜索结果。这样存储的好处是可以快速查询并更新图片列表。</p>
<p>一个草率的想法是自定义一个数据结构处理有序字典。但是你需要更加有前瞻性才行！你必须考虑到如何让你的应用在未来几年内都能正常工作！因此在这里使用泛型再合适不过了。<br />
<strong>初始数据结构</strong></p>
<p>点击“文件\新建\文件...”新建一个文件，并选择“IOS\Source\Swift File”。点击“下一步”并把这个文件命名为“OrderedDictionary”。最后，点击“创建”。</p>
<p>你会得到一个空的Swift文件，加这样一段代码进去：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="44672" class="copybut" id="copybut44672" onclick="doCopy('code44672')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code44672">struct OrderedDictionary {&nbsp; }</div></p>
<p>到现在为止应该都没有什么问题。通过语义可以看出这个对象是一个结构体。</p>
<p><br />
注意：总之，值的语义可以想象为“复制、粘贴的行为”，而不是“分享、参考的行为”。值的语义带来一系列的好处，例如不用担心一段代码无意地修改你的数据。了解更多，点击"Swift by Tutorials"的第三章节：类和结构体。</p>
<p>现在你需要将其一般化，以便它能够装载你需要的任何类型的数据。通过下列改变你对Swift中“结构”的定义：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="84193" class="copybut" id="copybut84193" onclick="doCopy('code84193')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84193">struct OrderedDictionary&lt;KeyType, ValueType&gt;</div></p>
<p>在尖括弧中的元素是通用类型的参数。KeyType和ValueType不是他们自身的类型，而是你可以使用在结构里定义取代的类型。现在就简洁清新许多了！</p>
<p>最简单的实现一个有顺序的字典是保持一个数组和一个字典。字典中将会装载衍射，而数组将装载keys的顺序。</p>
<p><br />
在结构体内部的定义中，加入以下的代码：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="65630" class="copybut" id="copybut65630" onclick="doCopy('code65630')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code65630">typealias ArrayType = [KeyType]typealias DictionaryType = [KeyType: ValueType] var array = ArrayType()var dictionary = DictionaryType()</div></p>
<p>这样声明有两个目的，就像上例描述的，有两种类型的用于给已经存在的类型的取新的名称的别名。在这，你将分别地为后面的数组和字典赋值了别名。声明别名是将复杂类型定义为更短名称的类型的一种非常有效的方式。</p>
<p>你将注意怎么样从结构体中定义用“KeyType”和“ValueType”的参数类型中替换类型。上例的"KeyTypes"是数组类型的。当然这是没有这样的类型的“KeyType”；当在一般的实例化时，将替代Swift像对OrderedDictionary的类型的一切类型通过。</p>
<p>就因为这样，你将会注意到编译错误：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="47876" class="copybut" id="copybut47876" onclick="doCopy('code47876')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code47876">Type 'Keytype' does not conform to protocol 'Hashable'</div></p>
<p>或许你会诧异怎么会这样？请再观察下Dictionary的继承者：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="74579" class="copybut" id="copybut74579" onclick="doCopy('code74579')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code74579">struct Dictionary&lt;KeyType: Hashable, ValueType&gt;</div></p>
<p><br />
除了在KeyType之后的HashTable， 其他的都和OrderedDictionary的定义特别的相似。在分号后面为KeyType声明的Hashable，一定符合Hashable的协议。这是因为字典需要为hash key实现。</p>
<p>用这种方式约束泛型参数是非常常见的。例如，你想要依据你的应用使用参数做什么，来约束值的类型以，确保相等性、可打印性协议。</p>
<p>打开OrderedDictionary.Swift，用下例来取代你对结构体的定义：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="94469" class="copybut" id="copybut94469" onclick="doCopy('code94469')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code94469">struct OrderedDictionary&lt;KeyType: Hashable, ValueType&gt;</div></p>
<p>这样为OrderedDictionary声明KeyType，必须符合Hashable。这就意味着，无论KeyType变成什么类型，都可以接受为没有声明的字典的KEY。</p>
<p>这样，文件再次编译，将不会报错！</p>
<p><strong>Keys, Values 和所有的这些趣事</strong></p>
<p>如果不能为字典添加值，那么字典有什么作用了？打开OrderedDictionary.swift，在你的结构体定义中添加以下函数：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="61357" class="copybut" id="copybut61357" onclick="doCopy('code61357')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code61357">// 1mutating func insert(value: ValueType, forKey key: KeyType, atIndex index: Int) -&gt; ValueType&#63;{<br />
&nbsp; var adjustedIndex = index<br />
&nbsp;&nbsp; // 2<br />
&nbsp; let existingValue = self.dictionary[key]<br />
&nbsp; if existingValue != nil {<br />
&nbsp;&nbsp;&nbsp; // 3<br />
&nbsp;&nbsp;&nbsp; let existingIndex = find(self.array, key)!&nbsp;&nbsp;&nbsp;&nbsp; // 4<br />
&nbsp;&nbsp;&nbsp; if existingIndex &lt; index {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adjustedIndex--<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; self.array.removeAtIndex(existingIndex)<br />
&nbsp; }&nbsp;&nbsp; // 5<br />
&nbsp; self.array.insert(key, atIndex:adjustedIndex)<br />
&nbsp; self.dictionary[key] = value<br />
&nbsp;&nbsp; // 6<br />
&nbsp; return existingValue}</div></p>
<p>下面介绍一些新的特性。让我们一步一步来介绍：</p>
<ul>
<li>&nbsp;&nbsp;&nbsp; 插入一个新对象的方法，insert(_:forKey:atIndex),需要三个参数：一个特别的key的值，插入一对key-value的索引。这是你之前没有注意到的一个关键字：改变。</li>
<li>&nbsp;&nbsp;&nbsp; 结构体的设计是默认不变的，这意味着通常你在实例化的方法中，不能改变结构的成员变量。这十分有限，你能添加改变的关键字，并告诉编译器这个方式在结构体中是允许改变的。这将帮助编译器做出决定什么时候复制结构体（他们是写时复制的），也有助于API的编档。</li>
<li>&nbsp;&nbsp;&nbsp; 你为字典的索引器输入一个如果已经存在，那么返回已存在的值的key，这个插入方法模拟字典更新值相同的行为，因此为这个值保持已经存在的值。</li>
<li>&nbsp;&nbsp;&nbsp; 如果这有一个已经存在的值，只有这样函数才能为这个值在数组里找出索引。</li>
<li>&nbsp;&nbsp;&nbsp; 如果这个已经存在的key在插入索引的之前，这时你需要调整插入的索引，因为你需要移除已经存在的key。</li>
<li>&nbsp;&nbsp;&nbsp; 你将适当地更新数组和字典。</li>
<li>&nbsp;&nbsp;&nbsp; 最后，你返回已存在的值，当这或许没有已存在的值，这个函数返回一个可选的值！</li>
</ul>
<p><br />
现在你可以为字典添加移除值？</p>
<p>像下列对OrderedDictionary结构体的定义的函数：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="60694" class="copybut" id="copybut60694" onclick="doCopy('code60694')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60694">// 1mutating func removeAtIndex(index: Int) -&gt; (KeyType, ValueType){<br />
&nbsp; // 2<br />
&nbsp; precondition(index &lt; self.array.count, "Index out-of-bounds")&nbsp;&nbsp; // 3<br />
&nbsp; let key = self.array.removeAtIndex(index)&nbsp;&nbsp; // 4<br />
&nbsp; let value = self.dictionary.removeValueForKey(key)!&nbsp;&nbsp; // 5<br />
&nbsp; return (key, value)}</div></p>
<p>现在再让我们一步一步分析：</p>
<p>1.这是改变结构体状态的函数，removeAtIndex的名称需要和数组的方法匹配。恰当的时候，考虑使用镜像系统库中API是不错的选择。这样帮助开发者在他们的工作平台里，非常容易地使用你的API。</p>
<p>2.首先，你需要检查索引，观察他们是否是在大量的数组里。尝试着从未声明的数组中移除越位的元素，将会导致超时错误，所有在这时检查将会更早符合这样的情况。你或许在Objective-C中使用断言函数；在Swift中断言也是可使用的。但是前提是在释放的工程中是活动的，否则你运行的应用的将会终止。</p>
<p>3.接着，当同时从数组中移除值时，你在给定的索引中数组中获得值。</p>
<p>4.然后，你从字典中为这个key移除的值，同时也会返回这个值。或许在给出的key中，字典也没有相应的值，所以removeValueForKey返回一个可选的。这种情况下，你知道字典将会为给出的key，包含一个值，因为这是唯一的自己给字典添加值的方法--insert(_:forKey:atIndex:),这时你可以选择使用“！”，表明这将会有正义感值。</p>
<p>5.最后，你在一个元组返回的key和value。数组的removeAtIndex和字典的removeValueForKey是一样的返回已存在的值功能。</p>
<p><strong>值的读取跟写入</strong></p>
<p>把值写入字典(dictionary)是没问题了, 可是这样还不够! 你还需要实现一个方法(method) 从字典中读出相应的值.</p>
<p>打开 OrderedDictionary.swift 文件, 然后把下列代码添加到结构定义(struct definition)当中, , 就放在 thearrayanddictionaryvariable 声明的下面:<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="83011" class="copybut" id="copybut83011" onclick="doCopy('code83011')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code83011">var count: Int {<br />
&nbsp; return self.array.count}</div></p>
<p>这个常用的属性, 用来算出字典里面有几条记录. 只要返回数组的 count 属性的中值就可以了!</p>
<p>接下来, 就是如何访问(Access)字典中的记录了(Element). 我们可以通过下标(Subscript)来访问, 代码如下:<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="56712" class="copybut" id="copybut56712" onclick="doCopy('code56712')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code56712">let dictionary = [1: "one", 2: "two"]let one = dictionary[1] // Subscript</div></p>
<p>下标的语法我们会用了, 但是如果是我们自己定义的类那该怎么用呢&#63; 好在 Swift 支持在自定义类里头添加这项功能. 而且实现起来也不复杂.</p>
<p><br />
把下列代码添加到结构定义的底部:<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="9050" class="copybut" id="copybut9050" onclick="doCopy('code9050')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code9050">// 1<br />
subscript(key: KeyType) -&gt; ValueType&#63; {<br />
&nbsp; // 2(a)<br />
&nbsp; get {<br />
&nbsp;&nbsp;&nbsp; // 3<br />
&nbsp;&nbsp;&nbsp; return self.dictionary[key]<br />
&nbsp; }<br />
&nbsp; // 2(b)<br />
&nbsp; set {<br />
&nbsp;&nbsp;&nbsp; // 4<br />
&nbsp;&nbsp;&nbsp; if let index = find(self.array, key) {<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.array.append(key)<br />
&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; // 5<br />
&nbsp;&nbsp;&nbsp; self.dictionary[key] = newValue&nbsp; <br />
&nbsp; }<br />
}</div></p>
<p>我们详细解释下这段代码:</p>
<ul>
<li>&nbsp;&nbsp;&nbsp; 上面代码注释中标有 1 的那一段:跟 func 和 var 类似, subscript 也是个关键字, 通过它定义下标.&nbsp; 参数 key 是出现在中括号中的那个对象.</li>
<li>&nbsp;&nbsp;&nbsp; 注释中标有 2 的那一段: 下标由 setter 跟 getter 两部分组成. 本例同时定义了 setter (代码中的 set&nbsp; ) 跟 getter (代码中的 get ). 当然, 不是每个下标都要同时定义 setter 跟 getter.</li>
<li>&nbsp;&nbsp;&nbsp; 注释中标有 3 的那一段: getter 比较简单, 只要通过参数 key, 在字典中找到相应的值即可. 字典返回的是可选值(optinal), 如果 key 不存在, 该值为 nil.</li>
<li>&nbsp;&nbsp;&nbsp; 注释中标有 4 的那一段: setter 就复杂些. 首先要检测这个 key 在有序字典里面是不是已经存在. 如果不存在, 则把 key 添加到数组中. 由于我们需要把 key 添加到数组的尾部, 所以这里调用的是 append 方法.</li>
<li>&nbsp;&nbsp;&nbsp; 注释中标有 5 的那一段: 把值添加到字典中. 这里用隐性命名的变量 newValue 获取传递过来的值.</li>
</ul>
<p>就像用 Swift 自带的字典类的下标那样去, 你可以通过 key 来查找某个值. 可是如果我们需要像访问数组那样, 用下标索引(index)访问某个值, 该怎么办呢&#63; 既然是有序字典, 没有道理不能通过下标索引一个一个的按顺序访问.</p>
<p><br />
结构体跟类可以定义多个参数类型不同的下标(subscript). 把下列代码添加到结构定义的底部:<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="52035" class="copybut" id="copybut52035" onclick="doCopy('code52035')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code52035">subscript(index: Int) -&gt; (KeyType, ValueType) {<br />
&nbsp; // 1<br />
&nbsp; get {<br />
&nbsp;&nbsp;&nbsp; // 2<br />
&nbsp;&nbsp;&nbsp; precondition(index &lt; self.array.count, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Index out-of-bounds")&nbsp;&nbsp;&nbsp;&nbsp; // 3<br />
&nbsp;&nbsp;&nbsp; let key = self.array[index]&nbsp;&nbsp;&nbsp;&nbsp; // 4<br />
&nbsp;&nbsp;&nbsp; let value = self.dictionary[key]!&nbsp;&nbsp;&nbsp;&nbsp; // 5<br />
&nbsp;&nbsp;&nbsp; return (key, value)<br />
&nbsp; }}</div></p>
<p>这段代码跟前面那段类似, 不同的是参数类型变成了 Int. 因为我们现在要实的功能是现像数组那样, 使用下标索引访问有序字典. 不过这次返回的是由 key 跟 value 组成的一个元组(tuple). 因为有序字典就是由这样一个一个的元组构成的.</p>
<p>下面具体解释下这段代码:</p>
<ul>
<li>&nbsp;&nbsp;&nbsp; 这个下标只定义了 getter. 当然你也可以把 setter 加上. 不过要注意先检查 index 会不会越界.</li>
<li>&nbsp;&nbsp;&nbsp; index 的值不能超出数组的界限, 也就是字典元组的个数. 我们可以利用 precondition 提示开发人员, 程序出现越界访问.</li>
<li>&nbsp;&nbsp;&nbsp; 用 index 从数组中读出 key.</li>
<li>&nbsp;&nbsp;&nbsp; 再用 key 从字典中读取 value. 需要注意的是, 由于数组中的每一个 key 跟字典的 value 是一一对应的, 所以这里使用符号 ! (unwrapped) 对读出来的 value 拆包.</li>
<li>&nbsp;&nbsp;&nbsp; 最后, 返回一个包含 key 和 value 的元组.</li>
</ul>
<p><br />
挑战: 为上面那个下标实现 setter . 可以参考前面的例子.<br />
提示 1 &nbsp;</p>
<p><br />
&nbsp;注意, newValue 是个包含 key 跟 value 的元组.</p>
<p>&nbsp;<br />
提示 2 &nbsp;</p>
<p><br />
&nbsp;下列代码可以将值从元组中提取出来:<br />
&nbsp;<div class="codetitle"><span><a style="CURSOR: pointer" data="76197" class="copybut" id="copybut76197" onclick="doCopy('code76197')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76197">let(key, value) = newValue</div></p>
<p>&nbsp;</p>
<p>也许你会好奇, 如果 KeyType 是 Int 型的, 会出现什么问题&#63; 使用泛型的好处是, 不管是什么类型, 只要能算出哈希值(hashable)的就行,&nbsp; 所以 Int 当然也能用.&nbsp; 问题是, 当 key 也是 Int 型的时候, 这俩个下标该怎么区分呢&#63;</p>
<p>这就需要我们给编译器提供更多的类型信息. 让它知道在什么时调用哪个下标. 比如我们定义的这两个下标, 返回的类型不一样. 如果你用 key-value 类型的元组给它赋值, 编译器就会自动调用那个数组式(array-style )的下标.</p>
<p><strong>在项目中测试</strong></p>
<p>让我们在实际项目中，实验编译推断使用的下标函数，以及一般情况下，OrderedDictionary是怎么工作的。</p>
<p>通过点击"文件"、"创建"、"文件"，新建一个项目，依次选择"IOS"、"Source"、"Playground"，再点击下一步。然后点击创建。</p>
<p>你必须得这样操作：复制和粘贴OrderedDictionary.swift整体到新建的项目中。因为不能在写教程时你的应用模型中”看见”代码</p>
<p>注意：这有一个解决方法，可以取代复制、粘贴的方式。如果你需要将你应用的代码加入到一个框架中，你的项目将接受的你代码，就像Corrine Krych指出的这样。</p>
<p><br />
现在，在你的项目底部加入下列的代码：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="3710" class="copybut" id="copybut3710" onclick="doCopy('code3710')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code3710">var dict = OrderedDictionary&lt;Int, String&gt;()dict.insert("dog", forKey: 1, atIndex: 0)dict.insert("cat", forKey: 2, atIndex: 1)println(dict.array.description <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + " : " <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + dict.dictionary.description) var byIndex: (Int, String) = dict[0]println(byIndex) var byKey: String&#63; = dict[2]println(byKey)</div></p>
<p>在侧栏中（或者通过视图/助理编辑/显示助理编辑/），你将可以看到println()函数输出的内容：<br />
</p>
<p></p>
<p>在这个例子中，字典有一个整数型的key，所以编译器会审查被使用分配决定使用哪个下标变量的类型。如果被使用的下标是一个(Int, String)的byIndex，编译器会匹配期望的返回值类型，使用数组类型的索引的下标。</p>
<p>如果你想从一个 byIndex 或者 byKey的变量中，移除类型的定义。编译器将会报错，表明编译器不知道使用哪一个下标。</p>
<p><br />
小贴士：由于编译器是按照类型推理来工作的，所以需要明确地表示出类型。当存在多个有相同的争议的返回值类型的函数时，调用者需要具体化。需要注意：Swift中函数，可以“建-破”改变。</p>
<p>通过在项目中，对有顺序的字典的实验中，你可以发现他的工作原理。在重返app之前，尝试从中添加、移除、以及改变key和value的类型。现在，你可以在你的顺序字典中读、写操作！但要小心你的数据结构。现在你可以通过app来感受其中的乐趣了！</p>
<p><strong>添加图片查找</strong></p>
<p>现在是时候让你回过头来注意手中的app了。打开 MasterViewController.swift。在两个@IBOutlets 的下面，添加下列变量的定义：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="68057" class="copybut" id="copybut68057" onclick="doCopy('code68057')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code68057">var searches = OrderedDictionary&lt;String, [Flickr.Photo]&gt;()</div></p>
<p>你或许在困惑，为什么Flickr.Photo的类型中有个句号。那是因为Photo是在Flickr类的内部定义的类。在Swift中，这样的层次结构是非常有利的。它将有助于类的名称简短化。在Flickr的内部，你可以单独使用Photo类，因为上下文关系告诉了编译器这是什么。这是顺序化字典查询用户订阅的Flickr的功能。真像你看到的，包含查询的字符串，和Flickr.Photo数组，或是从Flickr API 中返回的照片。注意，你在尖括号里给出的key和value，将成为在具体实现中KeyType和ValueType的参数类型。</p>
<p><br />
接下来，找到表格视图数据源的tableView(_:numberOfRowsInSection:)方法，然后把它改为如下所示：<br />
&nbsp;<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="1574" class="copybut" id="copybut1574" onclick="doCopy('code1574')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code1574">func tableView(tableView: UITableView, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numberOfRowsInSection section: Int) -&gt; Int{<br />
&nbsp; return self.searches.count}</div></p>
<p>这个方法使用有序字典来告诉表格视图有多少行。接着，找到表格视图数据源的tableView(_:cellForRowAtIndexPath:)方法并把它改为如下所示：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="74466" class="copybut" id="copybut74466" onclick="doCopy('code74466')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code74466">&nbsp;<br />
func tableView(tableView: UITableView, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cellForRowAtIndexPath indexPath: NSIndexPath)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; UITableViewCell{<br />
&nbsp; // 1<br />
&nbsp; let cell = <br />
&nbsp;&nbsp;&nbsp; tableView.dequeueReusableCellWithIdentifier("Cell", <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forIndexPath: indexPath) as UITableViewCell&nbsp;&nbsp; // 2<br />
&nbsp; let (term, photos) = self.searches[indexPath.row]&nbsp;&nbsp; // 3<br />
&nbsp; if let textLabel = cell.textLabel {<br />
&nbsp;&nbsp;&nbsp; textLabel.text = "\(term) (\(photos.count))"<br />
&nbsp; }<br />
&nbsp; return cell}</div></p>
<p>这是你在这个方法中所做的：</p>
<p>1. 首先，从UITableView中挪出一个单元格。你需要把它直接转换为UITableViewCell，因为dequeueReusableCellWithIdentifier仍旧返回AnyObject(id in Objective-C)，而不是UITableViewCell。或许在将来，苹果公司会利用泛型重写这部分API。</p>
<p>2. 接着，用你给的下标索引从指定的行获取Key和Value，</p>
<p>3. 最后，适当地设置单元格的文本标签并且返回当前单元格。</p>
<p><br />
现在让我们尝尝鲜。找到UISearchBarDelegate 的拓展，就像下列的代码一样，改变单例方法。<br />
&nbsp;<div class="codetitle"><span><a style="CURSOR: pointer" data="82347" class="copybut" id="copybut82347" onclick="doCopy('code82347')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code82347"><br />
func searchBarSearchButtonClicked(searchBar: UISearchBar!) {<br />
&nbsp; // 1<br />
&nbsp; searchBar.resignFirstResponder()&nbsp;&nbsp; // 2<br />
&nbsp; let searchTerm = searchBar.text<br />
&nbsp; Flickr.search(searchTerm) {<br />
&nbsp;&nbsp;&nbsp; switch ($0) {<br />
&nbsp;&nbsp;&nbsp; case .Error:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 3<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break&nbsp;&nbsp;&nbsp; case .Results(let results):<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.searches.insert(results, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forKey: searchTerm, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atIndex: 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 5<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.tableView.reloadData()<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }}</div></p>
<p>当用户点击查询按钮时，这个方法将会被调用。下列就是在这个方法中，你正做的事：</p>
<p>1.你第一反应是放弃使用查询框以及键盘。</p>
<p>2.然后，你又会使用搜索框查询你输入的文字，为查询的文字而使用Flickr类来寻找。Flickr的查询方法是：查询术语，关闭执行查询成功或者失败。通过参数关闭：要不是错误，那就是结果。</p>
<p>3.在错误的情况下，不会发生任何事。但是你可以通过使用警报来提示错误，但是现在我们可以简化这样的操作。代码需要在这时暂停会儿，告诉Swfit编译器你的错误没有任何反应的动机。</p>
<p>4.如果查询有效，将会在查询结果中显示相关的值。你将查询的术语作为key加入到顺序字典中。如果已经在字典中存在了，将会把他放入到list的顶部，然后用最后的结果更新整个字典。</p>
<p>5.最终，由于你有新的数据，将再次加载table view。</p>
<p>哇！你的app将可以用于查询图片了！</p>
<p><br />
构建并运行app，做几次查询。你将会看到下面这样的一些东西:<br />
</p>
<p></p>
<p>现在再用与之前搜索词不同的另外一个进行查询. 你将会看到它跳到了顶部:<br />
</p>
<p></p>
<p>选择一个查询结果点击去，你会发现它并没有显示照片。现在是时候修复这个问题了!<br />
给我看照片!</p>
<p>打开MasterViewController.swift 并找到 prepareForSegue. 将它修改成下面这样:<br />
&nbsp;<div class="codetitle"><span><a style="CURSOR: pointer" data="32145" class="copybut" id="copybut32145" onclick="doCopy('code32145')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code32145"><br />
override func prepareForSegue(segue: UIStoryboardSegue, <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sender: AnyObject&#63;){<br />
&nbsp; if segue.identifier == "showDetail" {<br />
&nbsp;&nbsp;&nbsp; if let indexPath = self.tableView.indexPathForSelectedRow()<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let (_, photos) = self.searches[indexPath.row]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (segue.destinationViewController&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as DetailViewController).photos = photos&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }}</div></p>
<p>这是用了同创建单元项时访问被排好序的查询结果字典一样的方法. 尽管没有使用关键词(检索词), 你也可以用下划线来显示出元组的这个部分不需要被绑定到一个本地变量.</p>
<p><br />
构建并运行app，做一次查询然后点进去。你会看到像下面这样的东西:<br />
</p>
<p></p>
<p>你好，小猫猫! 你有没有想要发出快乐的呼声呢&#63; :]<br />
</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/99412.html'>iOS App使用SQLite之句柄的定义及数据库的基本操作</a><a>下一篇</a><a href='/php/biji/99414.html'>Win7提示windows可能没有合适的权限访问文件</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>