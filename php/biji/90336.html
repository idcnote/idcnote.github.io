<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>iOS App设计模式开发之适配器模式使用的实战演练_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="相信做App开发的同学，对于一些第三方的统计分析、错误收集等SDK应该都不陌生。就目前而言市面上也有许多相同功能的产品，眼花缭乱，让人无法抉择选哪一款SDK才是最靠谱的。那就" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">iOS App设计模式开发之适配器模式使用的实战演练</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>相信做App开发的同学，对于一些第三方的统计分析、错误收集等SDK应该都不陌生。就目前而言市面上也有许多相同功能的产品，眼花缭乱，让人无法抉择选哪一款SDK才是最靠谱的。那就</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>相信做App开发的同学，对于一些第三方的统计分析、错误收集等SDK应该都不陌生。就目前而言市面上也有许多相同功能的产品，眼花缭乱，让人无法抉择选哪一款SDK才是最靠谱的。那就随便先选一款试试用吧！</p>
<p>那么问题来了：如果项目都快做完了结果发现这款SDK实在坑爹，不仅扩展性差，还经常让App Crash，那你是不是会想到替换掉这个SDK？</p>
<p>OK，那我们就换另一个试试，下载SDK下来，一看，傻眼了，设计风格，封装模块完全不一样，于是乎我们就到项目中全局搜索找到之前的SDK代码干掉，然后重新再到各种地方用新的SDK来写新的逻辑来替换，关键的是，中间还不知道会产生多少bug，漏掉多少未修改的代码，总之始终会有一种不靠谱的感觉。</p>
<p>换一次还算好的，如果之后团队壮大了，这些数据分析之类的东西突然想自己做了，毕竟这些有价值的数据并不想这么拱手让给一个第三方的公司嘛~这个时候你是不是就只想说：『呵呵』</p>
<p>所以这个时候适配器模式就起到作用了~</p>
<p><strong>何为适配器模式<br />
</strong>GoF对于适配器模式的解释如下：</p>
<p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。<br />
个人通俗理解：</p>
<p>适配器：顾名思义，将不兼容的转换为兼容，如电源适配器，将全世界各种不相同的电压转换成相同的电压输出给目标设备。</p>
<p>这里可以将目标设备理解为『接口』，世界各种电压可以理解为『产生相同功能的类』，电源适配器可以理解为『需要实现的适配器类』。</p>
<p>适配器模式产生的效果是：在不修改代码或者修改极少代码的情况下，快速的切换源（数据源、内容源等）。</p>
<p>就像电源适配器一样，去到不同国家，同一个设备只需要不同的电源适配器就可以使用当前国家的电源，而不需要取拆卸机器。</p>
<p><strong>使用真实场景<br />
</strong>如文章开头所讲，被某盟的SDK坑了之后（确实在某些状况下让App Crash，产生原因初步判断是滥用performSelector，不考虑对象被释放的情况而产生的Crash），产生替换念想而思考，如果将来替换岂不是又要苦逼我们自己？</p>
<p>于是乎为了将来的轻松就必须动动脑子去设计代码了，于是有了今天的适配器模式实战。</p>
<p><strong>如何使用适配器模式<br />
</strong>一个适配器允许接口不兼容的类在一起工作。它把它自己包裹成一个对象，公开一个与这个对象相互作用的标准接口。</p>
<p>如果你熟习适配器模式，你会注意到苹果实施它的时候有一点不同的习惯─苹果使用协议 (protocols)。你可能熟习像 UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying 这样的协议。例子，NSCopying 的协议 (protocol)，任何类都可以提供这样一个标准的复制方法。</p>
<p>我们提到的滚动区域是这样的：<br />
</p>
<p></p>
<p>现在开始，在项目导航的 View 文件夹上右击鼠标，选择 New File…，用 iOS\Cocoa Touch\Object-C class 模板创建一个新类。新类的名字叫 HorizontalScroller，选择它的子类为 UIView。</p>
<p>打开 HorizontalScroller.h 文件在 @end 后面插入如下代码：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="30257" class="copybut" id="copybut30257" onclick="doCopy('code30257')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code30257"><br />
@protocol HorizontalScrollerDelegate &lt;NSObject&gt;<br />
// methods declaration goes in here<br />
@end<br />
</div><br />
这里定义一个 HorizontalScrollerDelegate 名字的协议，它继承于 NSObject 协议，同样的这是继承它父类的一个 Objective-C 类。符合 NSObject 协议，这是一个很好的做法─或者遵照 NSObject 协议。这能使你从定义的 NSObject 发送消息到 HorizontalScroller 的代理。你将会看到为什么这很重要。</p>
<p>定义个代理执行的方法，要在 @protocol 和 @end 之间，它们分为必要方法和可选方法。添加下面协议方法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="21971" class="copybut" id="copybut21971" onclick="doCopy('code21971')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code21971"><br />
@required<br />
// 询问 delegate 在滚动区域里有多少个视图要被显示<br />
- (NSInteger)numberOfViewsForHorizontalScroller:&nbsp;&nbsp;&nbsp; (HorizontalScroller*)scroller;</p>
<p>// 返回索引是 index 的视图<br />
- (UIView*)horizontalScroller:(HorizontalScroller*)scroller viewAtIndex:(int)index;</p>
<p>// 当索引是 index 的视图被点击了，通知 delegate <br />
- (void)horizontalScroller:(HorizontalScroller*)scroller clickedViewAtIndex:(int)index;</p>
<p>@optional<br />
// 通知 delegate，显示初始化时索引是 Index 的视图。这个方法是可选的<br />
// ask the delegate for the index of the initial view to display. this method is optional<br />
// 如果没有被 delegate 执行，默认值是 0<br />
- (NSInteger)initialViewIndexForHorizontalScroller:(HorizontalScroller*)scroller;<br />
</div><br />
这里我们必选的和可选的方法我们都定义了。必选方法一定要被代理执行，它通常包含一些类必须要执行的数据。这里，必选方法是获取视图的数量，当前显示视图的索引和当视图被点击的时候执行的操作。可选方法这里是初始化视图；如果没有执行 HorizontalScroller 将会显示第一个索引的视图。</p>
<p>接下来，你需要在 HorizontalScroller 内部定义你的新代理。但是协议的定义在类的定义下面，因此在这点上它是不可见的。你该怎么办？</p>
<p>解决办法就是在前面声明协议以便于编译器（和Xcode）知道这个协议是可用的。好了，在 @interface 上面加入下面代码：<br />
[/ode]<br />
@protocol HorizontalScrollerDelegate;<br />
[/code]<br />
还是 HorizontalScroller.h，在 @interface 和 @end 之间加入下面代码：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="99945" class="copybut" id="copybut99945" onclick="doCopy('code99945')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code99945"><br />
@property (weak) id&lt;HorizontalScrollerDelegate&gt; delegate;<br />
- (void)reload;<br />
</div><br />
这个属性被定义成为一个 weak。这是为了防止循环 retain。如果一个类保持一个强指针(strong pointer)指向它的委托(delegate)，同时委托也保持一个强指针指向这个类，在释放类所占用的内存时会造成 app 内存泄漏。</p>
<p>id 的意思是把这个代理指定给一个类，它遵照 HorizontalScrollerDelegate，给你一些类型安全。</p>
<p>reload 方法是模仿 UITableView 类的 relaodData；它重新加载所有数据用来创建一个水平移动视图。</p>
<p>用下面代码替换 HorizontalScroller.m 的内容：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="39466" class="copybut" id="copybut39466" onclick="doCopy('code39466')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code39466"><br />
#import “HorizontalScroller.m”</p>
<p>#define VIEW_PADDING 10<br />
#define VIEW_DIMENSIONS 100<br />
#define VIEW_OFFSET 100</p>
<p>@interface HorizontalScroller () &lt;UIScrollViewDelegate&gt;<br />
@end<br />
</div><br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="20903" class="copybut" id="copybut20903" onclick="doCopy('code20903')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code20903"><br />
@implementation HorizontalScroller<br />
{<br />
&nbsp;&nbsp;&nbsp; UIScrollView *scroller;<br />
}<br />
@end<br />
</div><br />
来解释下每块代码：</p>
<p>常量定义，在设计时间可以方便修改布局。在滚动视图内，每个图片的大小在一个 100×100 内边距为 10 点(point) 的矩形内。<br />
HorizontalScroller 遵照 UIScrollViewDelegate 协议。因为 HorizontalScroller 使用一个 UIScrollView 来滚动专辑封面，它需要知道用户什么时候停止滚动。<br />
创建一个包含图片的滚动视图。<br />
接下来你需要执行初始化。添加下面的方法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="3149" class="copybut" id="copybut3149" onclick="doCopy('code3149')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code3149"><br />
- (id)initWithFrame:(CGRect)frame<br />
{<br />
&nbsp;&nbsp;&nbsp; self = [super initWithFrame:frame];<br />
&nbsp;&nbsp;&nbsp; if (self) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scroller = [[UIScrollerView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scroller.delegate = self;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UITapGestureRecognizer *tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarger:self action:@select(scrollerTapped:)];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [scroller addGestureRecognizer:tapRecognizer];<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; return self;<br />
}<br />
</div><br />
HorizontalScroller 将被滚动视图整个填充。如果一个专辑封面被点击，UITapGestureRecognizer 将会监听它上面的事件。如果有，它会通知 HorizontalScroller 的代理。</p>
<p>现在添加下面方法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="29853" class="copybut" id="copybut29853" onclick="doCopy('code29853')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code29853"><br />
- (void)scrollerTapped:(UITapGestureRecognizer*)gesture<br />
{<br />
&nbsp;&nbsp;&nbsp; CGPoint location = [gesture locationInView:gesture.view];<br />
&nbsp;&nbsp;&nbsp; // we can't use an enumerator here, because we don't want to enumerate over ALL of the UIScrollView subviews.<br />
&nbsp;&nbsp;&nbsp; // we want to enumerate only the subview that we added<br />
&nbsp;&nbsp;&nbsp; for (int index=0; index&lt;[self.delegate numberOfViewForHorizontalScroller:self]; index++) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UIView *view = scroller.subviews[index];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (CGRectContainsPoint(view.frame, location)) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [self.delegate horizontalScroller:self clickedViewAtIndex:index];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [scroller setContentOffset:CGPointMake(view.frame.origin.x - self.frame.size.width/2 + view.frame.size.width/2, 0) animated:YES];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</div><br />
手势操作就如同传入的一个参数，可以从 locationInView: 获取定位信息。</p>
<p>接下来，调用委托的 numberOfViewForHorizontalScroller: 方法。它必须遵照 HorizontalScrollerDelegate 的协议安全发送消息，否则 HorizontalScroller 实例的代理是没法使用这些信息。</p>
<p>滚动视图里的每个视图，用 CGRectContainsPoint 执行一个点击测试，找到那个被点击的视图。当视图被找到，发送给委托一个消息 horizontalScroller:clickedViewAtIndex:。当你跳出这个循环后，设置被点击的视图滚动到视图中间。</p>
<p>现在添加下面的代码，用来刷新滚动视图(scroller):<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="49743" class="copybut" id="copybut49743" onclick="doCopy('code49743')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49743"><br />
- (void)reload<br />
{<br />
&nbsp;&nbsp;&nbsp; // 1 - nothing to load if there's no delegate<br />
&nbsp;&nbsp;&nbsp; if (self.delegate == nil) return;</p>
<p>&nbsp;&nbsp;&nbsp; // 2 - remover all subviews<br />
&nbsp;&nbsp;&nbsp; [scroller.subviews enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [obj removeFromSuperview];<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; // 3 - xValue is the starting point of the views inside the scroller<br />
&nbsp;&nbsp;&nbsp; CGFloat xValue = VIEWS_OFFSET;<br />
&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;[self.delegate numberOfViewsForHorizontalScroller:self]; i++) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 4 - add a view at the right position<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xValue += VIEW_PADDING;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UIView *view = [self.delegate horizontalScroller:self viewAtIndex:i]<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; view.frame = CGRectMake(xValue, VIEW_PADDING, VIEW_DIMENSIONS, VIEW_DIMENSIONS);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xValue += VIEW_DIMENSIONS + VIEW_PADDING;<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; // 5<br />
&nbsp;&nbsp;&nbsp; [scroller setContentSize:CGSizeMake(xValue+VIEWS_OFFSET, self.frame.size.height)];</p>
<p>&nbsp;&nbsp;&nbsp; // 6 - if an initial view is defined, center the scroller on it<br />
&nbsp;&nbsp;&nbsp; if (self.delegate respondsToSelector:@select(initialViewIndexForHorizontalScroller:)]) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int initialView = [self.delegate initialViewIndexForHorizontalScroller:self];<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [scroller setContentOffset:CGPointMake(initialView*(VIEW_DIMENSIONS+(2*VIEW_PADDING)), 0) animated:YES];<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</div><br />
能过代码一步步来讨论：</p>
<p>如果没有代理，这里什么事情也不做。<br />
移除之前添加的所有的子视图。<br />
给所有视图设置一个偏移(offset)位置。现在的是 100，但是通过顶部的 #define，它很容易修改。<br />
HorizontalScroller 通过它的委托一次请求一个视图，用之前定义的 padding 值把它们依次的一个个放置下来。<br />
当所有的视图都生成好，通过设置滚动视图内容的偏移量以达到用户能过滚动可以看到所有专辑封面的目的。<br />
HorizontalScroller 的委托需要验证是否响应了 initialViewIndexForHorizontalScroller: 方法。这个验证是必需的，因为这个特别的协议方法是可选性的。如果代理没有执行这个方法，它的默认值会是 0。最终，通过委托，这块代码会在滚动视图中间设置一个初始化好的视图。<br />
当数据发生改变的时候执行 reload 方法。当添加 HorizontalScroller 到别个一个视图时，你同样可以执行这个方法。在 HorizontalScroller.m 添加下面的代码替换后面的方案：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="16631" class="copybut" id="copybut16631" onclick="doCopy('code16631')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16631"><br />
- (void)didMoveToSuperview<br />
{<br />
&nbsp;&nbsp;&nbsp; [self reload];<br />
} <br />
</div><br />
当它要添加一个子视图的时候，didMoveToSuperview 会发送消息给视图。这时正好可以更新滚动视图的内容。</p>
<p>HorizontalScroller 的最后一个难题就是，如何设置你看到的专辑总是在滚动视图的中间。为了这些，当用户通过他们的手指拖动滚动视图的时候你就需要做一些计算了。</p>
<p>添加下面方法（同样在 HorizontalScroller.m）：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="15967" class="copybut" id="copybut15967" onclick="doCopy('code15967')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code15967"><br />
- (void)centerCurrentView {<br />
&nbsp;&nbsp;&nbsp; int xFinal = scroller.contentOffset.x + (VIEWS_OFFSET/2) + VIEW_PADDING;<br />
&nbsp;&nbsp;&nbsp; int viewIndex = xFinal / (VIEW_DIMENSIONS + (2*VIEW_PADDING));<br />
&nbsp;&nbsp;&nbsp; xFinal = viewIndex * (VIEW_DIMENSIONS+(2*VIEW_PADDING));<br />
&nbsp;&nbsp;&nbsp; [scroller setContentOffset:CGPointMake(xFinal, 0) animated:YES];<br />
&nbsp;&nbsp;&nbsp; [self.delegate horizontalScroller:self clickedViewAtIndex:viewIndex];<br />
}<br />
</div><br />
上面的代码通过滚动视图的当前偏移量，外观尺寸，内边距来计算当前视图离中心的距离。最后一行非常重要：当一个视图居中后，你需要通知委托你选择的视图改变了。</p>
<p>为了侦测用户在滚动视图内完成拖拽的动作，你需要添加 UIScrollViewDelegate 方法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="91400" class="copybut" id="copybut91400" onclick="doCopy('code91400')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code91400"><br />
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate<br />
{<br />
&nbsp;&nbsp;&nbsp; if (!decelerate)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [self centerCurrentView];<br />
&nbsp;&nbsp;&nbsp; }<br />
}</p>
<p>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView<br />
{<br />
&nbsp;&nbsp;&nbsp; [self centerCurrentView];<br />
}<br />
</div><br />
当用户完成拖拽的时候 scrollViewDidEndDragging:willDecelerate: 通知委托。如果滚动视图没有停止滚动， decelerate 参数会返回 true。当滚动结束，系统将会调用 scrollViewDidEndDecelerating。当用户拖动滚动当前视图后，两种情况，我们都需要调用一个新方法来使当前视图居中。</p>
<p>HorizontalScroller 现在可以使用了。浏览你刚刚写的代码；这里没有一处提到 Album 和 AlbumView 类。这非常棒，说明这个新的滚动视图是真正的完全独立的和可重用的。</p>
<p>Build 项目，确保所有的代码编译正确。</p>
<p>现在 HorizontalScroller 完成了，是时候在你的 APP 中使用了。打开 ViewController.m 添加如下引用：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="65101" class="copybut" id="copybut65101" onclick="doCopy('code65101')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code65101"><br />
#import “HorizontalScroller.h”<br />
#import “AlbumView.h”<br />
</div><br />
给 ViewController 添加 HorizontalScrollerDelegate：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="17440" class="copybut" id="copybut17440" onclick="doCopy('code17440')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code17440"><br />
@interface ViewController () &lt;UITableViewDataSource, UITableViewDelegate, HorizontalScroller&gt;<br />
</div><br />
在类的扩展里为水平滚动视图添加如下实例变量：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="60424" class="copybut" id="copybut60424" onclick="doCopy('code60424')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60424"><br />
HorizontalScroller *scroller;<br />
</div><br />
现在你可以执行代理方法了；你会惊奇的发现只需要几行代码你就能实现很多功能。</p>
<p>在 ViewController.m 添加如下代码：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="84587" class="copybut" id="copybut84587" onclick="doCopy('code84587')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84587"><br />
#pragma mark - HorizontalScrollerDelegate methods<br />
- (void)horizontalScroller:(HorizontalScroller *)scroller clickedViewAtIndex:(int)index<br />
{<br />
&nbsp;&nbsp;&nbsp; currentAlbumIndex = index;<br />
&nbsp;&nbsp;&nbsp; [self showDataForAlbumAtIndex:index];<br />
}<br />
</div><br />
这里设置一个变量用来存储当前的专辑，然后调用 showDataForAlbumAtIndex: 显示一个新专辑的数据。</p>
<p>提示：一般在方法代码的前面放置 #pragma mark 指示符。编译器会忽略这一行，当你在使用 Xcode 的跳转工具栏(Xcode's jump bar)查看你的方法列表时，你会看到一个分隔符和个加粗的指示标题。在 Xcode 里，这可以帮助你很容易的组织代码。</p>
<p>下面，添加如下代码：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="12099" class="copybut" id="copybut12099" onclick="doCopy('code12099')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code12099"><br />
- (NSInteger)numberOfViewsForHorizontalScroller:(HorizontalScroller *)scroller<br />
{<br />
&nbsp;&nbsp;&nbsp; return allAlbums.count;<br />
}<br />
</div><br />
这里，协议方法返回滚动视图里的视图数量。因为滚动视图需要显示所有的专辑封面，这个 count 是所有专辑的数目。</p>
<p>现在，添加这些代码：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="76446" class="copybut" id="copybut76446" onclick="doCopy('code76446')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76446"><br />
- (UIView *)horizontalScroller:(HorizontalScroller *)scroller viewAtIndex:(ini)index<br />
{<br />
&nbsp;&nbsp;&nbsp; Album *album = allAlbums[index];<br />
&nbsp;&nbsp;&nbsp; return [[Album alloc] initWithFrame:CGRectMake(0, 0, 100, 100) albumCover:album.coverUrl];<br />
}<br />
</div><br />
这里你创建了一个新 AlbumView，然后交给 HorizontalScroller 使用。</p>
<p>就是这样，通过三个这么短的方法就可以显示一个漂亮的滚动视图。</p>
<p>实际上，你仍需要创建一个真正的滚动视图，然后添加到你的主视图上，但是在这之前，先添加下面的方法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="9963" class="copybut" id="copybut9963" onclick="doCopy('code9963')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code9963"><br />
- (void)reloadScroller<br />
{<br />
&nbsp;&nbsp;&nbsp; allAlbums = [[LibraryAPI sharedInstance] getAlbums];<br />
&nbsp;&nbsp;&nbsp; if (currentAlbumIndex &lt; 0) currentAlbumIndex = 0;<br />
&nbsp;&nbsp;&nbsp; else if (currentAlbumIndex &gt;=allAlbum.count) currentAlbumIndex = allAlbum.count - 1;<br />
&nbsp;&nbsp;&nbsp; [scroller reload];</p>
<p>&nbsp;&nbsp;&nbsp; [self showDataFroAlbumAtIndex:currentAlbumIndex;<br />
}<br />
</div><br />
这个方法从 LibraryAPI 加载专辑数据，然后以当前视图的索引值为基础设置显示当前的图片。 如果当前视图的索引小于零，意味着当前没有选择视图，显示列表里的第一张专辑。否则显示最后一张专辑。</p>
<p>现在，在 viewDidLoad 里 [self showDataForAlbumIndex:0] 前面添加下面代码来初始化滚动视图：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="82855" class="copybut" id="copybut82855" onclick="doCopy('code82855')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code82855"><br />
scroller&nbsp; = [[HorizontalScroller alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 120)];<br />
scroller.backgroundColor = [UIColor colorWithRed:0.24f greed:0.35f blue:0.49f alpha:1];<br />
scroller.delegate = self;<br />
[self.view addSubview:scroller];</p>
<p>[self reloadScroller];<br />
</div><br />
上面的代码创建了一个 HorizontalScroller 的实例，设置了它的背景颜色和委托，添加滚动视图到主视图上，在滚动视图的子视图上加载专辑数据。</p>
<p>提示：如果一个协议变得很大，里面有很多方法，你应该考虑把它们分散到几个小的协议里去。UITableViewDelegate 和 UITableViewDataSource 就是一个很好的例子，因为它们都是 UITablveView 的协议。设计协议的时候，最好一个名称引导一个功能。<br />
构建和运行你的项目，你会看到一个新的很了不起的水平滚动视图：<br />
</p>
<p></p>
<p>啊嗯，等等。水平滚动的视图已经有了，可是专辑封面在哪里？</p>
<p>对了，你还没有代码来执行下载图片的功能。你需要添加一个下载图片的方法。查检 LibraryAPI 服务的所有接口，这里需要添加一个新的方法。不管怎样，现在还有几件事情需要考虑：</p>
<p>AlbumView 并没没有通过 LibraryAPI 立即工作。你没有给视图添加通信逻辑。<br />
相同的原因，LibraryAPI 并不认识 AlbumView。<br />
LibraryAPI 需要通知 AlbumView，一旦封面下载完成，AlbumView 就会显示它。</p>
<p></p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/90335.html'>PHP创建桌面快捷方式的实例代码</a><a>下一篇</a><a href='/php/biji/90337.html'>jquery实现选中单选按钮下拉伸缩效果</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>