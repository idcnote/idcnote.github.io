<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>在ASP.NET 2.0中操作数据之六十：创建一个自定义的Database-Driven Site Map Provider_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="导言：<br />
　　ASP.NET 2.0的网站地图(site map)功能允许页面开发者在一些持久介质(persistent medium),比如一个XML文件里，自己定义一个web程序的site map.一旦定义了之后，我们可" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">在ASP.NET 2.0中操作数据之六十：创建一个自定义的Database-Driven Site Map Provider</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>导言：<br />
　　ASP.NET 2.0的网站地图(site map)功能允许页面开发者在一些持久介质(persistent medium),比如一个XML文件里，自己定义一个web程序的site map.一旦定义了之后，我们可</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>导言：</strong></p>
<p>　　ASP.NET 2.0的网站地图(site map)功能允许页面开发者在一些持久介质(persistent medium),比如一个XML文件里，自己定义一个web程序的site map.一旦定义了之后，我们可以通过System.Web命名空间的SiteMap class类或某个Web导航控件，比如SiteMapPath, Menu, 或TreeView来对其进行访问。site map系统使用的是provider model模式，所以可以创建不同的site map，并将其应用到一个web应用程序。ASP.NET 2.0默认的site map provider，其结构为一个XML文件。在教程《Master Pages and Site Navigation》里我们创建了一个Web.sitemap文件，它就包含了这种结构，并且在教程的每一个新部分里我们都要更新其XML.</p>
<p>　　当site map的结构是静态的时候，默认的这种基于XML(XML-based)的site map provider工作正常，就像本系列教程一样。但是在很多时候我们需要动态的site map.如图1的site map，每个种类以及属于该种类的产品在网站的结构里做层次状体系分布。在该site map里，当访问根目录的web页面时，将列出所有的种类；再访问某个具体的种类的根目录时，将列出属于该种类的所有产品；再访问某个具体的产品时将列出该产品的详细信息。</p>
<p><br />
<strong>图1：Categories 和 Products构成了Site Map的层次结构</strong></p>
<p>　　这种基于category 和product的结构可以通过"硬编码"的方式添加到Web.sitemap文件.每当对category 或 product进行添加、删除、重命名等操作时，都需要对该文件进行更新。很自然的，如果其结构是通过数据库，或更理想地，是从业务逻辑层来获取的，那么对site map的维护是很简单的。那样的话，只要对products 和 categories进行添加、删除、重命名时，site map会自动的更新以反应这些变化。</p>
<p>　　由于ASP.NET 2.0的site map是建立在provider模式的基础上的，因此我们可以创建一个自定义的site map provider，从数据库或某个层来获取数据.在本文，我们创建的provider将从业务逻辑层获取数据。让我们开始吧！<br />
</p>
<p>　　<span style="color: #ff0000">注意：本文创建的用户定制site map provider仅仅依赖于系统的层及其数据模式(data model)。</span>Jeff Prosise的文章《Storing Site Maps in SQL Server》(http://msdn.microsoft.com/msdnmag/issues/05/06/WickedCode/)<br />
和《The SQL Site Map Provider You've Been Waiting For》<br />
(http://msdn.microsoft.com/msdnmag/issues/06/02/wickedcode/default.aspx)<br />
考察了将site map数据存储在SQL Server的方法。</p>
<p><strong>第一步：创建用户定制Site Map Provider页面</strong></p>
<p>在创建用户定制Site Map Provider之前，先添加本章将用到的ASP.NET页面。首先添加一个名为SiteMapProvider的文件夹；然后在文件夹里添加如下所示的页面确保采用母版Site.master：</p>
<p>Default.aspx<br />
ProductsByCategory.aspx<br />
ProductDetails.aspx</p>
<p>同样，在App_Code文件夹里添加CustomProviders</p>
<p><br />
<strong>图2：添加相关的ASP.NET页面.</strong></p>
<p>由于这部分只有一篇文章，没有必要使Default.aspx页面列出本部分的文章；我们将在Default.aspx里用一个GridView控件来列出categories，在第二步里探讨.</p>
<p>然后，更新Web.sitemap使其包含对Default.aspx页面的引用。特别的，在“Caching” &lt;siteMapNode&gt;后面添加以下代码：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;siteMapNode
 title="Customizing the Site Map" url="~/SiteMapProvider/Default.aspx"
 description="Learn how to create a custom provider that retrieves the site map from the Northwind database." /&gt;

</pre>
</div>
<p>完成Web.sitemap的更新后，花点时间在浏览器里登录页面，在左面的菜单里包含了本教程的条目。</p>
<p><br />
<strong>图3：Site Map现在包含了本章的条目</strong></p>
<p>　　本教程主要考察如何创建一个用户自定义的site map provider，及对设置web应用程序进行包含该site map provider.具体来讲，它返回的网站地图(site map)不仅包含了根节点，而且包含每个种类节点和产品节点，就像图1显示的那样。总的来说，网站地图里的每一个节点都对应一个具体的URL.就我们的网站地图而言，根节点的URL为~/SiteMapProvider/Default.aspx，它列出了所有产品和种类；每个种类节点对应的URL 为~/SiteMapProvider/ProductsByCategory.aspx&#63;CategoryID=categoryID,它根据指定的categoryID列出该种类的所有产品；最后，每个产品对应的URL为~/SiteMapProvider/ProductDetails.aspx&#63;ProductID=productID, 它根据指定的productID值,列出该产品的详细信息。</p>
<p>　　首先，让我们创建Default.aspx, ProductsByCategory.aspx和ProductDetails.aspx页面。我们将分别在第二、三、四步创建这些页面.因为本文的重点是site map providers，并且这种主/从页面在前面的教程里已经讨论过了，我们在第2到第4步将一笔带过，如果你对这种主/从页面页面不是很了解的话，请参考前面的教程之9《Master/Detail Filtering Across Two Pages》.</p>
<p><strong>第二步：将Categories显示出来</strong></p>
<p>　　打开文件夹SiteMapProvider里的Default.aspx页面，在设计模式里从工具箱拖一个 GridView控件到页面，设置其ID为Categories.从其智能标签里，将其绑定到一个名为CategoriesDataSource的ObjectDataSource，设置其使用CategoriesBLL类的 GetCategories方法。因为该GridView控件只是显示categories而不修改数据，因此在UPDATE, INSERT和 DELETE标签里选“(None)”.</p>
<p><br />
<strong>图4：设置ObjectDataSource使用GetCategories方法返回Categories</strong></p>
<p><br />
<strong>图5：在UPDATE, INSERT和DELETE标签里选“(None)”</strong></p>
<p>　　设置完成后，Visual Studio会自动的添加CategoryID, CategoryName, Description, NumberOfProducts 和 BrochurePath这些绑定列(BoundField),修改GridView，使其只包含CategoryName 和 Description两列，且将CategoryName绑定列的HeaderText属性改为“Category”.</p>
<p>　　然后，添加一个HyperLinkField，将其放在最左边，设其DataNavigateUrlFields属性为 CategoryID；DataNavigateUrlFormatString 属性为 ~/SiteMapProvider/ProductsByCategory.aspx&#63;CategoryID={0}；再将Text属性设置为“View Products”.</p>
<p><br />
<strong>图6：为GridView添加一个HyperLinkField</strong></p>
<p>创建完ObjectDataSource并定制GridView控件的列后，这2个控件的声明代码看起来应该和下面的差不多：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
&lt;asp:GridView ID="Categories" runat="server" AutoGenerateColumns="False"
 DataKeyNames="CategoryID" DataSourceID="CategoriesDataSource"
 EnableViewState="False"&gt;
 &lt;Columns&gt;
 &lt;asp:HyperLinkField DataNavigateUrlFields="CategoryID"
  DataNavigateUrlFormatString=
  "~/SiteMapProvider/ProductsByCategory.aspx&#63;CategoryID={0}"
  Text="View Products" /&gt;
 &lt;asp:BoundField DataField="CategoryName" HeaderText="Category"
  SortExpression="CategoryName" /&gt;
 &lt;asp:BoundField DataField="Description" HeaderText="Description"
  SortExpression="Description" /&gt;
 &lt;/Columns&gt;
&lt;/asp:GridView&gt;

&lt;asp:ObjectDataSource ID="CategoriesDataSource" runat="server"
 OldValuesParameterFormatString="original_{0}" SelectMethod="GetCategories"
 TypeName="CategoriesBLL"&gt;&lt;/asp:ObjectDataSource&gt;
</pre>
</div>
<p>图7显示的是在浏览器里查看的Default.aspx页面，点某个类的“View Products”链接，将会转到ProductsByCategory.aspx&#63;CategoryID=categoryID页面，该页面我们将在第三步新建。</p>
<p><br />
<strong>图7：每个类都有一个“View Products”链接</strong></p>
<p><strong>第三步：显示指定类的所有产品</strong></p>
<p>　　打开ProductsByCategory.aspx页面并添加一个GridView控件，设其ID为ProductsByCategory.从其智能标签，将其绑定到一个名为ProductsByCategoryDataSource的ObjectDataSource；设置它使用ProductsBLL类的 GetProductsByCategoryID(categoryID)方法；在UPDATE, INSERT,和 DELETE标签里选择“(None)”.</p>
<p><br />
<strong>图8：使用ProductsBLL类的GetProductsByCategoryID(categoryID)方法</strong></p>
<p>　　设置向导的最后一步是指定categoryID的参数来源，因为此信息是通过查询字符串(querystring field)CategoryID来传递的，因此在参数来源里选QueryString，在QueryStringField里输入“CategoryID”；如图9所示，点Finish完成设置.</p>
<p><br />
<strong>图9：为参数categoryID指定CategoryID Querystring Field</strong></p>
<p>　　完成设置后，Visual Studio将为GridView添加相应的绑定列以及CheckBo列；将除ProductName, UnitPrice, SupplierName外的列删除掉。将这3个列的HeaderText属性分别设置为“Product”, “Price”, and “Supplier”, 将UnitPrice列格式化为货币形式.</p>
<p>　　然后，添加一个HyperLinkField列，并将其放在最左边；设其Text属性为“View Details”，设其DataNavigateUrlFields属性为ProductID；其DataNavigateUrlFormatString属性为 ~/SiteMapProvider/ProductDetails.aspx&#63;ProductID={0}.</p>
<p><br />
<strong>图10：添加一个“View Details” HyperLinkField，以链接到ProductDetails.aspx</strong></p>
<p>完成后，GridView和 ObjectDataSource的声明代码为:</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
&lt;asp:GridView ID="ProductsByCategory" runat="server" AutoGenerateColumns="False"
 DataKeyNames="ProductID" DataSourceID="ProductsByCategoryDataSource"
 EnableViewState="False"&gt;
 &lt;Columns&gt;
 &lt;asp:HyperLinkField DataNavigateUrlFields="ProductID"
  DataNavigateUrlFormatString=
  "~/SiteMapProvider/ProductDetails.aspx&#63;ProductID={0}"
  Text="View Details" /&gt;
 &lt;asp:BoundField DataField="ProductName" HeaderText="Product"
  SortExpression="ProductName" /&gt;
 &lt;asp:BoundField DataField="UnitPrice" DataFormatString="{0:c}"
  HeaderText="Price" HtmlEncode="False"
  SortExpression="UnitPrice" /&gt;
 &lt;asp:BoundField DataField="SupplierName" HeaderText="Supplier"
  ReadOnly="True" SortExpression="SupplierName" /&gt;
 &lt;/Columns&gt;
&lt;/asp:GridView&gt;

&lt;asp:ObjectDataSource ID="ProductsByCategoryDataSource" runat="server"
 OldValuesParameterFormatString="original_{0}"
 SelectMethod="GetProductsByCategoryID" TypeName="ProductsBLL"&gt;
 &lt;SelectParameters&gt;
 &lt;asp:QueryStringParameter Name="categoryID"
  QueryStringField="CategoryID" Type="Int32" /&gt;
 &lt;/SelectParameters&gt;
&lt;/asp:ObjectDataSource&gt;

</pre>
</div>
<p>　　返回来登录Default.aspx页面，点Beverages(饮料)的“View Products”链接，这将转到ProductsByCategory.aspx&#63;CategoryID=1页面，显示饮料类的所有产品的names, prices, 和 suppliers信息(见图11)。尽管改进该页面吧，添加一个链接以方便用户返回上一页(Default.aspx) .还可以添加一个DetailsView 或 FormView控件来显示该种类的名称和描述。</p>
<p><br />
<strong>图11：显示Beverages类的Names, Prices, Suppliers信息</strong></p>
<p><strong>第四步：显示产品的详细信息</strong></p>
<p>　　最后要创建的页面—ProductDetails.aspx,是用来显示指定产品的详细信息的。打开ProductDetails.aspx页面，从工具箱拖一个DetailsView控件到页面，设置其ID为ProductInfo，并清除其Height 和 Width属性值。在其智能标签里，绑定到一个名为ProductDataSource的ObjectDataSource，设置该ObjectDataSource使用ProductsBLL类的GetProductByProductID(productID)方法。在UPDATE, INSERT,和DELETE标签里选“(None)”.</p>
<p><br />
<strong>图12：设置该ObjectDataSource控件调用GetProductByProductID(productID)方法</strong></p>
<p>　　最后，需要设置参数productID的来源，由于数据通过查询字符串ProductID来传递，在参数源下拉列表里选QueryString，在QueryStringField对话框里输入“ProductID”. 最后，点Finish按钮完成设置。</p>
<p><br />
<strong>图13:设置参数productID来源于查询字符串</strong></p>
<p>　　完成设置后，Visual Studio会为DetailsView控件添加相应的绑定列和CheckBox列，移除ProductID, SupplierID, 和CategoryID列，剩下的列想怎样设就怎样设置吧。我对界面做了些优化，这样的话，声明代码看起来像下面这样：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
&lt;asp:DetailsView ID="ProductInfo" runat="server" AutoGenerateRows="False"
 DataKeyNames="ProductID" DataSourceID="ProductDataSource"
 EnableViewState="False"&gt;
 &lt;Fields&gt;
 &lt;asp:BoundField DataField="ProductName" HeaderText="Product"
  SortExpression="ProductName" /&gt;
 &lt;asp:BoundField DataField="CategoryName" HeaderText="Category"
  ReadOnly="True" SortExpression="CategoryName" /&gt;
 &lt;asp:BoundField DataField="SupplierName" HeaderText="Supplier"
  ReadOnly="True" SortExpression="SupplierName" /&gt;
 &lt;asp:BoundField DataField="QuantityPerUnit" HeaderText="Qty/Unit"
  SortExpression="QuantityPerUnit" /&gt;
 &lt;asp:BoundField DataField="UnitPrice" DataFormatString="{0:c}"
  HeaderText="Price" HtmlEncode="False"
  SortExpression="UnitPrice" /&gt;
 &lt;asp:BoundField DataField="UnitsInStock" HeaderText="Units In Stock"
  SortExpression="UnitsInStock" /&gt;
 &lt;asp:BoundField DataField="UnitsOnOrder" HeaderText="Units On Order"
  SortExpression="UnitsOnOrder" /&gt;
 &lt;asp:BoundField DataField="ReorderLevel" HeaderText="Reorder Level"
  SortExpression="ReorderLevel" /&gt;
 &lt;asp:CheckBoxField DataField="Discontinued" HeaderText="Discontinued"
  SortExpression="Discontinued" /&gt;
 &lt;/Fields&gt;
&lt;/asp:DetailsView&gt;

&lt;asp:ObjectDataSource ID="ProductDataSource" runat="server"
 OldValuesParameterFormatString="original_{0}"
 SelectMethod="GetProductByProductID" TypeName="ProductsBLL"&gt;
 &lt;SelectParameters&gt;
 &lt;asp:QueryStringParameter Name="productID"
  QueryStringField="ProductID" Type="Int32" /&gt;
 &lt;/SelectParameters&gt;
&lt;/asp:ObjectDataSource&gt;

</pre>
</div>
<p>　　来对该页面进行测试，返回Default.aspx页面，点种类Beverages的“View Products”链接；再点产品Chai Tea的“View Details”链接。这将转到ProductDetails.aspx&#63;ProductID=1页面，其显示的是Chai Tea的详细信息(如图14所示).</p>
<p><br />
<strong>图14：Chai Tea的Supplier, Category, Price等信息显示出来了</strong></p>
<p><strong>第五步：理解Site Map Provider的内部处理机制</strong></p>
<p>　　site map呈现的是源于某种层次结构的SiteMapNode实例集(a&nbsp; collection of SiteMapNode instances)。其必须有一个根节点，所有的非根节点都有一个父节点，且每个节点都可以有任意数量的子节点.每个SiteMapNode对象对应的是website体系结构的某个部分。这些部分通常都有对应的web页面，因此，SiteMapNode class类有像Title, Url, 和 Description这样的属性，它们用来描述SiteMapNode所对应部分的相关信息。<br />
还有一个Key属性用来专门唯一的标识这些SiteMapNode；除此以外，还有ChildNodes, ParentNode, NextSibling, PreviousSibling等等.</p>
<p><br />
<strong>图15显示的是对应于图1的site map的总体结构，只是更细化了而已.</strong></p>
<p>&nbsp;　　可以通过命名空间System.Web的SiteMap class类来访问site map；该类的RootNode属性返回网站地图的根目录的SiteMapNode实例；CurrentNode属性返回的是这种SiteMapNode，其Url属性刚好与当前请求页面的URL匹配.ASP.NET 2.0的Web导航控件的内部就会用到SiteMap class类.</p>
<p>　　当访问SiteMap class类的属性时，必须将网站地图的层次结构从某个介质传入内存(memory).SiteMap class类并不是通过“硬编码”的方式来处理网站地图的逻辑关系，而是通过某种site map provider来工作.在默认情况下，使用的是XmlSiteMapProvider class类，它从一个标准的XML文件读取网站地图的结构.不过，我们稍微做点工作就可以创建自己的site map provider.</p>
<p>　　所有的site map providers都继承自SiteMapProvider class类，该类包含了site map providers要用到的最基本的方法和属性，不过略去了很多执行细节.site map providers要用到的第二个类是StaticSiteMapProvider class类，它对SiteMapProvider class类进行了扩充，包含了更多的必要的函数.在其内部，StaticSiteMapProvider将网站地图的SiteMapNode实例存储在一个哈希表(Hashtable)里，并包含了AddNode(child, parent), RemoveNode(siteMapNode), Clear()等方法，以对哈希表里的SiteMapNodes执行添加、删除等操作.另外，XmlSiteMapProvider也继承自StaticSiteMapProvider.</p>
<p>　　当创建自定义的site map provider时，要对StaticSiteMapProvider进行扩充，重写(overrid)2个抽象方法——BuildSiteMap 和 GetRootNodeCore. 对BuildSiteMap而言，就像它的名字暗示的那样，将网站地图的结构从某种介质里按层次结构装载进内存；而GetRootNodeCore返回的是网站地图的根目录.</p>
<p>　　在使用某个site map provider时，需要在应用程序的配置文件里进行注册(registered)<br />
.默认情况下，XmlSiteMapProvider class类被注册为AspNetXmlSiteMapProvider.为对额外添加的site map providers进行注册，可以在Web.config文件里添加如下的代码：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;configuration&gt;
 &lt;system.web&gt;
 ...

 &lt;siteMap defaultProvider="defaultProviderName"&gt;
  &lt;providers&gt;
  &lt;add name="name" type="type" /&gt;
  &lt;/providers&gt;
 &lt;/siteMap&gt;
 &lt;/system.web&gt;
&lt;/configuration&gt;
</pre>
</div>
<p>　　name属性可以为site map provider指派一个易读的名称；type属性决定了该site map provider的类型.当创建完我们定制的site map provider后，我们将在第七步为name 和type属性赋值.</p>
<p>　　当第一次从SiteMap class类访问site map provider时，site map provider class类都应该被实例化，并在web应用程序的整个生命周期里都驻留在内存.</p>
<p>　　基于性能等方面的考虑，我们应该将对驻留在内存里的网站地图结构进行数据缓存，每次调用BuildSiteMap的方法时，直接返回缓存的数据而不用重新检索数据.在任何情况下，如果我们不对BuildSiteMap对应的网站结构进行缓存的话，每次调用时，我们都需要通过“层”来重新检索产品和种类的信息(这将最终导致对数据库的查询).我们在前面的缓存章节探讨过缓存数据“过时”的问题，为此，我们要么使用基于时间，要么使用基于SQL cache dependency的缓存技术.</p>
<p>　　注意：一个site map provider可以任意地重写(override)Initialize method方法.Initialize 方法是当site map provider第一次实例化的时候被调用的，并可以将我们在Web.config 文件的&lt;add&gt;元素里赋值的用户自定义属性值传递给它，比如：&lt;add name="name" type="type" customAttribute="value" /&gt;.当一个页面开发者希望指定各种与site map provider相关的设置，而又不希望修改site map provider的代码的时候，这样做很有用.比如，假如我们希望不通过“层”而直接从数据库读取category 和 products的数据时，我们当然希望页面开发者调用Web.config文件里的数据库连接字符串，而不使用site map provider代码里的“硬编码”值.我们不打算在第六步创建的自定义site map provider里重写Initialize方法.见Jeff Prosise的文章《Storing Site Maps in SQL Server》(http://msdn.microsoft.com/msdnmag/issues/05/06/WickedCode/)</p>
<p><strong>第六步：创建自定义的Site Map Provider</strong></p>
<p>　　要想创建一个自定义的site map provider来构建源于Northwind数据库里的categories 和 products信息的网站地图(site map),我们需要创建一个类来扩展StaticSiteMapProvider.在前面我们在App_Code文件夹里添加了一个CustomProviders文件夹，在该文件夹里添加名为NorthwindSiteMapProvider的新类，在类里添加如下的代码：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Web.Caching;

public class NorthwindSiteMapProvider : StaticSiteMapProvider
{
 private readonly object siteMapLock = new object();
 private SiteMapNode root = null;
 public const string CacheDependencyKey =
 "NorthwindSiteMapProviderCacheDependency";

 public override SiteMapNode BuildSiteMap()
 {
 // Use a lock to make this method thread-safe
 lock (siteMapLock)
 {
  // First, see if we already have constructed the
  // rootNode. If so, return it...
  if (root != null)
  return root;

  // We need to build the site map!
  
  // Clear out the current site map structure
  base.Clear();

  // Get the categories and products information from the database
  ProductsBLL productsAPI = new ProductsBLL();
  Northwind.ProductsDataTable products = productsAPI.GetProducts();

  // Create the root SiteMapNode
  root = new SiteMapNode(
  this, "root", "~/SiteMapProvider/Default.aspx", "All Categories");
  AddNode(root);

  // Create SiteMapNodes for the categories and products
  foreach (Northwind.ProductsRow product in products)
  {
  // Add a new category SiteMapNode, if needed
  string categoryKey, categoryName;
  bool createUrlForCategoryNode = true;
  if (product.IsCategoryIDNull())
  {
   categoryKey = "Category:None";
   categoryName = "None";
   createUrlForCategoryNode = false;
  }
  else
  {
   categoryKey = string.Concat("Category:", product.CategoryID);
   categoryName = product.CategoryName;
  }

  SiteMapNode categoryNode = FindSiteMapNodeFromKey(categoryKey);

  // Add the category SiteMapNode if it does not exist
  if (categoryNode == null)
  {
   string productsByCategoryUrl = string.Empty;
   if (createUrlForCategoryNode)
   productsByCategoryUrl =
    "~/SiteMapProvider/ProductsByCategory.aspx&#63;CategoryID="
    + product.CategoryID;

   categoryNode = new SiteMapNode(
   this, categoryKey, productsByCategoryUrl, categoryName);
   AddNode(categoryNode, root);
  }

  // Add the product SiteMapNode
  string productUrl =
   "~/SiteMapProvider/ProductDetails.aspx&#63;ProductID="
   + product.ProductID;
  SiteMapNode productNode = new SiteMapNode(
   this, string.Concat("Product:", product.ProductID),
   productUrl, product.ProductName);
  AddNode(productNode, categoryNode);
  }
  
  // Add a "dummy" item to the cache using a SqlCacheDependency
  // on the Products and Categories tables
  System.Web.Caching.SqlCacheDependency productsTableDependency =
  new System.Web.Caching.SqlCacheDependency("NorthwindDB", "Products");
  System.Web.Caching.SqlCacheDependency categoriesTableDependency =
  new System.Web.Caching.SqlCacheDependency("NorthwindDB", "Categories");

  // Create an AggregateCacheDependency
  System.Web.Caching.AggregateCacheDependency aggregateDependencies =
  new System.Web.Caching.AggregateCacheDependency();
  aggregateDependencies.Add(productsTableDependency, categoriesTableDependency);

  // Add the item to the cache specifying a callback function
  HttpRuntime.Cache.Insert(
  CacheDependencyKey, DateTime.Now, aggregateDependencies,
  Cache.NoAbsoluteExpiration, Cache.NoSlidingExpiration,
  CacheItemPriority.Normal,
  new CacheItemRemovedCallback(OnSiteMapChanged));


  // Finally, return the root node
  return root;
 }
 }

 protected override SiteMapNode GetRootNodeCore()
 {
 return BuildSiteMap();
 }

 protected void OnSiteMapChanged(string key, object value, CacheItemRemovedReason reason)
 {
 lock (siteMapLock)
 {
  if (string.Compare(key, CacheDependencyKey) == 0)
  {
  // Refresh the site map
  root = null;
  }
 }
 }

 public DateTime&#63; CachedDate
 {
 get
 {
  return HttpRuntime.Cache[CacheDependencyKey] as DateTime&#63;;
 }
 }
}

</pre>
</div>
<p>　　让我们考察该类的BuildSiteMap方法，它有一个lock statement声明。lock statement每次只允许“单线程操作”(one thread at a time to enter)，以避免“多线程操作”之间的冲突.</p>
<p>　　属于“类级别”(class-level)的SiteMapNode变量—root，用来缓存网站地图结构.当网站地图第一次被“结构化”，或“源数据”发生变动后的第一次“结构化”时，root为null值，在“结构化”的过程中，root被赋值为网站地图的根节点；所以，当第二次调用BuildSiteMap方法时，root就不为null值了.自然，只要root不为null，直接将网站地图结构返回，而用不着重新创建.</p>
<p>　　如果root为null，那么将根据product 和 category信息创建网站地图结构.为此，先要创建一个SiteMapNode实例，再调用StaticSiteMapProvider class类的AddNode method方法来构建网站地图的层次体系，再将SiteMapNode实例存储进一个哈希表.在我们构建层次体系之前，我们首先调用Clear method方法，将内部的哈希表清空；然后，调用ProductsBLL class类的GetProducts()方法，把返回的ProductsDataTable存储进局部变量.</p>
<p>　　创建网站地图结构从创建根节点并赋值给root开始，本章要用到的SiteMapNode's constructor重载，接受如下的信息：</p>
<p>对一个site map provider (this)的引用.</p>
<p>SiteMapNode的Key值：对每个SiteMapNode而言，这个待定值必须是唯一的.</p>
<p>SiteMapNode的Url值：Url为可选项，但一旦指定的话，每个SiteMapNode的Url值必须是唯一的.</p>
<p>SiteMapNode的Title值：此为必选项.</p>
<p>　　AddNode(root) method方法将SiteMapNode root添加给网站地图作为根节点。然后，遍历ProductsDataTable里的所有ProductRow，如果当前product的category所对应的SiteMapNode已经存在的话，那么引用该SiteMapNode；如果不存在的话，则为该category创建一个新的SiteMapNode，并且调用AddNode(categoryNode, root) method方法，将其作为SiteMapNode root的子节点进行添加.当找到或创建category对应的SiteMapNode后，创建一个当前product对应的SiteMapNode，并通过AddNode(productNode, categoryNode)方法将其作为category SiteMapNode的子节点进行添加.注意，category SiteMapNode的Url属性为~/SiteMapProvider/ProductsByCategory.aspx&#63;CategoryID=categoryID；而product SiteMapNode的Url属性为~/SiteMapNode/ProductDetails.aspx&#63;ProductID=productID.<br />
</p>
<p>　　<span style="color: #ff0000">注意：对那种CategoryID为NULL值的产品，统统将其归为一个category，其对应的category SiteMapNode的Title属性可设置为“None”；Url属性设置为空字符串。</span>我将其Url设置为空字符串是因为ProductBLL class类的GetProductsByCategory(categoryID)方法无法返回那些CategoryID值为NULL的产品.不过我鼓励你对本教程进行扩展，使该category SiteMapNode的Url属性对应一个ProductsByCategory.aspx页面，该页面专门用来展示那些CategoryID为NULL的产品.</p>
<p>　　当完成site map的构建后，将一个AggregateCacheDependency object对象添加到data cache，该对象使用基于Categories 和 Products表的SQL cache dependency技术。我们在前面的教程里探讨过SQL cache dependencies，不过我们自定义的site map provider使用的是重载(overload)的data cache的Insert方法，该重载方法接受一个delegate作为输入参数.具体而言，我们将传入一个CacheItemRemovedCallback delegate，其指向OnSiteMapChanged method方法，该方法定义在NorthwindSiteMapProvider class类里<br />
注意：内存里的site map表述是缓存在一个“类级”(class-level)变量root里的.由于只有一个site map provider的实例(instance)，并且对web应用程序的线程来说都是共享的，这个类级变量当作缓存服务。BuildSiteMap method方法也会用到data cache，但仅仅做作为一种探测Categories 或 Products表里的数据发生改变的方法。注意添加到data cache里的仅仅是当前的date和time，实际的site map数据并没有添加到data cache.</p>
<p><strong>BuildSiteMap method方法最后返回网站地图的根节点.</strong></p>
<p>　　剩下的方法就比较简单易懂了.GetRootNodeCore方法用来返回根节点，由于BuildSiteMap返回根节点root， GetRootNodeCore方法仅仅返回BuildSiteMap方法的返回值.当缓存条码被清除掉时，OnSiteMapChanged方法将root设置为null；当root为null的时候，当下一次调用BuildSiteMap时，将重新创建地图网站结构.最后，如果data cache里存储有date 和 time值的话，CachedDate属性将返回这些值.页面开发员可以用该属性来探测site map数据最近被缓存的时间.</p>
<p><strong>第七步：对NorthwindSiteMapProvider进行登记</strong></p>
<p>　　为了使用我们在第六步创建的NorthwindSiteMapProvider site map provider，我们需要在Web.config文件的&lt;siteMap&gt;部分进行注册.具体来说，将下面的代码添加到Web.config文件的&lt;system.web&gt;部分：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;siteMap defaultProvider="AspNetXmlSiteMapProvider"&gt;
 &lt;providers&gt;
 &lt;add name="Northwind" type="NorthwindSiteMapProvider" /&gt;
 &lt;/providers&gt;
&lt;/siteMap&gt;</pre>
</div>
<p>　　上述代码阐明了如下2个事实：第一，它指明了“内置”的AspNetXmlSiteMapProvider为默认的site map provider；第二，它将我们在第六步创建的用户自定义site map provider进行了注册，取名为“Northwind”.<br />
注意：对那些位于在App_Code文件夹的site map providers而言，type属性的值就是类的名称.还一种方法，我们可以用一个单独的类库工程来创建自定义的site map provider，将其编译文件放置在/Bin目录；如果是那样的话，type属性就变成了“Namespace.ClassName, AssemblyName”.</p>
<p>　　更新Web.config文件后，花点时间在浏览器里登录本教程的任何一个页面，我们注意到左边的导航界面跟以前一样，那是因为我们把AspNetXmlSiteMapProvider作为默认的provider，为了使导航用户界面使用我们定制的NorthwindSiteMapProvider，我们应明确的指定使用“Northwind” site map provider，我们将在第八步完成.</p>
<p><strong>第八步：使用定制的Site Map Provider来显示网站地图信息</strong></p>
<p>　　把我们定制的site map provider注册到Web.config文件后，我们可以将导航控件添加到SiteMapProvider文件夹里的Default.aspx, ProductsByCategory.aspx, 和ProductDetails.aspx页面.首先，打开Default.aspx页面进入设计模式，从工具箱拖一个SiteMapPath控件到页面。该控件位于工具箱的导航区域.</p>
<p><br />
<strong>图16：为Default.aspx页面添加一个SiteMapPath控件</strong></p>
<p>　　SiteMapPath控件包含一个breadcrumb，用来显示当前页面在网站地图里的位置。我们在第三章《模板页和站点导航》里在模板页的顶部添加了一个SiteMapPath控件.</p>
<p>　　花点时间在浏览器里登录页面，我们在图16里添加的SiteMapPath控件使用的是默认的site map provider，它从Web.sitemap文件获取数据，因此breadcrumb显示为“Home &gt; Customizing the Site Map”.如下图：</p>
<p><br />
<strong>图17：Breadcrumb使用的是默认的Site Map Provider</strong></p>
<p>　　要使在图16里添加的SiteMapPath使用我们定制的site map provider的话，设其SiteMapProvider property属性为“Northwind”, 这个名字是我们在Web.config文件里分配给NorthwindSiteMapProvider的.不过，在设计器里依然使用的是默认的site map provider，但是如你在浏览器里登录该页面的话，你将看到breadcrumb使用的是我们定制的site map provider了.</p>
<p><br />
<strong>图18：Breadcrumb现在使用的是我们定制的NorthwindSiteMapProvider</strong></p>
<p>　　SiteMapPath控件将在ProductsByCategory.aspx 和 ProductDetails.aspx页面展示更具功能性的用户界面.在这2个页面里添加SiteMapPath控件，设置其SiteMapProvider属性为“Northwind”. 在Default.aspx页面里点击Beverages类的“View Products”链接，然后再点Chai Tea的“View Details”链接，如图19所示，breadcrumb显示的是当前的网站地图节点(“Chai Tea”)，及其上级节点：“Beverages” 和“All Categories”.</p>
<p><br />
<strong>图19：Breadcrumb现在使用的是我们定制的NorthwindSiteMapProvider</strong></p>
<p>　　除了SiteMapPath外，还可以使用其它的导航控件，比如Menu 和 TreeView控件.本章的下载代码里，Default.aspx, ProductsByCategory.aspx,和ProductDetails.aspx页面都包含Menu控件(见图20).要想更深入的了解ASP.NET 2.0里的导航控件和site map体系的话，可参阅《ASP.NET 2.0 QuickStarts》系列（http://quickstarts.asp.net/QuickStartv20/aspnet/）的《Examining ASP.NET 2.0's Site Navigation Features》和《Using Site Navigation Controls》部分.</p>
<p><br />
<strong>图20：Menu控件列出了所有的Categories 和 Products</strong></p>
<p>就像在本教程前面提到的那样，网站地图结构可以通过SiteMap class类来进行访问，下面的代码返回默认的provider的root SiteMapNode：</p>
<p>SiteMapNode root = SiteMap.RootNode;</p>
<p>由于AspNetXmlSiteMapProvider是默认的provider，上述代码返回的是定义在Web.sitemap文件里的根节点，要引用其它的site map provider的话，使用SiteMap class类的Providers property属性，如：</p>
<p>SiteMapNode root = SiteMap.Providers["name"].RootNode;<br />
这里的name是用户定制的site map provider的名称(就本文而言,为“Northwind”)</p>
<p>要访问某个具体的site map provider，使用SiteMap.Providers["name"]来获取该provider的实例，再将其转换成恰当的类型。比如，要展示NorthwindSiteMapProvider的CachedDate property属性，使用如下的代码：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
NorthwindSiteMapProvider customProvider =
 SiteMap.Providers["Northwind"] as NorthwindSiteMapProvider;
if (customProvider != null)
{
 DateTime&#63; lastCachedDate = customProvider.CachedDate;

 if (lastCachedDate != null)
 LabelID.Text = "Site map cached on: " + lastCachedDate.Value.ToString();
 else
 LabelID.Text = "The site map is being reconstructed!";
}

</pre>
</div>
<p>　　<span style="color: #ff0000">注意：务必测试SQL cache dependency属性，访问完Default.aspx, ProductsByCategory.aspx, 和 ProductDetails.aspx页面后，转到本系列教程的《编辑插入和删除数据》部分的任一个页面，编辑某个category 或 product的名称；然后再转到SiteMapProvider文件夹里的某个页面，假设时间足够长，长到检测机制(polling mechanism)发现“源数据库”已经发生了改动，那么site map应该被更新以显示新的product 或 category名字.</span></p>
<p><strong>结语：</strong></p>
<p>　　ASP.NET 2.0的site map属性包含一个SiteMap class类，一系列内置的的导航Web控件，以及一个默认的site map provider.为了使用来自某些数据源的site map信息——比如数据库、系统的“层”、或者某些Web服务，我们需要创建一个用户定制的 site map provider.这就要创建一个类，该类直接或间接的源自SiteMapProvider class类.</p>
<p>　　本章我们探讨了如何创建一个用户定制的site map provider，它以一个由product 和 category信息构成的site map为基础.我们的provider对StaticSiteMapProvider class类进行了扩充，并创建了一个BuildSiteMap method方法来获取数据、构建site map的层次体系，并且将最终的网站地图结构缓存在一个“类级”的变量里.我们使用一个SQL cache dependency来确保当Categories 或 Products的“源数据”发生改动时使缓存的数据失效.</p>
<p>　　祝编程快乐！</p>
<p><strong>作者简介</strong></p>
<p>　　本系列教程作者 Scott Mitchell，著有六本ASP/ASP.NET方面的书，是4GuysFromRolla.com的创始人，自1998年以来一直应用 微软Web技术。大家可以点击查看全部教程《[翻译]Scott Mitchell 的ASP.NET 2.0数据教程》，希望对大家的学习ASP.NET有所帮助。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/97260.html'>PHP中的按位与和按位或操作示例</a><a>下一篇</a><a href='/php/biji/97262.html'>禁止iframe页面的所有js脚本如alert及弹出窗口等</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>