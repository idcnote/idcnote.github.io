<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>面向Java开发人员的Ajax：Java对象序列化下_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这种类型的 XML 绑定框架在数据拆解时最有用（例如，使用 XML 文档并把它们转化成 Java 对象）。除非拥有大型数据模型而且有可能从生成的类中获益，否则基于代码生成的框架对于 Aja" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/122.html"></a></li><li><a href="/php/phpbiji/123.html"></a></li><li><a href="/php/phpbiji/124.html"></a></li><li><a href="/php/phpbiji/125.html"></a></li><li><a href="/php/phpbiji/126.html"></a></li><li><a href="/php/phpbiji/127.html"></a></li><li><a href="/php/phpbiji/128.html"></a></li><li><a href="/php/phpbiji/129.html"></a></li><li><a href="/php/phpbiji/130.html"></a></li><li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">面向Java开发人员的Ajax：Java对象序列化下</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这种类型的 XML 绑定框架在数据拆解时最有用（例如，使用 XML 文档并把它们转化成 Java 对象）。除非拥有大型数据模型而且有可能从生成的类中获益，否则基于代码生成的框架对于 Aja</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P>这种类型的 XML 绑定框架在数据拆解时最有用（例如，使用 XML 文档并把它们转化成 Java 对象）。除非拥有大型数据模型而且有可能从生成的类中获益，否则基于代码生成的框架对于 Ajax 应用程序来说可能有很大的杀伤力。</P>
<P>　　映射方式</P>
<P>　　采用映射方式的框架包括 Castor 和 Apache Commons Betwixt。映射通常是比代码生成更灵活和更轻量的解决方案。首先，可以像通常一样编写 JavaBean，包括任何行为以及任何自己喜欢的方便的方法。</P>
<P>　　然后，在运行时，调用框架中基于内省的编排器，并根据对象成员的类型、名称和值生成 XML 文档。通过定义类的映射文件，可以覆盖默认的绑定策略，并就类在 XML 中的表示方式对编排器提出建议。</P>
<P>　　这种方法是在可伸缩性与灵活性之间的良好折中。可以按照自己喜欢的方式编写 Java 类，编排器负责处理 XML。虽然映射定义文件编写起来简单，可伸缩性也足够好，但是映射规则最多只能改变标准的绑定行为，而且在对象结构和它们的 XML 表示之间总要残留一些耦合。最终，可能不得不在 Java 表示或 XML 格式之间任选一个做些折中，才能让映射方法起作用。</P>
<P>　　数据绑定总结</P>
<P>　　Dennis Sosnoski 就 XML 数据绑定 API 的主题，在代码生成和代码映射两个方面写了深入的文章。如果想进一步研究这个领域，我推荐他在 Castor 和代码生成框架方面的精彩文章。</P>
<P>　　总之，代码生成方式损失了过多的灵活性和方便性，对于典型的 Ajax 应用程序用处不大。另一方面，基于映射的框架可能工作得很好，但是要恰到好处地调整它们的映射策略，以便从对象生成需要的 XML。</P>
<P>　　所有的 XML 绑定 API 都具有手工序列化技术的一个主要不足：模型和视图的耦合。被限制为一个类型一个 XML 表示，就意味着在网络上总要有冗余数据传输<BR></P>
<P>　　在传统的 Web 应用程序开发中，采用页面模板系统把视图生成与控制器逻辑和模型数据干净地分离。这种方法在 Ajax 场景中也会有帮助。</P>
<P>　　页面模板系统</P>
<P>　　任何通用目的的页面模板技术都可以用来生成 XML，从而使 Ajax 应用程序根据自己的数据模型生成任何 XML 响应文档。</P>
<P>　　额外收获是：模板可以用简单的、表现力强的标记语言编写，而不是用一行行的 Java 代码编写。清单 5 是一个 JSP 页面，采用了 Customer bean 并表示出定制的 XML 视图，适合客户端代码生成订单历史组件。</P>
<P>　　清单 4. 生成订单历史文档的 JSP</P>
<P>value="${requestScope.customer}"/&gt;<BR>　　"${cust.username}"&gt;<BR>　　"${cust.orders}"&gt;<BR>　　"${order.formattedCost}"&gt;<BR>　　${order.date}<BR>　　"${order.items}"&gt;<BR>　　escapeXml="true"/&gt;<BR>　　${item.formattedPrice}</P>
<P>　　这个简洁的模板只输出订单历史视图需要的数据，不输出不相关的资料（例如商品说明）。创建产品搜索视图的定制 XML 应当同样简单，这个视图包含每个商品的完整说明和库存水平。</P>
<P>　　模板的问题</P>
<P>　　另一方面，现在我需要为每个不同视图创建一个新 JSP，而不能仅仅把需要的对象图组织起来并序列化它。从设计的角度来说，许多人可能会有争议，认为这无论如何是件好事，因为这意味着正式地考虑服务器要生成的文档类型。而且，因为我现在要处理通用的模板环境，而不是特定于 XML 的 API，所以确保标记匹配、元素和属性的顺序正确以及 XML 实体（例如 &lt; 或 &amp;）正确转义就成了我的责任<BR>JSP 的核心 out 标记使后面这项工作变得很容易，但是不是所有的模板技术都提供了这样的机制。最后，没有方便的途径可以在服务器端根据方案检验生成的 XML 文档的正确性，但这毕竟不是要在生产环境中做的事，可以方便地在开发期间处理它。</P>
<P>　　不用 XML 的响应数据</P>
<P>　　迄今为止，我介绍的所有技术都用 XML 文档的形式生成服务器响应。但是，XML 有一些问题。其中一个就是延迟。浏览器不能立即解析 XML 文档并生成 DOM 模型，所以这会降低某些 Ajax 组件需要的“迅捷”感，特别是在较慢的机器上解析大型文档的时候更是如此。</P>
<P>　　“现场搜索”就是一个示例，在这种搜索中，当用户输入搜索术语时，就会从服务器提取搜索结果并显示给用户。对于现场搜索组件来说，迅速地响应输入是非常重要的，但是同时它还需要迅速而持续地解析服务器的响应。</P>
<P>　　延迟是一个重要的考虑因素，但是避免使用 XML 的最大原因是差劲的客户端 DOM API。清单 5 显示了使用跨浏览器兼容的方式通过 DOM 得到某个值的时候，通常不得不面对的困难。</P>
<P>　　清单 5. 在 JavaScript 中导航 XML 响应文档</P>
<P>　// Find name of first item<BR>　　in customers last order<BR>　　var orderHistoryDoc = req.responseXML;<BR>　　var orders =<BR>　　orderHistoryDoc.getElementsByTagName("order");<BR>　　var lastOrder =<BR>　　orders[orders.length - 1];<BR>　　var firstItem =<BR>　　lastOrder.getElementsByTagName("item")[0];<BR>　　var itemNameElement =<BR>　　firstItem.firstChild;<BR>　　var itemNameText =<BR>　　itemNameElement.firstChild.data<BR>当元素中间存在空白时，情况就变得更加复杂，因为每个元素的 firstChild 经常是个空白文本节点。</P>
<P>　　现在有 JavaScript 库可以缓解处理 XML 文档的麻烦。这些库包括 Sarissa 和 Google-ajaXSLT，这两个库都把 XPath 功能添加到了大多数浏览器中。</P>
<P>　　但是，想想替代方案还是值得的。除了 responseXML 之外，XMLHttpRequest 对象还提供了名为 responseText 的属性，这个属性只是以字符串的方式提供服务器的响应体。</P>
<P>　　responseText 属性</P>
<P>　　当服务器需要向客户机发送非常简单的值时，responseText 特别方便，它可以避免 XML 导致的带宽支出和处理支出。例如，简单的 true/false 响应可以由服务器以纯文本方式返回，可以是逗号分隔的简单的名称或数字列表。</P>
<P>　　但是，一般来说，最好不要在同一个应用程序中把 XML 响应和纯文本响应混合使用；保持单一数据格式可以让代码抽象和重用更加简单。</P>
<P>　　responseText 与 XML 响应数据结合时也会有用。在只需要从响应文档中提取单一值的场景中，“欺骗性”地把 XML 当作文本字符串，而不把它当作结构化的文档对待，会更方便。</P>
<P>　　例如，清单 6 显示了如何用正则表达式从顾客的订单历史中提取第一笔订单的日期。不过，这实际是种花招，一般不应当依赖 XML 文档的词汇表达。</P>
<P>　　清单 6. 用正则表达式处理 XMLHttpRequest 的 responseText 对象</P>
<P>　var orderHistoryText =<BR>　　req.responseText;<BR>　　var matches =<BR>　　orderHistoryText.match<BR>　　(/(.*?)&lt;/date&gt;/);</P>
<P>　　var date = matches[1];在某些情况下，采用即时方式使用 responseText 会比较方便。但是，理想情况下，应当有种途径，可以用一种能够让 JavaScript 轻松导航、却没有 XML 处理支出的格式表示复杂的结构化数据。幸运的是，确实存在这样一种格式<BR>JavaScript 对象标注</P>
<P>　　实际上，JavaScript 对象的大部分都由联合数组、数字索引数组、字符串、数字或者这些类型的嵌套组合而成。因为所有类型都可以用 JavaScript 直接声明，所以可以在一条语句中静态地定义对象图。</P>
<P>　　清单 7 使用 JSON 语法声明了一个对象，并演示了如何访问这个对象。大括号表示联合数组（即对象），它的键 -值组合由逗号分隔。方括号表示数字索引数组。</P>
<P>　　清单 7. 用 JSON 在 JavaScript 中直接声明一个简单对象</P>
<P>　var band =<BR>　　{<BR>　　name: "The Beatles",<BR>　　members: [<BR>　　{<BR>　　name: "John",<BR>　　instruments:<BR>　　["Vocals","Guitar","Piano"]<BR>　　},<BR>　　{<BR>　　name: "Paul",<BR>　　instruments:<BR>　　["Vocals","Bass","Piano","Guitar"]<BR>　　},<BR>　　{<BR>　　name: "George",<BR>　　instruments:<BR>　　["Guitar","Vocals"]<BR>　　},<BR>　　{<BR>　　name: "Ringo",<BR>　　instruments:<BR>　　["Drums","Vocals"]<BR>　　}<BR>　　]<BR>　　};<BR>　　// Interrogate the band object<BR>　　var musician = band.members[3];<BR>　　alert( musician.name<BR>　　+ " played " +<BR>　　musician.instruments[0]<BR>　　+ " with " +<BR>　　band.name );</P>
<P>　　既然 JSON 是一个有趣的语言特性，那么它对 Ajax 有什么意义呢？妙处在于可以用 JSON 在 Ajax 服务器响应中通过网络发送 JavaScript 对象图<BR>这意味着在客户端可以避免使用笨拙的 DOM API 对 XML 进行导航 —— 只需要分析 JSON 响应，就会立即得到可以访问的 JavaScript 对象图。但是，首先需要把 JavaBean 变成 JSON。</P>
<P>　　从 Java 类产生 JSON</P>
<P>　　不同 XML 生成技术所具有的优缺点也适用于 JSON 的产生。而且可以证明，存在需要再次使用表示模板技术的情况。但是，使用 JSON 在理念上更接近于在应用层之间传递序列化的对象，而不是创建应用程序状态的视图。</P>
<P>　　我将介绍如何用 org.json 这个 Java API 在 Java 类上创建 toJSONObject() 方法。然后，就可以把 JSONObject 简单地序列化成 JSON。清单 8 反映了 清单 1 讨论的 XML，显示了 Order 类的 toJSONObject() 实现。</P>
<P>　　清单 8. Order 类的 toJSONObject() 方法实现</P>
<P>　public JSONObject toJSONObject()<BR>　　{<BR>　　JSONObject json = new JSONObject();<BR>　　json.put("id",id);<BR>　　json.put("cost",getFormattedCost());<BR>　　json.put("date",date);<BR>　　JSONArray jsonItems = new JSONArray();<BR>　　for (Iterator iter =<BR>　　items.iterator() ; iter.hasNext() ; )<BR>　　{<BR>　　jsonItems.put(iter.next().toJSONObject());<BR>　　}<BR>　　json.put("items",jsonItems);<BR>　　return json;<BR>　　}</P>
<P>　　可以看到，org.json API 非常简单。 JSONObject 代表 JavaScript 对象（即联合数组），有不同的 put() 方法，方法接受的 String 键和值是原生类型、String 类型或其他 JSON 类型。</P>
<P>　　JSONArray 代表索引数组，所以它的 put() 方法只接受一个值。请注意在清单 8 中，创建 jsonItems 数组，然后再用 put() 把它附加到 json 对象上；可以用另外一种方法做这项工作，就是对每个项目调用<BR>json.accumulate("items",</P>
<P>　　iter.next().toJSONObject());accumulate() 方法与 put()类似，区别在于它把值添加到按照键进行识别的索引数组。清单 9 显示了如何序列化 JSONObject 并把它写入 servlet 响应。</P>
<P>　　清单 9. 从 JSONObject 生成序列化的 JSON 响应</P>
<P>public void doGet(HttpServletRequest req,<BR>　　HttpServletResponse res)<BR>　　throws java.io.IOException,<BR>　　ServletException<BR>　　{<BR>　　String custId =<BR>　　req.getParameter("username");<BR>　　Customer customer =<BR>　　getCustomer(custId);<BR>　　res.setContentType("application/x-json");<BR>　　res.getWriter().print<BR>　　(customer.toJSONObject());</P>
<P>　　}可以看到，它实际上什么也没有做。在这里隐式调用的 JSONObject 的 toString() 方法做了所有工作。请注意，application/x-json 内容类型还有一点不确定 —— 在编写这篇文章的时候，关于 JSON 应当属于什么 MIME 类型还没有定论。但是，目前 application/x-json 是合理的选择。清单 10 显示了这个 servlet 代码的示例响应。</P>
<P>　　清单 10. Customer bean 的 JSON 表示</P>
<P>　{<BR>　　"orders":<BR>　　[<BR>　　{<BR>　　"items":<BR>　　[<BR>　　{<BR>　　"price": "$49.99",<BR>　　"description": "<BR>　　512 Megabyte Type 1 CompactFlash card.<BR>　　Manufactured by Oolong Industries",<BR>　　"name": "Oolong 512MB CF Card",<BR>　　"id": "i-55768"<BR>　　},<BR>　　{<BR>　　"price": "$299.99",<BR>　　"description": "<BR>　　7.2 Megapixel digital camera featuring six<BR>　　shooting modes and 3x optical zoom. Silver.",<BR>　　"name": "Fujak Superpix72 Camera",<BR>　　"id": "i-74491"<BR>　　}<BR>　　],<BR>　　"date": "08-26-2005",<BR>　　"cost": "$349.98",<BR>　　"id": "o-11123"<BR>　　}<BR>　　],<BR>　　"realname": "James Hyrax",<BR>　　"username": "jimmy66"<BR>　　}</P>
<P>在客户端使用 JSON</P>
<P>　　处理的最后一步是把在客户端把 JSON 数据变成 JavaScript 对象。这可以通过对 eval() 的简单调用实现，这个函数可以即时地解释包含 JavaScript 表达式的字符串。</P>
<P>　　清单 11 把 JSON 响应转变成 JavaScript 对象图，然后执行清单 5 的任务，从顾客的最后一次订单中得到第一个商品的名称。</P>
<P>　　清单 11. 评估 JSON 响应</P>
<P><CODE>　var jsonExpression =<BR>　　"(" + req.responseText + ")";<BR>　　var customer = eval(jsonExpression);<BR>　　// Find name of first<BR>　　item in customers last order<BR>　　var lastOrder = customer.orders<BR>　　[customer.orders.length-1];<BR>　　var name = lastOrder.items[0].name;</CODE></P>
<P>　　比较清单 11 和 清单 5 可以发现使用 JSON 的客户端的优势。如果在 Ajax 项目中要在客户端对许多复杂的服务器响应进行导航，那么 JSON 可能适合您的需要。</P>
<P>　　JSON 和 XMLHttpRequest 结合还会让 Ajax 交互看起来更像 RPC 调用而不是 SOA 请求，这对应用程序的设计可能会有意义。 </P>
<P>　　JSON 的不足</P>
<P>　　JSON 也有它的不足。使用这里介绍的 JSON 方式，就没有办法针对每个请求对对象的序列化进行裁剪，所以不需要的字段可能经常会在网络上发送。</P>
<P>　　另外，添加 toJSONObject() 方法到每个 JavaBean，可伸缩性不太好，虽然用内省和标注编写一个通用的 JavaBean 到 JSON 的序列化器可能很简单。最后，如果服务器端代码是面向服务的，没有单独针对处理 Ajax 客户请求调整过，那么由于对 XML 一致的支持，XML 会是更好的选择。</P>
<P>　　比较序列化技术</P>
<P>　　现在已经看到了把 Java 状态传输到 Ajax 客户端的五种不同技术。我讨论了自行手工编码 XML 序列化、通过代码生成的 XML 绑定、通过映射机制的 XML 绑定、基于模板的 XML 生成以及手工编码到 JSON 的序列化。</P>
<P></P>
<P>　　每种技术都有自己的优势和不足，分别适用于不同的应用程序架构。为了总结每种方式的优势与不足，表 1 从六个方面进行了粗略的评分：</P>
<P>　　可伸缩性</P>
<P>　　描述技术适应大量数据类型的容易程度。对于每个附加类型，编码和配置工作量是否会增长？</P>
<P>　　易于集成</P>
<P>　　评估把技术集成到项目的简单程度。是否需要更加复杂的构建过程？是否增加了部署的复杂性？</P>
<P>　　Java 类 API</P>
<P>　　描述以指定方式处理服务器端 Java 对象的容易程度。是可以编写普通的 bean，还是不得不处理笨拙的文档表示？</P>
<P>　　对输出的控制</P>
<P>　　描述对类的序列化表示控制的精确程度。</P>
<P>　　视图灵活性</P>
<P><CLK>　　评估从同一组对象是否可以创建不同的、定制的数据序列化。</CLK></P>
<P>　　客户端数据访问</P>
<P>　　描述 JavaScript 代码处理服务器响应数据的难易程度。</P>
<P></P>
<P>　　结束语</P>
<P>　　表 1 中的数据并不表明某项序列化技术比其他的技术好。毕竟，六种标准的相对重要性取决于项目的具体情况。例如，如果要处理数百种数据类型，这时想要的是可伸缩性，那么代码生成可能就是最好的选择。</P>
<P>　　如果需要为同一数据模型生成多个不同视图，那么就应当使用页面模板。如果处理的是小规模项目，想降低需要编写的JavaScript代码数量，那么请考虑JSON。希望这篇文章为您提供了选择适合自己应用程序的序列化技术所需要的的信息</P>
本文作者:<P>这种类型的 XML 绑定框架在数据拆解时最有用（例如，使用 XML 文档并把它们转化成 Java 对象）。除非拥有大型数据模型而且有可能从生成的类中获益，否则基于代码生成的框架对于 Ajax 应用程序来说可能有很大的杀伤力。</P>
<P>　　映射方式</P>
<P>　　采用映射方式的框架包括 Castor 和 Apache Commons Betwixt。映射通常是比代码生成更灵活和更轻量的解决方案。首先，可以像通常一样编写 JavaBean，包括任何行为以及任何自己喜欢的方便的方法。</P>
<P>　　然后，在运行时，调用框架中基于内省的编排器，并根据对象成员的类型、名称和值生成 XML 文档。通过定义类的映射文件，可以覆盖默认的绑定策略，并就类在 XML 中的表示方式对编排器提出建议。</P>
<P>　　这种方法是在可伸缩性与灵活性之间的良好折中。可以按照自己喜欢的方式编写 Java 类，编排器负责处理 XML。虽然映射定义文件编写起来简单，可伸缩性也足够好，但是映射规则最多只能改变标准的绑定行为，而且在对象结构和它们的 XML 表示之间总要残留一些耦合。最终，可能不得不在 Java 表示或 XML 格式之间任选一个做些折中，才能让映射方法起作用。</P>
<P>　　数据绑定总结</P>
<P>　　Dennis Sosnoski 就 XML 数据绑定 API 的主题，在代码生成和代码映射两个方面写了深入的文章。如果想进一步研究这个领域，我推荐他在 Castor 和代码生成框架方面的精彩文章。</P>
<P>　　总之，代码生成方式损失了过多的灵活性和方便性，对于典型的 Ajax 应用程序用处不大。另一方面，基于映射的框架可能工作得很好，但是要恰到好处地调整它们的映射策略，以便从对象生成需要的 XML。</P>
<P>　　所有的 XML 绑定 API 都具有手工序列化技术的一个主要不足：模型和视图的耦合。被限制为一个类型一个 XML 表示，就意味着在网络上总要有冗余数据传输<BR></P>
<P>　　在传统的 Web 应用程序开发中，采用页面模板系统把视图生成与控制器逻辑和模型数据干净地分离。这种方法在 Ajax 场景中也会有帮助。</P>
<P>　　页面模板系统</P>
<P>　　任何通用目的的页面模板技术都可以用来生成 XML，从而使 Ajax 应用程序根据自己的数据模型生成任何 XML 响应文档。</P>
<P>　　额外收获是：模板可以用简单的、表现力强的标记语言编写，而不是用一行行的 Java 代码编写。清单 5 是一个 JSP 页面，采用了 Customer bean 并表示出定制的 XML 视图，适合客户端代码生成订单历史组件。</P>
<P>　　清单 4. 生成订单历史文档的 JSP</P>
<P>value="${requestScope.customer}"/&gt;<BR>　　"${cust.username}"&gt;<BR>　　"${cust.orders}"&gt;<BR>　　"${order.formattedCost}"&gt;<BR>　　${order.date}<BR>　　"${order.items}"&gt;<BR>　　escapeXml="true"/&gt;<BR>　　${item.formattedPrice}</P>
<P>　　这个简洁的模板只输出订单历史视图需要的数据，不输出不相关的资料（例如商品说明）。创建产品搜索视图的定制 XML 应当同样简单，这个视图包含每个商品的完整说明和库存水平。</P>
<P>　　模板的问题</P>
<P>　　另一方面，现在我需要为每个不同视图创建一个新 JSP，而不能仅仅把需要的对象图组织起来并序列化它。从设计的角度来说，许多人可能会有争议，认为这无论如何是件好事，因为这意味着正式地考虑服务器要生成的文档类型。而且，因为我现在要处理通用的模板环境，而不是特定于 XML 的 API，所以确保标记匹配、元素和属性的顺序正确以及 XML 实体（例如 &lt; 或 &amp;）正确转义就成了我的责任<BR>JSP 的核心 out 标记使后面这项工作变得很容易，但是不是所有的模板技术都提供了这样的机制。最后，没有方便的途径可以在服务器端根据方案检验生成的 XML 文档的正确性，但这毕竟不是要在生产环境中做的事，可以方便地在开发期间处理它。</P>
<P>　　不用 XML 的响应数据</P>
<P>　　迄今为止，我介绍的所有技术都用 XML 文档的形式生成服务器响应。但是，XML 有一些问题。其中一个就是延迟。浏览器不能立即解析 XML 文档并生成 DOM 模型，所以这会降低某些 Ajax 组件需要的“迅捷”感，特别是在较慢的机器上解析大型文档的时候更是如此。</P>
<P>　　“现场搜索”就是一个示例，在这种搜索中，当用户输入搜索术语时，就会从服务器提取搜索结果并显示给用户。对于现场搜索组件来说，迅速地响应输入是非常重要的，但是同时它还需要迅速而持续地解析服务器的响应。</P>
<P>　　延迟是一个重要的考虑因素，但是避免使用 XML 的最大原因是差劲的客户端 DOM API。清单 5 显示了使用跨浏览器兼容的方式通过 DOM 得到某个值的时候，通常不得不面对的困难。</P>
<P>　　清单 5. 在 JavaScript 中导航 XML 响应文档</P>
<P>　// Find name of first item<BR>　　in customers last order<BR>　　var orderHistoryDoc = req.responseXML;<BR>　　var orders =<BR>　　orderHistoryDoc.getElementsByTagName("order");<BR>　　var lastOrder =<BR>　　orders[orders.length - 1];<BR>　　var firstItem =<BR>　　lastOrder.getElementsByTagName("item")[0];<BR>　　var itemNameElement =<BR>　　firstItem.firstChild;<BR>　　var itemNameText =<BR>　　itemNameElement.firstChild.data<BR>当元素中间存在空白时，情况就变得更加复杂，因为每个元素的 firstChild 经常是个空白文本节点。</P>
<P>　　现在有 JavaScript 库可以缓解处理 XML 文档的麻烦。这些库包括 Sarissa 和 Google-ajaXSLT，这两个库都把 XPath 功能添加到了大多数浏览器中。</P>
<P>　　但是，想想替代方案还是值得的。除了 responseXML 之外，XMLHttpRequest 对象还提供了名为 responseText 的属性，这个属性只是以字符串的方式提供服务器的响应体。</P>
<P>　　responseText 属性</P>
<P>　　当服务器需要向客户机发送非常简单的值时，responseText 特别方便，它可以避免 XML 导致的带宽支出和处理支出。例如，简单的 true/false 响应可以由服务器以纯文本方式返回，可以是逗号分隔的简单的名称或数字列表。</P>
<P>　　但是，一般来说，最好不要在同一个应用程序中把 XML 响应和纯文本响应混合使用；保持单一数据格式可以让代码抽象和重用更加简单。</P>
<P>　　responseText 与 XML 响应数据结合时也会有用。在只需要从响应文档中提取单一值的场景中，“欺骗性”地把 XML 当作文本字符串，而不把它当作结构化的文档对待，会更方便。</P>
<P>　　例如，清单 6 显示了如何用正则表达式从顾客的订单历史中提取第一笔订单的日期。不过，这实际是种花招，一般不应当依赖 XML 文档的词汇表达。</P>
<P>　　清单 6. 用正则表达式处理 XMLHttpRequest 的 responseText 对象</P>
<P>　var orderHistoryText =<BR>　　req.responseText;<BR>　　var matches =<BR>　　orderHistoryText.match<BR>　　(/(.*?)&lt;/date&gt;/);</P>
<P>　　var date = matches[1];在某些情况下，采用即时方式使用 responseText 会比较方便。但是，理想情况下，应当有种途径，可以用一种能够让 JavaScript 轻松导航、却没有 XML 处理支出的格式表示复杂的结构化数据。幸运的是，确实存在这样一种格式<BR>JavaScript 对象标注</P>
<P>　　实际上，JavaScript 对象的大部分都由联合数组、数字索引数组、字符串、数字或者这些类型的嵌套组合而成。因为所有类型都可以用 JavaScript 直接声明，所以可以在一条语句中静态地定义对象图。</P>
<P>　　清单 7 使用 JSON 语法声明了一个对象，并演示了如何访问这个对象。大括号表示联合数组（即对象），它的键 -值组合由逗号分隔。方括号表示数字索引数组。</P>
<P>　　清单 7. 用 JSON 在 JavaScript 中直接声明一个简单对象</P>
<P>　var band =<BR>　　{<BR>　　name: "The Beatles",<BR>　　members: [<BR>　　{<BR>　　name: "John",<BR>　　instruments:<BR>　　["Vocals","Guitar","Piano"]<BR>　　},<BR>　　{<BR>　　name: "Paul",<BR>　　instruments:<BR>　　["Vocals","Bass","Piano","Guitar"]<BR>　　},<BR>　　{<BR>　　name: "George",<BR>　　instruments:<BR>　　["Guitar","Vocals"]<BR>　　},<BR>　　{<BR>　　name: "Ringo",<BR>　　instruments:<BR>　　["Drums","Vocals"]<BR>　　}<BR>　　]<BR>　　};<BR>　　// Interrogate the band object<BR>　　var musician = band.members[3];<BR>　　alert( musician.name<BR>　　+ " played " +<BR>　　musician.instruments[0]<BR>　　+ " with " +<BR>　　band.name );</P>
<P>　　既然 JSON 是一个有趣的语言特性，那么它对 Ajax 有什么意义呢？妙处在于可以用 JSON 在 Ajax 服务器响应中通过网络发送 JavaScript 对象图<BR>这意味着在客户端可以避免使用笨拙的 DOM API 对 XML 进行导航 —— 只需要分析 JSON 响应，就会立即得到可以访问的 JavaScript 对象图。但是，首先需要把 JavaBean 变成 JSON。</P>
<P>　　从 Java 类产生 JSON</P>
<P>　　不同 XML 生成技术所具有的优缺点也适用于 JSON 的产生。而且可以证明，存在需要再次使用表示模板技术的情况。但是，使用 JSON 在理念上更接近于在应用层之间传递序列化的对象，而不是创建应用程序状态的视图。</P>
<P>　　我将介绍如何用 org.json 这个 Java API 在 Java 类上创建 toJSONObject() 方法。然后，就可以把 JSONObject 简单地序列化成 JSON。清单 8 反映了 清单 1 讨论的 XML，显示了 Order 类的 toJSONObject() 实现。</P>
<P>　　清单 8. Order 类的 toJSONObject() 方法实现</P>
<P>　public JSONObject toJSONObject()<BR>　　{<BR>　　JSONObject json = new JSONObject();<BR>　　json.put("id",id);<BR>　　json.put("cost",getFormattedCost());<BR>　　json.put("date",date);<BR>　　JSONArray jsonItems = new JSONArray();<BR>　　for (Iterator iter =<BR>　　items.iterator() ; iter.hasNext() ; )<BR>　　{<BR>　　jsonItems.put(iter.next().toJSONObject());<BR>　　}<BR>　　json.put("items",jsonItems);<BR>　　return json;<BR>　　}</P>
<P>　　可以看到，org.json API 非常简单。 JSONObject 代表 JavaScript 对象（即联合数组），有不同的 put() 方法，方法接受的 String 键和值是原生类型、String 类型或其他 JSON 类型。</P>
<P>　　JSONArray 代表索引数组，所以它的 put() 方法只接受一个值。请注意在清单 8 中，创建 jsonItems 数组，然后再用 put() 把它附加到 json 对象上；可以用另外一种方法做这项工作，就是对每个项目调用<BR>json.accumulate("items",</P>
<P>　　iter.next().toJSONObject());accumulate() 方法与 put()类似，区别在于它把值添加到按照键进行识别的索引数组。清单 9 显示了如何序列化 JSONObject 并把它写入 servlet 响应。</P>
<P>　　清单 9. 从 JSONObject 生成序列化的 JSON 响应</P>
<P>public void doGet(HttpServletRequest req,<BR>　　HttpServletResponse res)<BR>　　throws java.io.IOException,<BR>　　ServletException<BR>　　{<BR>　　String custId =<BR>　　req.getParameter("username");<BR>　　Customer customer =<BR>　　getCustomer(custId);<BR>　　res.setContentType("application/x-json");<BR>　　res.getWriter().print<BR>　　(customer.toJSONObject());</P>
<P>　　}可以看到，它实际上什么也没有做。在这里隐式调用的 JSONObject 的 toString() 方法做了所有工作。请注意，application/x-json 内容类型还有一点不确定 —— 在编写这篇文章的时候，关于 JSON 应当属于什么 MIME 类型还没有定论。但是，目前 application/x-json 是合理的选择。清单 10 显示了这个 servlet 代码的示例响应。</P>
<P>　　清单 10. Customer bean 的 JSON 表示</P>
<P>　{<BR>　　"orders":<BR>　　[<BR>　　{<BR>　　"items":<BR>　　[<BR>　　{<BR>　　"price": "$49.99",<BR>　　"description": "<BR>　　512 Megabyte Type 1 CompactFlash card.<BR>　　Manufactured by Oolong Industries",<BR>　　"name": "Oolong 512MB CF Card",<BR>　　"id": "i-55768"<BR>　　},<BR>　　{<BR>　　"price": "$299.99",<BR>　　"description": "<BR>　　7.2 Megapixel digital camera featuring six<BR>　　shooting modes and 3x optical zoom. Silver.",<BR>　　"name": "Fujak Superpix72 Camera",<BR>　　"id": "i-74491"<BR>　　}<BR>　　],<BR>　　"date": "08-26-2005",<BR>　　"cost": "$349.98",<BR>　　"id": "o-11123"<BR>　　}<BR>　　],<BR>　　"realname": "James Hyrax",<BR>　　"username": "jimmy66"<BR>　　}</P>
<P>在客户端使用 JSON</P>
<P>　　处理的最后一步是把在客户端把 JSON 数据变成 JavaScript 对象。这可以通过对 eval() 的简单调用实现，这个函数可以即时地解释包含 JavaScript 表达式的字符串。</P>
<P>　　清单 11 把 JSON 响应转变成 JavaScript 对象图，然后执行清单 5 的任务，从顾客的最后一次订单中得到第一个商品的名称。</P>
<P>　　清单 11. 评估 JSON 响应</P>
<P><CODE>　var jsonExpression =<BR>　　"(" + req.responseText + ")";<BR>　　var customer = eval(jsonExpression);<BR>　　// Find name of first<BR>　　item in customers last order<BR>　　var lastOrder = customer.orders<BR>　　[customer.orders.length-1];<BR>　　var name = lastOrder.items[0].name;</CODE></P>
<P>　　比较清单 11 和 清单 5 可以发现使用 JSON 的客户端的优势。如果在 Ajax 项目中要在客户端对许多复杂的服务器响应进行导航，那么 JSON 可能适合您的需要。</P>
<P>　　JSON 和 XMLHttpRequest 结合还会让 Ajax 交互看起来更像 RPC 调用而不是 SOA 请求，这对应用程序的设计可能会有意义。 </P>
<P>　　JSON 的不足</P>
<P>　　JSON 也有它的不足。使用这里介绍的 JSON 方式，就没有办法针对每个请求对对象的序列化进行裁剪，所以不需要的字段可能经常会在网络上发送。</P>
<P>　　另外，添加 toJSONObject() 方法到每个 JavaBean，可伸缩性不太好，虽然用内省和标注编写一个通用的 JavaBean 到 JSON 的序列化器可能很简单。最后，如果服务器端代码是面向服务的，没有单独针对处理 Ajax 客户请求调整过，那么由于对 XML 一致的支持，XML 会是更好的选择。</P>
<P>　　比较序列化技术</P>
<P>　　现在已经看到了把 Java 状态传输到 Ajax 客户端的五种不同技术。我讨论了自行手工编码 XML 序列化、通过代码生成的 XML 绑定、通过映射机制的 XML 绑定、基于模板的 XML 生成以及手工编码到 JSON 的序列化。</P>
<P></P>
<P>　　每种技术都有自己的优势和不足，分别适用于不同的应用程序架构。为了总结每种方式的优势与不足，表 1 从六个方面进行了粗略的评分：</P>
<P>　　可伸缩性</P>
<P>　　描述技术适应大量数据类型的容易程度。对于每个附加类型，编码和配置工作量是否会增长？</P>
<P>　　易于集成</P>
<P>　　评估把技术集成到项目的简单程度。是否需要更加复杂的构建过程？是否增加了部署的复杂性？</P>
<P>　　Java 类 API</P>
<P>　　描述以指定方式处理服务器端 Java 对象的容易程度。是可以编写普通的 bean，还是不得不处理笨拙的文档表示？</P>
<P>　　对输出的控制</P>
<P>　　描述对类的序列化表示控制的精确程度。</P>
<P>　　视图灵活性</P>
<P><CLK>　　评估从同一组对象是否可以创建不同的、定制的数据序列化。</CLK></P>
<P>　　客户端数据访问</P>
<P>　　描述 JavaScript 代码处理服务器响应数据的难易程度。</P>
<P></P>
<P>　　结束语</P>
<P>　　表 1 中的数据并不表明某项序列化技术比其他的技术好。毕竟，六种标准的相对重要性取决于项目的具体情况。例如，如果要处理数百种数据类型，这时想要的是可伸缩性，那么代码生成可能就是最好的选择。</P>
<P>　　如果需要为同一数据模型生成多个不同视图，那么就应当使用页面模板。如果处理的是小规模项目，想降低需要编写的JavaScript代码数量，那么请考虑JSON。希望这篇文章为您提供了选择适合自己应用程序的序列化技术所需要的的信息</P>
本文作者:
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/158.html'>实例讲解JSP Model2体系结构（中）</a><a>下一篇</a><a href='/php/biji/160.html'>用js实现的检测浏览器和系统的函数</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>