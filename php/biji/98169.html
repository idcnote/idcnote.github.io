<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Linux内核模块编写详解_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Linux内核模块编写详解</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核只是一个很大的、很复杂的C程序，它对每个人开放，任何人都去读它、学习它并改进它，而你也可以是其中之一。</p>
<p align="center"></p>
<p><br />学习内核编程的最简单的方式也许就是写个内核模块：一段可以动态加载进内核的代码。模块所能做的事是有限的&mdash;&mdash;例如，他们不能在类似进程描述符这样的公共数据结构中增减字段（LCTT译注：可能会破坏整个内核及系统的功能）。但是，在其它方面，他们是成熟的内核级的代码，可以在需要时随时编译进内核（这样就可以摒弃所有的限制了）。完全可以在Linux源代码树以外来开发并编译一个模块（这并不奇怪，它称为树外开发），如果你只是想稍微玩玩，而并不想提交修改以包含到主线内核中去，这样的方式是很方便的。</p>
<p>在本教程中，我们将开发一个简单的内核模块用以创建一个/dev/reverse设备。写入该设备的字符串将以相反字序的方式读回（&ldquo;Hello World&rdquo;读成&ldquo;World Hello&rdquo;）。这是一个很受欢迎的程序员面试难题，当你利用自己的能力在内核级别实现这个功能时，可以使你得到一些加分。在开始前，有一句忠告：你的模块中的一个bug就会导致系统崩溃（虽然可能性不大，但还是有可能的）和数据丢失。在开始前，请确保你已经将重要数据备份，或者，采用一种更好的方式，在虚拟机中进行试验。</p>
<p><strong>尽可能不要用root身份</strong></p>
<p>默认情况下，/dev/reverse只有root可以使用，因此你只能使用sudo来运行你的测试程序。要解决该限制，可以创建一个包含以下内容的/lib/udev/rules.d/99-reverse.rules文件：</p>
<p>SUBSYSTEM==&quot;misc&quot;, KERNEL==&quot;reverse&quot;, MODE=&quot;0666&quot;<br />别忘了重新插入模块。让非root用户访问设备节点往往不是一个好主意，但是在开发其间却是十分有用的。这并不是说以root身份运行二进制测试文件也不是个好主意。<br /><strong>模块的构造</strong></p>
<p>由于大多数的Linux内核模块是用C写的（除了底层的特定于体系结构的部分），所以推荐你将你的模块以单一文件形式保存（例如，reverse.c）。我们已经把完整的源代码放在GitHub上&mdash;&mdash;这里我们将看其中的一些片段。开始时，我们先要包含一些常见的文件头，并用预定义的宏来描述模块：</p>
<p>这里一切都直接明了，除了MODULE_LICENSE()：它不仅仅是一个标记。内核坚定地支持GPL兼容代码，因此如果你把许可证设置为其它非GPL兼容的（如，&ldquo;Proprietary&rdquo;[专利]），某些特定的内核功能将在你的模块中不可用。</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_4584')">复制内容到剪贴板</span></div>
<div id="code_4584">
<ol class="dp-bash">
<li class="alt"><span><span class="comments">#include&nbsp;&lt;linux/init.h&gt; </span><span>&nbsp;&nbsp;</span></span></li>
<li><span></span><span class="comments">#include&nbsp;&lt;linux/kernel.h&gt; </span><span>&nbsp;&nbsp;</span></li>
<li class="alt"><span></span><span class="comments">#include&nbsp;&lt;linux/module.h&gt; </span><span>&nbsp;&nbsp;</span></li>
<li><span>MODULE_LICENSE(</span><span class="string">&quot;GPL&quot;</span><span>); &nbsp;&nbsp;</span></li>
<li class="alt"><span>MODULE_AUTHOR(</span><span class="string">&quot;Valentine&nbsp;Sinitsyn&nbsp;&lt;valentine.sinitsyn@gmail.com&gt;&quot;</span><span>); &nbsp;&nbsp;</span></li>
<li><span>MODULE_DESCRIPTION(</span><span class="string">&quot;In-kernel&nbsp;phrase&nbsp;reverser&quot;</span><span>); &nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p><strong>什么时候不该写内核模块</strong></p>
<p>内核编程很有趣，但是在现实项目中写（尤其是调试）内核代码要求特定的技巧。通常来讲，在没有其它方式可以解决你的问题时，你才应该在内核级别解决它。以下情形中，可能你在用户空间中解决它更好：</p>
<p>你要开发一个USB驱动 &mdash;&mdash; 请查看libusb。<br />你要开发一个文件系统 &mdash;&mdash; 试试FUSE。<br />你在扩展Netfilter &mdash;&mdash; 那么libnetfilter_queue对你有所帮助。<br />通常，内核里面代码的性能会更好，但是对于许多项目而言，这点性能丢失并不严重。<br />由于内核编程总是异步的，没有一个main()函数来让Linux顺序执行你的模块。取而代之的是，你要为各种事件提供回调函数，像这个：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_3409')">复制内容到剪贴板</span></div>
<div id="code_3409">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;int&nbsp;__init&nbsp;reverse_init(void) &nbsp;&nbsp;</span></span></li>
<li><span>{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO&nbsp;</span><span class="string">&quot;reverse&nbsp;device&nbsp;has&nbsp;been&nbsp;registered\n&quot;</span><span>); &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0; &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>static&nbsp;void&nbsp;__exit&nbsp;reverse_exit(void) &nbsp;&nbsp;</span></li>
<li class="alt"><span>{ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO&nbsp;</span><span class="string">&quot;reverse&nbsp;device&nbsp;has&nbsp;been&nbsp;unregistered\n&quot;</span><span>); &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>module_init(reverse_init); &nbsp;&nbsp;</span></li>
<li class="alt"><span>module_exit(reverse_exit);&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>这里，我们定义的函数被称为模块的插入和删除。只有第一个的插入函数是必要的。目前，它们只是打印消息到内核环缓冲区（可以在用户空间通过dmesg命令访问）；KERN_INFO是日志级别（注意，没有逗号）。__init和__exit是属性 &mdash;&mdash; 联结到函数（或者变量）的元数据片。属性在用户空间的C代码中是很罕见的，但是内核中却很普遍。所有标记为__init的，会在初始化后释放内存以供重用（还记得那条过去内核的那条&ldquo;Freeing unused kernel memory&hellip;[释放未使用的内核内存&hellip;&hellip;]&rdquo;信息吗？）。__exit表明，当代码被静态构建进内核时，该函数可以安全地优化了，不需要清理收尾。最后，module_init()和module_exit()这两个宏将reverse_init()和reverse_exit()函数设置成为我们模块的生命周期回调函数。实际的函数名称并不重要，你可以称它们为init()和exit()，或者start()和stop()，你想叫什么就叫什么吧。他们都是静态声明，你在外部模块是看不到的。事实上，内核中的任何函数都是不可见的，除非明确地被导出。然而，在内核程序员中，给你的函数加上模块名前缀是约定俗成的。</p>
<p>这些都是些基本概念 &ndash; 让我们来做更多有趣的事情吧。模块可以接收参数，就像这样：</p>
<p># modprobe foo bar=1</p>
<p>modinfo命令显示了模块接受的所有参数，而这些也可以在/sys/module//parameters下作为文件使用。我们的模块需要一个缓冲区来存储参数 &mdash;&mdash; 让我们把这大小设置为用户可配置。在MODULE_DESCRIPTION()下添加如下三行：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_4482')">复制内容到剪贴板</span></div>
<div id="code_4482">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;unsigned&nbsp;long&nbsp;buffer_size&nbsp;=&nbsp;8192; &nbsp;&nbsp;</span></span></li>
<li><span>module_param(buffer_size,&nbsp;ulong,&nbsp;(S_IRUSR&nbsp;|&nbsp;S_IRGRP&nbsp;|&nbsp;S_IROTH)); &nbsp;&nbsp;</span></li>
<li class="alt"><span>MODULE_PARM_DESC(buffer_size,&nbsp;</span><span class="string">&quot;Internal&nbsp;buffer&nbsp;size&quot;</span><span>);&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>这儿，我们定义了一个变量来存储该值，封装成一个参数，并通过sysfs来让所有人可读。这个参数的描述（最后一行）出现在modinfo的输出中。</p>
<p>由于用户可以直接设置buffer_size，我们需要在reverse_init()来清除无效取值。你总该检查来自内核之外的数据 &mdash;&mdash; 如果你不这么做，你就是将自己置身于内核异常或安全漏洞之中。</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_7442')">复制内容到剪贴板</span></div>
<div id="code_7442">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;int&nbsp;__init&nbsp;reverse_init() &nbsp;&nbsp;</span></span></li>
<li><span>{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(!buffer_size) &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;-1; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">&quot;reverse&nbsp;device&nbsp;has&nbsp;been&nbsp;registered,&nbsp;buffer&nbsp;size&nbsp;is&nbsp;%lu&nbsp;bytes\n&quot;</span><span>, &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_size); &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0; &nbsp;&nbsp;</span></li>
<li class="alt"><span>}&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>来自模块初始化函数的非0返回值意味着模块执行失败。</p>
<p><strong>导航</strong></p>
<p>但你开发模块时，Linux内核就是你所需一切的源头。然而，它相当大，你可能在查找你所要的内容时会有困难。幸运的是，在庞大的代码库面前，有许多工具使这个过程变得简单。首先，是Cscope &mdash;&mdash; 在终端中运行的一个比较经典的工具。你所要做的，就是在内核源代码的顶级目录中运行make cscope &amp;&amp; cscope。Cscope和Vim以及Emacs整合得很好，因此你可以在你最喜爱的编辑器中使用它。</p>
<p>如果基于终端的工具不是你的最爱，那么就访问http://lxr.free-electrons.com吧。它是一个基于web的内核导航工具，即使它的功能没有Cscope来得多（例如，你不能方便地找到函数的用法），但它仍然提供了足够多的快速查询功能。<br />现在是时候来编译模块了。你需要你正在运行的内核版本头文件（linux-headers，或者等同的软件包）和build-essential（或者类似的包）。接下来，该创建一个标准的Makefile模板：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_7626')">复制内容到剪贴板</span></div>
<div id="code_7626">
<ol class="dp-bash">
<li class="alt"><span><span>obj-m&nbsp;+=&nbsp;reverse.o &nbsp;&nbsp;</span></span></li>
<li><span>all: &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="func">make</span><span>&nbsp;-C&nbsp;/lib/modules/$(shell&nbsp;</span><span class="func">uname</span><span>&nbsp;-r)/build&nbsp;M=$(PWD)&nbsp;modules &nbsp;&nbsp;</span></li>
<li><span>clean: &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="func">make</span><span>&nbsp;-C&nbsp;/lib/modules/$(shell&nbsp;</span><span class="func">uname</span><span>&nbsp;-r)/build&nbsp;M=$(PWD)&nbsp;clean&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>现在，调用make来构建你的第一个模块。如果你输入的都正确，在当前目录内会找到reverse.ko文件。使用sudo insmod reverse.ko插入内核模块，然后运行如下命令：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_6196')">复制内容到剪贴板</span></div>
<div id="code_6196">
<ol class="dp-bash">
<li class="alt"><span><span>$&nbsp;dmesg&nbsp;|&nbsp;</span><span class="func">tail</span><span>&nbsp;-1 &nbsp;&nbsp;</span></span></li>
<li><span>[&nbsp;5905.042081]&nbsp;reverse&nbsp;device&nbsp;has&nbsp;been&nbsp;registered,&nbsp;buffer&nbsp;size&nbsp;is&nbsp;8192&nbsp;bytes&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>恭喜了！然而，目前这一行还只是假象而已 &mdash;&mdash; 还没有设备节点呢。让我们来搞定它。</p>
<p><strong>混杂设备</strong></p>
<p>在Linux中，有一种特殊的字符设备类型，叫做&ldquo;混杂设备&rdquo;（或者简称为&ldquo;misc&rdquo;）。它是专为单一接入点的小型设备驱动而设计的，而这正是我们所需要的。所有混杂设备共享同一个主设备号（10），因此一个驱动(drivers/char/misc.c）就可以查看它们所有设备了，而这些设备用次设备号来区分。从其他意义来说，它们只是普通字符设备。</p>
<p>要为该设备注册一个次设备号（以及一个接入点），你需要声明struct misc_device，填上所有字段（注意语法），然后使用指向该结构的指针作为参数来调用misc_register()。为此，你也需要包含linux/miscdevice.h头文件：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_8471')">复制内容到剪贴板</span></div>
<div id="code_8471">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;struct&nbsp;miscdevice&nbsp;reverse_misc_device&nbsp;=&nbsp;{ &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;.minor&nbsp;=&nbsp;MISC_DYNAMIC_MINOR, &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;.name&nbsp;=&nbsp;</span><span class="string">&quot;reverse&quot;</span><span>, &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;.fops&nbsp;=&nbsp;&amp;reverse_fops &nbsp;&nbsp;</span></li>
<li class="alt"><span>}; &nbsp;&nbsp;</span></li>
<li><span>static&nbsp;int&nbsp;__init&nbsp;reverse_init() &nbsp;&nbsp;</span></li>
<li class="alt"><span>{ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;misc_register(&amp;reverse_misc_device); &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;printk(KERN_INFO&nbsp;... &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>这儿，我们为名为&ldquo;reverse&rdquo;的设备请求一个第一个可用的（动态的）次设备号；省略号表明我们之前已经见过的省略的代码。别忘了在模块卸下后注销掉该设备。</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_4390')">复制内容到剪贴板</span></div>
<div id="code_4390">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;void&nbsp;__exit&nbsp;reverse_exit(void) &nbsp;&nbsp;</span></span></li>
<li><span>{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;misc_deregister(&amp;reverse_misc_device); &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>&lsquo;fops&rsquo;字段存储了一个指针，指向一个file_operations结构（在Linux/fs.h中声明），而这正是我们模块的接入点。reverse_fops定义如下：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_6675')">复制内容到剪贴板</span></div>
<div id="code_6675">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;struct&nbsp;file_operations&nbsp;reverse_fops&nbsp;=&nbsp;{ &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;.owner&nbsp;=&nbsp;THIS_MODULE, &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;.</span><span class="func">open</span><span>&nbsp;=&nbsp;reverse_open, &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;.llseek&nbsp;=&nbsp;noop_llseek &nbsp;&nbsp;</span></li>
<li><span>};&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>另外，reverse_fops包含了一系列回调函数（也称之为方法），当用户空间代码打开一个设备，读写或者关闭文件描述符时，就会执行。如果你要忽略这些回调，可以指定一个明确的回调函数来替代。这就是为什么我们将llseek设置为noop_llseek()，（顾名思义）它什么都不干。这个默认实现改变了一个文件指针，而且我们现在并不需要我们的设备可以寻址（这是今天留给你们的家庭作业）。</p>
<p><strong>关闭和打开</strong></p>
<p>让我们来实现该方法。我们将给每个打开的文件描述符分配一个新的缓冲区，并在它关闭时释放。这实际上并不安全：如果一个用户空间应用程序泄漏了描述符（也许是故意的），它就会霸占RAM，并导致系统不可用。在现实世界中，你总得考虑到这些可能性。但在本教程中，这种方法不要紧。</p>
<p>我们需要一个结构函数来描述缓冲区。内核提供了许多常规的数据结构：链接列表（双联的），哈希表，树等等之类。不过，缓冲区常常从头设计。我们将调用我们的&ldquo;struct buffer&rdquo;：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_2310')">复制内容到剪贴板</span></div>
<div id="code_2310">
<ol class="dp-bash">
<li class="alt"><span><span>struct&nbsp;buffer&nbsp;{ &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*data,&nbsp;*end,&nbsp;*read_ptr; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;size; &nbsp;&nbsp;</span></li>
<li><span>};&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>data是该缓冲区存储的一个指向字符串的指针，而end指向字符串结尾后的第一个字节。read_ptr是read()开始读取数据的地方。缓冲区的size是为了保证完整性而存储的 &mdash;&mdash; 目前，我们还没有使用该区域。你不能假设使用你结构体的用户会正确地初始化所有这些东西，所以最好在函数中封装缓冲区的分配和收回。它们通常命名为buffer_alloc()和buffer_free()。</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_8325')">复制内容到剪贴板</span></div>
<div id="code_8325">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;struct&nbsp;buffer&nbsp;buffer_alloc(unsigned&nbsp;long&nbsp;size)&nbsp; &nbsp;&nbsp;</span></span></li>
<li><span>{&nbsp;struct&nbsp;buffer&nbsp;*buf;&nbsp;buf&nbsp;=&nbsp;kzalloc(sizeof(buf),&nbsp;GFP_KERNEL); &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp; &nbsp;&nbsp;</span></li>
<li><span>(unlikely(!buf))&nbsp;goto&nbsp;out;&nbsp;&hellip;&nbsp;out:&nbsp;</span><span class="keyword">return</span><span>&nbsp;buf;&nbsp; &nbsp;&nbsp;</span></li>
<li class="alt"><span>}&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>内核内存使用kmalloc()来分配，并使用kfree()来释放；kzalloc()的风格是将内存设置为全零。不同于标准的malloc()，它的内核对应部分收到的标志指定了第二个参数中请求的内存类型。这里，GFP_KERNEL是说我们需要一个普通的内核内存（不是在DMA或高内存区中）以及如果需要的话函数可以睡眠（重新调度进程）。sizeof(*buf)是一种常见的方式，它用来获取可通过指针访问的结构体的大小。</p>
<p>你应该随时检查kmalloc()的返回值：访问NULL指针将导致内核异常。同时也需要注意unlikely()宏的使用。它（及其相对宏likely()）被广泛用于内核中，用于表明条件几乎总是真的（或假的）。它不会影响到控制流程，但是能帮助现代处理器通过分支预测技术来提升性能。</p>
<p>最后，注意goto语句。它们常常为认为是邪恶的，但是，Linux内核（以及一些其它系统软件）采用它们来实施集中式的函数退出。这样的结果是减少嵌套深度，使代码更具可读性，而且非常像更高级语言中的try-catch区块。</p>
<p>有了buffer_alloc()和buffer_free()，open和close方法就变得很简单了。</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_4214')">复制内容到剪贴板</span></div>
<div id="code_4214">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;int&nbsp;reverse_open(struct&nbsp;inode&nbsp;*inode,&nbsp;struct&nbsp;</span><span class="func">file</span><span>&nbsp;*</span><span class="func">file</span><span>) &nbsp;&nbsp;</span></span></li>
<li><span>{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;err&nbsp;=&nbsp;0; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="func">file</span><span>-&gt;private_data&nbsp;=&nbsp;buffer_alloc(buffer_size); &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;err; &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>struct file是一个标准的内核数据结构，用以存储打开的文件的信息，如当前文件位置（file-&gt;f_pos)、标志(file-&gt;f_flags），或者打开模式（file-&gt;f_mode)等。另外一个字段file-&gt;privatedata用于关联文件到一些专有数据，它的类型是void *，而且它在文件拥有者以外，对内核不透明。我们将一个缓冲区存储在那里。</p>
<p>如果缓冲区分配失败，我们通过返回否定值（-ENOMEM）来为调用的用户空间代码标明。一个C库中调用的open(2)系统调用(如glibc)将会检测这个并适当地设置errno 。</p>
<p><strong>学习如何读和写</strong></p>
<p>&ldquo;read&rdquo;和&ldquo;write&rdquo;方法是真正完成工作的地方。当数据写入到缓冲区时，我们放弃之前的内容和反向地存储该字段，不需要任何临时存储。read方法仅仅是从内核缓冲区复制数据到用户空间。但是如果缓冲区还没有数据，revers_eread()会做什么呢？在用户空间中，read()调用会在有可用数据前阻塞它。在内核中，你就必须等待。幸运的是，有一项机制用于处理这种情况，就是&lsquo;wait queues&rsquo;。</p>
<p>想法很简单。如果当前进程需要等待某个事件，它的描述符（struct task_struct存储&lsquo;current&rsquo;信息）被放进非可运行（睡眠中）状态，并添加到一个队列中。然后schedule()就被调用来选择另一个进程运行。生成事件的代码通过使用队列将等待进程放回TASK_RUNNING状态来唤醒它们。调度程序将在以后在某个地方选择它们之一。Linux有多种非可运行状态，最值得注意的是TASK_INTERRUPTIBLE（一个可以通过信号中断的睡眠）和TASK_KILLABLE（一个可被杀死的睡眠中的进程）。所有这些都应该正确处理，并等待队列为你做这些事。</p>
<p>一个用以存储读取等待队列头的天然场所就是结构缓冲区，所以从为它添加wait_queue_headt read\queue字段开始。你也应该包含linux/sched.h头文件。可以使用DECLARE_WAITQUEUE()宏来静态声明一个等待队列。在我们的情况下，需要动态初始化，因此添加下面这行到buffer_alloc()：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_5586')">复制内容到剪贴板</span></div>
<div id="code_5586">
<ol class="dp-bash">
<li class="alt"><span><span>init_waitqueue_head(&amp;buf-&gt;read_queue);&nbsp;&nbsp;</span></span></li>
</ol>
</div>
</div>
<p>我们等待可用数据；或者等待read_ptr != end条件成立。我们也想要让等待操作可以被中断（如，通过Ctrl+C）。因此，&ldquo;read&rdquo;方法应该像这样开始：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_9237')">复制内容到剪贴板</span></div>
<div id="code_9237">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;ssize_t&nbsp;reverse_read(struct&nbsp;</span><span class="func">file</span><span>&nbsp;*</span><span class="func">file</span><span>,&nbsp;char&nbsp;__user&nbsp;*&nbsp;out, &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size,&nbsp;loff_t&nbsp;*&nbsp;off) &nbsp;&nbsp;</span></li>
<li class="alt"><span>{ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;buffer&nbsp;*buf&nbsp;=&nbsp;</span><span class="func">file</span><span>-&gt;private_data; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;result; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(buf-&gt;read_ptr&nbsp;==&nbsp;buf-&gt;end)&nbsp;{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(</span><span class="func">file</span><span>-&gt;f_flags&nbsp;&amp;&nbsp;O_NONBLOCK)&nbsp;{ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-EAGAIN; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;out; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(wait_event_interruptible &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(buf-&gt;read_queue,&nbsp;buf-&gt;read_ptr&nbsp;!=&nbsp;buf-&gt;end))&nbsp;{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-ERESTARTSYS; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;out; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>...</p>
<p>我们让它循环，直到有可用数据，如果没有则使用wait_event_interruptible()（它是一个宏，不是函数，这就是为什么要通过值的方式给队列传递）来等待。好吧，如果wait_event_interruptible()被中断，它返回一个非0值，这个值代表-ERESTARTSYS。这段代码意味着系统调用应该重新启动。file-&gt;f_flags检查以非阻塞模式打开的文件数：如果没有数据，返回-EAGAIN。</p>
<p>我们不能使用if()来替代while()，因为可能有许多进程正等待数据。当write方法唤醒它们时，调度程序以不可预知的方式选择一个来运行，因此，在这段代码有机会执行的时候，缓冲区可能再次空出。现在，我们需要将数据从buf-&gt;data 复制到用户空间。copy_to_user()内核函数就干了此事：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_9748')">复制内容到剪贴板</span></div>
<div id="code_9748">
<ol class="dp-bash">
<li class="alt"><span><span>size&nbsp;=&nbsp;min(size,&nbsp;(size_t)&nbsp;(buf-&gt;end&nbsp;-&nbsp;buf-&gt;read_ptr)); &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(copy_to_user(out,&nbsp;buf-&gt;read_ptr,&nbsp;size))&nbsp;{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-EFAULT; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;out; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>如果用户空间指针错误，那么调用可能会失败；如果发生了此事，我们就返回-EFAULT。记住，不要相信任何来自内核外的事物！</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_5586')">复制内容到剪贴板</span></div>
<div id="code_5586">
<ol class="dp-bash">
<li class="alt"><span><span>&nbsp;&nbsp;&nbsp;buf-&gt;read_ptr&nbsp;+=&nbsp;size; &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;size; &nbsp;&nbsp;</span></li>
<li class="alt"><span>out: &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;result; &nbsp;&nbsp;</span></li>
<li class="alt"><span>}&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>为了使数据在任意块可读，需要进行简单运算。该方法返回读入的字节数，或者一个错误代码。</p>
<p>写方法更简短。首先，我们检查缓冲区是否有足够的空间，然后我们使用copy_from_userspace()函数来获取数据。再然后read_ptr和结束指针会被重置，并且反转存储缓冲区内容：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_4790')">复制内容到剪贴板</span></div>
<div id="code_4790">
<ol class="dp-bash">
<li class="alt"><span><span>buf-&gt;end&nbsp;=&nbsp;buf-&gt;data&nbsp;+&nbsp;size; &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;buf-&gt;read_ptr&nbsp;=&nbsp;buf-&gt;data; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(buf-&gt;end&nbsp;&gt;&nbsp;buf-&gt;data) &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse_phrase(buf-&gt;data,&nbsp;buf-&gt;end&nbsp;-&nbsp;1);&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>这里， reverse_phrase()干了所有吃力的工作。它依赖于reverse_word()函数，该函数相当简短并且标记为内联。这是另外一个常见的优化；但是，你不能过度使用。因为过多的内联会导致内核映像徒然增大。</p>
<p>最后，我们需要唤醒read_queue中等待数据的进程，就跟先前讲过的那样。wake_up_interruptible()就是用来干此事的：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_9821')">复制内容到剪贴板</span></div>
<div id="code_9821">
<ol class="dp-bash">
<li class="alt"><span><span>wake_up_interruptible(&amp;buf-&gt;read_queue);&nbsp;&nbsp;</span></span></li>
</ol>
</div>
</div>
<p><br />耶！你现在已经有了一个内核模块，它至少已经编译成功了。现在，是时候来测试了。</p>
<p><strong>调试内核代码</strong></p>
<p>或许，内核中最常见的调试方法就是打印。如果你愿意，你可以使用普通的printk() （假定使用KERN_DEBUG日志等级）。然而，那儿还有更好的办法。如果你正在写一个设备驱动，这个设备驱动有它自己的&ldquo;struct device&rdquo;，可以使用pr_debug()或者dev_dbg()：它们支持动态调试（dyndbg）特性，并可以根据需要启用或者禁用（请查阅Documentation/dynamic-debug-howto.txt）。对于单纯的开发消息，使用pr_devel()，除非设置了DEBUG，否则什么都不会做。要为我们的模块启用DEBUG，请添加以下行到Makefile中：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_9897')">复制内容到剪贴板</span></div>
<div id="code_9897">
<ol class="dp-bash">
<li class="alt"><span><span>CFLAGS_reverse.o&nbsp;:=&nbsp;-DDEBUG&nbsp;&nbsp;</span></span></li>
</ol>
</div>
</div>
<p>完了之后，使用dmesg来查看pr_debug()或pr_devel()生成的调试信息。 或者，你可以直接发送调试信息到控制台。要想这么干，你可以设置console_loglevel内核变量为8或者更大的值（echo 8 /proc/sys/kernel/printk），或者在高日志等级，如KERN_ERR，来临时打印要查询的调试信息。很自然，在发布代码前，你应该移除这样的调试声明。</p>
<p>注意内核消息出现在控制台，不要在Xterm这样的终端模拟器窗口中去查看；这也是在内核开发时，建议你不在X环境下进行的原因。<br />惊喜，惊喜！</p>
<p>编译模块，然后加载进内核：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_2071')">复制内容到剪贴板</span></div>
<div id="code_2071">
<ol class="dp-bash">
<li class="alt"><span><span>$&nbsp;</span><span class="func">make</span><span>&nbsp;&nbsp;</span></span></li>
<li><span>$&nbsp;</span><span class="func">sudo</span><span>&nbsp;insmod&nbsp;reverse.ko&nbsp;buffer_size=2048 &nbsp;&nbsp;</span></li>
<li class="alt"><span>$&nbsp;lsmod &nbsp;&nbsp;</span></li>
<li><span>reverse&nbsp;2419&nbsp;0 &nbsp;&nbsp;</span></li>
<li class="alt"><span>$&nbsp;</span><span class="func">ls</span><span>&nbsp;-l&nbsp;/dev/reverse &nbsp;&nbsp;</span></li>
<li><span>crw-rw-rw-&nbsp;1&nbsp;root&nbsp;root&nbsp;10,&nbsp;58&nbsp;Feb&nbsp;22&nbsp;15:53&nbsp;/dev/reverse&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>一切似乎就位。现在，要测试模块是否正常工作，我们将写一段小程序来翻转它的第一个命令行参数。main()（再三检查错误）可能看上去像这样：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_1224')">复制内容到剪贴板</span></div>
<div id="code_1224">
<ol class="dp-bash">
<li class="alt"><span><span>int&nbsp;fd&nbsp;=&nbsp;</span><span class="func">open</span><span>(</span><span class="string">&quot;/dev/reverse&quot;</span><span>,&nbsp;O_RDWR); &nbsp;&nbsp;</span></span></li>
<li><span>write(fd,&nbsp;argv[1],&nbsp;strlen(argv[1])); &nbsp;&nbsp;</span></li>
<li class="alt"><span></span><span class="func">read</span><span>(fd,&nbsp;argv[1],&nbsp;strlen(argv[1])); &nbsp;&nbsp;</span></li>
<li><span></span><span class="func">printf</span><span>(</span><span class="string">&quot;Read:&nbsp;%s\n&quot;</span><span>,&nbsp;argv[1]);&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>像这样运行：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_1291')">复制内容到剪贴板</span></div>
<div id="code_1291">
<ol class="dp-bash">
<li class="alt"><span><span>$&nbsp;./</span><span class="func">test</span><span>&nbsp;</span><span class="string">'A&nbsp;quick&nbsp;brown&nbsp;fox&nbsp;jumped&nbsp;over&nbsp;the&nbsp;lazy&nbsp;dog'</span><span>&nbsp;&nbsp;</span></span></li>
<li><span>Read:&nbsp;dog&nbsp;lazy&nbsp;the&nbsp;over&nbsp;jumped&nbsp;fox&nbsp;brown&nbsp;quick&nbsp;A&nbsp;&nbsp;</span><br />它工作正常！玩得更逗一点：试试传递单个单词或者单个字母的短语，空的字符串或者是非英语字符串（如果你有这样的键盘布局设置），以及其它任何东西。</li>
</ol>
</div>
</div>
<p>现在，让我们让事情变得更好玩一点。我们将创建两个进程，它们共享一个文件描述符（及其内核缓冲区）。其中一个会持续写入字符串到设备，而另一个将读取这些字符串。在下例中，我们使用了fork(2)系统调用，而pthreads也很好用。我也省略打开和关闭设备的代码，并在此检查代码错误（又来了）：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_2685')">复制内容到剪贴板</span></div>
<div id="code_2685">
<ol class="dp-bash">
<li class="alt"><span><span>char&nbsp;*phrase&nbsp;=&nbsp;</span><span class="string">&quot;A&nbsp;quick&nbsp;brown&nbsp;fox&nbsp;jumped&nbsp;over&nbsp;the&nbsp;lazy&nbsp;dog&quot;</span><span>; &nbsp;&nbsp;</span></span></li>
<li><span></span><span class="keyword">if</span><span>&nbsp;(fork()) &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span></li>
<li><span>/*&nbsp;Parent&nbsp;is&nbsp;the&nbsp;writer&nbsp;*/ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(1) &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(fd,&nbsp;phrase,&nbsp;len); &nbsp;&nbsp;</span></li>
<li class="alt"><span></span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span></li>
<li class="alt"><span>/*&nbsp;child&nbsp;is&nbsp;the&nbsp;reader&nbsp;*/ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(1)&nbsp;{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="func">read</span><span>(fd,&nbsp;buf,&nbsp;len); &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="func">printf</span><span>(</span><span class="string">&quot;Read:&nbsp;%s\n&quot;</span><span>,&nbsp;buf); &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>你希望这个程序会输出什么呢？下面就是在我的笔记本上得到的东西：</p>
<p>Read: dog lazy the over jumped fox brown quick A<br />Read: A kcicq brown fox jumped over the lazy dog<br />Read: A kciuq nworb xor jumped fox brown quick A<br />Read: A kciuq nworb xor jumped fox brown quick A<br />...<br />这里发生了什么呢？就像举行了一场比赛。我们认为read和write是原子操作，或者从头到尾一次执行一个指令。然而，内核确实无序并发的，随便就重新调度了reverse_phrase()函数内部某个地方运行着的写入操作的内核部分。如果在写入操作结束前就调度了read()操作呢？就会产生数据不完整的状态。这样的bug非常难以找到。但是，怎样来处理这个问题呢？</p>
<p>基本上，我们需要确保在写方法返回前没有read方法能被执行。如果你曾经编写过一个多线程的应用程序，你可能见过同步原语（锁），如互斥锁或者信号。Linux也有这些，但有些细微的差别。内核代码可以运行进程上下文（用户空间代码的&ldquo;代表&rdquo;工作，就像我们使用的方法）和终端上下文（例如，一个IRQ处理线程）。如果你已经在进程上下文中和并且你已经得到了所需的锁，你只需要简单地睡眠和重试直到成功为止。在中断上下文时你不能处于休眠状态，因此代码会在一个循环中运行直到锁可用。关联原语被称为自旋锁，但在我们的环境中，一个简单的互斥锁 &mdash;&mdash; 在特定时间内只有唯一一个进程能&ldquo;占有&rdquo;的对象 &mdash;&mdash; 就足够了。处于性能方面的考虑，现实的代码可能也会使用读-写信号。</p>
<p>锁总是保护某些数据（在我们的环境中，是一个&ldquo;struct buffer&rdquo;实例），而且也常常会把它们嵌入到它们所保护的结构体中。因此，我们添加一个互斥锁（&lsquo;struct mutex lock&rsquo;）到&ldquo;struct buffer&rdquo;中。我们也必须用mutex_init()来初始化互斥锁；buffer_alloc是用来处理这件事的好地方。使用互斥锁的代码也必须包含linux/mutex.h。</p>
<p>互斥锁很像交通信号灯 &mdash;&mdash; 要是司机不看它和不听它的，它就没什么用。因此，在对缓冲区做操作并在操作完成时释放它之前，我们需要更新reverse_read()和reverse_write()来获取互斥锁。让我们来看看read方法 &mdash;&mdash; write的工作原理相同：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_9399')">复制内容到剪贴板</span></div>
<div id="code_9399">
<ol class="dp-bash">
<li class="alt"><span><span>static&nbsp;ssize_t&nbsp;reverse_read(struct&nbsp;</span><span class="func">file</span><span>&nbsp;*</span><span class="func">file</span><span>,&nbsp;char&nbsp;__user&nbsp;*&nbsp;out, &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size,&nbsp;loff_t&nbsp;*&nbsp;off) &nbsp;&nbsp;</span></li>
<li class="alt"><span>{ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;buffer&nbsp;*buf&nbsp;=&nbsp;</span><span class="func">file</span><span>-&gt;private_data; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;result; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(mutex_lock_interruptible(&amp;buf-&gt;lock))&nbsp;{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-ERESTARTSYS; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;out; &nbsp;&nbsp;</span></li>
<li class="alt"><span>} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>我们在函数一开始就获取锁。mutex_lock_interruptible()要么得到互斥锁然后返回，要么让进程睡眠，直到有可用的互斥锁。就像前面一样，_interruptible后缀意味着睡眠可以由信号来中断。</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_1536')">复制内容到剪贴板</span></div>
<div id="code_1536">
<ol class="dp-bash">
<li class="alt"><span><span class="keyword">while</span><span>&nbsp;(buf-&gt;read_ptr&nbsp;==&nbsp;buf-&gt;end)&nbsp;{ &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;buf-&gt;lock); &nbsp;&nbsp;</span></li>
<li class="alt"><span>/*&nbsp;...&nbsp;wait_event_interruptible()&nbsp;here&nbsp;...&nbsp;*/ &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(mutex_lock_interruptible(&amp;buf-&gt;lock))&nbsp;{ &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-ERESTARTSYS; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;out; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>下面是我们的&ldquo;等待数据&rdquo;循环。当获取互斥锁时，或者发生称之为&ldquo;死锁&rdquo;的情境时，不应该让进程睡眠。因此，如果没有数据，我们释放互斥锁并调用wait_event_interruptible()。当它返回时，我们重新获取互斥锁并像往常一样继续：</p>
<div class="codeText">
<div class="codeHead"><span class="lantxt">bash/shell Code</span><span style="CURSOR: pointer" class="copyCodeText" onclick="copyIdText('code_1703')">复制内容到剪贴板</span></div>
<div id="code_1703">
<ol class="dp-bash">
<li class="alt"><span><span class="keyword">if</span><span>&nbsp;(copy_to_user(out,&nbsp;buf-&gt;read_ptr,&nbsp;size))&nbsp;{ &nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-EFAULT; &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;out_unlock; &nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;</span></li>
<li><span>out_unlock: &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mutex_unlock(&amp;buf-&gt;lock); &nbsp;&nbsp;</span></li>
<li><span>out: &nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;result;&nbsp;&nbsp;</span></li>
</ol>
</div>
</div>
<p>最后，当函数结束，或者在互斥锁被获取过程中发生错误时，互斥锁被解锁。重新编译模块（别忘了重新加载），然后再次进行测试。现在你应该没发现毁坏的数据了。</p>
<p><strong>接下来是什么？</strong></p>
<p>现在你已经尝试了一次内核黑客。我们刚刚为你揭开了这个话题的外衣，里面还有更多东西供你探索。我们的第一个模块有意识地写得简单一点，在从中学到的概念在更复杂的环境中也一样。并发、方法表、注册回调函数、使进程睡眠以及唤醒进程，这些都是内核黑客们耳熟能详的东西，而现在你已经看过了它们的运作。或许某天，你的内核代码也将被加入到主线Linux源代码树中 &mdash;&mdash; 如果真这样，请联系我们！</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/98168.html'>asp.net中GridView控件遍历的小例子</a><a>下一篇</a><a href='/php/biji/98170.html'>详解MySQL中的SQRT函数的使用方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>