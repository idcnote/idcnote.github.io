<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Oracle中常见的33个等待事件小结_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="一． 等待事件的相关知识<br />
<br />
1.1 等待事件主要可以分为两类，即空闲(IDLE)等待事件和非空闲(NON-IDLE)等待事件。1). 空闲等待事件指ORACLE正等待某种工作，在诊断和优化数据库的时" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Oracle中常见的33个等待事件小结</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>一． 等待事件的相关知识<br />
<br />
1.1 等待事件主要可以分为两类，即空闲(IDLE)等待事件和非空闲(NON-IDLE)等待事件。1). 空闲等待事件指ORACLE正等待某种工作，在诊断和优化数据库的时</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span>一． 等待事件的相关知识<br><br>1.1 等待事件主要可以分为两类，即空闲(IDLE)等待事件和非空闲(NON-IDLE)等待事件。<BR>1). 空闲等待事件指ORACLE正等待某种工作，在诊断和优化数据库的时候，不用过多注意这部分事件。<BR>2). 非空闲等待事件专门针对ORACLE的活动，指数据库任务或应用运行过程中发生的等待，这些等待事件 是在调整数据库的时候需要关注与研究的。<br><br>&nbsp;<BR>在Oracle 10g中的等待事件有872个，11g中等待事件1116个。 我们可以通过v$event_name 视图来查看等待事件的相关信息。<br><br>1.2 查看v$event_name视图的字段结构<BR>SQL&gt; desc v$event_name;<BR>&nbsp;名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是否为空? 类型<BR>&nbsp;----------------------------------------- -------- ---------------<BR>&nbsp;EVENT#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER<BR>&nbsp;EVENT_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER<BR>&nbsp;NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARCHAR2(64)<BR>&nbsp;PARAMETER1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARCHAR2(64)<BR>&nbsp;PARAMETER2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARCHAR2(64)<BR>&nbsp;PARAMETER3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARCHAR2(64)<BR>&nbsp;WAIT_CLASS_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER<BR>&nbsp;WAIT_CLASS#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUMBER<BR>&nbsp;WAIT_CLASS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VARCHAR2(64)<br><br>1.3 查看等待事件总数<BR>11gr2:<BR>SQL&gt; select count(*) from v$event_name;<BR>&nbsp; COUNT(*)<BR>----------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1116<BR>10gr2 rac:<BR>sys@ORCL&gt; select count(*) from v$event_name;<br><br>&nbsp; COUNT(*)<BR>----------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 889<BR>10gr2:<BR>SQL&gt; select count(*) from v$event_name;<br><br>&nbsp; COUNT(*)<BR>----------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 874<br><br>&nbsp;<BR>1.4 查看等待事件分类情况<BR>/* Formatted on 6/27/2011 12:54:45 PM (QP5 v5.114.809.3010) */<BR>&nbsp; SELECT&nbsp;&nbsp; wait_class#,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_class_id,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_class,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COUNT ( * ) AS "count"<BR>&nbsp;&nbsp;&nbsp; FROM&nbsp;&nbsp; v$event_name<BR>GROUP BY&nbsp;&nbsp; wait_class#, wait_class_id, wait_class<BR>ORDER BY&nbsp;&nbsp; wait_class#;<br><br>WAIT_CLASS# WAIT_CLASS_ID WAIT_CLASS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count<BR>----------- ------------- -------------------- ----------<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; 1893977003 Other&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 717<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; 4217450380 Application&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3290255840 Configuration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; 4166625743 Administrative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 54<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 3875070507 Concurrency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 3386400367 Commit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp; 2723168908 Idle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 94<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 2000153315 Network&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 35<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 1740759767 User I/O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp; 4108307767 System I/O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; 2396326234 Scheduler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp; 3871361733 Cluster&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp; 644977587 Queueing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9<br><br>&nbsp;<BR>1.5 相关的几个视图<BR>V$SESSION：代表数据库活动的开始，视为源起。<BR>V$SESSION_WAIT：视图用以实时记录活动SESSION的等待情况，是当前信息。<BR>V$SESSION_WAIT_HISTORY：是对V$SESSION_WAIT的简单增强，记录活动SESSION的最近10次等待。<BR>V$SQLTEXT：当数据库出现瓶颈时，通常可以从V$SESSION_WAIT找到那些正在等待资源的SESSION，<BR>通过SESSION的SID，联合V$SESSION和V$SQLTEXT视图就可以捕获这些SESSION正在执行的SQL语句。<BR>V$ACTIVE_SESSION_HISTORY:是ASH的核心，用以记录活动SESSION的历史等待信息，每秒采样一次，这部分内容记录在内存中，期望值是记录一个小时的内容。<BR>WRH#_ACTIVE_SESSION_HISTORY: 是V$ACTIVE_SESSION_HISTORY在AWR的存储地。<BR>V$ACTIVE_SESSION_HISTORY中 的信息会被定期(每小时一次)的刷新到负载库中，并缺省保留一个星期<BR>用于分析。<BR>DBA_HIST_ACTIVE_SESS_HISTORY:视图是WRH#_ACTIVE_SESSION_HISTORY视图和其他几个视图的联合展现，通常通过这个视图进行历史数据的访问。<BR>V$SYSTEM_EVENT: 由于V$SESSION记录的是动态信息，和SESSION的生命周期相关，而并不记录历史信<BR>息，所以ORACLE提供视图V$SYSTEM_EVENT来记录数据库自启动以来所有等待事件的汇总信息。通过这个视图，用户可以迅速获得数据库运行的总体概况。<br><br>&nbsp;<BR>二． 33个常见的等待事件<br><br>1. Buffer busy waits<BR>从本质上讲，这个等待事件的产生仅说明了一个会话在等待一个Buffer（数据块），但是导致这个现象的原因却有很多种。<BR>常见的两种是：<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个会话试图修改一个数据块，但这个数据块正在被另一个会话修改时。<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个会话需要读取一个数据块，但这个数据块正在被另一个会话读取到内存中时。<br><br>Oracle 操作的最小单位是块（Block），即使你要修改一条记录，也需要对这条记录所在的这个数据块做操作。 当你对这个数据块做修改时，其他的会话将被阻止对这个数据块上的数据做修改（即使其他用户修改的不是当前用户修改的数据），但是可以以一致性的方式读取这个数据块（from undo）。当前的用户修改完这个数据块后，将会立即释放掉加在这个数据块上的排他锁，这样另一个会话就可以继续修改它。修改操作是一个非常短暂的时间，这种加锁的机制我们叫Latch。<br><br>当一个会话修改一个数据块时，是按照以下步骤来完成的：<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以排他的方式获得这个数据块（Latch）<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 修改这个数据块。<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 释放Latch。<br><br>Buffer busy waits等待事件常见于数据库中存在热块的时候，当多个用户频繁地读取或者修改同样的数据块时，这个等待事件就会产生。 如果等待的时间很长，我们在AWR或者statspack 报告中就可以看到。<br><br>这个等待事件有三个参数。查看有几个参数我们可以用以下SQL:<BR>/* Formatted on 6/27/2011 1:06:09 PM (QP5 v5.114.809.3010) */<BR>SELECT&nbsp;&nbsp; name,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter3<BR>&nbsp; FROM&nbsp;&nbsp; v$event_name<BR>&nbsp;WHERE&nbsp;&nbsp; name = 'buffer busy waits';<BR>NAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARAMETER1&nbsp;&nbsp; PARAMETER2&nbsp; PARAMETER3<BR>--------------------&nbsp; ----------&nbsp;&nbsp; ----------&nbsp; ----------<BR>buffer busy waits&nbsp;&nbsp;&nbsp;&nbsp; file#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class#<br><br>&nbsp;<BR>在下面的示例中，查询的方法和这个一样，所以其他事件对参数的查询将不做过多的说明。<br><br>File#: 等待访问数据块所在的文件id号。<BR>Blocks： 等待访问的数据块号。<BR>ID： 在10g之前，这个值表示一个等待时间的原因，10g之后则表示等待事件的类别。<br><br>2. Buffer latch<BR>内存中数据块的存放位置是记录在一个hash列表（cache buffer chains）当中的。当一个会话需要访问某个数据块时，它首先要搜索这个hash 列表，从列表中获得数据块的地址，然后通过这个地址去访问需要的数据块，这个列表Oracle会使用一个latch来保护它的完整性。 当一个会话需要访问这个列表时，需要获取一个Latch，只有这样，才能保证这个列表在这个会话的浏览当中不会发生变化。<br><br>产生buffer latch的等待事件的主要原因是：<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer chains太长，导致会话搜索这个列表花费的时间太长，使其他的会话处于等待状态。<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同样的数据块被频繁访问，就是我们通常说的热快问题。<br><br>产生buffer chains太长，我们可以使用多个buffer pool的方式来创建更多的buffer chains，或者使用参数DB_BLOCK_LRU_LATCHES来增加latch的数量，以便于更多的会话可以获得latch，这两种方法可以同时使用。<br><br>这个等待事件有两个参数：<BR>Latch addr： 会话申请的latch在SGA中的虚拟地址。<BR>通过以下的SQL语句可以根据这个地址找到它对应的Latch名称：<BR>/* Formatted on 6/27/2011 1:12:48 PM (QP5 v5.114.809.3010) */<BR>select * from v$latch a,v$latchname b where<BR>addr=latch addr -- 这里的latch addr 是你从等待事件中看到的值 <BR>and a.latch#=b.latch#;<br><br>chain#： buffer chains hash 列表中的索引值，当这个参数的值等于s 0xfffffff时，说明当前的会话正在等待一个LRU latch。<br><br>3. Control file parallel write<BR>当数据库中有多个控制文件的拷贝时，Oracle 需要保证信息同步地写到各个控制文件当中，这是一个并行的物理操作过程，因为称为控制文件并行写，当发生这样的操作时，就会产生control file parallel write等待事件。<BR>控制文件频繁写入的原因很多，比如：<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 日志切换太过频繁，导致控制文件信息相应地需要频繁更新。<BR>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 系统I/O 出现瓶颈，导致所有I/O出现等待。<br><br>当系统出现日志切换过于频繁的情形时，可以考虑适当地增大日志文件的大小来降低日志切换频率。<BR>当系统出现大量的control file parallel write 等待事件时，可以通过比如降低控制文件的拷贝数量，将控制文件的拷贝存放在不同的物理磁盘上的方式来缓解I/O 争用。<br><br>这个等待事件包含三个参数：<BR>Files： Oracle 要写入的控制文件个数。<BR>Blocks： 写入控制文件的数据块数目。<BR>Requests： 写入控制请求的I/O 次数。<br><br>4. Control file sequential read<BR>当数据库需要读取控制文件上的信息时，会出现这个等待事件，因为控制文件的信息是顺序写的，所以读取的时候也是顺序的，因此称为控制文件顺序读，它经常发生在以下情况：<BR>备份控制文件<BR>RAC 环境下不同实例之间控制文件的信息共享<BR>读取控制文件的文件头信息<BR>读取控制文件其他信息<br><br>这个等待事件有三个参数：<BR>File#： 要读取信息的控制文件的文件号。<BR>Block#： 读取控制文件信息的起始数据块号。<BR>Blocks： 需要读取的控制文件数据块数目。<br><br>&nbsp;<BR>5. Db file parallel read<BR>这是一个很容易引起误导的等待事件，实际上这个等待事件和并行操作（比如并行查询，并行DML）没有关系。 这个事件发生在数据库恢复的时候，当有一些数据块需要恢复的时候，Oracle会以并行的方式把他们从数据文件中读入到内存中进行恢复操作。<br><br>这个等待事件包含三个参数：<BR>Files： 操作需要读取的文件个数。<BR>Blocks： 操作需要读取的数据块个数。<BR>Requests： 操作需要执行的I/O次数。<br><br>&nbsp;<BR>6. Db file parallel write<BR>这是一个后台等待事件，它同样和用户的并行操作没有关系，它是由后台进程DBWR产生的，当后台进程DBWR向磁盘上写入脏数据时，会发生这个等待。<br><br>DBWR会批量地将脏数据并行地写入到磁盘上相应的数据文件中，在这个批次作业完成之前，DBWR将出现这个等待事件。如果仅仅是这一个等待事件，对用户的操作并没有太大的影响，当伴随着出现free buffer waits等待事件时，说明此时内存中可用的空间不足，这时候会影响到用户的操作，比如影响到用户将脏数据块读入到内存中。<br><br>当出现db file parallel write等待事件时，可以通过启用操作系统的异步I/O的方式来缓解这个等待。当使用异步I/O时，DBWR不再需要一直等到所有数据块全部写入到磁盘上，它只需要等到这个数据写入到一个百分比之后，就可以继续进行后续的操作。<br><br>这个等待事件有两个参数：<BR>Requests： 操作需要执行的I/O次数。<BR>Timeouts： 等待的超时时间。<br><br>&nbsp;<BR>7. Db file scattered read<BR>这个等待事件在实际生产库中经常可以看到，这是一个用户操作引起的等待事件，当用户发出每次I/O需要读取多个数据块这样的SQL 操作时，会产生这个等待事件，最常见的两种情况是全表扫描（FTS： Full Table Scan）和索引快速扫描（IFFS： index fast full scan）。<br><br>这个名称中的scattered( 分散)，可能会导致很多人认为它是以scattered 的方式来读取数据块的，其实恰恰相反，当发生这种等待事件时，SQL的操作都是顺序地读取数据块的，比如FTS或者IFFS方式（如果忽略需要读取的数据块已经存在内存中的情况）。<br><br>这里的scattered指的是读取的数据块在内存中的存放方式，他们被读取到内存中后，是以分散的方式存在在内存中，而不是连续的。<br><br>这个等待事件有三个参数：<BR>File#： 要读取的数据块所在数据文件的文件号。<BR>Block#： 要读取的起始数据块号。<BR>Blocks： 需要读取的数据块数目。<br><br>&nbsp;<BR>8. Db file sequential read<BR>这个等待事件在实际生产库也很常见，当Oracle 需要每次I/O只读取单个数据块这样的操作时，会产生这个等待事件。最常见的情况有索引的访问（除IFFS外的方式），回滚操作，以ROWID的方式访问表中的数据，重建控制文件，对文件头做DUMP等。<br><br>这里的sequential也并非指的是Oracle 按顺序的方式来访问数据，和db file scattered read一样，它指的是读取的数据块在内存中是以连续的方式存放的。<br><br>这个等待事件有三个参数：<BR>File#： 要读取的数据块锁在数据文件的文件号。<BR>Block#： 要读取的起始数据块号。<BR>Blocks： 要读取的数据块数目（这里应该等于1）。<br><br>&nbsp;<BR>9. Db file single write<BR>这个等待事件通常只发生在一种情况下，就是Oracle 更新数据文件头信息时（比如发生Checkpoint）。<br><br>当这个等待事件很明显时，需要考虑是不是数据库中的数据文件数量太大，导致Oracle 需要花较长的时间来做所有文件头的更新操作（checkpoint）。<br><br>这个等待事件有三个参数：<BR>File#: 需要更新的数据块所在的数据文件的文件号。<BR>Block#： 需要更新的数据块号。<BR>Blocks： 需要更新的数据块数目（通常来说应该等于1）。<br><br>&nbsp;<BR>10. Direct path read<BR>这个等待事件发生在会话将数据块直接读取到PGA当中而不是SGA中的情况，这些被读取的数据通常是这个会话私有的数据，所以不需要放到SGA作为共享数据，因为这样做没有意义。这些数据通常是来自于临时段上的数据，比如一个会话中SQL的排序数据，并行执行过程中间产生的数据，以及Hash Join，merge join产生的排序数据，因为这些数据只对当前的会话的SQL操作有意义，所以不需要放到SGA当中。<br><br>当发生direct path read等待事件时，意味着磁盘上有大量的临时数据产生，比如排序，并行执行等操作。或者意味着PGA中空闲空间不足。<br><br>这个等待事件有三个参数：<BR>Descriptor address:&nbsp; 一个指针，指向当前会话正在等待的一个direct read I/O。<BR>First dba: descriptor address 中最旧的一个I/O数据块地址。<BR>Block cnt: descriptor address上下文中涉及的有效的buffer 数量。<br><br>&nbsp;<BR>11. Direct path write<BR>这个等待事件和direct path read 正好相反，是会话将一些数据从PGA中直接写入到磁盘文件上，而不经过SGA。<br><br>这种情况通常发生在：<BR>使用临时表空间排序（内存不足）<BR>数据的直接加载（使用append方式加载数据）<BR>并行DML操作。<br><br>这个等待事件有三个参数：<BR>Descriptor address: 一个指针，指向当前会话正在等待的一个direct I/O.<BR>First dba: descriptor address 中最旧的一个I/O数据块地址。<BR>Block cnt: descriptor address 上下文中涉及的有效地 buffer 数量。<br><br>&nbsp;<BR>12. Enqueue<BR>Enqueue 这个词其实是lock 的另一种描述语。<br><br>当我们在AWR 报告中发现长时间的enqueue 等待事件时，说明数据库中出现了阻塞和等待，可以关联AWR报告中的enqueue activity部分来确定是哪一种锁定出现了长时间等待。<br><br>这个等待事件有2个参数：<BR>Name： enqueue 的名称和类型。<BR>Mode： enqueue的模式。<br><br>可以使用如下SQL 查看当前会话等待的enqueue名称和类型：<BR>/* Formatted on 6/27/2011 1:31:48 PM (QP5 v5.114.809.3010) */<BR>SELECT&nbsp;&nbsp; CHR (TO_CHAR (BITAND (p1, -16777216)) / 16777215)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || CHR (TO_CHAR (BITAND (p1, 16711680)) / 65535)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Lock",<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TO_CHAR (BITAND (p1, 65535)) "Mode"<BR>&nbsp; FROM&nbsp;&nbsp; v$session_wait<BR>&nbsp;WHERE&nbsp;&nbsp; event = 'enqueue';<br><br>Oracle 的enqueue 包含以下模式：<br><br>模式代码<BR>解释<BR>1<BR>Null (NULL)<BR>2<BR>Row-S(SS)<BR>3<BR>Row-X(SX)<BR>4<BR>Share(S)<BR>5<BR>S/Row-X(SSX)<BR>6<BR>Exclusive(X)<br><br>Oracle的enqueue 有如下类型：<BR>Enqueue 缩写<BR>缩写解释<BR>BL<BR>Buffer Cache management<BR>BR<BR>Backup/Restore<BR>CF<BR>Controlfile transaction<BR>CI<BR>Cross-instance Call Invocation<BR>CU<BR>Bind Enqueue<BR>DF<BR>Datafile<BR>DL<BR>Direct Loader Index Creation<BR>DM<BR>Database Mount<BR>DR<BR>Distributed Recovery Process<BR>DX<BR>Dirstributed Transaction<BR>FP<BR>File Object<BR>FS<BR>File Set<BR>HW<BR>High-water Lock<BR>IN<BR>Instance Number<BR>IR<BR>Instance Recovery<BR>IS<BR>Instance State<BR>IV<BR>Library Cache Invalidation<BR>JI<BR>Enqueue used during AJV snapshot refresh<BR>JQ<BR>Job Queue<BR>KK<BR>Redo Log “Kick”<BR>KO<BR>Multiple Object Checkpoint<BR>L[A-p]<BR>Library Cache Lock<BR>LS<BR>Log start or switch<BR>MM<BR>Mount Definition<BR>MR<BR>Media recovery<BR>N[A-Z]<BR>Library Cache bin<BR>PE<BR>Alter system set parameter =value<BR>PF<BR>Password file<BR>PI<BR>Parallel slaves<BR>PR<BR>Process startup<br><br>Parallel slave synchronization<BR>Q[A-Z]<BR>Row Cache<BR>RO<BR>Object Reuse<BR>RT<BR>Redo Thread<BR>RW<BR>Row Wait<BR>SC<BR>System Commit Number<BR>SM<BR>SMON<br><br>Sequence Number<BR>SQ<BR>Sequence Number Enqueue<BR>SR<BR>Synchronized replication<br><br>Sort segment<BR>ST<BR>Space management transaction<BR>SV<BR>Sequence number Value<BR>TA<BR>Transaction recovery<BR>TC<BR>Thread Checkpoint<BR>TE<BR>Extend Table<BR>TM<BR>DML enqueue<BR>TO<BR>Temporary Table Object Enqueue<BR>TS<BR>Temporary Segement(also TableSpace)<BR>TT<BR>Temporary Table<BR>TX<BR>Transaction<BR>UL<BR>User-defined Locks<BR>UN<BR>User name<BR>US<BR>Undo segment, Serialization<BR>WL<BR>Being Written Redo Log<BR>XA<BR>Instance Attribute Log<BR>XI&nbsp;&nbsp;&nbsp; <BR>Instance Registration Lock<br><br>&nbsp;<BR>关于enqueue 可以参考如下的连接：<BR>Wait Events - Enqueue Waits<BR>http://www.toadworld.com/KNOWLEDGE/KnowledgeXpertforOracle/tabid/648/TopicID/WE1/Default.aspx<br><br>&nbsp;<BR>13. Free buffer waits<BR>当一个会话将数据块从磁盘读到内存中时，它需要到内存中找到空闲的内存空间来存放这些数据块，当内存中没有空闲的空间时，就会产生这个等待；除此之外，还有一种情况就是会话在做一致性读时，需要构造数据块在某个时刻的前映像（image），此时需要申请内存来存放这些新构造的数据块，如果内存中无法找到这样的内存块，也会发生这个等待事件。<br><br>当数据库中出现比较严重的free buffer waits等待事件时，可能的原因是：<BR>（1）data buffer 太小，导致空闲空间不够<BR>（2）内存中的脏数据太多，DBWR无法及时将这些脏数据写到磁盘中以释放空间<br><br>这个等待事件包含2个参数：<BR>File#： 需要读取的数据块所在的数据文件的文件号。<BR>Block#： 需要读取的数据块块号。<br><br>&nbsp;<BR>14. Latch free<BR>在10g之前的版本里，latch free 等待事件代表了所有的latch等待，在10g以后，一些常用的latch事件已经被独立了出来：<BR>11gr2:<BR>SQL&gt; select name from v$event_name where name like 'latch%' order by 1;<BR>NAME<BR>----------------------------------------------------------------<BR>latch activity<BR>latch free<BR>latch: Change Notification Hash table latch<BR>latch: In memory undo latch<BR>latch: MQL Tracking Latch<BR>latch: PX hash array latch<BR>latch: Undo Hint Latch<BR>latch: WCR: processes HT<BR>latch: WCR: sync<BR>latch: cache buffer handles<BR>latch: cache buffers chains<BR>latch: cache buffers lru chain<BR>latch: call allocation<BR>latch: change notification client cache latch<BR>latch: checkpoint queue latch<BR>latch: enqueue hash chains<BR>latch: gc element<BR>latch: gcs resource hash<BR>latch: ges resource hash list<BR>latch: lob segment dispenser latch<BR>latch: lob segment hash table latch<BR>latch: lob segment query latch<BR>latch: messages<BR>latch: object queue header operation<BR>latch: parallel query alloc buffer<BR>latch: redo allocation<BR>latch: redo copy<BR>latch: redo writing<BR>latch: row cache objects<BR>latch: session allocation<BR>latch: shared pool<BR>latch: undo global data<BR>latch: virtual circuit queues<BR>已选择33行。<br><br>10gr2 rac:<BR>sys@ORCL&gt; select name from v$event_name where name like 'latch%' order by 1;<br><br>NAME<BR>--------------------------------------------------<BR>latch activity<BR>latch free<BR>latch: Change Notification Hash table latch<BR>latch: In memory undo latch<BR>latch: KCL gc element parent latch<BR>latch: MQL Tracking Latch<BR>latch: Undo Hint Latch<BR>latch: cache buffer handles<BR>latch: cache buffers chains<BR>latch: cache buffers lru chain<BR>latch: checkpoint queue latch<BR>latch: enqueue hash chains<BR>latch: gcs resource hash<BR>latch: ges resource hash list<BR>latch: library cache<BR>latch: library cache lock<BR>latch: library cache pin<BR>latch: messages<BR>latch: object queue header heap<BR>latch: object queue header operation<BR>latch: parallel query alloc buffer<BR>latch: redo allocation<BR>latch: redo copy<BR>latch: redo writing<BR>latch: row cache objects<BR>latch: session allocation<BR>latch: shared pool<BR>latch: undo global data<BR>latch: virtual circuit queues<br><br>29 rows selected.<br><br>&nbsp;<BR>所以latch free 等待事件在10g以后的版本中并不常见，而是以具体的Latch 等待事件出现。<br><br>这个等待事件有三个参数：<BR>Address: 会话等待的latch 地址。<BR>Number： latch号，通过这个号，可以从v$latchname 视图中找到这个latch 的相关的信息。<BR>SQL&gt; select * from v$latchname where latch#=number;<BR>Tries: 会话尝试获取Latch 的次数。<br><br>&nbsp;<BR>15. Library cache lock<BR>这个等待事件发生在不同用户在共享中由于并发操作同一个数据库对象导致的资源争用的时候，比如当一个用户正在对一个表做DDL 操作时，其他的用户如果要访问这张表，就会发生library cache lock等待事件，它要一直等到DDL操作完成后，才能继续操作。<br><br>这个事件包含四个参数：<BR>Handle address: 被加载的对象的地址。<BR>Lock address： 锁的地址。<BR>Mode： 被加载对象的数据片段。<BR>Namespace： 被加载对象在v$db_object_cache 视图中namespace名称。<br><br>10gr2 rac:<BR>sys@ORCL&gt; select name from v$event_name where name like 'library%' order by 1;<br><br>NAME<BR>--------------------------------------------------<BR>library cache load lock<BR>library cache lock<BR>library cache pin<BR>library cache revalidation<BR>library cache shutdown<br><br>&nbsp;<BR>16. Library cache pin<BR>这个等待事件和library cache lock 一样是发生在共享池中并发操作引起的事件。通常来讲，如果Oracle 要对一些PL/SQL 或者视图这样的对象做重新编译，需要将这些对象pin到共享池中。如果此时这个对象被其他的用户特有，就会产生一个library cache pin的等待。<br><br>这个等待事件也包含四个参数：<BR>Handle address: 被加载的对象的地址。<BR>Lock address： 锁的地址。<BR>Mode： 被加载对象的数据片段。<BR>Namespace： 被加载对象在v$db_object_cache 视图中namespace名称。<br><br>&nbsp;<BR>17. Log file parallel write<BR>后台进程LGWR 负责将log buffer当中的数据写到REDO 文件中，以重用log buffer的数据。如果每个REDO LOG组里面有2个以上的成员，那么LGWR进程会并行地将REDO 信息写入这些文件中。<br><br>如果数据库中出现这个等待事件的瓶颈，主要的原因可能是磁盘I/O性能不够或者REDO 文件的分布导致了I/O争用，比如同一个组的REDO 成员文件放在相同的磁盘上。<br><br>这个等待事件有三个参数：<BR>Files： 操作需要写入的文件个数。<BR>Blocks： 操作需要写入的数据块个数。<BR>Requests：操作需要执行的I/O次数。<br><br>&nbsp;<BR>18. Log buffer space<BR>当log buffer 中没有可用空间来存放新产生的redo log数据时，就会发生log buffer space等待事件。如果数据库中新产生的redo log的数量大于LGWR 写入到磁盘中的redo log 数量，必须等待LGWR 完成写入磁盘的操作，LGWR必须确保redo log写到磁盘成功之后，才能在redo buffer当中重用这部分信息。<br><br>如果数据库中出现大量的log buffer space等待事件，可以考虑如下方法：<BR>（1）增加redo buffer的大小。<BR>（2）提升磁盘的I/O性能<br><br>19. Log file sequential read<BR>这个等待事件通常发生在对redo log信息进行读取时，比如在线redo 的归档操作，ARCH进程需要读取redo log的信息，由于redo log的信息是顺序写入的，所以在读取时也是按照顺序的方式来读取的。<br><br>这个等待事件包含三个参数：<BR>Log#： 发生等待时读取的redo log的sequence号。<BR>Block#： 读取的数据块号。<BR>Blocks： 读取的数据块个数。<br><br>&nbsp;<BR>20. Log file single write<BR>这个等待事件发生在更新redo log文件的文件头时，当为日志组增加新的日志成员时或者redo log的sequence号改变时，LGWR 都会更新redo log文件头信息。<br><br>这个等待事件包含三个参数：<BR>Log#： 写入的redo log组的编号。<BR>Block#：写入的数据块号。<BR>Blocks：写入的数据块个数。<br><br>&nbsp;<BR>21. Log file switch(archiving needed)<BR>在归档模式下，这个等待事件发生在在线日志切换（log file switch）时，需要切换的在线日志还没有被归档进程（ARCH）归档完毕的时候。 当在线日志文件切换到下一个日志时，需要确保下一个日志文件已经被归档进程归档完毕，否则不允许覆盖那个在线日志信息（否则会导致归档日志信息不完整）。<br><br>出现这样的等待事件通常是由于某种原因导致ARCH 进程死掉，比如ARCH进程尝试向目的地写入一个归档文件，但是没有成功（介质失效或者其他原因），这时ARCH进程就会死掉。 如果发生这种情况，在数据库的alert log文件中可以找到相关的错误信息。<br><br>这个等待事件没有参数。<br><br>&nbsp;<BR>22. Log file switch(checkpoint incomplete)<BR>当一个在线日志切换到下一个在线日志时，必须保证要切换到的在线日志上的记录的信息（比如一些脏数据块产生的redo log）被写到磁盘上（checkpoint），这样做的原因是，如果一个在线日志文件的信息被覆盖，而依赖这些redo 信息做恢复的数据块尚未被写到磁盘上（checkpoint），此时系统down掉的话，Oracle将没有办法进行实例恢复。<br><br>在v$log 视图里记录了在线日志的状态。通常来说，在线日志有三种状态。<BR>Active: 这个日志上面保护的信息还没有完成checkpoint。<BR>Inactive： 这个日志上面保护的信息已完成checkpoint。<BR>Current： 当前的日志。<br><br>Oracle 在做实例恢复时，会使用状态为current和Active的日志进行实例恢复。<br><br>如果系统中出现大量的log file switch（checkpoint incomplete）等待事件，原因可能是日志文件太小或者日志组太少，所以解决的方法是，增加日志文件的大小或者增加日志组的数量。<br><br>这个等待事件没有参数。<br><br>23. Log file sync<BR>这是一个用户会话行为导致的等待事件，当一个会话发出一个commit命令时，LGWR进程会将这个事务产生的redo log从log buffer里面写到磁盘上，以确保用户提交的信息被安全地记录到数据库中。<br><br>会话发出的commit指令后，需要等待LGWR将这个事务产生的redo 成功写入到磁盘之后，才可以继续进行后续的操作，这个等待事件就叫作log file sync。<br><br>当系统中出现大量的log file sync等待事件时，应该检查数据库中是否有用户在做频繁的提交操作。<br><br>这种等待事件通常发生在OLTP系统上。OLTP 系统中存在很多小的事务，如果这些事务频繁被提交，可能引起大量的log file sync的等待事件。<br><br>这个等待事件包含一个参数：<BR>Buffer#: redo buffer 中需要被写入到磁盘中的buffer。<br><br>&nbsp;<BR>24. SQL*Net break/reset to client<BR>当出现这个等待事件时，说明服务器端在给客户端发送一个断开连接或者重置连接的请求，正在等待客户的响应，通常的原因是服务器到客户端的网络不稳定导致的。<br><br>这个等待事件包含两个参数：<BR>Driver id: 服务器和客户端连接使用的协议信息。<BR>Break？：零表示服务端向客户端发送一个重置（reset）信息，非零表示服务器端向客户端发送一个断开（break）消息。<br><br>&nbsp;<BR>25. SQL*Net break/reset to dblink<BR>这个等待事件和SQL*Net break/reset to client 相同。不过它表示的是数据库通过dblink访问另一台数据库时，他们之间建立起一个会话，这个等待事件发生在这个会话之间的通信过程中，同样如果出现这个等待事件，需要检查两台数据库之间的通信问题。<br><br>这个等待事件有两个参数：<BR>Driver id: 服务器和客户端连接使用的协议信息。<BR>Break？：零表示服务端向客户端发送一个重置（reset）信息，非零表示服务器端向客户端发送一个断开（break）消息。<br><br>26. SQL*Net message from client<BR>这个等待事件基本上是最常见的一个等待事件。当一个会话建立成功后，客户端会向服务器端发送请求，服务器端处理完客户端请求后，将结果返回给客户端，并继续等待客户端的请求，这时候会产生SQL*Net message from client 等待事件。<br><br>很显然，这是一个空闲等待，如果客户端不再向服务器端发送请求，服务器端将一直处于这个等待事件状态。<br><br>这个等待事件包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端接收到的来自客户端消息的字节数。<br><br>&nbsp;<BR>27． SQL*Net message from dblink<BR>这个等待事件和SQL*Net message from client相同，不过它表示的是数据库通过dblink 访问另一个数据库时，他们之间会建立一个会话，这个等待事件发生在这个会话之间的通信过程中。<br><br>这个等待事件也是一个空闲等待事件。<br><br>这个事件包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端通过dblink 收到的来自另一个服务器端消息的字节数。<br><br>28. SQL*Net message to client<BR>这个等待事件发生在服务器端向客户端发送消息的时候。当服务器端向客户端发送消息产生等待时，可能的原因是用户端太繁忙，无法及时接收服务器端送来的消息，也可能是网络问题导致消息无法从服务器端发送到客户端。<br><br>这个等待事件有两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端向客户端发送消息的字节数。<br><br>&nbsp;<BR>29. SQL*Net message to dblink<BR>这个等待事件和SQL*Net message to client 相同，不过是发生在数据库服务器和服务器之间的等待事件，产生这个等待的原因可能是远程服务器繁忙，而无法及时接收发送过来的消息，也可能是服务器之间网络问题导致消息无法发送过来。<br><br>这个等待时间包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端通过dblink发送给另一个服务器消息的字节数。<br><br>&nbsp;<BR>30. SQL*Net more data from client<BR>服务器端等待用户发出更多的数据以便完成操作，比如一个大的SQL文本，导致一个SQL*Net 数据包无法完成传输，这样服务器端会等待客户端把整个SQL 文本发过来在做处理，这时候就会产生一个SQL*Net more data from client 等待事件。<br><br>这个等待时间包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端从客户端接收到消息的字节数。<br><br>&nbsp;<BR>31. SQL*Net more data from dblink<BR>在一个分布式事务中，SQL 分布在不同的数据库中执行，远程数据库执行完毕后将结果通过dblink返给发出SQL的数据库，在等待数据从其他数据库中通过dblink传回的过程中，如果数据在远程数据库上处理时间很久，或者有大量的结果集需要返回，或者网络性能问题都会产生SQL*Net more data from dblink 等待事件，它的意思是本地数据库需要等到所有的数据从远程处理完毕通过dblink传回后，才可以在本机继续执行操作。<br><br>这个等待时间包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端通过dblink发送给另一个服务器消息的字节数。<br><br>&nbsp;<BR>32. SQL*Net more data to client<BR>当服务器端有太多的数据需要发给客户端时，可能会产生SQL*Net more data to client等待事件，也可能由于网络问题导致服务器无法及时地将信息或者处理结果发送给客户端，同样会产生这个等待。<br><br>这个等待时间包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端向客户端发送消息的字节数。<br><br>&nbsp;<BR>33. SQL*Net more data to dblink<BR>这个等待事件和SQL*Net more data to client 等待时间基本相同，只不过等待发生在分布式事务中，即本地数据库需要将更多的数据通过dblink发送给远程数据库。由于发送的数据太多或者网络性能问题，就会出现SQL*Net more data to dblink等待事件。<br><br>这个等待时间包含两个参数：<BR>Driver id: 服务器端和客户端连接使用的协议信息。<BR>#bytes: 服务器端通过dblink发送给另一个服务器消息的字节数。
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/83315.html'>详解SQL中Group By的用法</a><a>下一篇</a><a href='/php/biji/83317.html'>jQuery实现网站添加高亮突出显示效果的方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>