<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Vue.js组件与组件间的通信的解决办法_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="这篇文章主要为大家详细介绍了Vue.js组件与组件间的通信的简单示例，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！<br />
什么是组件？<br />
组件（Compo" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Vue.js组件与组件间的通信的解决办法</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>这篇文章主要为大家详细介绍了Vue.js组件与组件间的通信的简单示例，具有一定的参考价值，可以用来参考一下。<br />
<br />
对此感兴趣的朋友，看看idc笔记做的技术笔记！<br />
什么是组件？<br />
组件（Compo</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>这篇文章主要为大家详细介绍了Vue.js组件与组件间的通信的简单示例，具有一定的参考价值，可以用来参考一下。</p>

<p>对此感兴趣的朋友，看看idc笔记做的技术笔记！</p>
<h3>什么是组件？</h3>
<p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p>
<p><strong>使用组件</strong></p>
<p>注册</p>
<p>之前说过，我们可以用 Vue.extend() 创建一个组件构造器：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
var MyComponent = Vue.extend({
 // 选项...
})</code></pre>End 512pic.com
<p>要把这个构造器用作组件，需要用 `Vue.component(tag, constructor)` **注册** ：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
// 全局注册组件，tag 为 my-component
Vue.component('my-component', MyComponent)
</code></pre>End 512pic.com
<p>&lt;p class=&quot;tip&quot;&gt;对于自定义标签名字，Vue.js 不强制要求遵循 W3C 规则（小写，并且包含一个短杠），尽管遵循这个规则比较好。</p>
<p>组件在注册之后，便可以在父实例的模块中以自定义元素 &lt;my-component&gt; 的形式使用。要确保在初始化根实例之前注册了组件：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div id="example"&gt;
 &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;

// 定义
var MyComponent = Vue.extend({
 template: '&lt;div&gt;A custom component!&lt;/div&gt;'
})

// 注册
Vue.component('my-component', MyComponent)

// 创建根实例
new Vue({
 el: '#example'
})

</code></pre>End 512pic.com
<p>渲染为：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div id="example"&gt;
 &lt;div&gt;A custom component!&lt;/div&gt;
&lt;/div&gt;
</code></pre>End 512pic.com
<p>注意组件的模板替换了自定义元素，自定义元素的作用只是作为一个挂载点。可以用实例选项 replace 决定是否替换。</p>
<p>局部注册</p>
<p>不需要全局注册每个组件。可以让组件只能用在其它组件内，用实例选项 components 注册：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
var Child = Vue.extend({ /* ... */ })

var Parent = Vue.extend({
 template: '...',
 components: {
 // &lt;my-component&gt; 只能用在父组件模板内
 'my-component': Child
 }
})

</code></pre>End 512pic.com
<p>这种封装也适用于其它资源，如指令、过滤器和过渡。</p>
<p>注册语法糖</p>
<p>为了让事件更简单，可以直接传入选项对象而不是构造器给 Vue.component() 和 component 选项。Vue.js 在背后自动调用 Vue.extend()：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
// 在一个步骤中扩展与注册
Vue.component('my-component', {
 template: '&lt;div&gt;A custom component!&lt;/div&gt;'
})

// 局部注册也可以这么做
var Parent = Vue.extend({
 components: {
 'my-component': {
 template: '&lt;div&gt;A custom component!&lt;/div&gt;'
 }
 }
})

</code></pre>End 512pic.com
<p>组件选项问题</p>
<p>传入 Vue 构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例： data 和 el。试想如果我们简单地把一个对象作为 data 选项传给 Vue.extend()：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
var data = { a: 1 }
var MyComponent = Vue.extend({
 data: data
})
</code></pre>End 512pic.com
<p>这么做的问题是 `MyComponent` 所有的实例将共享同一个 `data` 对象！这基本不是我们想要的，因此我们应当使用一个函数作为 `data` 选项，让这个函数返回一个新对象：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
 var MyComponent = Vue.extend({
 data: function () {
 return { a: 1 }
 }
})
</code></pre>End 512pic.com
<p>同理，`el` 选项用在 `Vue.extend()` 中时也须是一个函数。</p>
<p>模板解析</p>
<p>Vue 的模板是 DOM 模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM 模板有一些好处，但是也有问题，它必须是有效的 HTML 片段。一些 HTML 元素对什么元素可以放在它里面有限制。常见的限制：&bull;a 不能包含其它的交互元素（如按钮，链接）&bull;ul 和 ol 只能直接包含 li&bull;select 只能包含 option 和 optgroup&bull;table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup&bull;tr 只能直接包含 th 和 td</p>
<p>在实际中，这些限制会导致意外的结果。尽管在简单的情况下它可能可以工作，但是你不能依赖自定义组件在浏览器验证之前的展开结果。例如 &lt;my-select&gt;&lt;option&gt;...&lt;/option&gt;&lt;/my-select&gt; 不是有效的模板，即使 my-select 组件最终展开为 &lt;select&gt;...&lt;/select&gt;。</p>
<p>另一个结果是，自定义标签（包括自定义元素和特殊标签，如 &lt;component&gt;、&lt;template&gt;、 &lt;partial&gt; ）不能用在 ul, select, table 等对内部元素有限制的标签内。放在这些元素内部的自定义标签将被提到元素的外面，因而渲染不正确。</p>
<p>对于自定义元素，应当使用 is 特性：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;table&gt;
 &lt;tr is="my-component"&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>End 512pic.com
<p>`` 不能用在 `` 内，这时应使用 ``，`` 可以有多个 ``：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;table&gt;
 &lt;tbody v-for="item in items"&gt;
 &lt;tr&gt;Even row&lt;/tr&gt;
 &lt;tr&gt;Odd row&lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

</code></pre>End 512pic.com
<h3>Props</h3>
<p>使用 Props 传递数据</p>
<p>组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</p>
<p>&ldquo;prop&rdquo; 是组件数据的一个字段，期望从父组件传下来。子组件需要显式地用 props 选项 声明 props：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('child', {
 // 声明 props
 props: ['msg'],
 // prop 可以用在模板内
 // 可以用 `this.msg` 设置
 template: '&lt;span&gt;{{ msg }}&lt;/span&gt;'
})
</code></pre>End 512pic.com
<p>然后向它传入一个普通字符串：&lt;child msg=&quot;hello!&quot;&gt;&lt;/child&gt;</p>
<p>驼峰式vs.横杠式</p>
<p>HTML 特性不区分大小写。名字形式为 camelCase 的 prop 用作特性时，需要转为 kebab-case（短横线隔开）：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('child', {
 // camelCase in JavaScript
 props: ['myMessage'],
 template: '&lt;span&gt;{{ myMessage }}&lt;/span&gt;'
})

&lt;!-- kebab-case in HTML --&gt;
&lt;child my-message="hello!"&gt;&lt;/child&gt;

</code></pre>End 512pic.com
<p>动态 Props</p>
<p>类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 绑定动态 Props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div&gt;
 &lt;input v-model="parentMsg"&gt;
 &lt;br&gt;
 &lt;child v-bind:my-message="parentMsg"&gt;&lt;/child&gt;
&lt;/div&gt;
</code></pre>End 512pic.com
<p>使用 `v-bind` 的缩写语法通常更简单：&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</p>
<p>字面量语法 vs. 动态语法</p>
<p>初学者常犯的一个错误是使用字面量语法传递数值：</p>
<p>&lt;!-- 传递了一个字符串 &quot;1&quot; --&gt;&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;因为它是一个字面 prop，它的值以字符串 `&rdquo;1&rdquo;` 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用动态语法，从而让它的值被当作 JavaScript 表达式计算：&lt;!-- 传递实际的数字 --&gt;&lt;comp :some-prop=&quot;1&quot;&gt;&lt;/comp&gt;</p>
<p>Prop 绑定类型</p>
<p>prop 默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态&mdash;&mdash;这会让应用的数据流难以理解。不过，也可以使用 .sync 或 .once 绑定修饰符显式地强制双向或单次绑定：</p>
<p>比较语法：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;!-- 默认为单向绑定 --&gt;
&lt;child :msg="parentMsg"&gt;&lt;/child&gt;

&lt;!-- 双向绑定 --&gt;
&lt;child :msg.sync="parentMsg"&gt;&lt;/child&gt;

&lt;!-- 单次绑定 --&gt;
&lt;child :msg.once="parentMsg"&gt;&lt;/child&gt;

</code></pre>End 512pic.com
<p>双向绑定会把子组件的 msg 属性同步回父组件的 parentMsg 属性。单次绑定在建立之后不会同步之后的变化。</p>
<p>注意如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它会影响父组件的状态，不管是使用哪种绑定类型。</p>
<p>Prop 验证</p>
<p>组件可以为 props 指定验证要求。当组件给其他人使用时这很有用，因为这些验证要求构成了组件的 API，确保其他人正确地使用组件。此时 props 的值是一个对象，包含验证要求：</p>
<p></p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('example', {
 props: {
 // 基础类型检测 （`null` 意思是任何类型都可以）
 propA: Number,
 // 多种类型 (1.0.21+)
 propM: [String, Number],
 // 必需且是字符串
 propB: {
 type: String,
 required: true
 },
 // 数字，有默认值
 propC: {
 type: Number,
 default: 100
 },
 // 对象/数组的默认值应当由一个函数返回
 propD: {
 type: Object,
 default: function () {
 return { msg: 'hello' }
 }
 },
 // 指定这个 prop 为双向绑定
 // 如果绑定类型不对将抛出一条警告
 propE: {
 twoWay: true
 },
 // 自定义验证函数
 propF: {
 validator: function (value) {
 return value &gt; 10
 }
 },
 // 转换函数（1.0.12 新增）
 // 在设置值之前转换值
 propG: {
 coerce: function (val) {
 return val + '' // 将值转换为字符串
 }
 },
 propH: {
 coerce: function (val) {
 return JSON.parse(val) // 将 JSON 字符串转换为对象
 }
 }
 }
})

</code></pre>End 512pic.com
<p>type 可以是下面原生构造器：&bull;String&bull;Number&bull;Boolean&bull;Function&bull;Object&bull;Array</p>
<p>type 也可以是一个自定义构造器，使用 instanceof 检测。</p>
<p>当 prop 验证失败了，Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。</p>
<h3>父子组件通信</h3>
<p>父链</p>
<p>子组件可以用 this.$parent 访问它的父组件。根实例的后代可以用 this.$root 访问它。父组件有一个数组 this.$children，包含它所有的子元素。</p>
<p>尽管可以访问父链上任意的实例，不过子组件应当避免直接依赖父组件的数据，尽量显式地使用 props 传递数据。另外，在子组件中修改父组件的状态是非常糟糕的做法，因为：1.这让父组件与子组件紧密地耦合；</p>
<p>2.只看父组件，很难理解父组件的状态。因为它可能被任意子组件修改！理想情况下，只有组件自己能修改它的状态。</p>
<p>自定义事件</p>
<p>Vue 实例实现了一个自定义事件接口，用于在组件树中通信。这个事件系统独立于原生 DOM 事件，用法也不同。</p>
<p>每个 Vue 实例都是一个事件触发器：&bull;使用 $on() 监听事件；</p>
<p>&bull;使用 $emit() 在它上面触发事件；</p>
<p>&bull;使用 $dispatch() 派发事件，事件沿着父链冒泡；</p>
<p>&bull;使用 $broadcast() 广播事件，事件向下传导给所有的后代。</p>
<p>不同于 DOM 事件，Vue 事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回 true。</p>
<p>简单例子：</p>
<p></p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;!-- 子组件模板 --&gt;
&lt;template id="child-template"&gt;
 &lt;input v-model="msg"&gt;
 &lt;button v-on:click="notify"&gt;Dispatch Event&lt;/button&gt;
&lt;/template&gt;

&lt;!-- 父组件模板 --&gt;
&lt;div id="events-example"&gt;
 &lt;p&gt;Messages: {{ messages | json }}&lt;/p&gt;
 &lt;child&gt;&lt;/child&gt;
&lt;/div&gt;

// 注册子组件
// 将当前消息派发出去
Vue.component('child', {
 template: '#child-template',
 data: function () {
 return { msg: 'hello' }
 },
 methods: {
 notify: function () {
 if (this.msg.trim()) {
 this.$dispatch('child-msg', this.msg)
 this.msg = ''
 }
 }
 }
})

// 初始化父组件
// 将收到消息时将事件推入一个数组
var parent = new Vue({
 el: '#events-example',
 data: {
 messages: []
 },
 // 在创建实例时 `events` 选项简单地调用 `$on`
 events: {
 'child-msg': function (msg) {
 // 事件回调内的 `this` 自动绑定到注册它的实例上
 this.messages.push(msg)
 }
 }
})

</code></pre>End 512pic.com
<h3>使用 v-on 绑定自定义事件</h3>
<p>上例非常好，不过从父组件的代码中不能直观的看到 &quot;child-msg&quot; 事件来自哪里。如果我们在模板中子组件用到的地方声明事件处理器会更好。为此子组件可以用 v-on 监听自定义事件：</p>
<p>&lt;child v-on:child-msg=&quot;handleIt&quot;&gt;&lt;/child&gt;这样就很清楚了：当子组件触发了 `&rdquo;child-msg&rdquo;` 事件，父组件的 `handleIt` 方法将被调用。所有影响父组件状态的代码放到父组件的 `handleIt` 方法中；子组件只关注触发事件。子组件索引</p>
<p>尽管有 props 和 events，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 v-ref 为子组件指定一个索引 ID。例如：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div id="parent"&gt;
 &lt;user-profile v-ref:profile&gt;&lt;/user-profile&gt;
&lt;/div&gt;

var parent = new Vue({ el: '#parent' })
// 访问子组件
var child = parent.$refs.profile

</code></pre>End 512pic.com
<p>v-ref 和 v-for 一起用时，ref 是一个数组或对象，包含相应的子组件。</p>
<h3>使用 Slot 分发内容</h3>
<p>在使用组件时，常常要像这样组合它们：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;app&gt;
 &lt;app-header&gt;&lt;/app-header&gt;
 &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/app&gt;

</code></pre>End 512pic.com
<p>注意两点：1.&lt;app&gt; 组件不知道它的挂载点会有什么内容，挂载点的内容是由 &lt;app&gt; 的父组件决定的。</p>
<p>2.&lt;app&gt; 组件很可能有它自己的模板。</p>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个处理称为内容分发（或 &ldquo;transclusion&rdquo;，如果你熟悉 Angular）。Vue.js 实现了一个内容分发 API，参照了当前 Web 组件规范草稿，使用特殊的 &lt;slot&gt; 元素作为原始内容的插槽。</p>
<h3>编译作用域</h3>
<p>在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：</p>
<p>&lt;child-component&gt; {{ msg }}&lt;/child-component&gt;</p>
<p>msg 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：</p>
<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p>
<p>&lt;!-- 无效 --&gt;&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</p>
<p>假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。</p>
<p>如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('child-component', {
 // 有效，因为是在正确的作用域内
 template: '&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;',
 data: function () {
 return {
 someChildProperty: true
 }
 }
})
</code></pre>End 512pic.com
<p>类似地，分发内容是在父组件作用域内编译。</p>
<p>单个 Slot</p>
<p>父组件的内容将被抛弃，除非子组件模板包含 &lt;slot&gt;。如果子组件模板只有一个没有特性的 slot，父组件的整个内容将插到 slot 所在的地方并替换它。</p>
<p>&lt;slot&gt; 标签的内容视为回退内容。回退内容在子组件的作用域内编译，当宿主元素为空并且没有内容供插入时显示这个回退内容。</p>
<p>假定 my-component 组件有下面模板：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div&gt;
 &lt;h1&gt;This is my component!&lt;/h1&gt;
 &lt;slot&gt;
 如果没有分发内容则显示我。
 &lt;/slot&gt;
&lt;/div&gt;
</code></pre>End 512pic.com
<p>父组件模板：&lt;my-component&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt;&lt;/my-component&gt;渲染结果：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div&gt;
 &lt;h1&gt;This is my component!&lt;/h1&gt;
 &lt;p&gt;This is some original content&lt;/p&gt;
 &lt;p&gt;This is some more original content&lt;/p&gt;
&lt;/div&gt;
</code></pre>End 512pic.com
<p>具名 Slot</p>
<p>&lt;slot&gt; 元素可以用一个特殊特性 name 配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。</p>
<p>仍然可以有一个匿名 slot，它是默认 slot，作为找不到匹配的内容片段的回退插槽。如果没有默认的 slot，这些找不到匹配的内容片段将被抛弃。</p>
<p>例如，假定我们有一个 multi-insertion 组件，它的模板为：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div&gt;
 &lt;slot name="one"&gt;&lt;/slot&gt;
 &lt;slot&gt;&lt;/slot&gt;
 &lt;slot name="two"&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>End 512pic.com
<p>父组件模板：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;multi-insertion&gt;
 &lt;p slot="one"&gt;One&lt;/p&gt;
 &lt;p slot="two"&gt;Two&lt;/p&gt;
 &lt;p&gt;Default A&lt;/p&gt;
&lt;/multi-insertion&gt;
</code></pre>End 512pic.com
<p>渲染结果为：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;div&gt;
 &lt;p slot="one"&gt;One&lt;/p&gt;
 &lt;p&gt;Default A&lt;/p&gt;
 &lt;p slot="two"&gt;Two&lt;/p&gt;
&lt;/div&gt;
</code></pre>End 512pic.com
<p>在组合组件时，内容分发 API 是非常有用的机制。</p>
<p>动态组件</p>
<p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 &lt;component&gt; 元素，动态地绑定到它的 is 特性：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
new Vue({
 el: 'body',
 data: {
 currentView: 'home'
 },
 components: {
 home: { /* ... */ },
 posts: { /* ... */ },
 archive: { /* ... */ }
 }
})

&lt;component :is="currentView"&gt;
 &lt;!-- 组件在 vm.currentview 变化时改变 --&gt;
&lt;/component&gt;

</code></pre>End 512pic.com
<p>keep-alive</p>
<p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：</p>
<p>&lt;component :is=&quot;currentView&quot; keep-alive&gt; &lt;!-- 非活动组件将被缓存 --&gt;&lt;/component&gt;</p>
<p>activate 钩子</p>
<p>在切换组件时，切入组件在切入前可能需要进行一些异步操作。为了控制组件切换时长，给切入组件添加 activate 钩子：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('activate-example', {
 activate: function (done) {
 var self = this
 loadDataAsync(function (data) {
 self.someData = data
 done()
 })
 }
})
</code></pre>End 512pic.com
<p>注意 `activate` 钩子只作用于动态组件切换或静态组件初始化渲染的过程中，不作用于使用实例方法手工插入的过程中。transition-mode</p>
<p>transition-mode 特性用于指定两个动态组件之间如何过渡。</p>
<p>在默认情况下，进入与离开平滑地过渡。这个特性可以指定另外两种模式：&bull;in-out：新组件先过渡进入，等它的过渡完成之后当前组件过渡出去。</p>
<p>&bull;out-in：当前组件先过渡出去，等它的过渡完成之后新组件过渡进入。</p>
<p>示例：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
&lt;!-- 先淡出再淡入 --&gt;
&lt;component
 :is="view"
 transition="fade"
 transition-mode="out-in"&gt;
&lt;/component&gt;

.fade-transition {
 transition: opacity .3s ease;
}
.fade-enter, .fade-leave {
 opacity: 0;
}

</code></pre>End 512pic.com
<p>杂项</p>
<p>组件和 v-for</p>
<p>自定义组件可以像普通元素一样直接使用 v-for：</p>
<p>&lt;my-component v-for=&quot;item in items&quot;&gt;&lt;/my-component&gt;</p>
<p>但是，不能传递数据给组件，因为组件的作用域是孤立的。为了传递数据给组件，应当使用 props：</p>
<p>&lt;my-component v-for=&quot;item in items&quot; :item=&quot;item&quot; :index=&quot;$index&quot;&gt;&lt;/my-component&gt;</p>
<p>不自动把 item 注入组件的原因是这会导致组件跟当前 v-for 紧密耦合。显式声明数据来自哪里可以让组件复用在其它地方。</p>
<p>编写可复用组件</p>
<p>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。</p>
<p>Vue.js 组件 API 来自三部分&mdash;&mdash;prop，事件和 slot：&bull;prop 允许外部环境传递数据给组件；</p>
<p>&bull;事件 允许组件触发外部环境的 action；</p>
<p>&bull;slot 允许外部环境插入内容到组件的视图结构内。</p>
<p>使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：</p>
<p>&lt;my-component :foo=&quot;baz&quot; :bar=&quot;qux&quot; @event-a=&quot;doThis&quot; @event-b=&quot;doThat&quot;&gt; &lt;!-- content --&gt; &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt; &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;&lt;/my-component&gt;</p>
<p>异步组件</p>
<p>在大型应用中，我们可能需要将应用拆分为小块，只在需要时才从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('async-example', function (resolve, reject) {
 setTimeout(function () {
 resolve({
 template: '&lt;div&gt;I am async!&lt;/div&gt;'
 })
 }, 1000)
})

</code></pre>End 512pic.com
<p>工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 Webpack 的代码分割功能：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
Vue.component('async-webpack-example', function (resolve) {
 // 这个特殊的 require 语法告诉 webpack
 // 自动将编译后的代码分割成不同的块，
 // 这些块将通过 ajax 请求自动下载。
 require(['./my-async-component'], resolve)
})

</code></pre>End 512pic.com
<p>资源命名约定</p>
<p>一些资源，如组件和指令，是以 HTML 特性或 HTML 自定义元素的形式出现在模板中。因为 HTML 特性的名字和标签的名字不区分大小写，所以资源的名字通常需使用 kebab-case 而不是 camelCase 的形式，这不大方便。</p>
<p>Vue.js 支持资源的名字使用 camelCase 或 PascalCase 的形式，并且在模板中自动将它们转为 kebab-case（类似于 prop 的命名约定）：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
// 在组件定义中
components: {
 // 使用 camelCase 形式注册
 myComponent: { /*... */ }
}

&lt;!-- 在模板中使用 kebab-case 形式 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;

ES6 对象字面量缩写 也没问题：

// PascalCase
import TextBox from './components/text-box';
import DropdownMenu from './components/dropdown-menu';

export default {
 components: {
 // 在模板中写作 &lt;text-box&gt; 和 &lt;dropdown-menu&gt;
 TextBox,
 DropdownMenu
 }
}

</code></pre>End 512pic.com
<p>递归组件</p>
<p>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：</p>
<p>代码如下：</p>
<pre>
<code class="language-javascript">
var StackOverflow = Vue.extend({
 name: 'stack-overflow',
 template:
 '&lt;div&gt;' +
 // 递归地调用它自己
 '&lt;stack-overflow&gt;&lt;/stack-overflow&gt;' +
 '&lt;/div&gt;'
})

</code></pre>End 512pic.com
<p>上面组件会导致一个错误 &ldquo;max stack size exceeded&rdquo;，所以要确保递归调用有终止条件。当使用 Vue.component() 全局注册一个组件时，组件 ID 自动设置为组件的 name 选项。</p>
<p>片断实例</p>
<p>在使用 template 选项时，模板的内容将替换实例的挂载元素。因而推荐模板的顶级元素始终是单个元素。</p>
<p>不这么写模板：</p>
<p>&lt;div&gt;root node 1&lt;/div&gt;&lt;div&gt;root node 2&lt;/div&gt;</p>
<p>推荐这么写：</p>
<p>&lt;div&gt; I have a single root node! &lt;div&gt;node 1&lt;/div&gt; &lt;div&gt;node 2&lt;/div&gt;&lt;/div&gt;</p>
<p>下面几种情况会让实例变成一个片断实例：1.模板包含多个顶级元素。2.模板只包含普通文本。3.模板只包含其它组件（其它组件可能是一个片段实例）。4.模板只包含一个元素指令，如 &lt;partial&gt; 或 vue-router 的 &lt;router-view&gt;。5.模板根节点有一个流程控制指令，如 v-if 或 v-for。</p>
<p>这些情况让实例有未知数量的顶级元素，它将把它的 DOM 内容当作片断。片断实例仍然会正确地渲染内容。不过，它没有一个根节点，它的 $el 指向一个锚节点，即一个空的文本节点（在开发模式下是一个注释节点）。</p>
<p>但是更重要的是，组件元素上的非流程控制指令，非 prop 特性和过渡将被忽略，因为没有根元素供绑定：</p>
<p>&lt;!-- 不可以，因为没有根元素 --&gt;&lt;example v-show=&quot;ok&quot; transition=&quot;fade&quot;&gt;&lt;/example&gt;</p>
<p>&lt;!-- props 可以 --&gt;&lt;example :prop=&quot;someData&quot;&gt;&lt;/example&gt;</p>
<p>&lt;!-- 流程控制可以，但是不能有过渡 --&gt;&lt;example v-if=&quot;ok&quot;&gt;&lt;/example&gt;</p>
<p>当然片断实例有它的用处，不过通常给组件一个根节点比较好。它会保证组件元素上的指令和特性能正确地转换，同时性能也稍微好些。</p>
<p>内联模板</p>
<p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。</p>
<p>&lt;my-component inline-template&gt; &lt;p&gt;These are compiled as the component&#39;s own template&lt;/p&gt; &lt;p&gt;Not parent&#39;s transclusion content.&lt;/p&gt;&lt;/my-component&gt;</p>
<p>但是 inline-template 让模板的作用域难以理解，并且不能缓存模板编译结果。最佳实践是使用 template 选项在组件内定义模板。</p>

<p>注：关于Vue.js组件与组件间的通信的简单示例的内容就先介绍到这里，更多相关文章的可以留意</span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/115696.html'>jquery定时器的解决办法</a><a>下一篇</a><a href='/php/biji/115698.html'>vue.js通过自定义指令实现数据拉取更新的实现方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>