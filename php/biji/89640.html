<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Symfony2学习笔记之系统路由详解_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="本文详细讲述了Symfony2的系统路由。分享给大家供大家参考，具体如下：<br />
漂亮的URL绝对是一个严肃的web应用程序必须做到的，这种方式使index.php&amp;#63;article_id=57这类的丑陋URL" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Symfony2学习笔记之系统路由详解</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>本文详细讲述了Symfony2的系统路由。分享给大家供大家参考，具体如下：<br />
漂亮的URL绝对是一个严肃的web应用程序必须做到的，这种方式使index.php&amp;#63;article_id=57这类的丑陋URL</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>本文详细讲述了Symfony2的系统路由。分享给大家供大家参考，具体如下：</p>
<p>漂亮的URL绝对是一个严肃的web应用程序必须做到的，这种方式使index.php&#63;article_id=57这类的丑陋URL被隐藏，由更受欢迎的像 /read/intro-to-symfony 来替代。</p>
<p>拥有灵活性更为重要，如果你要改变一个页面的URL，比如从/blog 到 /new 怎么办？</p>
<p>有多少链接需要你找出来并更新呢？ 如果你使用Symfony的router，这种改变将变得很简单。</p>
<p>Symfony2 router让你定义更具创造力的URL，你可以map你的应用程序的不同区域。</p>
<p>创建复杂的路由并map到controllers并可以在模板和controllers内部生成URLs</p>
<p>从bundles（或者其他任何地方）加载路由资源</p>
<p>调试你的路由</p>
<p><strong>路由活动</strong></p>
<p>一个路径是一个从URL 模式到一个controller的绑定。</p>
<p>比如假设你想匹配任何像 /blog/my-post 或者 /blog/all-about-symfony的路径并把它们发送到一个controller在那里可以查找并渲染blog实体。</p>
<p>该路径很简单：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
# app/config/routing.yml
blog_show:
pattern: /blog/{slug}
defaults: {_controller: AcmeBlogBundle:Blog:show }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;!-- app/config/routing.xml --&gt;
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
&lt;route id="blog_show" pattern="/blog/{slug}"&gt;
&lt;default key="_controller"&gt;AcmeBlogBundle:Blog:show&lt;/default&gt;
&lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
// app/config/routing.php
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog_show', new Route('/blog/{slug}', array(
     '_controller' =&gt; 'AcmeBlogBundle:Blog:show',
)));

</pre>
</div>
<p>blog_show路径定义了一个URL模式，它像/blog/* 这里的通配符被命名为slug。对于URL/blog/my-blog-post，slug变量会得到值 my-blog-post。<br />
_controller参数是一个特定的键，它告诉Symfogy当一个URL匹配这个路径时哪个controller将要被执行。<br />
_controller字符串被称为逻辑名。它的值会按照特定的模式来指定具体的PHP类和方法。</p>
<div class="phpstudycode">
<pre class="brush:php;">
// src/Acme/BlogBundle/Controller/BlogController.php
namespace Acme\BlogBundle\Controller;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
class BlogController extends Controller
{
  public function showAction($slug)
  {
    $blog = // use the $slug variable to query the database
    return $this-&gt;render('AcmeBlogBundle:Blog:show.html.twig', array(
      'blog' =&gt; $blog,
    ));
  }
}

</pre>
</div>
<p>现在当你再访问/blog/my-post 时，showAction controller将被执行并且$slug变量的值为my-post</p>
<p>Symfogy2 的路由器目标：映射一个请求的URL到controller。</p>
<p><strong>路由：内部的秘密</strong></p>
<p>当一个请求发送到应用程序时，它包含一个客户端想要获取资源的地址。这个地址叫做URL或者URI。可能是/contact,/blog/read-me或者其它样式。</p>
<p>GET /blog/my-blog-post</p>
<p>Symfony2 路由系统的目标是解析这些URL并决定哪个controller应该被执行来回复该请求。</p>
<p>整个路由过程可以分为：</p>
<p>1.请求被Symfony2的前端控制器（app.php)处理。<br />
2.Symfony2核心（kernel)要求路由器检查请求。<br />
3.路由器匹配接收到的URL到一个特定的路径并返回有关信息，包括应该被执行的controller。<br />
4.Symfony2核心执行该controller，该controller最终会返回一个Response对象。</p>
<p>路由器层就是一个把接收到的URL转换为要执行的特定controller的工具。</p>
<p><strong>创建路由</strong></p>
<p>Symfony会从一个单独的路由配置文件中加载你应用程序的所有路由。该文件通常为 app/config/routing.yml。 它可以被配置成包括XML或者PHP文件等文件。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
# app/config/config.yml
framework:
  # ...
  router:    { resource: "%kernel.root_dir%/config/routing.yml" }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;!-- app/config/config.xml --&gt;
&lt;framework:config ...&gt;
  &lt;!-- ... --&gt;
  &lt;framework:router resource="%kernel.root_dir%/config/routing.xml" /&gt;
&lt;/framework:config&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
// app/config/config.php
$container-&gt;loadFromExtension('framework', array(
  // ...
  'router'    =&gt; array('resource' =&gt; '%kernel.root_dir%/config/routing.php'),
));

</pre>
</div>
<p><strong>基础路由配置</strong></p>
<p>定义一个路由很简单，通常一个应用程序拥有很多路由。一个基础路由是由两部分组成：pattern部分和defaults数组部分。<br />
比如：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
_welcome:
  pattern:  /
  defaults: { _controller: AcmeDemoBundle:Main:homepage }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="_welcome" pattern="/"&gt;
    &lt;default key="_controller"&gt;AcmeDemoBundle:Main:homepage&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('_welcome', new Route('/', array(
  '_controller' =&gt; 'AcmeDemoBundle:Main:homepage',
)));
return $collection;

</pre>
</div>
<p>该路由匹配首页(/)并映射到AcmeDemoBundle:Main:homepage controller。_controller字符串被Symfony2翻译成一个相应的PHP函数并被执行。</p>
<p><strong>带占位符路由</strong></p>
<p>当然，路由系统支持更多有趣的路由。许多路由会包含一个或者多个被命名的通配符占位符。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
blog_show:
  pattern:  /blog/{slug}
  defaults: { _controller: AcmeBlogBundle:Blog:show }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="blog_show" pattern="/blog/{slug}"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:show&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog_show', new Route('/blog/{slug}', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:show',
)));
return $collection;

</pre>
</div>
<p>该模式将匹配任何类似/blog/*形式的URL。匹配占位符{slug}的值将会在controller中被使用。换句话说，如果URL是/blog/hello-world,则$slug变量值是hello-world， 该值将能在controller中被使用。该模式不会匹配像/blog, 因为默认情况下所有的占位符都是必须的。 当然可以通过在defaults数组中给这些占位符赋来改变它。</p>
<p><strong>必需和可选占位符</strong></p>
<p>我们来添加一个新的路由，显示所有可用的blog列表。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
blog:
  pattern:  /blog
  defaults: { _controller: AcmeBlogBundle:Blog:index }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="blog" pattern="/blog"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:index&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog', new Route('/blog', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:index',
)));
return $collection;

</pre>
</div>
<p>到目前为止，我们的路由都是非常简单的路由模式。它们包含的非占位符将会被精确匹配。</p>
<p>如果你想该路由能够支持分页，比如让/blog/2 显示第二页的blog,那就需要为之前的路由添加一个新的{page}占位符。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
blog:
  pattern:  /blog/{page}
  defaults: { _controller: AcmeBlogBundle:Blog:index }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="blog" pattern="/blog/{page}"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:index&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog', new Route('/blog/{page}', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:index',
)));
return $collection;

</pre>
</div>
<p>跟之前的{slug}占位符一样{page}占位符将会在你的controller内部可用，它的值可以用于表示要显示的blog值的页码。但是要清楚，因为占位符默认情况下都是必需的，该路由也将不再匹配之前的/blog URL，这时候你如果还像看第一页的话，就必须通过/blog/1 URL来访问了。要解决该问题，可以在该路由的defaults数组中指定{page}的默认值。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
blog:
  pattern:  /blog/{page}
  defaults: { _controller: AcmeBlogBundle:Blog:index, page: 1 }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="blog" pattern="/blog/{page}"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:index&lt;/default&gt;
    &lt;default key="page"&gt;1&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog', new Route('/blog/{page}', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:index',
  'page' =&gt; 1,
)));
return $collection;

</pre>
</div>
<p>通过添加page到defaults键， {page}占位符就不再是必需的。这时候 /blog将会被匹配并且page参数被设置为1，URL /blog/2 也会被匹配。</p>
<p><strong>添加要求约束</strong></p>
<p>看看下面这些路由：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
blog:
  pattern:  /blog/{page}
  defaults: { _controller: AcmeBlogBundle:Blog:index, page: 1 }
blog_show:
  pattern:  /blog/{slug}
  defaults: { _controller: AcmeBlogBundle:Blog:show }

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="blog" pattern="/blog/{page}"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:index&lt;/default&gt;
    &lt;default key="page"&gt;1&lt;/default&gt;
  &lt;/route&gt;
  &lt;route id="blog_show" pattern="/blog/{slug}"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:show&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog', new Route('/blog/{page}', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:index',
  'page' =&gt; 1,
)));
$collection-&gt;add('blog_show', new Route('/blog/{show}', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:show',
)));
return $collection;

</pre>
</div>
<p>你发现问题了吗？注意这两个路由都能匹配像/blog/* 类型的URL。Symfony只会选择第一个与之匹配的路由。</p>
<p>换句话说，blog_show将永远不会被像/blog/* 类型的URL匹配。而像 /blog/my-blog-post这样的URL也会被blog路由匹配，并且page变量会获得my-blog-post这样的值。</p>
<p>这肯定不可以，那么怎么办呢？答案是给路由添加约束要求requirements。</p>
<p>在blog路由中占位符{page}理想状态下只匹配整数值。幸运的是正则表达可以很容易的满足这一要求。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
blog:
  pattern:  /blog/{page}
  defaults: { _controller: AcmeBlogBundle:Blog:index, page: 1 }
  requirements:
    page: \d+
</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="blog" pattern="/blog/{page}"&gt;
    &lt;default key="_controller"&gt;AcmeBlogBundle:Blog:index&lt;/default&gt;
    &lt;default key="page"&gt;1&lt;/default&gt;
    &lt;requirement key="page"&gt;\d+&lt;/requirement&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('blog', new Route('/blog/{page}', array(
  '_controller' =&gt; 'AcmeBlogBundle:Blog:index',
  'page' =&gt; 1,
), array(
  'page' =&gt; '\d+',
)));
return $collection;

</pre>
</div>
<p>这里 \d+ 约束是一个正则表达式，它指定了{page}只接受整数。这样像/blog/my-blog-post就不再被匹配了。这时候，它才会被blog_show路由匹配。因为参数的约束都是正则表达式，所以其复杂程度和灵活性都有你来决定了。<br />
假设home页使用两种语言则可以这样配置路由：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
homepage:
  pattern:  /{culture}
  defaults: { _controller: AcmeDemoBundle:Main:homepage, culture: en }
  requirements:
    culture: en|fr
</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="homepage" pattern="/{culture}"&gt;
    &lt;default key="_controller"&gt;AcmeDemoBundle:Main:homepage&lt;/default&gt;
    &lt;default key="culture"&gt;en&lt;/default&gt;
    &lt;requirement key="culture"&gt;en|fr&lt;/requirement&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('homepage', new Route('/{culture}', array(
  '_controller' =&gt; 'AcmeDemoBundle:Main:homepage',
  'culture' =&gt; 'en',
), array(
  'culture' =&gt; 'en|fr',
)));
return $collection;

</pre>
</div>
<p><strong>添加HTTP 方法约束</strong></p>
<p>除了URL，你还可以匹配请求的方法（GET,HEAD,POST,PUT,DELETE等）。假设你有一个联系表单有两个controller，一个用于显示表单（使用GET请求）一个用于处理提交的表单（POST请求）。它的配置如下：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
contact:
  pattern: /contact
  defaults: { _controller: AcmeDemoBundle:Main:contact }
  requirements:
    _method: GET
contact_process:
  pattern: /contact
  defaults: { _controller: AcmeDemoBundle:Main:contactProcess }
  requirements:
    _method: POST

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="contact" pattern="/contact"&gt;
    &lt;default key="_controller"&gt;AcmeDemoBundle:Main:contact&lt;/default&gt;
    &lt;requirement key="_method"&gt;GET&lt;/requirement&gt;
  &lt;/route&gt;
  &lt;route id="contact_process" pattern="/contact"&gt;
    &lt;default key="_controller"&gt;AcmeDemoBundle:Main:contactProcess&lt;/default&gt;
    &lt;requirement key="_method"&gt;POST&lt;/requirement&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('contact', new Route('/contact', array(
  '_controller' =&gt; 'AcmeDemoBundle:Main:contact',
), array(
  '_method' =&gt; 'GET',
)));
$collection-&gt;add('contact_process', new Route('/contact', array(
  '_controller' =&gt; 'AcmeDemoBundle:Main:contactProcess',
), array(
  '_method' =&gt; 'POST',
)));
return $collection;

</pre>
</div>
<p>尽管这两个路由拥有同一个URL模式定义（/contact)，但是第一个路由只会匹配GET请求，而第二个只会匹配POST请求。这就意味着你可以通过同一个URL来显示表单并提交表单，而用不同的controller对他们进行处理。如果没有指定_method约束，那么该路由会匹配所有请求方法。跟其它约束一样，_method约束也接受正则表达式，如果只想匹配GET或者POST那么你可以用GET|POST</p>
<p><strong>高级路由例子：</strong></p>
<p>Symfony2中具备一切让你创建任何形式路由的条件。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
article_show:
 pattern: /articles/{culture}/{year}/{title}.{_format}
 defaults: { _controller: AcmeDemoBundle:Article:show, _format: html }
 requirements:
   culture: en|fr
   _format: html|rss
   year:   \d+

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="article_show" pattern="/articles/{culture}/{year}/{title}.{_format}"&gt;
    &lt;default key="_controller"&gt;AcmeDemoBundle:Article:show&lt;/default&gt;
    &lt;default key="_format"&gt;html&lt;/default&gt;
    &lt;requirement key="culture"&gt;en|fr&lt;/requirement&gt;
    &lt;requirement key="_format"&gt;html|rss&lt;/requirement&gt;
    &lt;requirement key="year"&gt;\d+&lt;/requirement&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('homepage', new Route('/articles/{culture}/{year}/{title}.{_format}', array(
  '_controller' =&gt; 'AcmeDemoBundle:Article:show',
  '_format' =&gt; 'html',
), array(
  'culture' =&gt; 'en|fr',
  '_format' =&gt; 'html|rss',
  'year' =&gt; '\d+',
)));
return $collection;

</pre>
</div>
<p>上面的路由，在匹配时只会匹配{culture}部分值为en或者fr并且{year}的值为数字的URL。该路由还告诉我们，可以用在占位符之间使用区间代替斜线。</p>
<p>它能够匹配如下URL：</p>
<p>/articles/en/2010/my-post<br />
/articles/fr/2010/my-post.rss</p>
<p>这其中有个特殊的路由参数 _format，在使用该参数时，其值变为请求格式。这种请求格式相当于Respose对象的Content-Type，比如json请求格式会翻译成一个Content-Type为application/json.该参数可以用于在controller中为每个_format渲染一个不同的模板。它是一个很强的方式来渲染同一个内容到不同的格式。</p>
<p><strong>特殊的路由参数：</strong></p>
<p>正如你所看到的，每一个路由参数或者默认值最终都是作为一个controller方法输入参数被使用。另外，有三个参数比较特别，它们每一个都在你的应用程序中增加一个唯一功能。</p>
<p>_controller: 这个参数决定了当路由匹配时，哪个controller被执行。<br />
_format: 用于设置请求格式。<br />
_locale: 用于在session上设置本地化。</p>
<p><strong>Controller的命名模式：</strong></p>
<p>每一个路由必须有一个_controller参数，它决定了当路由匹配时哪个controller应该被执行。该参数使用单一的字符串模式，被称为logical controller name。</p>
<p>通过它Symfony可以映射到一个特定的PHP方法和类。该模式有三部分，每一部分用冒号分割开：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
bundle:controller:action

</pre>
</div>
<p>比如_controller 的值为 AcmeBlogBundle:Blog:show 意思是AcmeBlogBundle bundle中BlogController类里面的showAction方法。</p>
<div class="phpstudycode">
<pre class="brush:php;">
// src/Acme/BlogBundle/Controller/BlogController.php
namespace Acme\BlogBundle\Controller;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
class BlogController extends Controller
{
  public function showAction($slug)
  {
    // ...
  }
}

</pre>
</div>
<p>Symfony会自动把它们的添加相应的后缀，Blog=&gt;BlogController, show =&gt; showAction。</p>
<p>你也可以使用它的完全限定名和方法来给_controller赋值，Acme\BlogBundle\Controller\BlogController::showAction 但一般为了简洁灵活而是用逻辑名称。另外除了上面两种形式外，Symfony还支持第三种方式只有一个冒号分割符，如service_name:indexAction来为_controller赋一个作为服务使用的controller。</p>
<p><strong>路由参数和控制器参数</strong></p>
<p>路由参数非常重要，因为每一个路由参数都会转变成一个控制器参数被在方法中使用。</p>
<div class="phpstudycode">
<pre class="brush:php;">
public function showAction($slug)
{
 // ...
}

</pre>
</div>
<p>事实上，全部的defaults集合和表单的参数值合并到一个单独的数组中。这个数组中的每个键都会成为controller方法的参数。换句话说，你的controller方法的每一个参数，Symfony都会从路由参数中查找并把找到的值赋给给参数。上面例子中的变量 $culture, $year,$title,$_format,$_controller 都会作为showAction()方法的参数。因为占位符和defaults集合被合并到一起，即使$_controller变量也是一样。你也可以使用一个特殊的变量$_route 来指定路由的名称。</p>
<p><strong>包括外部路由资源</strong></p>
<p>所有的路由资源的都是通过一个单一的配置文件导入的。通常是app/config/routing.yml。当然你可能想从别处导入路由资源，比如你定义的bundle中的路由资源，你可以这样导入：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
# app/config/routing.yml
acme_hello:
  resource: "@AcmeHelloBundle/Resources/config/routing.yml"
</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;!-- app/config/routing.xml --&gt;
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;import resource="@AcmeHelloBundle/Resources/config/routing.xml" /&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
// app/config/routing.php
use Symfony\Component\Routing\RouteCollection;
$collection = new RouteCollection();
$collection-&gt;addCollection($loader-&gt;import("@AcmeHelloBundle/Resources/config/routing.php"));
return $collection;

</pre>
</div>
<p>在使用YAML导入资源时，键（比如acme_hello)是没有意义的，只是用来保证该资源唯一不被其它行覆盖。使用resources key加载给定的路由资源。在这个示例中资源是一个全路径文件，@AcmeHelloBundle是简写语法，它会被指向bundle路径。被导入的文件内容如下：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
# src/Acme/HelloBundle/Resources/config/routing.yml
acme_hello:
   pattern: /hello/{name}
   defaults: { _controller: AcmeHelloBundle:Hello:index }
</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;!-- src/Acme/HelloBundle/Resources/config/routing.xml --&gt;
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="acme_hello" pattern="/hello/{name}"&gt;
    &lt;default key="_controller"&gt;AcmeHelloBundle:Hello:index&lt;/default&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
// src/Acme/HelloBundle/Resources/config/routing.php
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('acme_hello', new Route('/hello/{name}', array(
  '_controller' =&gt; 'AcmeHelloBundle:Hello:index',
)));
return $collection;

</pre>
</div>
<p>这个文件中的路由会被解析并跟主要的路由文件内容一起被加载。</p>
<p><strong>给导入的路由资源添加前缀</strong></p>
<p>你可以为导入的路由资源选择一个前缀，比如说假设你想acme_hello路由有一个这样的 匹配模式：/admin/hello/{name} 而不是直接的 /hello/{name}</p>
<p>那么你在导入它的时候可以为其指定prefix。</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
# app/config/routing.yml
acme_hello:
  resource: "@AcmeHelloBundle/Resources/config/routing.yml"
  prefix:  /admin

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;!-- app/config/routing.xml --&gt;
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;import resource="@AcmeHelloBundle/Resources/config/routing.xml" prefix="/admin" /&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
// app/config/routing.php
use Symfony\Component\Routing\RouteCollection;
$collection = new RouteCollection();
$collection-&gt;addCollection($loader-&gt;import("@AcmeHelloBundle/Resources/config/routing.php"), '/admin');
return $collection;

</pre>
</div>
<p>当该外部路由资源加载的时候字符串 /admin 将被插入到匹配模式的前面。</p>
<p><strong>可视化并调试路由</strong></p>
<p>当你添加和个性化路由时，能够看到它并能获取一些细节信息将是非常有用的。一个好的查看你应用程序的路由的方法是通过router:debug 命令行工具。</p>
<p>在你项目目录下执行如下命令：</p>
<div class="phpstudycode">
<pre class="brush:php;">
$ php app/console router:debug

</pre>
</div>
<p>将会输出你应用程序的所有路由。你也可以在该命令后面添加某个路由的名字来获取单个路由信息</p>
<div class="phpstudycode">
<pre class="brush:php;">
$ php app/console router:debug article_show

</pre>
</div>
<p><strong>生成URL</strong></p>
<p>一个路由系统应该也能用来生成URL。事实上，路由系统是一个双向的系统，映射URL到controller+parameters 和 回对应到 一个URL。可以使用match()和generate（）方法来操作。比如：</p>
<div class="phpstudycode">
<pre class="brush:php;">
$params = $router-&gt;match('/blog/my-blog-post');
// array('slug' =&gt; 'my-blog-post', '_controller' =&gt; 'AcmeBlogBundle:Blog:show')
$uri = $router-&gt;generate('blog_show', array('slug' =&gt; 'my-blog-post'));
// /blog/my-blog-post

</pre>
</div>
<p>要生成一个URL，你需要指定路由的名称（比如 blog_show)和任意的通配符（比如：slug=my-blog-post)作为参数。通过这些信息，可以生成任意的URL。</p>
<div class="phpstudycode">
<pre class="brush:php;">
class MainController extends Controller
{
  public function showAction($slug)
  {
   // ...
   $url = $this-&gt;get('router')-&gt;generate('blog_show', array('slug' =&gt; 'my-blog-post'));
  }
}

</pre>
</div>
<p>那么如何从模板内部来生成URL呢？如果你的应用程序前端使用了AJAX请求，你也许想能够基于你的路由配置在javascript中生成URL，通过使用</p>
<p>FOSJsRoutingBundle(https://github.com/FriendsOfSymfony/FOSJsRoutingBundle) 你可以做到：</p>
<div class="phpstudycode">
<pre class="brush:php;">
var url = Routing.generate('blog_show', { "slug": 'my-blog-post'});

</pre>
</div>
<p><strong>生成绝对路径的URL</strong></p>
<p>默认的情况下，路由器生成相对路径的URL（比如 /blog).要生成一个绝对路径的URL，只需要传入一个true到generate方法作为第三个参数值即可。</p>
<div class="phpstudycode">
<pre class="brush:php;">
$router-&gt;generate('blog_show', array('slug' =&gt; 'my-blog-post'), true);
// http://www.example.com/blog/my-blog-post

</pre>
</div>
<p>当生成一个绝对路径URL时主机是当前请求对象的主机，这个是基于PHP提供的服务器信息自动决定的。当你需要为运行子命令行的脚本生成一个绝对URL时，你需要在Request对象上手动设置期望的主机头。</p>
<div class="phpstudycode">
<pre class="brush:php;">
$request-&gt;headers-&gt;set('HOST', 'www.example.com');
</pre>
</div>
<p><strong>生成带有查询字符串的URL</strong></p>
<p>generate()带有一个数组通配符值来生成URI。 但是如果你传入额外的值，它将被添加到URI作为查询字符串：</p>
<div class="phpstudycode">
<pre class="brush:php;">
$router-&gt;generate('blog', array('page' =&gt; 2, 'category' =&gt; 'Symfony'));
// /blog/2&#63;category=Symfony

</pre>
</div>
<p><strong>从模板中生成URL</strong></p>
<p>最常用到生成URL的地方是从模板中链接两个页面时，这来需要使用一个模板帮助函数：</p>
<p>Twig格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;a href="{{ path('blog_show', { 'slug': 'my-blog-post' }) }}"&gt;
 Read this blog post.
&lt;/a&gt;

</pre>
</div>
<p>PHP格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
&lt;a href="&lt;&#63;php echo $view['router']-&gt;generate('blog_show', array('slug' =&gt; 'my-blog-post')) &#63;&gt;"&gt;
  Read this blog post.
&lt;/a&gt;

</pre>
</div>
<p>也可以生成绝对路径：</p>
<p>Twig格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;a href="{{ url('blog_show', { 'slug': 'my-blog-post' }) }}"&gt;
 Read this blog post.
&lt;/a&gt;

</pre>
</div>
<p>PHP格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
&lt;a href="&lt;&#63;php echo $view['router']-&gt;generate('blog_show', array('slug' =&gt; 'my-blog-post'), true) &#63;&gt;"&gt;
  Read this blog post.
&lt;/a&gt;

</pre>
</div>
<p><strong>强制路由使用HTTPS或者HTTP</strong></p>
<p>有时候为了安全起见，你需要你的站点必须使用HTTPS协议访问。这时候路由组件可以通过_scheme 约束来强迫URI方案。比如：</p>
<p>YAML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
secure:
  pattern: /secure
  defaults: { _controller: AcmeDemoBundle:Main:secure }
  requirements:
    _scheme: https

</pre>
</div>
<p>XML格式：</p>
<div class="phpstudycode">
<pre class="brush:xml;">
&lt;&#63;xml version="1.0" encoding="UTF-8" &#63;&gt;
&lt;routes xmlns="http://symfony.com/schema/routing"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd"&gt;
  &lt;route id="secure" pattern="/secure"&gt;
    &lt;default key="_controller"&gt;AcmeDemoBundle:Main:secure&lt;/default&gt;
    &lt;requirement key="_scheme"&gt;https&lt;/requirement&gt;
  &lt;/route&gt;
&lt;/routes&gt;

</pre>
</div>
<p>PHP代码格式：</p>
<div class="phpstudycode">
<pre class="brush:php;">
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;
$collection = new RouteCollection();
$collection-&gt;add('secure', new Route('/secure', array(
  '_controller' =&gt; 'AcmeDemoBundle:Main:secure',
), array(
  '_scheme' =&gt; 'https',
)));
return $collection;

</pre>
</div>
<p>上面的路由定义就是强迫secure路由使用HTTPS协议访问。</p>
<p>反之，当生成secure 的URL的时候，路由系统会根据当前的访问协议方案生成相应的访问协议。比如当前是HTTP，则会自动生成HTTPS访问；如果是HTTPS访问，那么就也会相应的生成HTTPS访问。</p>
<div class="phpstudycode">
<pre class="brush:php;">
# 如果方案是 HTTPS
{{ path('secure') }}
# 生成 /secure
# 如果方案是 HTTP
{{ path('secure') }}
# 生成 https://example.com/secure

</pre>
</div>
<p>当然你也可以通过设置_scheme为HTTP，来强制使用HTTP访问协议。除了上面说的强迫使用HTTPS协议访问的设置方法外，还有一种用于站点区域设置</p>
<p>使用requires_channel 比如你想让你站点中/admin 下面的所有路由都必须使用HTTPS协议访问，或者你的安全路由定义在第三方bundle时使用。</p>
<p><strong>总结：</strong></p>
<p>路由系统是一个为将接收的请求URL映射到被调用来处理该请求的controller函数的系统。它既能够让你生成漂亮的URL同时又能保持你的应用程序功能跟这些URL解耦。路由系统是双向机制的，也就是说它们也可以用来生成URL。</p>
<p>希望本文所述对大家基于Symfony框架的PHP程序设计有所帮助。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/89639.html'>C#基于COM方式读取Excel表格的方法</a><a>下一篇</a><a href='/php/biji/89641.html'>node.js中的socket.io入门实例</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>