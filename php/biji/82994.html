<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Java编程之jdk1.4,jdk1.5和jdk1.6的区别分析(经典)_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="本文结合实例详细分析了Java编程之jdk1.4,jdk1.5和jdk1.6的区别。分享给大家供大家参考，具体如下：<br />
简单说：1.4和1.5最大的区别有两个，一个是1.5有泛型，另一个1.5可以自动封装八大" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Java编程之jdk1.4,jdk1.5和jdk1.6的区别分析(经典)</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>本文结合实例详细分析了Java编程之jdk1.4,jdk1.5和jdk1.6的区别。分享给大家供大家参考，具体如下：<br />
简单说：1.4和1.5最大的区别有两个，一个是1.5有泛型，另一个1.5可以自动封装八大</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>本文结合实例详细分析了Java编程之jdk1.4,jdk1.5和jdk1.6的区别。分享给大家供大家参考，具体如下：</p>
<p>简单说：<span style="color: #ff0000">1.4和1.5最大的区别有两个，一个是1.5有泛型，另一个1.5可以自动封装八大基本数据类型的封装数据类型</span>，即，Integer a = 4这个1.4是不可以的。<span style="color: #ff0000">1.5和1.6的区别不大。1.6我觉得最多的变化，我觉得最大的部分是在GUI上面，提供了很多方便的布局管理和扩展</span>。</p>
<p>这段时间进了一家电子政务公司，都用weblogic8,那咱就用jdk1.4吧，eclipse一改jdk版本，这不以前的项目基本都一片红了。</p>
<p><span style="color: #ff6600"><strong>★jdk1.5的新特性：</strong></span></p>
<p><span style="color: #ff0000">1. 泛型 <br />
2 自动装箱/拆箱 <br />
3 for-each <br />
4 static import <br />
5 变长参数</span></p>
<p><strong>1. 泛型 （避免类型强制转换可能引起的运行错误）</strong></p>
<p>例如:</p>
<div class="phpstudycode">
<pre class="brush:java;">
ArrayList list=new ArrayList(); 
list.add(new Integer(3)); 
list.add(new Integer(4)); 
int i=((Integer)(list.get(0))).parseInt(); 

</pre>
</div>
<p>很麻烦</p>
<div class="phpstudycode">
<pre class="brush:java;">
ArrayList&lt;Integer&gt;list=new ArrayList&lt;Integer&gt;(); 
list.add(new Integer(3)); 
list.add(new Integer(4)); 
int i=list.get(0).parseInt();

</pre>
</div>
<p><strong>2 自动装箱/拆箱</strong></p>
<p>上面例子的最后一句可改为： <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="61901" class="copybut" id="copybut61901" onclick="doCopy('code61901')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code61901">int i=list.get(0);</div><br />
因为原始类型与对应的包装类不用显式转换</p>
<p><strong>3 for-each</strong></p>
<p>循环的增强</p>
<div class="phpstudycode">
<pre class="brush:java;">
int a[]={........};//初始化 
for(int i:a) 
{ 
...... 
} 

</pre>
</div>
<p>不用以前的i=0;i&lt;a.length;i++</p>
<p><strong>4 static import </strong></p>
<p>以前调Java.math <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="53615" class="copybut" id="copybut53615" onclick="doCopy('code53615')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code53615">Math.sqrt();</div><br />
现在 static import java.lang.Math.sqrt; <br />
再 sqrt(); <br />
相当于你自己类里有这个方法</p>
<p><strong>5 变长参数</strong></p>
<div class="phpstudycode">
<pre class="brush:java;">
int sum(int ...intlist) 
{ 
int sum; 
sum=0; 
for(int i=0;i&lt;intlist.length;i++) 
{ 
sum+=intlist[i]; 
} 
return sum;
} 

</pre>
</div>
<p>有任意个参数,把他看作数组</p>
<p><span style="color: #ff6600"><strong>★jdk6.0新特性 </strong></span></p>
<p><span style="color: #ff0000">增强的for循环语句 <br />
注释<br />
枚举<br />
“隐藏的”静态方法 <br />
可变参数(Vararg) <br />
通配符和协变返回<br />
增强的for循环语句 </span></p>
<p>为了迭代集合和数组，增强的for循环提供了一个简单、兼容的语法。有两点值得一提：</p>
<p><strong>一、在循环中，初始化表达式只计算一次。int表达式</strong></p>
<p>未增强的For：</p>
<div class="phpstudycode">
<pre class="brush:java;">
int sum = 0; 
Integer[] numbers = computeNumbers(); 
for (int i=0; i &lt; numbers.length ; i++) 
sum += numbers[i];

</pre>
</div>
<p>增强后的For：</p>
<div class="phpstudycode">
<pre class="brush:java;">
int sum = 0; 
for ( int number: computeNumbers() ) 
sum += number;

</pre>
</div>
<p><strong>局限性 </strong></p>
<p>增强的for循环迭代期间不能访问迭代器或下标</p>
<p>请看下面的例子：</p>
<div class="phpstudycode">
<pre class="brush:java;">
for (int i=0; i &lt; numbers.length ; i++) {
if (i != 0) System.out.print(",");
System.out.print(numbers[i]);
}

</pre>
</div>
<p>这是另一个例子：</p>
<div class="phpstudycode">
<pre class="brush:java;">
for (Iterator&lt;integer&gt; it = n.iterator() ; it.hasNext() ; )
if (it.next() &lt; 0)
it.remove();

</pre>
</div>
<p><strong>注释 </strong></p>
<p>注释处理是一个很大的话题。因为本文只关注核心的语言特性，所以我们不打算涵盖它所有的可能形式和陷阱。 我们将讨论内置的注释（SuppressWarnings，Deprecated和Override）以及一般注释处理的局限性。</p>
<p><strong>Suppress Warnings </strong></p>
<p>该注释关闭了类或方法级别的编译器警告。有时候您比编译器更清楚地知道，代码必须使用一个被否决的方法或执行一些无法静态确定是否类型安全的动作，而使用：</p>
<div class="phpstudycode">
<pre class="brush:java;">
@SuppressWarnings("deprecation")
public static void selfDestruct() {
Thread.currentThread().stop();
}

</pre>
</div>
<p>这可能是内置注释最有用的地方。遗憾的是，1.5.0_04的javac不支持它。但是1.6支持它，并且Sun正在努力将其向后移植到1.5中。</p>
<p>Eclipse 3.1中支持该注释，其他IDE也可能支持它。这允许您把代码彻底地从警告中解脱出来。如果在编译时出现警告，可以确定是您刚刚把它添加进来——以帮助查看那些可能不安全的代码。随着泛型的添加，它使用起来将更趁手。</p>
<p><strong>Deprecated</strong></p>
<p>遗憾的是，Deprecated没那么有用。它本来旨在替换@deprecated javadoc标签，但是由于它不包含任何字段，所以也就没有方法来建议deprecated类或方法的用户应该使用什么做为替代品。大多数</p>
<p>用法都同时需要javadoc标签和这个注释。</p>
<p><strong>Override </strong></p>
<p>Override表示，它所注释的方法应该重写超类中具有相同签名的方法：</p>
<div class="phpstudycode">
<pre class="brush:java;">
@Override
public int hashCode() {
...
}

</pre>
</div>
<p>看上面的例子，如果没有在hashCode中将“C”大写，在编译时不会出现错误，但是在运行时将无法像期望的那样调用该方法。通过添加Override标签，编译器会提示它是否真正地执行了重写。</p>
<p>在超类发生改变的情况中，这也很有帮助。如果向该方法中添加一个新参数，而且方法本身也被重命名了，那么子类将突然不能编译，因为它不再重写超类的任何东西。</p>
<p><strong>其它注释 </strong></p>
<p>注释在其他场景中非常有用。当不是直接修改行为而是增强行为时，特别是在添加样板代码的情况下，注释在诸如EJB和Web services这样的框架中运行得非常好。</p>
<p>注释不能用做预处理器。Sun的设计特别预防了完全因为注释而修改类的字节码。这样可以正确地理解该语言的成果，而且IDE之类的工具也可以执行深入的代码分析和重构之类的功能。</p>
<p>注释不是银弹。第一次遇到的时候，人们试图尝试各种技巧。请看下面这个从别人那里获得的建议：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public class Foo {
@Property
private int bar;
}

</pre>
</div>
<p>其思想是为私有字段bar自动创建getter和setter方法。遗憾的是，这个想法有两个失败之处：1)它不能运行，2)它使代码难以阅读和处理。 它是无法实现的，因为前面已经提到了，Sun特别阻止了对出现注释的类进行修改。</p>
<p>即使是可能的，它也不是一个好主意，因为它使代码可读性差。第一次看到这段代码的人会不知道该注释创建了方法。此外，如果将来您需要在这些方法内部执行一些操作，注释也是没用的。 总之，不要试图用注释去做那些常规代码可以完成的事情。</p>
<p><strong>枚举 </strong></p>
<p>enum非常像public static final int声明，后者作为枚举值已经使用了很多年。对int所做的最大也是最明显的改进是类型安全——您不能错误地用枚举的一种类型代替另一种类型，这一点和int不同，所有的int对编译器来说都是一样的。除去极少数例外的情况，通常都应该用enum实例替换全部的枚举风格的int结构。</p>
<p>枚举提供了一些附加的特性。EnumMap和EnumSet这两个实用类是专门为枚举优化的标准集合实现。如果知道集合只包含枚举类型，那么应该使用这些专门的集合来代替HashMap或HashSet。</p>
<p>大部分情况下，可以使用enum对代码中的所有public static final int做插入替换。它们是可比的，并且可以静态导入，所以对它们的引用看起来是等同的，即使是对于内部类（或内部枚举类型）。注意，比较枚举类型的时候，声明它们的指令表明了它们的顺序值。</p>
<p><strong>“隐藏的”静态方法 </strong></p>
<p>两个静态方法出现在所有枚举类型声明中。因为它们是枚举子类上的静态方法，而不是Enum本身的方法，所以它们在java.lang.Enum的javadoc中没有出现。</p>
<p>第一个是values()，返回一个枚举类型所有可能值的数组。 <br />
第二个是valueOf()，为提供的字符串返回一个枚举类型，该枚举类型必须精确地匹配源代码声明。</p>
<p><strong>方法</strong></p>
<p>关于枚举类型，我们最喜欢的一个方面是它可以有方法。过去您可能需要编写一些代码，对public static final int进行转换，把它从数据库类型转换为JDBC URL。而现在则可以让枚举类型本身带一个整</p>
<p>理代码的方法。下面就是一个例子，包括DatabaseType枚举类型的抽象方法以及每个枚举实例中提供的实现：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public enum DatabaseType {
ORACLE {
public String getJdbcUrl() {...}
},
MYSQL {
public String getJdbcUrl() {...}
};
public abstract String getJdbcUrl();
}

</pre>
</div>
<p>现在枚举类型可以直接提供它的实用方法。例如：</p>
<div class="phpstudycode">
<pre class="brush:java;">
DatabaseType dbType = ...; 
String jdbcURL = dbType.getJdbcUrl();

</pre>
</div>
<p>要获取URL，必须预先知道该实用方法在哪里。</p>
<p><strong>可变参数(Vararg) </strong></p>
<p>正确地使用可变参数确实可以清理一些垃圾代码。典型的例子是一个带有可变的String参数个数的log方法：</p>
<div class="phpstudycode">
<pre class="brush:java;">
Log.log(String code)
Log.log(String code, String arg)
Log.log(String code, String arg1, String arg2)
Log.log(String code, String[] args)

</pre>
</div>
<p>当讨论可变参数时，比较有趣的是，如果用新的可变参数替换前四个例子，将是兼容的： <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="31589" class="copybut" id="copybut31589" onclick="doCopy('code31589')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code31589">Log.log(String code, String... args)</div></p>
<p>所有的可变参数都是源兼容的——那就是说，如果重新编译log()方法的所有调用程序，可以直接替换全部的四个方法。然而，如果需要向后的二进制兼容性，那么就需要舍去前三个方法。只有最后那个带一个字符串数组参数的方法等效于可变参数版本，因此可以被可变参数版本替换。</p>
<p><strong>类型强制转换 </strong></p>
<p>如果希望调用程序了解应该使用哪种类型的参数，那么应该避免用可变参数进行类型强制转换。看下面这个例子，第一项希望是String，第二项希望是Exception：</p>
<div class="phpstudycode">
<pre class="brush:java;">
Log.log(Object... objects) {
String message = (String)objects[0];
if (objects.length &gt; 1) {
Exception e = (Exception)objects[1];
// Do something with the exception
}
}

</pre>
</div>
<p>方法签名应该如下所示，相应的可变参数分别使用String和Exception声明：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="71110" class="copybut" id="copybut71110" onclick="doCopy('code71110')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code71110">Log.log(String message, Exception e, Object... objects) {...}</div></p>
<p>不要使用可变参数破坏类型系统。需要强类型化时才可以使用它。对于这个规则，PrintStream.printf()是一个有趣的例外：它提供类型信息作为自己的第一个参数，以便稍后可以接受那些类型。</p>
<p><strong>协变返回 </strong></p>
<p>协变返回的基本用法是用于在已知一个实现的返回类型比API更具体的时候避免进行类型强制转换。在下面这个例子中，有一个返回Animal对象的Zoo接口。我们的实现返回一个AnimalImpl对象，但是在JDK 1.5之前，要返回一个Animal对象就必须声明。:</p>
<div class="phpstudycode">
<pre class="brush:java;">
public interface Zoo {
public Animal getAnimal();
}
public class ZooImpl implements Zoo {
public Animal getAnimal(){
return new AnimalImpl();
}
}

</pre>
</div>
<p><strong>协变返回的使用替换了三个反模式：</strong></p>
<p>直接字段访问。为了规避API限制，一些实现把子类直接暴露为字段：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="52547" class="copybut" id="copybut52547" onclick="doCopy('code52547')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code52547">ZooImpl._animal</div><br />
另一种形式是，在知道实现的实际上是特定的子类的情况下，在调用程序中执行向下转换：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="34793" class="copybut" id="copybut34793" onclick="doCopy('code34793')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code34793">((AnimalImpl)ZooImpl.getAnimal()).implMethod();</div></p>
<p>我看到的最后一种形式是一个具体的方法，该方法用来避免由一个完全不同的签名所引发的问题：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="61496" class="copybut" id="copybut61496" onclick="doCopy('code61496')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code61496">ZooImpl._getAnimal();</div></p>
<p>这三种模式都有它们的问题和局限性。要么是不够整洁，要么就是暴露了不必要的实现细节。</p>
<p><strong>协变 </strong></p>
<p>协变返回模式就比较整洁、安全并且易于维护，它也不需要类型强制转换或特定的方法或字段：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public AnimalImpl getAnimal(){ 
return new AnimalImpl(); 
}

</pre>
</div>
<p>使用结果： <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="81386" class="copybut" id="copybut81386" onclick="doCopy('code81386')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code81386">ZooImpl.getAnimal().implMethod();</div></p>
<p><strong>使用泛型 </strong></p>
<p>我们将从两个角度来了解泛型：使用泛型和构造泛型。我们不讨论List、Set和Map的显而易见的用法。知道泛型集合是强大的并且应该经常使用就足够了。</p>
<p>我们将讨论泛型方法的使用以及编译器推断类型的方法。通常这些都不会出问题，但是当出问题时，错误信息会非常令人费解，所以需要了解如何修复这些问题。</p>
<p><strong>泛型方法</strong></p>
<p>除了泛型类型，Java 5还引入了泛型方法。在这个来自java.util.Collections的例子中，构造了一个单元素列表。新的List的元素类型是根据传入方法的对象的类型来推断的： <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="48274" class="copybut" id="copybut48274" onclick="doCopy('code48274')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code48274">static &lt;T&gt; List&lt;T&gt; Collections.singletonList(T o)</div></p>
<p><strong>示例用法：</strong></p>
<div class="phpstudycode">
<pre class="brush:java;">
public List&lt;Integer&gt; getListOfOne() {
return Collections.singletonList(1);
}

</pre>
</div>
<p>在示例用法中，我们传入了一个int。所以方法的返回类型就是List&lt;Integer&gt;。编译器把T推断为Integer。这和泛型类型是不同的，因为您通常不需要显式地指定类型参数。</p>
<p>这也显示了自动装箱和泛型的相互作用。类型参数必须是引用类型：这就是为什么我们得到的是List&lt;Integer&gt;而不是List&lt;int&gt;。</p>
<p><strong>不带参数的泛型方法 </strong></p>
<p>emptyList()方法与泛型一起引入，作为java.util.Collections中EMPTY_LIST字段的类型安全置换： <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="47611" class="copybut" id="copybut47611" onclick="doCopy('code47611')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code47611">static &lt;T&gt; List&lt;T&gt; Collections.emptyList()</div></p>
<p>示例用法：<br />
</p>
<div class="phpstudycode">
<pre class="brush:java;">
public List&lt;Integer&gt; getNoIntegers() {
return Collections.emptyList();
}
</pre>
</div>
<p>与先前的例子不同，这个方法没有参数，那么编译器如何推断T的类型呢？基本上，它将尝试使用一次参数。如果没有起作用，它再次尝试使用返回或赋值类型。在本例中，返回的是List&lt;Integer&gt;，所以T被推断为Integer。</p>
<p>如果在返回语句或赋值语句之外的位置调用泛型方法会怎么样呢？那么编译器将无法执行类型推断的第二次传送。在下面这个例子中，emptyList()是从条件运算符内部调用的：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public List&lt;Integer&gt; getNoIntegers() {
return x &#63; Collections.emptyList() : null;
}

</pre>
</div>
<p>因为编译器看不到返回上下文，也不能推断T，所以它放弃并采用Object。您将看到一个错误消息，比如：“无法将List&lt;Object&gt;转换为List&lt;Integer&gt;。” <br />
为了修复这个错误，应显式地向方法调用传递类型参数。这样，编译器就不会试图推断类型参数，就可以获得正确的结果： <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="23044" class="copybut" id="copybut23044" onclick="doCopy('code23044')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code23044">return x &#63; Collections.&lt;Integer&gt;emptyList() : null;</div><br />
这种情况经常发生的另一个地方是在方法调用中。如果一个方法带一个List&lt;String&gt;参数，并且需要为那个参数调用这个传递的emptyList()，那么也需要使用这个语法。</p>
<p><strong>集合之外 </strong></p>
<p>这里有三个泛型类型的例子，它们不是集合，而是以一种新颖的方式使用泛型。这三个例子都来自标准的Java库：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="96745" class="copybut" id="copybut96745" onclick="doCopy('code96745')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code96745">Class&lt;T&gt;</div><br />
Class在类的类型上被参数化了。这就使无需类型强制转换而构造一个newInstance成为可能。 <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="49083" class="copybut" id="copybut49083" onclick="doCopy('code49083')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49083">Comparable&lt;T&gt;</div><br />
Comparable被实际的比较类型参数化。这就在compareTo()调用时提供了更强的类型化。例如，String实现Comparable&lt;String&gt;。对除String之外的任何东西调用compareTo()，都会在编译时失败。 <br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="92068" class="copybut" id="copybut92068" onclick="doCopy('code92068')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code92068">Enum&lt;E extends Enum&lt;E&gt;&gt;</div></p>
<p>Enum被枚举类型参数化。一个名为Color的枚举类型将扩展Enum&lt;Color&gt;。getDeclaringClass()方法返回枚举类型的类对象，在这个例子中就是一个Color对象。它与getClass()不同，后者可能返回一个无名类。</p>
<p><strong>通配符 </strong></p>
<p>泛型最复杂的部分是对通配符的理解。我们将讨论三种类型的通配符以及它们的用途。</p>
<p>首先让我们了解一下数组是如何工作的。可以从一个Integer[]为一个Number[]赋值。如果尝试把一个Float写到Number[]中，那么可以编译，但在运行时会失败，出现一个ArrayStoreException：</p>
<div class="phpstudycode">
<pre class="brush:java;">
Integer[] ia = new Integer[5];
Number[] na = ia;
na[0] = 0.5; // compiles, but fails at runtime

</pre>
</div>
<p>如果试图把该例直接转换成泛型，那么会在编译时失败，因为赋值是不被允许的：</p>
<div class="phpstudycode">
<pre class="brush:java;">
List&lt;Integer&gt; iList = new ArrayList&lt;Integer&gt;();
List&lt;Number&gt; nList = iList; // not allowed
nList.add(0.5);

</pre>
</div>
<p>如果使用泛型，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException。</p>
<p><strong>上限通配符 </strong></p>
<p>我们想要的是一个确切元素类型未知的列表，这一点与数组是不同的。 <br />
List&lt;Number&gt;是一个列表，其元素类型是具体类型Number。 <br />
List&lt;&#63; extends Number&gt;是一个确切元素类型未知的列表。它是Number或其子类型。</p>
<p><strong>上限 </strong></p>
<p>如果我们更新初始的例子，并赋值给List&lt;&#63; extends Number&gt;，那么现在赋值就会成功了：</p>
<div class="phpstudycode">
<pre class="brush:java;">
List&lt;Integer&gt; iList = new ArrayList&lt;Integer&gt;();
List&lt;&#63; extends Number&gt; nList = iList;
Number n = nList.get(0);
nList.add(0.5); // Not allowed

</pre>
</div>
<p>我们可以从列表中得到Number，因为无论列表的确切元素类型是什么（Float、Integer或Number），我们都可以把它赋值给Number。</p>
<p>我们仍然不能把浮点类型插入列表中。这会在编译时失败，因为我们不能证明这是安全的。如果我们想要向列表中添加浮点类型，它将破坏iList的初始类型安全——它只存储Integer。</p>
<p>通配符给了我们比数组更多的表达能力。</p>
<p><strong>为什么使用通配符 </strong></p>
<p>在下面这个例子中，通配符用于向API的用户隐藏类型信息。在内部，Set被存储为CustomerImpl。而API的用户只知道他们正在获取一个Set，从中可以读取Customer。</p>
<p>此处通配符是必需的，因为无法从Set&lt;CustomerImpl&gt;向Set&lt;Customer&gt;赋值：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public class CustomerFactory {
private Set&lt;CustomerImpl&gt; _customers;
public Set&lt;&#63; extends Customer&gt; getCustomers() {
return _customers;
}
}

</pre>
</div>
<p><strong>通配符和协变返回</strong></p>
<p>通配符的另一种常见用法是和协变返回一起使用。与赋值相同的规则可以应用到协变返回上。如果希望在重写的方法中返回一个更具体的泛型类型，声明的方法必须使用通配符：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public interface NumberGenerator {
public List&lt;&#63; extends Number&gt; generate();
}
public class FibonacciGenerator extends NumberGenerator {
public List&lt;Integer&gt; generate() {
...
}
}

</pre>
</div>
<p>如果要使用数组，接口可以返回Number[]，而实现可以返回Integer[]。</p>
<p><strong>下限 </strong></p>
<p>我们所谈的主要是关于上限通配符的。还有一个下限通配符。List&lt;&#63; super Number&gt;是一个确切“元素类型”未知的列表，但是可能是Mnumber，或者Number的超类型。所以它可能是一个List&lt;Number&gt;或一个List&lt;Object&gt;。</p>
<p>下限通配符远没有上限通配符那样常见，但是当需要它们的时候，它们就是必需的。</p>
<p><strong>下限与上限 </strong></p>
<div class="phpstudycode">
<pre class="brush:java;">
List&lt;&#63; extends Number&gt; readList = new ArrayList&lt;Integer&gt;();
Number n = readList.get(0);
List&lt;&#63; super Number&gt; writeList = new ArrayList&lt;Object&gt;();
writeList.add(new Integer(5));

</pre>
</div>
<p>第一个是可以从中读数的列表。</p>
<p>第二个是可以向其写数的列表。</p>
<p><strong>无界通配符 </strong></p>
<p>最后，List&lt;&#63;&gt;列表的内容可以是任何类型，而且它与List&lt;&#63; extends Object&gt;几乎相同。可以随时读取Object，但是不能向列表中写入内容。</p>
<p><strong>公共API中的通配符 </strong></p>
<p>总之，正如前面所说，通配符在向调用程序隐藏实现细节方面是非常重要的，但即使下限通配符看起来是提供只读访问，由于remove(int position)之类的非泛型方法，它们也并非如此。如果您想要一个真正不变的集合，可以使用java.util.Collection上的方法，比如unmodifiableList()。</p>
<p>编写API的时候要记得通配符。通常，在传递泛型类型时，应该尝试使用通配符。它使更多的调用程序可以访问API。</p>
<p>通过接收List&lt;&#63; extends Number&gt;而不是List&lt;Number&gt;，下面的方法可以由许多不同类型的列表调用：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="16230" class="copybut" id="copybut16230" onclick="doCopy('code16230')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16230">void removeNegatives(List&lt;&#63; extends Number&gt; list);</div><br />
<strong>构造泛型类型 </strong></p>
<p>现在我们将讨论构造自己的泛型类型。我们将展示一些例子，其中通过使用泛型可以提高类型安全性，我们还将讨论一些实现泛型类型时的常见问题。</p>
<p><strong>集合风格(Collection-like)的函数</strong></p>
<p>第一个泛型类的例子是一个集合风格的例子。Pair有两个类型参数，而且字段是类型的实例：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public final class Pair&lt;A,B&gt; {
public final A first;
public final B second;
public Pair(A first, B second) {
this.first = first;
this.second = second;
}
}

</pre>
</div>
<p>这使从方法返回两个项而无需为每个两种类型的组合编写专用的类成为可能。另一种方法是返回Object[]，而这样是类型不安全或者不整洁的。</p>
<p>在下面的用法中，我们从方法返回一个File和一个Boolean。方法的客户端可以直接使用字段而无需类型强制转换：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public Pair&lt;File,Boolean&gt; getFileAndWriteStatus(String path){
// create file and status
return new Pair&lt;File,Boolean&gt;(file, status);
}
Pair&lt;File,Boolean&gt; result = getFileAndWriteStatus("...");
File f = result.first;
boolean writeable = result.second;

</pre>
</div>
<p><strong>集合之外 </strong></p>
<p>在下面这个例子中，泛型被用于附加的编译时安全性。通过把DBFactory类参数化为所创建的Peer类型，您实际上是在强制Factory子类返回一个Peer的特定子类型：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public abstract class DBFactory&lt;T extends DBPeer&gt; {
protected abstract T createEmptyPeer();
public List&lt;T&gt; get(String constraint) {
List&lt;T&gt; peers = new ArrayList&lt;T&gt;();
// database magic
return peers;
}
}

</pre>
</div>
<p>通过实现DBFactory&lt;Customer&gt;，CustomerFactory必须从createEmptyPeer()返回一个Customer：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public class CustomerFactory extends DBFactory&lt;Customer&gt;{
public Customer createEmptyPeer() {
return new Customer();
}
}

</pre>
</div>
<p><strong>泛型方法 </strong></p>
<p>不管想要对参数之间还是参数与返回类型之间的泛型类型施加约束，都可以使用泛型方法：</p>
<p>例如，如果编写的反转函数是在位置上反转，那么可能不需要泛型方法。然而，如果希望反转返回一个新的List，那么可能会希望新List的元素类型与传入的List的类型相同。在这种情况下，就需要一个泛型方法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="43743" class="copybut" id="copybut43743" onclick="doCopy('code43743')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code43743">&lt;T&gt; List&lt;T&gt; reverse(List&lt;T&gt; list)</div></p>
<p><strong>具体化 </strong></p>
<p>当实现一个泛型类时，您可能想要构造一个数组T[]。因为泛型是通过擦除(erasure)实现的，所以这是不允许的。</p>
<p>您可以尝试把Object[]强制转换为T[]。但这是不安全的。</p>
<p><strong>具体化解决方案 </strong></p>
<p>按照泛型教程的惯例，解决方案使用的是“类型令牌”，通过向构造函数添加一个Class&lt;T&gt;参数，可以强制客户端为类的类型参数提供正确的类对象：</p>
<div class="phpstudycode">
<pre class="brush:java;">
public class ArrayExample&lt;T&gt; {
private Class&lt;T&gt; clazz;
public ArrayExample(Class&lt;T&gt; clazz) {
this.clazz = clazz;
}
public T[] getArray(int size) {
return (T[])Array.newInstance(clazz, size);
}
}

</pre>
</div>
<p>为了构造ArrayExample&lt;String&gt;，客户端必须把String.class传递给构造函数，因为String.class的类型是Class&lt;String&gt;。</p>
<p>拥有类对象使构造一个具有正确元素类型的数组成为可能</p>
<p>希望本文所述对大家Java程序设计有所帮助。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/82993.html'>在WordPress中获取数据库字段内容和添加主题设置菜单</a><a>下一篇</a><a href='/php/biji/82995.html'>win10家庭版和专业版哪个好？win10家庭版和专业版的区别详解</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>