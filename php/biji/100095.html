<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>javascript 函数及作用域总结介绍_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="在js中使用函数注意三点：1、函数被调用时，它是运行在他被声明时的语法环境中的；<br />
2、函数自己无法运行，它总是被对象调用的，函数运行时，函数体内的this指针指向调用该函数的对象，如" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">javascript 函数及作用域总结介绍</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>在js中使用函数注意三点：1、函数被调用时，它是运行在他被声明时的语法环境中的；<br />
2、函数自己无法运行，它总是被对象调用的，函数运行时，函数体内的this指针指向调用该函数的对象，如</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P><STRONG><FONT style="COLOR: #ff0000">在js中使用函数注意三点：<BR></FONT></STRONG><BR>1、函数被调用时，它是运行在他被声明时的语法环境中的；</P>
<P>2、函数自己无法运行，它总是被对象调用的，函数运行时，函数体内的this指针指向调用该函数的对象，如果调用函数时没有明确指定该对象， this 默认指向 window ( strict 模式除外，本文不涉及 strict 模式)；</P>
<P>3、函数是一种带有可执行代码的对象类型数据。</P>
<P><STRONG><FONT style="COLOR: #0000ff">一、声明函数</FONT></STRONG></P>
<P><STRONG>1、使用 function 关键字<BR></STRONG><div class="codetitle"><span><a style="CURSOR: pointer" data="90458" class="copybut" id="copybut90458" onclick="doCopy('code90458')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code90458"><BR>function myfun(a,b){ //声明名为myfun的函数</P>
<P>return a+b;</P>
<P>} <BR></div><BR><STRONG>2、 声明匿名函数</STRONG></P>
<P>function(a,b){ return a+b;}匿名函数自身是无法保存的，由于在js中函数是一种对象型数据，因此可以把匿名函数赋给变量来保存。</P>
<P>var myfun = function(a,b){ return a+b;}<br><br><STRONG>3、使用函数构造器Function //注意首字母大写</STRONG></P>
<P>Function 是js内置的一个函数，他是所有函数对象的构造器。（其他数据对象也有自己的内置构造函数，比如Number，Object等，这些构造函数自己的构造器就是Function，因为他们都是函数）。</P>
<P>var myfun = new Function('a,b','return a+b;'); 其中最后一个参数是函数体，前面的参数都是函数的形式参数名，个数不定，因为需要用字符串传参来构造，函数较长时这种写法很不方便，一般很少用，也许你会用它来构造特定的返回值从而取代 eval函数。</P>
<P>需要注意的是，全局变量和全局函数都可以看作window对象的属性，如果存在同名的函数和变量，只能有一个生效(实际上只有一个属性)，试试下面的代码。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="82172" class="copybut" id="copybut82172" onclick="doCopy('code82172')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code82172"><BR>function a(){ alert('a');}</P>
<P>alert(window.a);&nbsp; //访问window对象的属性也可以省去window不写</P>
<P>var a=1;</P>
<P>alert(window.a); <BR></div><BR>函 数和变量的声明都发生在代码解析期，不同的是，变量在解析期只声明不赋值，因此，同一个作用域内存在同名的函数和变量时，在代码运行期执行到变量赋值之 前，同名函数生效，同名变量赋值之后(用新的数据覆盖了该window对象属性原有的值)，变量生效(但是要注意，在firefox 下， 在 with 伪闭包内声明的函数，只能在声明之后才能被调用，即，firefox 的 with 内没有对函数预先声明)。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="60146" class="copybut" id="copybut60146" onclick="doCopy('code60146')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60146"><BR>with({}){ <BR>&nbsp;a();&nbsp; //在 firefox 下 a 是未声明<BR>&nbsp;function a(){ console.log("function a is called");} <BR>} <BR></div><BR>如果同名称的函数被多次声明，后面声明的将覆盖前面声明的，如：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="99667" class="copybut" id="copybut99667" onclick="doCopy('code99667')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code99667"><BR>alert(func1);//弹出func1(){alert(2);}</P>
<P>func1(){</P>
<P>alert(1);</P>
<P>}</P>
<P>alert(func1);&nbsp; //弹出func1(){alert(2);}</P>
<P>func1(){&nbsp; //这是最后一次声明的func1，以该函数为准</P>
<P>alert(2);</P>
<P>}</P>
<P>alert(func1);&nbsp; //弹出func1(){alert(2);}</P>
<P>var func1 = function(){&nbsp; //注意 ，这里是变量赋值，不是函数声明</P>
<P>alert(3);</P>
<P>}</P>
<P>alert(func1);&nbsp; //弹出function(){alert(3);} <BR></div><BR>除了 IE8 及IE8以下的浏览器，表达式中的函数声明都会返回匿名函数，不会成功声明具名函数<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="81104" class="copybut" id="copybut81104" onclick="doCopy('code81104')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code81104"><BR>if(function fun(){}){<BR>&nbsp;&nbsp; alert(fun); // error，不会成功声明名称为 fun 的函数，但在IE8 及以下的浏览器中中会成功声明一个函数 fun</P>
<P>}</P>
<P>(function fun(){ });</P>
<P>alert(fun); //error但是即使在 IE8 一下， 表达式中的具名函数也不能覆盖该作用于下同名的变量：</P>
<P>var fun = 1; //该变量不能被函数表达式中的函数名覆盖<BR>var f = function fun(){};<BR>alert(f); //function fun(){};<BR>alert(fun); //1 <BR></div><BR><STRONG>注意区别：</STRONG></P>
<P>if(fun = function (){}){<BR>&nbsp;&nbsp; alert(fun); // ok，这里声明了一个变量，该变量保存了一个匿名函数</P>
<P>} </P>
<P><STRONG>js函数是引用型的对象</STRONG></P>
<P>var a = function(){};<BR>var b=a;<BR>b.x=2;<BR>alert(a.x); //2 </P>
<P><STRONG><FONT style="COLOR: #0000ff">二、函数的参数</FONT></STRONG></P>
<P>js函数不会检查函数调用时传入的参数个数与定义他时的形式参数个数是否一致，一般地，js函数调用时可以接收的参数个数为25个，当然不同的浏览器可能有差异，ECMAScript标准对这一点并没有规范。</P>
<P>如果你不确定函数调用时传入了多少个参数，可以使用函数的arguments对象。</P>
<P>arguments 有点像数组，arguments.length 为传入的参数个数，arguments[0] 是第一个参数，arguments[1]是第二个参数，类推...</P>
<P>函数对象的length属性：这个属性很少用到，甚至很少人知道，函数的length属性就是该函数定义时的形式参数个数。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="63350" class="copybut" id="copybut63350" onclick="doCopy('code63350')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code63350"><BR>function myfun(a,b){ </P>
<P>alert(arguments.length);&nbsp; //弹出调用时实际传入的参数个数</P>
<P>alert(arguments[0]); //对应参数a</P>
<P>return a+b;</P>
<P>}</P>
<P>alert(myfun.length);&nbsp;&nbsp; //形参个数，2 <BR></div><BR>arguments对象还有其他属性，比如常用的arguments.callee ，指向该函数自身。</P>
<P>要注意：如果函数内部声明了与形参同名的子函数（同域内，变量未赋值时同名函数生效），arguments 的相应值也会被修改，但是，在作用域内使用 var 声明了同名的 变量则不会导致 arguments 的参数值被函数替换（但firefox 依然替换）。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="90053" class="copybut" id="copybut90053" onclick="doCopy('code90053')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code90053"><BR>function aa(a , b,c){ //js 群的一道题<BR>&nbsp;&nbsp;&nbsp; function a(){}<br><br>&nbsp;&nbsp;&nbsp; console.log(a); //function a <BR>&nbsp;&nbsp;&nbsp; console.log(aa);<br><br>&nbsp;&nbsp;&nbsp; //如果作用域内没有 var a ,则 arguments[0] 为 function a (friefox(version 17) 则一定是function a)<BR>&nbsp;&nbsp;&nbsp; console.log(arguments[0]); <BR>&nbsp;&nbsp;&nbsp; var a = "ee";&nbsp; //注销此句，考擦 arguments[0] 将变为 a 函数<BR>&nbsp;&nbsp;&nbsp; var aa = "444";<BR>&nbsp;&nbsp;&nbsp; arguments = 6;<BR>&nbsp;&nbsp;&nbsp; console.log(a);<BR>&nbsp;&nbsp;&nbsp; console.log(aa);<BR>&nbsp;&nbsp;&nbsp; console.log(arguments);<BR>}<BR>aa(1,2,3); <BR></div><BR><STRONG><FONT style="COLOR: #0000ff">三、函数的返回值</FONT></STRONG></P>
<P>js函数使用 return 语句返回值。</P>
<P>一切数据类型都可以作为函数的返回值(包括函数)，js函数也可以没有返回值。</P>
<P><STRONG><FONT style="COLOR: #0000ff">四、函数调用</FONT></STRONG></P>
<P>函数自己是不会运行的，当它运行时，总是存在一个调用它的对象。</P>
<P>默认情况下，在任何语法环境中，如果没有显式指定函数的调用对象，就是指通过window对象来调用该函数，此时，函数体内的this指针指向window对象。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="9943" class="copybut" id="copybut9943" onclick="doCopy('code9943')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code9943"><BR>function myfun(a,b){</P>
<P>&nbsp;alert(this);</P>
<P>return a+b;</P>
<P>}</P>
<P>myfun(1,2); // 调用函数并传入2个参数，这2个参数分别对应形式参数a,b调用函数时，如果传入的参数个数超过形式参数，就只有用arguments加下标来接收了。 <BR></div><BR>由于没有显式指定调用函数的对象，alert(this)将弹出 window对象。这种调用方法是最常见的。</P>
<P><STRONG><FONT style="BACKGROUND-COLOR: #ffff99">用于显式指定函数的调用对象方法有三个：</FONT></STRONG></P>
<P>1、如果一个函数被赋为一个对象的属性值，这个函数只能通过该对象来访问（但并非是说该函数只能被该对象调用），通过该对象调用这个函数的方式类似以面向对象编程语言中的方法调用(实际上在js中也习惯使用方法这种称呼)。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="76831" class="copybut" id="copybut76831" onclick="doCopy('code76831')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76831"><BR>var obj={}; //定义一个对象</P>
<P>obj.fun=function(a,b){</P>
<P>alert(this); //弹出this指针</P>
<P>return a+b;</P>
<P>} //对象属性值为函数</P>
<P>alert(obj.fun);// 访问fun函数。 只能通过该对象来访问这个函数</P>
<P>obj.fun(1,2);&nbsp; //通过obj对象来调用fun函数，将弹出obj对象。这种方式也称为调用obj对象的fun方法。 <BR></div><BR>2、 任意指定函数的调用对象：在某个语法环境中，如果可以同时访问到函数fun和对象obj，只要你愿意，可以指定通过obj对象来调用fun函数。指定方法 有2种：call方法和apply方法。(因为window对象是浏览器环境下的顶级对象，在任何语法环境中都能访问到window对象，因此，任何函数 都可以通过window对象来调用)<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="76168" class="copybut" id="copybut76168" onclick="doCopy('code76168')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76168"><BR>function fun(a,b){</P>
<P>alert(this);</P>
<P>return a+b;</P>
<P>}</P>
<P>var obj={};</P>
<P>fun.call(obj,1,2);&nbsp;&nbsp; //通过obj对象来调用fun函数，并传入2个参数，弹出的指针为obj对象。</P>
<P>&nbsp;</P>
<P>var obj2={};</P>
<P>obj2.fun2 = function(a,b){ //obj2对象的属性fun2是一个函数</P>
<P>alert(this);</P>
<P>return a+b;</P>
<P>};</P>
<P>obj2.fun2.call(obj,1,2);&nbsp;&nbsp; //通过obj对象来调用obj2对象的fun2属性值所保存的函数，弹出的this指针是obj对象</P>
<P>//比较隐蔽的方法调用：数组调用一个函数[9,function(){ alert(this[0]); }][1]();</P>
<P>//使用window对象调用函数下面几种方法是等价的<BR>fun(1,2);<BR>window.fun(1,2);&nbsp; //如果fun函数是全局函数<BR>fun.call(window,1,2);<BR>fun.call(this,1,2);&nbsp; //如果该句代码在全局环境下（或者被window对象调用的函数体内），因为该语法环境下的this就是指向window对象。<BR>func.call(); //如果函数不需要传参<BR>func.call(null,1,2);<BR>func.call(undefined,1,2);var name = "window";<BR>function kkk(){<BR>console.log(this.name); // not ie<BR>}<BR>kkk(); //window<BR>kkk.call(kkk); //kkk 函数被自己调用了 <BR></div><BR>另一种比较容易疏忽的错误是，在A 对象的方法中，执行了使用了 B 对象的方法调用，试图在 B 对象的方法里使用 this 来访问 A 对象，这在各种回调函数中比较常见，最常见的情形就是 ajax 回调函数中使用 this 。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="51601" class="copybut" id="copybut51601" onclick="doCopy('code51601')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51601"><BR>var obj = {<BR>&nbsp;&nbsp; data:null,<BR>&nbsp;&nbsp; getData:function(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $.post(url,{param:token},function(dataBack){ //jQuery ajax post method<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.data = dataBack; //试图将服务器返回的数据赋给 obj.data ,但这里的 this 已经指向 jQuery 的 ajax 对象了<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },'json');&nbsp;&nbsp; <BR>&nbsp;&nbsp; }<BR>}</P>
<P>//正确做法<BR>var obj = {<BR>&nbsp;&nbsp; data:null,<BR>&nbsp;&nbsp; getData:function(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var host = this; //保存 obj 对象的引用<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $.post(url,{param:"token"},function(dataBack){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host.data = dataBack;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },'json');&nbsp;&nbsp; <BR>&nbsp;&nbsp; }<BR>} <BR></div><BR>3、apply方法调用：</P>
<P>apply方法与call方法唯一不同的地方是函数传参方式不同。</P>
<P>obj2.fun2.call(obj,1,2);&nbsp;&nbsp; 改为 apply方式就是obj2.fun2.apply(obj,[1,2]);</P>
<P>apply使用类数组方式传参，除数组外，还可以使用arguments、HTMLCollection来传参，但arguments并非数组，如：</P>
<P>var obj={};</P>
<P>function fun_1(x,y){</P>
<P>&nbsp;&nbsp; function fun_2(a,b){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; return a+b;</P>
<P>&nbsp; }</P>
<P>fun_2.apply(obj,arguments);&nbsp; //用fun_1的arguments对象来传参，实际上是接收了x,y</P>
<P>}apply 传参在IE8 及IE8一下的浏览器中哟2个问题</P>
<P>在 call 和 apply 调用中，如果传入标量数据(true/false ，string，number)，函数运行时将把他们传入的基本数据包装成对象，然后把this指向包装后的对象,试试下面的代码。 <BR>function a(){</P>
<P>alert(typeof this);</P>
<P>&nbsp;alert(this.constructor);</P>
<P>&nbsp;alert(this);</P>
<P>}</P>
<P>a.call(false);</P>
<P>a.call(100);</P>
<P>a.call('hello');</P>
<P>甚至可以用这个特点来传参数，但是不建议这种用法：</P>
<P>function a(){&nbsp; alert(1+this); } //对象在运算中自动进行类型转换</P>
<P>a.call(100); //101 </P>
<P>4、函数作为对象构造器</P>
<P>当函数使用 new 运算作为对象构造器运行时，this 指向新构造出对象，如果该构造函数的返回值不是 null 以外的对象，构造函数运行完毕将返回 this 指向的对象,否则返回原定义的对象。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="25302" class="copybut" id="copybut25302" onclick="doCopy('code25302')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code25302"><BR>function Fun(){ </P>
<P>this.a = 1; </P>
<P>this.b = 3;</P>
<P>console.log(this); //{a:1,b:2}</P>
<P>// return {a:999};&nbsp; //加上此举 ,将返回 {a:999}</P>
<P>&nbsp;}</P>
<P>var obj = new Fun();&nbsp; //obj = {a:1,b:2} ，如果没有参数，也可以写成 var obj = new Fun; <BR></div><BR><STRONG><FONT style="COLOR: #0000ff">五、函数作用域</FONT></STRONG></P>
<P>js的变量作用域是函数级的，在js里没有类似c语言的块级作用域。</P>
<P>js编程环境的顶级作用域是window对象下的范围，称为全局作用域，全局作用域中的变量称为全局变量。</P>
<P>js函数内的变量无法在函数外面访问，在函数内却可以访问函数外的变量，函数内的变量称为局部变量。</P>
<P>js函数可以嵌套，多个函数的层层嵌套构成了多个作用域的层层嵌套，这称为js的作用域链。</P>
<P>js作用域链的变量访问规则是：如果当前作用域内存在要访问的变量，则使用当前作用域的变量，否则到上一层作用域内寻找，直到全局作用域，如果找不到，则该变量为未声明。</P>
<P>注意，变量的声明在代码解析期完成，如果当前作用域的变量的声明和赋值语句写在变量访问语句后面，js函数会认为当前作用域已经存在要访问的变量不再向上级作用域查找，但是，由于变量的赋值发生的代码运行期，访问的到变量将是undefined.</P>
<P>如：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="77640" class="copybut" id="copybut77640" onclick="doCopy('code77640')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code77640"><BR>var c=1000;</P>
<P>function out(){</P>
<P>var a=1;</P>
<P>var b=2;</P>
<P>function fun(){</P>
<P>&nbsp;alert(a); //undefined</P>
<P>var a=10;</P>
<P>&nbsp;alert(a); //10</P>
<P>alert(b); //2</P>
<P>alert(c); //1000</P>
<P>}</P>
<P>fun();</P>
<P>}</P>
<P>out(); <BR></div><BR><STRONG><FONT style="COLOR: #0000ff">六、匿名函数的调用</FONT></STRONG></P>
<P>匿名函数的使用在js很重要，由于js中一切数据都是对象，包括函数，因此经常使用函数作为另一个函数的参数或返回值。</P>
<P>如果匿名函数没有被保存，则运行后即被从内存中释放。</P>
<P>匿名函数的调用方式一般是直接把匿名函数放在括号内替代函数名。如：</P>
<P>(function(a,b){ return a+b;})(1,2); //声明并执行匿名函数，运行时传入两个参数：1和2</P>
<P>//或者</P>
<P>(function(a,b){ return a+b;}(1,2));</P>
<P>//下面这种写法是错误的：</P>
<P>function(a,b){ return a+b;}(1,2);&nbsp; </P>
<P>由于js中语句结束的分号可以省略，js引擎会认为function(a,b){ return a+b;}是一句语句结束，因此匿名函数只声明了没有被调用，如果语句没有传参(1,2)写成()，还会导致错误，js中空括号是语法错误。</P>
<P>下面这种写法是正确的。</P>
<P>var&nbsp; ab = function(a,b){ return a+b;}(1,2);&nbsp; // ab=3 </P>
<P>js 解析语法时，如果表达式出现在赋值运算或操作符运算中，是"贪婪匹配"的(尽量求值)</P>
<P>function(t){ return 1+t;}(); //error<BR>var f = function(t){ return t+1;}(); // ok</P>
<P>~ function(t){return t+1;}();&nbsp; //ok<BR>+ function(t){return t+1;}(); //ok </P>
<P>如果你只是想把一个匿名函数赋给一个变量，记得在赋值语句后面加上分号，否则，如果后面跟了小括号就变成了函数调用了，尤其是小括号与函数结尾之间分隔了多行时，这种错误往往很难发现。</P>
<P>实际开发中，匿名函数可能以运算值的方式返回，这种情况可能不容易看出，比如</P>
<P>var a =1;<BR>var obj = {a:2,f:function(){ return this.a;}};</P>
<P>(1,obj.f)(); //1 逗号表达式反悔了一个匿名函数，当这个匿名函数被调用时,函数体内的 thsi 指向 window </P>
<P>声 明并立即运行匿名函数被称为”自执行函数“，自执行函数经常用于封装一段js代码。由于函数作用域的特点，自执行函数内的变量无法被外部访问，放在函数内 的代码不会对外面的代码产生影响，可以避免造成变量污染。js开发很容易造成变量污染，在开发中经常引入其他编码人员开发的代码，如果不同的编码人员定义 了同名称不同含义的全局变量或函数，便造成了变量污染，同一作用域内出现同名的变量或函数，后来的将覆盖前面的。</P>
<P>(function(){</P>
<P>&nbsp;&nbsp; //自己的代码.....</P>
<P>})();匿名函数还可以使内存及时释放：因为变量被声明在匿名函数内，如果这些变量没有在匿名函数之外被引用，那么这个函数运行完毕，里面的变量所占据的内存就会立即释放。</P>
<P>函数的name：在firefox等浏览器，函数有一个name属性，就是该函数的函数名，但是这个属性在IE中不存在，另外，匿名函数的name为空值。</P>
<P>var a=function(){}<BR>alert(a.name); //undefined，a是一个存储了一个匿名函数的变量<BR>function b(){}<BR>alert(b.name); //b ,but undefined for IE </P>
<P><STRONG><FONT style="COLOR: #0000ff">七、函数被调用时，运行在他被定义时的环境中</FONT></STRONG></P>
<P>无论函数在哪里被调用，被谁调用，都无法改变其被声明时的语法环境，这决定了函数的运行环境<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="20625" class="copybut" id="copybut20625" onclick="doCopy('code20625')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code20625"><BR>var x=99;</P>
<P>var inerFun=null;</P>
<P>function fun1(){</P>
<P>&nbsp;&nbsp;&nbsp; alert(x);</P>
<P>}</P>
<P>function holder(){</P>
<P>&nbsp; var x = 100;</P>
<P>&nbsp; var fun2 = fun1;</P>
<P>&nbsp;inerFun = function(){ alert(x);}</P>
<P>&nbsp; fun1(); //99</P>
<P>&nbsp;fun2();//99</P>
<P>&nbsp; inerFun(); //100</P>
<P>}</P>
<P>holder();</P>
<P>fun1(); //99</P>
<P>inerFun(); //100</P>
<P>&nbsp;</P>
<P>&nbsp;//另一个例子：</P>
<P>var x = 100;<BR>var y=77;<BR>var a1={<BR>x:99,<BR>xx:function(){<BR>&nbsp; //var y=88;&nbsp; //如果注释这个变量，y将是全局变量的77<BR>&nbsp; alert(y); //没有使用this指针，调用函数的对象无法影响y的值，函数运行时将从这里按作用域链逐级搜索取值<BR>&nbsp; alert(this.x);&nbsp; //使用了 this 指针，调用函数的<BR>}<BR>}</P>
<P>a1.xx();<BR>a1.xx.call(window);</P>
<P>var jj = a1.xx;</P>
<P>jj(); //效果跟a1.xx.call(window); 一样//试试下面代码</P>
<P>var x=99;<BR>function xb(){<BR>this.x=100;<BR>this.a = (function(){return this.x}).call(this); //new 的时候执行了,匿名函数被 实例化的对象 调用<BR>this.b = (function(){return this.x})(); //new 的时候执行了,匿名函数被window调用<BR>this.method = function(){return this.x;}<BR>}</P>
<P><BR>var xbObj = new xb();<BR>console.log(xbObj.x);<BR>console.log(xbObj.a);<BR>console.log(xbObj.b);<BR>console.log(xbObj.method()); <BR></div><BR>注意区分调用函数的对象、函数声明时的语法环境、函数调用语句的语法环境这几个概念</P>
<P>1、调用函数的对象(或者说函数的调用方式)决定了函数运行时函数体内的this指针指向谁</P>
<P>2、函数声明时的语法环境决定了函数运行时的访问权限</P>
<P>3、函数调用语句的语法环境决定了函数是否真的能够被调用及何时被调用(只有函数在某个语法环境是可见的，这个函数才能被调用)</P>
<P>函数在运行时，产生一个 arguments 对象可以访问传入函数内的参数,arguments 有一个属性可以指向函数自身：arguments.callee.</P>
<P>函数运行时，函数的 caller 属性可以指向本函数调用语句所在函数，比如，a函数在b函数体内被调用，则当a函数运行时，a.caller就指向了b函数，如果a 函数在全局环境中被调用则 a.caller=null</P>
<P>arguments 和a.caller 的值与函数的每一次调用直接关联，他们都是在函数运行时产生的，只能在函数体内访问。</P>
<P>IE8及IE8以下浏览器中，a 函数的内的 arguments.caller( IE9之后这个属性被移除) 指向 a.caller 执行时的 arguments （arguments.caller.callee === a.caller），</P>
<P><STRONG><FONT style="COLOR: #0000ff">七、字符串实时解析中的函数调用：eval()、new Function()、setTimeout()、setInterval()</FONT></STRONG></P>
<P>eval() 与 window.eval()<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="44787" class="copybut" id="copybut44787" onclick="doCopy('code44787')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code44787"><BR>function a(){<BR>&nbsp;&nbsp;&nbsp; console.log('out of b');<BR>}<BR>function b(){<BR>&nbsp;&nbsp;&nbsp; function a(){ console.log("in b"); }<BR>&nbsp;&nbsp;&nbsp; var f = function(){ a(); };<BR>&nbsp;&nbsp;&nbsp; eval('a()'); // in b<BR>&nbsp;&nbsp;&nbsp; window.eval('a()'); //out of b ,ie 6\7\8 in b, ie 9 out of b<BR>&nbsp;&nbsp;&nbsp; (new Function('a();'))(); //out of b<BR>&nbsp;&nbsp;&nbsp; setTimeout('a()',1000);&nbsp;&nbsp; // out of b <BR>&nbsp;&nbsp;&nbsp; setTimeout(f,2000);// in b<BR>}<BR>b(); <BR></div><BR>eval() 中的代码执行于eval() 语句所处的作用域内：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="72300" class="copybut" id="copybut72300" onclick="doCopy('code72300')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code72300"><BR>var Objinit = function(){<BR>&nbsp; var param = 123;<BR>&nbsp; return {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execute:function(codes){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eval(codes);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setCallback:function(f){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.callback = f;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fireCallback:function(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.callback && this.callback.call(this);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getParam:function(){<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return param;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp; }<BR>};</P>
<P>var obj = Objinit ();<BR>var param = 'outerParam';<BR>console.log(param,obj.getParam()); //outerParam 123<BR>obj.execute('param = 456');<BR>console.log(param,obj.getParam()); //outerParam 456<BR>obj.setCallback(function(){ eval("param = 8888")});<BR>obj.fireCallback();<BR>console.log(param,obj.getParam()); //8888 456<BR>obj.setCallback(function(){ eval("eval(param = 9999)")});<BR>obj.fireCallback();<BR>console.log(param,obj.getParam()); //9999 456eval() <BR></div><BR>字符串中解析出的代码运在 eval 所在的作用域，window.eval() 则是运行在顶级作用域（低版本 chrome 和 低于IE9 则同 eval()）.</P>
<P>IE 中 ，window.execScript();&nbsp; 相当于 window.eval()</P>
<P>new Function()、setTimeout()、setInterval()&nbsp; 的第一个字符串参数所解析得到的代码，都是在顶级作用域执行。</P>
<P><STRONG><FONT style="COLOR: #0000ff">八、函数闭包</FONT></STRONG></P>
<P>要理解函数闭包，先了解 js 的垃圾自动回收机制。</P>
<P>number、string、boolean、undefined、null 在运算和赋值操作中是复制传值，而对象类型的数据按引用传值，</P>
<P>js 的同一个对象型数据可能被多次引用，如果某个对象不再被引用，或者两个对象之间互相引用之外不在被第三方所引用，浏览器会自动释放其占用的内存空间。</P>
<P>函数被引用：函数被赋为其他对象的属性值，或者函数内部定义的数据在该函数外被使用，闭包的形成基于后一种情形。<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="36647" class="copybut" id="copybut36647" onclick="doCopy('code36647')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code36647"><BR>var f;</P>
<P>function fun(){</P>
<P>var a =1;</P>
<P>f = function(){ return ++a;};</P>
<P>}</P>
<P>fun(); //产生一个闭包</P>
<P>f(); //&nbsp; 闭包中 a=2</P>
<P>f(); // 闭包中 a =3&nbsp; ，模拟静态变量 <BR></div><BR>在 fun 内 声明的匿名函数赋给 fun 外的变量 f，该匿名函数内使用了在 fun 内声明的变量 a，于是 f可以访问 变量 a，为了维持这种访问权限(f执 行时需要访问a，但何时执行未定)， fun() 执行完毕产生的变量 a 不能被释放（除非f 中的函数被释放），于是产生了一个闭包（变量 a 被封 闭了，供 f 使用）。</P>
<P>产生闭包的关键是，一个在函数 A内的声明的函数 B被传出 A 之外，并且 B 函数内使用了在 函数A 内生成的数据（声明或按值传参）,</P>
<P>函数B传出函数A之外的方式有多种，如：<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="70163" class="copybut" id="copybut70163" onclick="doCopy('code70163')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code70163"><BR>function fun(){&nbsp;&nbsp;&nbsp; <BR>var a =1;</P>
<P>return {a:123,b:456, c: function(){ return ++a;} };</P>
<P>}</P>
<P>var f = fun();</P>
<P>f.c(); //a=2 <BR></div></P>
<P>广义上来说，函数运行时都会形成闭包，没有数据在函数外被引用时，闭包的生命周期很短：函数执行完毕即释放。</P>
<P>闭包的独立性：即使由同一个函数产生的多个闭包也是相互独立的<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="43055" class="copybut" id="copybut43055" onclick="doCopy('code43055')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code43055"><BR>function fun(){</P>
<P>var a =1;</P>
<P>return function(){ return ++a;};</P>
<P>}</P>
<P>var f1 =&nbsp; fun(); //一份闭包</P>
<P>var f2 = fun(); //另一份闭包</P>
<P>alert(f1()); //2</P>
<P>&nbsp;alert(f1()); //3</P>
<P>&nbsp;alert(f2()); //2</P>
<P>&nbsp;alert(f2()); //3 <BR></div><BR>这两份闭包中的变量 a 是不同的数据，每产生一份闭包， fun() 执行了一次，&nbsp; 变量声明语句也执行了一次。</P>
<P>js oop 编程中闭包可以用于模拟私有成员、构造单体类<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="50937" class="copybut" id="copybut50937" onclick="doCopy('code50937')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code50937"><BR>function MakeItem(name,val){<BR>&nbsp;var myName,myVal; //私有属性</P>
<P>//私有方法<BR>&nbsp;function setName(name){<BR>&nbsp;&nbsp;&nbsp;&nbsp; myname=name; <BR>}</P>
<P>&nbsp;//私有 方法<BR>function setVal(val){<BR>&nbsp;&nbsp;&nbsp; myVal=val;<BR>&nbsp;}</P>
<P>&nbsp;//执行new构造对象时调用内部私有方法 <BR>setName(name);<BR>setVal(val);</P>
<P>//公共方法<BR>this.getName=function(){ <BR>&nbsp;&nbsp;&nbsp; return myName; <BR>} </P>
<P>&nbsp;this.getVal=function(){ <BR>&nbsp;&nbsp;&nbsp; return myVal;<BR>&nbsp;}<BR>}</P>
<P>var obj = new MakeItem("name",100);<BR>obj.myname; //undefined 无法在外面访问私有属性<BR>obj.getName(); //ok <BR></div><BR>下面是一种单体类构建方法<BR><div class="codetitle"><span><a style="CURSOR: pointer" data="735" class="copybut" id="copybut735" onclick="doCopy('code735')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code735"><BR>var Singleton = (function(){</P>
<P>&nbsp;&nbsp;&nbsp; var instance = null; //在闭包中保存单体类的实例</P>
<P>&nbsp;&nbsp;&nbsp; var args = null;</P>
<P>&nbsp;&nbsp;&nbsp; var f = function(){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!instance){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(this===window){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args = Array.prototype.slice.call(arguments,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance = new arguments.callee();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.init.apply(this,args||arguments);</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance = this;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance;</P>
<P>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; f.prototype = {</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init:function(a,b,c){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.a = a;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.b = b;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.c = c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.method1 = function(){ console.log("method 1"); };</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.method1 = function(){ console.log("method 1"); };</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console.log("init instance");</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;&nbsp;&nbsp; f.prototype.constructor = f.prototype.init;</P>
<P>&nbsp;&nbsp;&nbsp; return f;</P>
<P>&nbsp;</P>
<P>})();</P>
<P><BR>//单体的使用<BR>var obj1 =&nbsp; Singleton(1,2,3);</P>
<P>var obj2 = new Singleton();</P>
<P>var obj3 = new Singleton();</P>
<P>console.log(obj1===obj2,obj2===obj3); //true</P>
<P>console.log(obj1);</P>
<P>//一个单体类声明函数</P>
<P>var SingletonDefine= function(fun){</P>
<P>&nbsp;&nbsp;&nbsp; return (function(){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var instance = null;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var args = null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var f = function(){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!instance){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(this===window){</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; args = Array.prototype.slice.call(arguments,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance = new arguments.callee();</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fun.apply(this,args||arguments);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instance = this;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</P>
<P>&nbsp;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.prototype = fun.prototype; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.prototype.constructor = fun;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return f;</P>
<P>&nbsp;&nbsp;&nbsp; })();</P>
<P>};</P>
<P>var fun = function(a,b,c){</P>
<P>&nbsp;&nbsp;&nbsp; this.a = a;</P>
<P>&nbsp;&nbsp;&nbsp; this.b = b;</P>
<P>&nbsp;&nbsp;&nbsp; this.c = c;</P>
<P>&nbsp;&nbsp;&nbsp; this.method1 = function(){ console.log("method 1"); };</P>
<P>&nbsp;&nbsp;&nbsp; console.log("init instance");</P>
<P>};</P>
<P>fun.prototype.method2 = function(){ console.log('method 2'); };</P>
<P><BR>//单体类声明函数用法<BR>var Singleton = SingletonDefine(fun);</P>
<P>var obj1 =&nbsp; Singleton(8,9,10);</P>
<P>var obj2 = new Singleton();</P>
<P>var obj3 = new Singleton(3,2,1);</P>
<P>console.log(obj1===obj2,obj2===obj3);</P>
<P>console.log(obj1);</P>
<P>//console.log(obj1.toSource()); //firefox</P>
<P>obj1.method1();</P>
<P>obj1.method2(); <BR></div><BR><STRONG><FONT style="BACKGROUND-COLOR: #ccffcc">IE6 的内存泄露与闭包</FONT></STRONG></P>
<P>在IE 6 中，非原生js对象（DOM 等）的循环引用会导致内存泄露，使用闭包时如果涉及非 js 原生对象引用时要注意。</P>
<P>function fun(){</P>
<P>var node = document.getElementById('a');<BR>node.onclick = function(){ alert(node.value); };</P>
<P>node = null; //打断循环引用防止内存泄露 </P>
<P>node 保存的是 DOM 对象，DOM对象存在于 fun 之外(并且一直存在，即使删除也只是从文档树移出)，fun 执行后产生闭包，也构成DOM对象与回调函数的循环引用（node-function-node），在IE 6 下发生内存泄露。</P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/100094.html'>ThinkPHP公共配置文件与各自项目中配置文件组合的方法</a><a>下一篇</a><a href='/php/biji/100096.html'>PHP 设计模式系列之 specification规格模式</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>