<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>基于C语言实现五子棋游戏完整实例代码_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="本文实例讲述了基于C语言实现五子棋游戏的方法，代码备有比较完整的注释，可以帮助读者更好的加以理解。<br />
五子棋游戏代码如下：<br />
<br />
<br />
/*<br />
 * 使用键盘的上下左右键移动棋盘，空格键表示" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">基于C语言实现五子棋游戏完整实例代码</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>本文实例讲述了基于C语言实现五子棋游戏的方法，代码备有比较完整的注释，可以帮助读者更好的加以理解。<br />
五子棋游戏代码如下：<br />
<br />
<br />
/*<br />
 * 使用键盘的上下左右键移动棋盘，空格键表示</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>本文实例讲述了基于C语言实现五子棋游戏的方法，代码备有比较完整的注释，可以帮助读者更好的加以理解。</p>
<p>五子棋游戏代码如下：</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
/*
 * 使用键盘的上下左右键移动棋盘，空格键表示下棋，ESC键退出程序
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;bios.h&gt;
#include &lt;graphics.h&gt;
#include&lt;malloc.h&gt;
/*
 * 对应键盘键的十六进制数字
 */
#define ESC 0x11b
#define UP 0x4800
#define DOWN 0x5000
#define LEFT 0x4b00
#define RIGHT 0x4d00
#define BLANK 0x3920

#define PLAYER1 1
#define PLAYER2 2
#define COMPUTER 2
#define LENGTH 15
#define SEARCH_DEEP 2
/*
 * 用来在函数can_expand()查找可以扩展的节点步长
 */
#define STEP 1

/************全局变量定义***************/
int       x1 = 240,
        y1 = 240,
        oldx = 240,
        oldy = 240;
int       key_mode;
int       key_net;
int       step_sum = 0;
int       chessman[LENGTH][LENGTH];
int       depth = 2; /* 搜索的深度 */
int       a = 0,
        b = 0;
int       flag_run;
int       win_flag = 0;


typedef struct five_chess *point;
struct five_chess {
  int       x;
  int       y;
  int       layer;
  double     value;
  double     score;
  int       chess[LENGTH][LENGTH];
  int       record[LENGTH][LENGTH];
} A;

int       stack_deep0 = 0;
point      stack_c[10];
point      close[600];

void
push(point s0)
{
  if (stack_deep0 &lt; 10)
 stack_c[stack_deep0++] = s0;
}

point
top()
{
  if (stack_deep0 &gt; 0)
 return stack_c[stack_deep0 - 1];
  /*else return 一个什么样的东西&#63;*/
}

void
pop()
{
  if (stack_deep0 &gt; 0)
 stack_deep0--;
}

int
is_empty()
{
  if (stack_deep0 != 0)
 return 1;
  else
 return 0;
}

 

/************函数的声明**************/
void      five();
void      show();
int       win_or_not(int x0, int y0, int who,
   int chessman[LENGTH][LENGTH], int a);
void      set_chessman();
void      print_result();
/************评价函数部分************/
double     score_row(int i, int j, int chessman[LENGTH][LENGTH]);
double     score_col(int i, int j, int chessman[LENGTH][LENGTH]);
double     score_diag_45(int i, int j, int chessman[LENGTH][LENGTH]);
double     score_diag_135(int i, int j, int chessman[LENGTH][LENGTH]);
double     total_score(int who_running, int chessman[LENGTH][LENGTH]);
double     score(int chessman[LENGTH][LENGTH]);
int       rowdt(int i, int j, int chessman[LENGTH][LENGTH]);
int       coldt(int i, int j, int chessman[LENGTH][LENGTH]);
int       diadt(int i, int j, int chessman[LENGTH][LENGTH]);
int       vdiadt(int i, int j, int chessman[LENGTH][LENGTH]);
int       can_expand(int i, int j, int chessman[LENGTH][LENGTH]);
void     copy(point s1, point s0);

int
POW(int s, int t)
{
  int       sum = s,
          i;
  if (t &lt;= 0)
 return 1;
  for (i = 0; i &lt; t; i++)
 sum *= sum;
  return sum;

}


/*
 * 定义computer先手
 */
point
expand(point s0)
{
  int       flag;
  int       i,
          j;
  point      new_chess = (point) malloc(sizeof(struct five_chess));
/*************************这里出错***********************************/
  for (i = 0; i &lt; LENGTH; i++)
 for (j = 0; j &lt; LENGTH; j++)
   new_chess-&gt;chess[i][j] = s0-&gt;chess[i][j];

  for (i = 0; i &lt; LENGTH; i++)
 for (j = 0; j &lt; LENGTH; j++)
   new_chess-&gt;record[i][j] = s0-&gt;chess[i][j];

/*************************这里出错***********************************/
  if (s0-&gt;layer % 2 == 0)
 flag = COMPUTER;
  else
 flag = PLAYER1;


  for (i = 0; i &lt; LENGTH; i++)
 for (j = 0; j &lt; LENGTH; j++) {

   if (s0-&gt;record[i][j])             /*如果有棋子*/
 continue;
   if (can_expand(i, j, s0-&gt;chess) == 0)  /*如果有棋子，而且沿水平，树直，左上—右下，右上—左下，四个方向可以扩展*/
 continue;
   s0-&gt;record[i][j] = flag;
   new_chess-&gt;chess[i][j] = flag;
   new_chess-&gt;layer = s0-&gt;layer + 1;
   new_chess-&gt;x = i;
   new_chess-&gt;y = j;
   new_chess-&gt;record[i][j] = flag;
   return new_chess;
 }
  /*
   * for(i=5;i&lt;10;i++) for(j=5;j&lt;10;j++){ if(s0-&gt;record[i][j]) continue;
   * if(can_expand(i,j,s0-&gt;chess)==0) continue; s0-&gt;record[i][j]=flag;
   * new_chess-&gt;x=i; new_chess-&gt;y=j; new_chess-&gt;record[i][j]=flag;
   * new_chess-&gt;layer=s0-&gt;layer+1; new_chess-&gt;chess[i][j]=flag ; return
   * new_chess; } for(i=2;i&lt;12;i++) for(j=2;j&lt;12;j++){
   * if(i&gt;4&&i&lt;10&&j&gt;4&&j&lt;10) continue; if(s0-&gt;record[i][j]) continue;
   * if(can_expand(i,j,s0-&gt;chess)==0) continue; s0-&gt;record[i][j]=flag;
   * new_chess-&gt;x=i; new_chess-&gt;y=j; new_chess-&gt;record[i][j]=flag;
   * new_chess-&gt;layer=s0-&gt;layer+1; new_chess-&gt;chess[i][j]=flag; return
   * new_chess;
   * 
   * } for(i=0;i&lt;LENGTH;i++) for(j=0;j&lt;LENGTH;j++){
   * if(i&gt;1&&i&lt;12&&j&gt;1&&j&lt;12) continue; if(s0-&gt;record[i][j]) continue;
   * if(can_expand(i,j,s0-&gt;chess)==0) continue; s0-&gt;record[i][j]=flag;
   * new_chess-&gt;chess[i][j]=flag; new_chess-&gt;layer=s0-&gt;layer+1;
   * new_chess-&gt;x=i; new_chess-&gt;y=j; new_chess-&gt;record[i][j]=flag; return 
   * new_chess; } 
   */
  new_chess-&gt;layer = -1;
  return new_chess;
}

 

void
computer()
{
  int       i,
          j,
          k,
          num = 0;
  int       break_now = 0;
  int       break_then = 0;
  int       go_on = 0;
  point     s0 = NULL,
          s1 = NULL,
          s2 = NULL,
          max_chess = NULL;
  point     temps = NULL,
          s01;
  /*
   * 堆栈的初始化
   */
  stack_deep0 = 0;
  s0 = malloc(sizeof(struct five_chess));
  for (i = 0; i &lt; 600; i++)              /*为什么是600*/
 close[i] = NULL;                 /*close是一个point 数组*/
  close[num++] = s0;
  for (i = 0; i &lt; LENGTH; i++)
 for (j = 0; j &lt; LENGTH; j++) {
   s0-&gt;chess[i][j] = chessman[i][j];
   s0-&gt;record[i][j] = chessman[i][j];
 }
  s0-&gt;layer = 0;
  s0-&gt;value = -3000000;
  s0-&gt;score = -3000000;
  push(s0);
  while (is_empty() != 0) {        /*看是栈否为空*/
 s01 = top();                  /*如果不是空*/
 s1 = expand(s01);             /*从栈顶开始展开*/
 close[num++] = s1;
 if (s1-&gt;layer == -1) {
   pop();
   continue;
 }
 go_on =
   win_or_not((s1-&gt;x + 1) * 30, (s1-&gt;y + 1) * 30, 2, s1-&gt;chess,
     1);
 if (go_on == 2) {
   a = (s1-&gt;x + 1) * 30;
   b = (s1-&gt;y + 1) * 30;
   break_then = 1;
   break;
 }
 go_on =
   win_or_not((s1-&gt;x + 1) * 30, (s1-&gt;y + 1) * 30, 1, s1-&gt;chess,
     1);
 if (go_on == 1) {
   a = (s1-&gt;x + 1) * 30;
   b = (s1-&gt;y + 1) * 30;
   break_then = 1;
   break;
 }
 s1-&gt;value = 30000;
 push(s1);
 while (1) {
   s1 = top();
   s2 = expand(s1);
   if (s2-&gt;layer == -1) {
 pop();
 if (s1-&gt;value &gt; top()-&gt;value) {
   top()-&gt;value = s1-&gt;value;
   max_chess = s1;
 }
 free(s2);
 break;
   }/*end of if*/
   s2-&gt;score = score(s2-&gt;chess);
   temps = top();
   if (s2-&gt;score &lt; temps-&gt;value)
 temps-&gt;value = s2-&gt;score;
   free(s2);
 }/*end of whiile(1) */
  }
  if (break_then == 0) {
 for (i = 0; i &lt; LENGTH; i++) {
   for (j = 0; j &lt; LENGTH; j++)
 if (max_chess-&gt;chess[i][j] != chessman[i][j]) {
   a = i * 30 + 30;
   b = j * 30 + 30;
   break_now = 1;
   break;
 }
   if (break_now == 1)
 break;
 }
  }
  for (i = 0; i &lt; 600; i++) {
 if (close[i] == NULL)
   continue;
 free(close[i]);
  }

}

/**********************************************************/
void
main()
{
  int       key;
  int       play_with_who = 1;

  printf("1.Play with human\n2.Play with computer\nPlease choice: ");
  scanf("%d", &play_with_who);
 
  five();              /*显示棋盘*/
  show();

  if (play_with_who == 1) {   /*人与人玩*/
 while (1) {  /*设置人与人玩的界面*/
   settextstyle(0, 0, 2);
   if ((step_sum + 1) % 2) {
 setcolor(1);
 outtextxy(500, 180, "Player2");
 setcolor(4);
 outtextxy(500, 180, "Player1");
   } else {
 setcolor(1);
 outtextxy(500, 180, "Player1");
 setcolor(10);
 outtextxy(500, 180, "Player2");
   }


   if (bioskey(1))
 /*
  * 按了一次键盘那么就true，执行下面代码，这是bios。h
  */
   {
 key = bioskey(0);
 /*
  * 返回一个键盘值，如没有按键，则一直等待
  */
 switch (key) {
 case ESC:
   exit(0);
 case LEFT:
   if (x1 &gt; 30) {
  x1 -= 30;
  show();   /*显示方框*/
   }
   break;
 case UP:
   if (y1 &gt; 30) {
  y1 -= 30;
  show();
   }
   break;
 case RIGHT:
   if (x1 &lt; 450) {
  x1 += 30;
  show();
   }
   break;
 case DOWN:
   if (y1 &lt; 450) {
  y1 += 30;
  show();
   }
   break;
 case BLANK:         /*按下空格键后放置棋子*/
   {
  if (chessman[x1 / 30][y1 / 30])
    break;       /*如果当前位置有棋子，不能放置，退出*/
  step_sum++;    /*如果没有棋子，下一步谁走加1*/
  /*
  * P1 设置棋子
  */
  if (step_sum % 2) {
    setcolor(15);  /*画棋子*/
    setfillstyle(SOLID_FILL, 15); /* 封闭图形，进行实体填充*/
    circle(x1, y1, 10);      /*画圆*/
    floodfill(x1, y1, 15);    /*填充圆*/
    chessman[x1 / 30][y1 / 30] = PLAYER1;        /*设置棋盘状态*/
    win_flag = win_or_not(x1, y1, 1, chessman, 0);   /*分析游戏是否结束,谁胜谁败*/
    if (win_flag == 1)
  outtextxy(480, 240, "P1 Win");
    else if (win_flag == 3)
  outtextxy(480, 240, "DOGFALL");
    if (win_flag != 0) {           /*如果没人胜，游戏继续*/
  while (bioskey(1) == 0);
  closegraph();            /*what this mean&#63;*/
    }
  } else { /* P2 设置棋子 */

    setcolor(12);            
    setfillstyle(SOLID_FILL, 12);
    circle(x1, y1, 10);
    floodfill(x1, y1, 12);
    chessman[x1 / 30][y1 / 30] = PLAYER2;
    win_flag = win_or_not(x1, y1, 2, chessman, 0);
    if (win_flag == 2)
  outtextxy(480, 240, "P2 Win");
    else if (win_flag == 3)
  outtextxy(480, 240, "DOGFALL");
    if (win_flag != 0) {
  while (bioskey(1) == 0);
  closegraph();
    }
  }

 

   }
   break;
 }
   }
 }
  } else {
 chessman[7][7] = COMPUTER;       /*人和电脑玩,电脑先走一步*/      
 setcolor(12);
 setfillstyle(SOLID_FILL, 12);
 circle(240, 240, 10);
 floodfill(240, 240, 12);
 flag_run = 0;          /*有什么用&#63;*/
 step_sum++;          /*下一步谁走？*/
 while (1) {
   while (1) {
 if (flag_run == 1)
   break;
 if (bioskey(1)) {
   key = bioskey(0);
   /*
    * 返回一个键盘值，如没有按键，则一直等待
    */
   switch (key) {

   case ESC:
  exit(0);
   case LEFT:
  if (x1 &gt; 30) {
    x1 -= 30;
    show();
  }
  break;
   case UP:
  if (y1 &gt; 30) {
    y1 -= 30;
    show();
  }
  break;
   case RIGHT:
  if (x1 &lt; 450) {
    x1 += 30;
    show();
  }
  break;
   case DOWN:
  if (y1 &lt; 450) {
    y1 += 30;
    show();
  }
  break;
   case BLANK:
  {
    if (chessman[x1 / 30 - 1][y1 / 30 - 1])
  break;                             /*有棋子了不走*/

    setcolor(15);
    setfillstyle(SOLID_FILL, 15); /* 封闭图形，进行实体填充 
     */
    circle(x1, y1, 10);
    floodfill(x1, y1, 15);               /*画棋子*/
    chessman[x1 / 30 - 1][y1 / 30 - 1] = PLAYER1;

    flag_run = 1;                 /*有什么用&#63;*/
    step_sum++;                 /*下一步谁走*/
    win_flag = win_or_not(x1, y1, 1, chessman, 0);  /*谁胜谁负*/
    if (win_flag == 1)
  outtextxy(480, 240, "P1 Win");
    else if (win_flag == 3)
  outtextxy(480, 240, "DOGFALL");
    if (win_flag != 0) {
  while (bioskey(1) == 0);                 /*没有人胜则继续等待下棋*/
  closegraph();
    }

  }
   } /* switch */

 }

   }
   computer();                      /*调用智能体*/
   /*
   * a,b存放的是现在电脑准备下的位置
   * 返回一个a,b的结构体不是更好，用全局变量不爽啊
   * struct {
   *     int a;
   *     int b;
   * }
   */

   setcolor(12);
   setfillstyle(SOLID_FILL, 12);
   circle(a, b, 10);
   floodfill(a, b, 12);
   chessman[a / 30 - 1][b / 30 - 1] = COMPUTER;
   flag_run = 0;
   step_sum++;
   win_flag = win_or_not(a, b, 2, chessman, 0);
   if (win_flag == 2)
 outtextxy(480, 240, "ComputerWin");
   else if (win_flag == 3)
 outtextxy(480, 240, "DOGFALL");
   if (win_flag != 0) {
 while (bioskey(1) == 0);
 closegraph();
   }

 

 

 }
  }

}
void
five()
{
  int       i,
          j;
  /*
   * 画棋盘的过程
   */
  int       gdriver = DETECT,
          gmode;
  registerbgidriver(EGAVGA_driver);
  initgraph(&gdriver, &gmode, " ");
  /*
   * 对显示适配器进行配置
   */
  setbkcolor(1);

  for (i = 0; i &lt; 30; i++) {
 setcolor((i &gt;= 2) &#63; 9 : i);
 rectangle(i, i, 479 - i, 479 - i); /* 画矩形边框 */
  }
  /*
   * 画棋盘
   */
  for (i = 1; i &lt; 14; i++)
 for (j = 1; j &lt; 14; j++) {
   setcolor(14);
   line(30 + 30 * i, 30, 30 + 30 * i, 449);
   line(30, 30 + 30 * i, 449, 30 + 30 * i);
 }
  /*
   * 画整个图的边框
   */
  for (i = 0; i &lt; 15; i++) {
 setcolor(i);
 rectangle(i, i, 640 - i, 480 - i);
 line(480 - i, 15, 480 - i, 465);
  }
  /*
   * 输出屏幕右侧的信息
   */
  setcolor(4);
  settextstyle(0, 0, 2);
  outtextxy(500, 45, "GOBANG");
  setcolor(10);
  settextstyle(0, 0, 1);
  outtextxy(500, 90, "Designed By");
  outtextxy(514, 118, "Ye Binbin");
  outtextxy(480, 140, "from class A of CS");


}

/*
 * 移动光标
 */
void
show()
{
  setcolor(1);

  if (oldx &lt; 450) {
 if (oldy &gt; 30)
   line(oldx + 7, oldy - 15, oldx + 15, oldy - 15);
 if (oldy &gt; 30)
   line(oldx + 15, oldy - 15, oldx + 15, oldy - 7);
 if (oldy &lt; 450)
   line(oldx + 15, oldy + 7, oldx + 15, oldy + 15);
 if (oldy &lt; 450)
   line(oldx + 15, oldy + 15, oldx + 7, oldy + 15);
  }
  if (oldx &gt; 30) {
 if (oldy &lt; 450)
   line(oldx - 7, oldy + 15, oldx - 15, oldy + 15);
 if (oldy &lt; 450)
   line(oldx - 15, oldy + 15, oldx - 15, oldy + 7);
 if (oldy &gt; 30)
   line(oldx - 15, oldy - 7, oldx - 15, oldy - 15);
 if (oldy &gt; 30)
   line(oldx - 15, oldy - 15, oldx - 7, oldy - 15);
  }
  setcolor(12);
  if (x1 &lt; 450) {
 if (y1 &gt; 30)
   line(x1 + 7, y1 - 15, x1 + 15, y1 - 15);
 if (y1 &gt; 30)
   line(x1 + 15, y1 - 15, x1 + 15, y1 - 7);
 if (y1 &lt; 450)
   line(x1 + 15, y1 + 7, x1 + 15, y1 + 15);
 if (y1 &lt; 450)
   line(x1 + 15, y1 + 15, x1 + 7, y1 + 15);
  }

  if (x1 &gt; 30) {
 if (y1 &lt; 450)
   line(x1 - 7, y1 + 15, x1 - 15, y1 + 15);
 if (y1 &lt; 450)
   line(x1 - 15, y1 + 15, x1 - 15, y1 + 7);
 if (y1 &gt; 30)
   line(x1 - 15, y1 - 7, x1 - 15, y1 - 15);
 if (y1 &gt; 30)
   line(x1 - 15, y1 - 15, x1 - 7, y1 - 15);
  }
  oldx = x1;
  oldy = y1;

}

 

void
set_chessman()
{
  /*
   * 棋子有三种状态，0是未初始状态，1是控制方棋子，2是对方棋子 
   */
  int       i,
          j;
  for (i = 0; i &lt; 15; i++)
 for (j = 0; j &lt; 15; j++)
   chessman[i][j] = 0;
}


/*
 * 0表示没有赢，1表示p1胜利，2表示p2胜利，3表示平局
 */
int
win_or_not(int x0, int y0, int who, int chessman[LENGTH][LENGTH], int a)
{
  int       i = x0 / 30 - 1,
          j = y0 / 30 - 1;
  int       who_run = who;
  int       line_sum = -1;
  int       tmp_i = i,
          tmp_j = j;
  int       c;
  if (a == 1) {
 /*
 * 测试第一层扩展是否满足赢的条件
 */
 c = chessman[i][j];
 chessman[i][j] = who_run;
  }


  while (1) {  /* 查找共行的棋子是否连接了五个 */
 while (tmp_i &gt;= 0 && line_sum != 4) {
   if (chessman[tmp_i--][j] == who_run)
 line_sum++;
   else
 break;
 }
 if (line_sum == 4)
   line_sum++;
 tmp_i = i;
 while (tmp_i &lt;= 15 && line_sum != 5) {
   if (chessman[tmp_i++][j] == who_run)
 line_sum++;
   else
 break;
 }
 if (line_sum == 5) {
   if (a == 1)
 chessman[i][j] = c;
   return who_run;
 }
 line_sum = -1;
 tmp_i = i;
 break;

  }
  while (1) {  /* 查找共列的棋子是否连接了五个 */
 while (tmp_j &gt;= 0 && line_sum != 4) {
   if (chessman[i][tmp_j--] == who_run)
 line_sum++;
   else
 break;
 }
 if (line_sum == 4)
   line_sum++;
 tmp_j = j;
 while (tmp_j &lt;= 15 && line_sum != 5) {
   if (chessman[i][tmp_j++] == who_run)
 line_sum++;
   else
 break;
 }
 if (line_sum == 5) {
   if (a == 1)
 chessman[i][j] = c;
   return who_run;
 }
 line_sum = -1;
 tmp_j = j;
 break;

  }
  while (1) {  /* 查找上对角线上是否连接了五个 */
 while (line_sum != 4 && tmp_i &lt;= 15 && tmp_j &gt;= 0) {
   if (chessman[tmp_i++][tmp_j--] == who_run)
 line_sum++;
   else
 break;
 }
 tmp_i = i;
 tmp_j = j;
 if (line_sum == 4)
   line_sum++;
 while (line_sum != 5 && tmp_i &gt;= 0 && tmp_j &lt;= 15) {
   if (chessman[tmp_i--][tmp_j++] == who_run)
 line_sum++;
   else
 break;
 }
 if (line_sum == 5) {
   if (a == 1)
 chessman[i][j] = c;
   return who_run;
 }
 tmp_i = i;
 tmp_j = j;
 line_sum = -1;
 break;
  }
  while (1) {  /* 查找下对角线上是否连接了五个 */
 while (line_sum != 4 && tmp_i &gt;= 0 && tmp_j &gt;= 0) {
   if (chessman[tmp_i--][tmp_j--] == who_run)
 line_sum++;
   else
 break;
 }
 tmp_i = i;
 tmp_j = j;
 if (line_sum == 4)
   line_sum++;
 while (line_sum != 5 && tmp_i &lt;= 15 && tmp_j &lt;= 15) {
   if (chessman[tmp_i++][tmp_j++] == who_run)
 line_sum++;
   else
 break;
 }
 if (line_sum == 5) {
   if (a == 1)
 chessman[i][j] = c;
   return who_run;
 }
 break;
  }
  if (step_sum == 225) {
 if (a == 1)
   chessman[i][j] = c;
 return 3;
  }
  if (a == 1)
 chessman[i][j] = c;
  return 0;

}

 

double
score_row(int i, int j, int chessman[LENGTH][LENGTH])
{
  int       sum_chessmen = 0;
  double     score = 0;
  int       mid_j;
  int       who_running = chessman[i][j];
  if (j == LENGTH) {
 while (chessman[i][j] == who_running) {
   j--;
   sum_chessmen++;
 }
 if (sum_chessmen &gt;= 5)
   score = 200000;
 else {
   if (chessman[i][j] == 0) /* 没有下子,活的情况 */
 score = 2000 / POW(10, 4 - sum_chessmen);
   else
 score = 0; /* 死的情况 */
 }
  } else {
 while (chessman[i][j] == who_running && j != LENGTH) {
   j++;
   sum_chessmen++;
 }
 mid_j = j;
 j = j - sum_chessmen - 1;
 while (chessman[i][j] == who_running && j != -1) {
   j--;
   sum_chessmen++;
 }
 if (j &gt;= 0 && mid_j &lt; LENGTH) {
   if (chessman[i][j] == 0 && chessman[i][mid_j] == 0)
 score = 18000 / POW(50, 4 - sum_chessmen);
   else if ((chessman[i][j] != 0 && chessman[i][mid_j] == 0)
    || (chessman[i][j] == 0 && chessman[i][mid_j] != 0))
 score = 2000 / POW(10, 4 - sum_chessmen);
   else
 score = 0;
 }
 if (j &lt; 0 && mid_j &lt; LENGTH) {
   if (chessman[i][mid_j] == 0)
 score = 2000 / POW(10, 4 - sum_chessmen);
   else
 score = 0;
 }
 if (j &gt;= 0 && mid_j &gt;= LENGTH) {
   if (chessman[i][j] == 0)
 score = 2000 / POW(10, 4 - sum_chessmen);
   else
 score = 0;
 }
 if (j &lt; 0 && mid_j &gt;= LENGTH)
   score = 0;
  }
  return score;
}

double
score_col(int i, int j, int chessman[LENGTH][LENGTH])
{
  int       sum_chessmen = 0,
          mid_i;
  double     score = 0;
  int       who_running = chessman[i][j];
  if (i == LENGTH) {
 while (chessman[i][j] == who_running) {
   i--;
   sum_chessmen++;
 }
 if (sum_chessmen &gt;= 5)
   score = 200000;
 if (chessman[i][j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
  } else {
 while (chessman[i][j] == who_running) {
   i++;
   sum_chessmen++;
 }
 mid_i = i;
 if (i == LENGTH || chessman[i][j] != who_running) {
   i = i - sum_chessmen;
   while (chessman[i - 1][j] == who_running) {
 i--;
 sum_chessmen++;
   }
   if (i &gt;= 0) {
 if (chessman[i][j] == 0 && chessman[mid_i][j] == 0)
   score = 18000 / POW(50, 4 - sum_chessmen);
 else if ((chessman[i][j] != 0 && chessman[mid_i][j]) == 0
  || (chessman[i][j] == 0
    && chessman[mid_i][j] != 0))
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
   if (i &lt; 0 && mid_i &lt; LENGTH) {
 if (chessman[mid_i][j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
   if (i &lt; 0 && mid_i &lt; LENGTH) {
 if (chessman[mid_i][j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
   if (i &gt;= 0 && mid_i &gt;= LENGTH) {
 if (chessman[i][j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
 }
  }
  return score;
}

double
score_diag_45(int i, int j, int chessman[LENGTH][LENGTH])
{
  int       sum_chessmen = 0;
  double     score = 0;
  int       mid_i,
          mid_j;
  int       who_running = chessman[i][j];
  if (i == LENGTH || j == LENGTH) {
 while (chessman[i][j] == who_running && i &gt; 1 && j &gt; 1) {
   i--;
   j--;
   sum_chessmen++;
 }
 if (sum_chessmen &gt;= 5)
   score = 200000;
 else {
   if (chessman[i][j] == 0)
 score = 2000 / POW(10, 4 - sum_chessmen);
   else
 score = 0;
 }
  } else {
 while (chessman[i][j] == who_running && i &lt;= LENGTH && j &lt;= LENGTH) {
   i++;
   j++;
   sum_chessmen++;
 }
 mid_i = i;
 mid_j = j;
 i = i - sum_chessmen;
 j = j - sum_chessmen;
 while (chessman[i - 1][j - 1] == who_running) {
   i--;
   j--;
   sum_chessmen++;
 }
 if (sum_chessmen &gt;= 5)
   score = 200000;
 if (i &gt;= 0 && j &gt;= 0 && mid_i &lt; LENGTH && mid_j &lt; LENGTH) {
   if (chessman[mid_i][mid_j] == 0 && chessman[i][j] == 0)
 score = 18000 / POW(50, 4 - sum_chessmen);
   else if ((chessman[mid_i][mid_j] == 0 && chessman[i][j] != 0)
    || (chessman[mid_i][mid_j] != 0
  && chessman[i][j] == 0))
 score = 2000 / POW(10, 4 - sum_chessmen);
   else
 score = 0;
 } else {
   if (i &gt;= 0 && j &gt;= 0) {
 if (chessman[i][j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   } else if (mid_i &lt; LENGTH && mid_j &lt; LENGTH) {
 if (chessman[mid_i][mid_j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   } else
 score = 0;
 }
  }
  return score;
}

double
score_diag_135(int i, int j, int chessman[LENGTH][LENGTH])
{
  int       sum_chessmen = 0;
  double     score = 0;
  int       mid_i,
          mid_j;
  int       who_running = chessman[i][j];
  while (chessman[i][j] == who_running && j != -1 && i &lt; LENGTH) {
 i++;
 j--;
 sum_chessmen++;
  }
  mid_i = i;
  mid_j = j;
  j += sum_chessmen;
  i -= sum_chessmen;
  j++;
  i--;
  while (chessman[i][j] == who_running && j != LENGTH) {
 i--;
 j++;
 sum_chessmen++;
  }
  if (sum_chessmen &gt;= 5)
 score = 200000;
  else {
 if (i &gt;= 0 && j &lt; LENGTH && mid_j &gt;= 0 && mid_i &lt; LENGTH) {
   if (chessman[i][j] == 0 && chessman[mid_i][mid_j] == 0)
 score = 18000 / POW(50, 4 - sum_chessmen);
   else {
 if ((chessman[i][j] == 0 && chessman[mid_i][mid_j] != 0)
   || (chessman[i][j] != 0
  && chessman[mid_i][mid_j] == 0))
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
 } else {
   if (i &gt;= 0 && j &lt; LENGTH) {
 if (chessman[i][j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
   if (mid_j &gt;= 0 && mid_i &lt; LENGTH) {
 if (chessman[mid_i][mid_j] == 0)
   score = 2000 / POW(10, 4 - sum_chessmen);
 else
   score = 0;
   }
 }
  }
  return score;
}

double
total_score(int who_running, int chessman[LENGTH][LENGTH])
{
  /*
   * 统计出在该点上的得分,who_running=1表示人的棋子,2为电脑的棋子
   */
  int       i,
          j;
  double     score = 0;
  for (i = 0; i &lt; LENGTH; i++)
 for (j = 0; j &lt; LENGTH; j++) {
   if (chessman[i][j] == who_running) {
 score += score_row(i, j, chessman);
 score += score_col(i, j, chessman);
 score += score_diag_45(i, j, chessman);
 score += score_diag_135(i, j, chessman);
   }
 }
  return score;
}

double
score(int chessman[LENGTH][LENGTH])
{
  /*
   * 计算最终的得分数,分别考虑了在这个位置放对方棋子跟自己棋子的综合
   */
  double     sum1,
            sum2;
  sum1 = total_score(COMPUTER, chessman);
  sum2 = total_score(PLAYER1, chessman);
  return sum1 - sum2;
}

/*
 * 扩展-----剪枝过程
 */

int
rowdt(int i, int j, int chessman[LENGTH][LENGTH])  /*在树直方向*/
{
  int       k;
  int       midjl = j - STEP,         /*当前棋子的上方*/
          midjr = j + STEP + 1;     /*当前棋子的下方棋子的下方&#63;&#63;&#63;&#63;&#63;&#63;*/
  if (midjl &lt; 0)                   
 midjl = 0;          
  if (midjr &gt; LENGTH)
 midjr = LENGTH;
  for (k = midjl; k &lt; midjr; k++)       /**/ 
 if (chessman[i][k] != 0)         /*如果有棋子*/
   return 1;
  return 0;
}

int
coldt(int i, int j, int chessman[LENGTH][LENGTH])     /*水平方向*/
{
  int       k;
  int       midil = i + STEP + 1,         /*当前的右边棋子的右一个*/
          midiu = i - STEP;            /*当前棋子的左一个*/
  if (midiu &lt; 0)
 midiu = 0;
  if (midil &gt; LENGTH)
 midil = LENGTH;
  for (k = midiu; k &lt; midil; k++)
 if (chessman[k][j] != 0)
   return 1;
  return 0;
}

int
diadt(int i, int j, int chessman[LENGTH][LENGTH])   /*右上到左下方向*/
{
  int       k,
          midi,
          midj;
  midi = i;
  midj = j;
  for (k = 0; k &lt; STEP; k++) {
 midi++;
 midj--;
 if (midj &lt; 0 || midi &gt;= LENGTH)
   break;
 if (chessman[midi][midj] != 0)
   return 1;
  }
  for (k = 0; k &lt; STEP; k++) {
 i--;
 j++;
 if (i &lt; 0 || j &gt;= LENGTH)
   break;
 if (chessman[i][j] != 0)
   return 1;
  }
  return 0;
}

int
vdiadt(int i, int j, int chessman[LENGTH][LENGTH])  /*左上到右下方向*/
{
  int       k,
          midi,
          midj;
  midi = i;
  midj = j;
  for (k = 0; k &lt; STEP; k++) {
 midi--;
 midj--;
 if (midi &lt; 0 || midj &lt; 0)
   break;
 if (chessman[midi][midj] != 0)
   return 1;
  }
  for (k = 0; k &lt; STEP; k++) {
 i++;
 j++;
 if (j &gt;= LENGTH || i &gt;= LENGTH)
   break;
 if (chessman[i][j] != 0)
   return 1;
  }
  return 0;
}


int
can_expand(int i, int j, int chessman[LENGTH][LENGTH])
{
  if (rowdt(i, j, chessman))
 return 1;
  if (coldt(i, j, chessman))
 return 1;
  if (diadt(i, j, chessman))
 return 1;
  if (vdiadt(i, j, chessman))
 return 1;
  /*
   * 如果不能扩展,返回0
   */
  return 0;
}

/************************************************************/</pre>
</div>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/87959.html'>win7系统物理光驱怎么禁用?Win7物理光驱禁用方法</a><a>下一篇</a><a href='/php/biji/87961.html'>PHP中的流(streams)浅析</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>