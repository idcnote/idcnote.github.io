<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Mysql基础知识点汇总_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="1.什么是SQL语句<br />
sql语言：结构化的查询语言。（Structured Query Language），是关系数据库管理系统的标准语言。<br />
它是一种解释语言：写一句执行一句，不需要整体编译执行。<br />
语法特点：<br />
1" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Mysql基础知识点汇总</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>1.什么是SQL语句<br />
sql语言：结构化的查询语言。（Structured Query Language），是关系数据库管理系统的标准语言。<br />
它是一种解释语言：写一句执行一句，不需要整体编译执行。<br />
语法特点：<br />
1</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>1.什么是SQL语句</strong></p>
<p>sql语言：结构化的查询语言。（Structured Query Language），是关系数据库管理系统的标准语言。</p>
<p>它是一种解释语言：写一句执行一句，不需要整体编译执行。</p>
<p>语法特点：</p>
<p>1.没有“ ”，字符串使用‘ '包含<br />
2.没有逻辑相等，赋值和逻辑相等都是=<br />
3.类型不再是最严格的。任何数据都可以包含在‘ '以内<br />
4.没有bool值的概念，但是在视图中可以输入true/false<br />
5.它也有关系运算符：&gt; &lt; &gt;= &lt;= = &lt;&gt; != ,它返回一个bool值<br />
6.它也有逻辑运算符： ！(not) &&(and) ||(or)<br />
7.它不区别大小写</p>
<p><strong>2.使用sql语句创建数据库和表</strong></p>
<p>语法：</p>
<div class="phpstudycode">
<pre class="brush:sql;">
create database 数据库名称
on primary --默认在主文件组上
(
name='逻辑名称_data' , --当你发现它不是一句完整的sql语句，而仅仅是一个处理结构中的某一句的时候，就需要添加 ,
size=初始大小,--数值不包含在‘'以内
filegrowth=文件增长 ,
maxsize=最大容量,
filename='物理路径'
)
log on
(
name='逻辑名称_log' , --当你发现它不是一句完整的sql语句，而仅仅是一个处理结构中的某一句的时候，就需要添加 ,
size=初始大小,--数值不包含在‘'以内
filegrowth=文件增长 ,
maxsize=最大容量, --一般来说日志文件不限制最大容量
filename='物理路径'
)</pre>
</div>
<p><br />
--判断数据库文件是否已经存在 ：数据库的记录都存储在master库中的sysdatabases表中<br />
--自动切换当前数据库<br />
--使用代码开启外围应该配置器<br />
</p>
<div class="phpstudycode">
<pre class="brush:sql;">
exec sp_configure 'show advanced options' ,1
RECONFIGURE
exec sp_configure 'xp_cmdshell',1
RECONFIGURE
</pre>
</div>
<p>--自定义目录&nbsp; xp_cmdshell可以创建出目录&nbsp;&nbsp; 'mkdir f:\project'：指定创建目录<br />
exec xp_cmdshell 'mkdir f:\project'</p>
<p>use master<br />
--exists 函数判断（）中的查询语句是否返回结果集，如果返回了结果集则得到true,否则得到false<br />
</p>
<div class="phpstudycode">
<pre class="brush:sql;">
if exists( select * from sysdatabases where name='School')
  drop database School --删除当前指定名称的数据库
create database School
on primary
(
 name='School_data',--逻辑名称.说明最多能够存储100mb数据，如果没有限制就可以将硬盘存储满
 size=3mb,--初始大小
 maxsize=100mb,--最大容量
 filegrowth=10%,--文件增长一次增长10%
 filename='f:\project\School_data.mdf'  
),
</pre>
</div>
<p>--创建文件组<br />
</p>
<div class="phpstudycode">
<pre class="brush:sql;">
filegroup mygroup
(
 name='School_data1',--逻辑名称.说明最多能够存储100mb数据，如果没有限制就可以将硬盘存储满
 size=3mb,--初始大小
 maxsize=100mb,--最大容量
 filegrowth=10%,--文件增长一次增长10%
 filename='F:\qiyi\School_data1.ndf'  
)
log on
(
 name='School_log',--逻辑名称
 size=3mb,--初始大小
 --maxsize=100mb,--最大容量
 filegrowth=10%,--文件增长一次增长10%
 filename='f:\project\School_log.ldf'  
),
(
 name='School_log1',--逻辑名称
 size=3mb,--初始大小
 --maxsize=100mb,--最大容量
 filegrowth=10%,--文件增长一次增长10%
 filename='F:\qiyi\School_log1.ldf'  
)
</pre>
</div>
<p><strong>3.创建数据表</strong></p>
<p>语法：</p>
<p>create table 表名<br />
(<br />
字段名称 字段类型 字段特征(是否为null,默认值 标识列 主键 唯一键 外键 check约束),<br />
字段名称 字段类型 字段特征(是否为null,默认值 标识列 主键 唯一键 外键 check约束)<br />
)<br />
创建老师表Teacher :Id、Name、Gender、Age、Salary、Birthday<br />
</p>
<div class="phpstudycode">
<pre class="brush:sql;">
use School
if exists(select * from sysobjects where name='Classes')
 drop table Classes
create table Classes
(
 Classid int identity(1,1),
 ClassName nvarchar(50) not null 
)
if exists(select * from sysobjects where name='teacher')
 drop table teacher
create table Teacher
(
 Id int identity(1,1),--可以同时创建多个特征，用空格 分隔开。 identity是标识列，第一个参数是种子，第二个是增量
Name nvarchar(50) not null,-- not null标记它的值不能为null--不能不填写
ClassId int not null,
 Gender bit not null,
Age int  ,
Salary money, --如果不标记为 not null.那么就相当于标记了null
Birthday datetime 
)
</pre>
</div>
<p><strong>4.数据完整性约束</strong></p>
<p>实体完整性：实体就是指一条记录。这种完整性就是为了保证每一条记录不是重复记录。是有意义的</p>
<p>主键：非空和唯一.一个表只有一个主键，但是一个主键可以是由多个字段组成的 组合键<br />
标识列：系统自动生成，永远不重复<br />
唯一键：唯一，但是可以为null,只能null一次<br />
域完整性：域就是指字段，它是为了保证字段的值是准和有效，合理值</p>
<p>类型 是否null，默认值，check约束，关系<br />
自定义完整性：</p>
<p>check约束 ， 存储过程 触发器<br />
引用完整性：一个表的某个字段的值是引用自另外一个表的某个字段的值。引用的表就是外键表，被引用的表就是主键表</p>
<p>1.建立引用的字段类型必须一致<br />
2.建立引用的字段的意义一样<br />
3.建立主外键关系的时候选择 外键表 去建立主外键关系<br />
4.建立主外键关系的字段在主表中必须是主键或者唯一键<br />
</p>
<p><strong>5.对于操作的影响</strong><br />
</p>
<p>①.在添加数据时，先添加主键表再添加外键表数据<br />
②.在删除的时候先外键表数据再删除主键表数据</p>
<p>级联的操作：不建议使用：会破坏数据完整性<br />
不执行任何操作：该报错就报错，该删除就删除<br />
级联：删除主表记录，从表引用该值的记录也被删除<br />
设置null:删除主表记录，从表对应的字段值设置为null,前提是可以为null<br />
设置为default:删除主表记录，从表对应的字段值设置为default,前提是可以为default<br />
主键约束（PK Primary key）唯一键约束(UQ unique) 外键约束(FK foreign key) 默认值约束(DF default) check约束(CK check)</p>
<p>语法：</p>
<p>alter table 表名<br />
add constraint 前缀_约束名称 约束类型 约束说明（字段 关系表达式 值)<br />
use School<br />
if exists(select * from sysobjects where name='PK_Classes_Classid')<br />
&nbsp;alter table classes&nbsp; drop constraint PK_Classes_Classid<br />
alter table classes <br />
add constraint PK_Classes_Classid primary key(classid)<br />
--为id添加主键<br />
alter table teacher <br />
add constraint PK_teacher_id primary key(id)<br />
--为name添加唯一键<br />
alter table teacher<br />
add constraint UQ_Teacher_Name unique(Name)<br />
--同时创建salary的默认约束和age的check约束<br />
alter table teacher<br />
add constraint DF_Teacher_Salary default(5000) for salary,<br />
constraint CK_Teacher_Age check(age&gt;0 and age&lt;=100)<br />
--为teacher表的classid字段创建主外键<br />
if exists(select * from sysobjects where name='FK_Teacher_Classes_Classid')<br />
&nbsp;alter table teacher&nbsp; drop constraint FK_Teacher_Classes_Classid<br />
alter table teacher<br />
with nocheck --不检查现有数据<br />
add constraint FK_Teacher_Classes_Classid foreign key(classid) references classes(classid)<br />
--on delete set default&nbsp; 级联操作<br />
--不执行任何操作：该报错就报错，该删除就删除&nbsp; --no action --默认选择<br />
--级联：删除主表记录，从表引用该值的记录也被删除 --cascade<br />
--设置null:删除主表记录，从表对应的字段值设置为null,前提是可以为null&nbsp;&nbsp; --set null<br />
--设置为default:删除主表记录，从表对应的字段值设置为default,前提是可以为default&nbsp; --set default<br />
</p>
<p><strong>5.四中基本字符类型说明</strong></p>
<p>--len(参数) --获取指定参数内容的字符个数<br />
select LEN('abcd') 【4】运行结果<br />
select LEN('中华人民共和国') 【7】</p>
<p>--DataLength(参数)：获取指定内占据的字节数--空间大小<br />
select DataLength('abcd') 【4】<br />
select DataLength('中华人民共和国') 【14】</p>
<p>--char类型：当空间分配后，不会因为存储的内容比分配的空间小就回收分配的空间。但是如果存储的内容超出了指定的空间大小，就会报错，当你存储的内容的长度变化区间不大的时候可以考虑使用char<br />
select LEN(char) from CharTest 【2】<br />
select DataLength(char) from CharTest 【10】</p>
<p>--varchar&nbsp; var--变化的：当你存储的内容小于分配的空间的时候，多余的空间会自动收缩。但是如果存储的内容超出了指定的空间大小，就会报错 当存储的内容波动区间比较大时候使用varchar<br />
select LEN(varchar) from CharTest 【2】<br />
select DataLength(varchar) from CharTest 【2】</p>
<p>--nchar--&nbsp; n代表它是一个unicode字符。规定不管什么样的字符都占据两个字节。&nbsp; char:空间是固定的<br />
select LEN(nchar) from CharTest 【10】<br />
select DataLength(nchar) from CharTest 【20】</p>
<p>--nvarchar&nbsp; n&nbsp; var&nbsp; char <br />
select LEN(nvarchar) from CharTest 【2】<br />
select DataLength(nvarchar) from CharTest 【4】<br />
</p>
<p><strong>6.SQL基本语句</strong></p>
<p>数据插入</p>
<p>调用方法 一 一对应原则：类型对应，数量对应，顺序对应。</p>
<p>语法： 形参 实参</p>
<p>insert into 表名([字段列表]) values(值列表) --数据必须要符合数据完整性<br />
插入操作是单个表的操作<br />
插入操作insert一次只能插入一条记录<br />
use School<br />
--插入teacher所有字段的数据.如果在表后没有指定需要插入的字段名称，那么就默认为所有字段添加值<br />
--但是一定需要注意的是：标识列永远不能自定义值--不能人为插入值<br />
--仅当使用了列列表并且 IDENTITY_INSERT 为 ON 时，才能为表'Teacher'中的标识列指定显式值。<br />
insert into Teacher values('张三',5,1,30,4000,'1984-9-11')<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('张三',5,1,30,4000,'1984-9-11')<br />
--不为可以为null的字段插入值&nbsp; :可以null的字段可以不赋值 <br />
--列名或所提供值的数目与表定义不匹配<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary) values('李四',5,1,30,4000)<br />
--非空字段一定需要赋值 ：不能将值 NULL 插入列 'Gender'，表 'School.dbo.Teacher'；列不允许有 Null 值。INSERT 失败<br />
insert into Teacher(Name,ClassId,Age,Salary) values('李四',5,30,4000)<br />
--为有默认值的字段插入值：<br />
--1.不写这一列让系统自动赋值<br />
insert into Teacher(Name,ClassId,Gender,Age) values('王五',5,1,30)<br />
--指定 null或者default<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('赵六',5,1,30,default,null)<br />
--数据必须完全符合表的完整性约束<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('赵六1',5,1,300,default,null)</p>
<p>--任意类型的数据都可以包含在''以内,&nbsp;&nbsp;&nbsp;&nbsp; 不包括关键字<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('马鹏飞','5','0','15',default,null)<br />
--但是字符串值如果没有包含在''以内.会报错&nbsp;&nbsp; 列名 '兰鹏' 无效。<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('兰鹏','5','0','15',default,null)<br />
--但是数值组成的字符串可以不使用''包含<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values(123,'5','0','15',default,null)<br />
--日期值必须包含在'‘以内，否则就是默认值<br />
insert into Teacher(Name,ClassId,Gender,Age,Salary,Birthday) values('邹元标2','5','0','15',default,'1991-9-11')<br />
数据删除</p>
<p>语法:</p>
<p>delete [from] 表名 where 条件<br />
delete from Teacher where Age&lt;20<br />
--特点:<br />
--1.删除是一条一条进行删除的<br />
--2.每一条记录的删除都需要将操作写入到日志文件中<br />
--3.标识列不会从种子值重新计算,以从上次最后一条标识列值往下计算<br />
--4.这种删除可以触发delete触发器</p>
<p>--truncate table 表名 --没有条件，它是一次性删除所有数据<br />
--特点：<br />
--1.一次性删除所有数据，没有条件，那么日志文件只以最小化的数据写入<br />
--2.它可以使用标识列从种子值重新计算<br />
--3.它不能触发delete触发器<br />
truncate table teacher<br />
数据更新(数据修改)：一定需要考虑是否有条件</p>
<p>语法:</p>
<p>update 表名 set 字段=值，字段=值 。。where 条件<br />
update Teacher set Gender='true'<br />
--修改时添加条件<br />
update Teacher set Gender=0 where Id=20<br />
--多字段修改<br />
update Teacher set ClassId=4,Age+=5,Salary=5000 where Id=22<br />
--修改班级id=4，同时年龄》20岁的人员工资+500<br />
update Teacher set Salary=Salary+500 where ClassId=4 and Age&gt;20<br />
数据检索--查询</p>
<p>语法： *代表所有字段</p>
<p>select */字段名称列表 from 表列表<br />
select StudentNo,StudentName,Sex,[Address] from Student<br />
--可以为标题设置&nbsp; 别名，别名可以是中文别名<br />
select StudentNo as 学号,StudentName 姓名,性别=Sex,[Address] from Student<br />
--添加常量列<br />
select StudentNo as 学号,StudentName 姓名,性别=Sex,[Address] ,国籍='中华人民共和国' from Student<br />
--select的作用<br />
--1.查询<br />
--2.输出<br />
select 1+1<br />
--+是运算符,系统会自动为你做类型转换<br />
select 1+'1'<br />
select '1'+1<br />
--如果+两边都是字符串,那么它就是一字符串连接符<br />
select '1'+'1'<br />
select 'a'+1<br />
--可以输出多列值<br />
select 1,2,34,3,545,67,567,6,7<br />
--Top、Distinct<br />
select * from Student<br />
--top可以获取指定的记录数,值可以大于总记录数.但是不能是负值<br />
select top 100 * from Student<br />
--百分比是取ceiling()<br />
select top 10 percent * from Student</p>
<p>--重复记录与原始的数据表数据无关,只与你查询的结果集有关系 distinct可以去除结果集中的重复记录--结果集中每一列的值都一样<br />
select distinct LoginPwd,Sex,Email from Student<br />
select distinct Sex from Student</p>
<p>select的作用<br />
--聚合函数：<br />
--1.对null过滤<br />
--2.都需要有一个参数<br />
--3.都是返回一个数值<br />
--sum()：求和:只能对数值而言,对字符串和日期无效<br />
--avg()：求平均值<br />
--count()：计数：得到满足条件的记录数<br />
--max()：求最大值:可以对任意类型的数据进行聚合，如果是字符串就比较拼音字母进行排序<br />
--min()：求最小值<br />
--获取学员总人数<br />
select COUNT(*) from Student<br />
--查询最大年龄值<br />
select&nbsp; MIN(BornDate) from Student<br />
select&nbsp; max(BornDate) from Student</p>
<p>--查询总分<br />
select SUM(StudentResult) from Result where StudentNo=2<br />
--平均分<br />
select avg(StudentResult) from Result where SubjectId=1<br />
--注意细节：<br />
select&nbsp; SUM(StudentName) from Student<br />
select&nbsp; SUM(BornDate) from Student</p>
<p>select&nbsp; min(StudentName) from Student<br />
select&nbsp; max(StudentName) from Student</p>
<p>--查询学号，姓名，性别，年龄，电话，地址 ---查询女生<br />
select StudentNo,StudentName,Sex,BornDate,Address from Student where Sex='女' and BornDate &gt;'1990-1-1' and Address='广州传智播客'<br />
--指定区间范围<br />
select StudentNo,StudentName,Sex,BornDate,Address from Student where&nbsp; BornDate &gt;='1990-1-1' and BornDate&lt;='1993-1-1'<br />
--between...and&nbsp; &gt;=&nbsp; &lt;=<br />
select StudentNo,StudentName,Sex,BornDate,Address from Student where BornDate&nbsp; between '1990-1-1' and '1993-1-1'<br />
--查询班级id&nbsp; 1&nbsp; 3 5&nbsp; 7的学员信息<br />
select * from Student where ClassId=1 or ClassId=3 or ClassId=5 or ClassId=7<br />
--指定具体的取值范围--可以是任意类型的范围.值的类型需要一致--可以相互转换<br />
select * from Student where ClassId in(1,3,'5',7)<br />
select * from Student where ClassId not in(1,3,'5',7)</p>
<p>聚合函数<br />
--带条件的查询-模糊查询-- 只针对字符串而言</p>
<p>--查询&nbsp; 姓 林 的女生信息<br />
--=是一种精确查询，需要完全匹配<br />
select * from Student where Sex='女' and StudentName='林'<br />
--通配符--元字符<br />
--%：任意个任意字段&nbsp; window:*&nbsp; 正则表达式 ：.*<br />
--_:任意的单个字符<br />
--[]:代表一个指定的范围，范围可以是连续也可以是间断的。与正则表达式完全一样[0-9a-zA-Z].可以从这个范围中取一个字符<br />
--[^]:取反值<br />
select * from Student where Sex='女' and StudentName='林%'<br />
--通配符必须在模糊查询关键的中才可以做为通配符使用，否则就是普通字符<br />
--like&nbsp;&nbsp; 像 。。。。一样<br />
select * from Student where Sex='女' and StudentName&nbsp; like '林%'<br />
select * from Student where Sex='女' and StudentName&nbsp; like '林_'<br />
--[]的使用&nbsp; 学号在11~15之间的学员信息<br />
select * from Student where StudentNo like '[13579]'</p>
<p>---处理null值<br />
--null:不是地址没有分配,而是不知道你需要存储什么值&nbsp; 所以null是指&nbsp;&nbsp; 不知道。但是=只能匹配具体的值，而null根本就不是一个值<br />
select COUNT(email) from Student where Email !=null<br />
select COUNT(email) from Student where Email&nbsp; is null<br />
select count(email) from Student where Email&nbsp; is not null<br />
--将null值替换为指定的字符串值<br />
select StudentName,ISNULL(Email,'没有填写电子邮箱') from Student where ClassId=2</p>
<p>模糊查询<br />
--当你看到&nbsp; 每一个，，各自，不同，，分别&nbsp; 需要考虑分组<br />
--查询每一个班级的男生人数<br />
--与聚合函数一起出现在查询中的列，要么也被聚合，要么被分组<br />
select classid,Sex,COUNT(*) from Student where Sex='男' group by ClassId,sex<br />
--查询每一个班级的总人数,显示人数&gt;=2的信息<br />
--1.聚合不应出现在 WHERE 子句中--语法错误<br />
select ClassId ,COUNT(*) as num from Student where Email is not null&nbsp;&nbsp; GROUP by ClassId having COUNT(*)&gt;=2 order by num desc<br />
--完整的sql查询家庭<br />
&nbsp;--5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />
--select 字段列表 from 表列表&nbsp; where 数据源做筛选 group by 分组字段列表 having 分组结果集做筛选 Order by&nbsp; 对结果集做记录重排</p>
<p>select ClassId ,COUNT(*) as num from Student where Email is not null&nbsp;&nbsp; GROUP by ClassId order by ClassId desc</p>
<p>--关于top的执行顺序 排序之后再取top值<br />
select top 1 ClassId ,COUNT(*) as num from Student&nbsp; GROUP by ClassId&nbsp; order by num desc</p>
<p>分组统计<br />
</p>
<p><strong>7.类型转换函数</strong></p>
<p>--select :输出为结果集--虚拟表<br />
--print：以文本形式输出&nbsp; 只能输出一个字符串值.</p>
<p>print 1+'a'<br />
select 1,2</p>
<p>select * from Student</p>
<p>--类型转换<br />
--Convert(目标类型,源数据,[格式]) --日期有格式<br />
print '我的成绩是：'+convert(char(3),100)</p>
<p>print '今天是个大日子：'+convert(varchar(30),getdate(),120)<br />
select getdate()<br />
select len(getdate())</p>
<p>--cast(源数据&nbsp; as&nbsp; 目标类型)&nbsp; 它没有格式<br />
print '我的成绩是：'+cast(100 as char(3))<br />
</p>
<p><strong>8.日期函数</strong></p>
<p>--getdate():获取当前服务器日期<br />
select GETDATE()<br />
--可以在源日期值是追加指定时间间隔的日期数<br />
select DATEADD(dd,-90,GETDATE())<br />
--dateDiff:找到两个日期之间指定格式的差异值<br />
select StudentName,DATEDIFF(yyyy,getdate(),BornDate) as age from Student order by&nbsp; age<br />
--DATENAME:可以获取日期的指定格式的字符串表现形式<br />
select DATENAME(dw,getdate())<br />
--DATEPART:可以获取指定的日期部分<br />
select cast(DATEPART(yyyy,getdate()) as CHAR(4))+'-' +cast(DATEPART(mm,getdate()) as CHAR(2))+'-' +cast(DATEPART(dd,getdate()) as CHAR(2))<br />
</p>
<p><strong>9.数学函数</strong></p>
<p>--rand:随机数:返回0到1之间的数，理论上说可以返回0但是不能返回1<br />
select RAND()<br />
--abs:absolute:取绝对值<br />
select ABS(-100)<br />
--ceiling:获取比当前数大的最小整数<br />
select CEILING(1.00)<br />
--floor:获取比当前数小的最大整数<br />
select floor(1.99999)<br />
power:<br />
select POWER(3,4)<br />
--round():四舍五入.只关注指定位数后一位<br />
select ROUND(1.549,1)<br />
--sign:正数==1&nbsp; 负数 ==-1&nbsp; 0=0<br />
select SIGN(-100)</p>
<p>select ceiling(17*1.0/5)<br />
</p>
<p><strong>10.字符串函数</strong></p>
<p>--1.CHARINDEX --IndexOf():能够返回一个字符串在源字符串的起始位置。找不到就返回0，如果可以找到就返回从1开始的索引--没有数组的概念<br />
--第一个参数是指需要查询的字符串，第二个是源字符串，第三个参数是指从源字符的那个索引位置开始查找<br />
select CHARINDEX('人民','中华人民共和国人民',4)<br />
--LEN()：可以返回指定字符串的字符个数<br />
select LEN('中华人民共和国')<br />
--UPPER():小写字母转换为大写字母&nbsp; LOWER():大写转小写<br />
select LOWER(UPPER('sadfasdfa'))<br />
--LTRIM:去除左空格&nbsp; RTIRM:去除右空格<br />
select lTRIM(RTRIM('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdfsd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '))+'a'<br />
--RIGHT:可以从字符串右边开始截取指定位数的字符串&nbsp; 如果数值走出范围，不会报错，只会返回所有字符串值,但是不能是负值<br />
select RIGHT('中华人民共和国',40)<br />
select LEFT('中华人民共和国',2)<br />
--SUBSTRING()<br />
select SUBSTRING('中华人民共和国',3,2)<br />
--REPLACE 第一个参数是源字符串，第二个参数是需要替换的字符串，第三个参数是需要替换为什么<br />
select REPLACE('中华人民共和国','人民','居民')<br />
select REPLACE('中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 华&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 人民&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 共&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 和&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 国',' ','')<br />
--STUFF:将源字符串中从第几个开始，一共几个字符串替换为指定的字符串<br />
select STUFF('中华人民共和国',3,2,'你懂的')</p>
<p>--sudyfsagfyas@12fasdf6.fsadfdsaf</p>
<p>declare @email varchar(50)='sudyfsagfyas@12fasdf6.fsadfdsaf'<br />
select CHARINDEX('@',@email)<br />
select LEFT(@email,CHARINDEX('@',@email)-1)</p>
<p>--使用right<br />
select right(@email,len(@email)-CHARINDEX('@',@email))<br />
--使用substring<br />
select SUBSTRING(@email,CHARINDEX('@',@email)+1,LEN(@email))<br />
--使用stuff<br />
select STUFF(@email,1,CHARINDEX('@',@email),'')<br />
</p>
<p><strong>11.联合结果集union</strong></p>
<p>--联合结果集union<br />
select * from Student where Sex='男'<br />
--union<br />
select * from Student where Sex='女'</p>
<p>--联合的前提是：<br />
--1.列的数量需要一致:使用 UNION、INTERSECT 或 EXCEPT 运算符合并的所有查询必须在其目标列表中有相同数目的表达式<br />
--2.列的类型需要可以相互转换<br />
select StudentName,Sex from Student --在字符串排序的时候，空格是最小的，排列在最前面<br />
union<br />
select cast(ClassId as CHAR(3)),classname from grade</p>
<p>--union和union all的区别<br />
--union是去除重复记录的<br />
--union all不去除重复 ：效率更高，因为不需要判断记录是否重复，也没有必须在结果庥是执行去除重复记录的操作。但是可以需要消耗更多的内存存储空间<br />
select * from Student where ClassId=2<br />
union all<br />
select * from Student where ClassId=2</p>
<p>--查询office这科目的全体学员的成绩，同时在最后显示它的平均分，最高分，最低分<br />
select ' '+cast(StudentNo as CHAR(3)),cast(SubjectId as CHAR(2)),StudentResult from Result where SubjectId=1<br />
union<br />
select '1','平均分',AVG(StudentResult) from Result where SubjectId=1<br />
union<br />
select '1','最高分',max(StudentResult) from Result where SubjectId=1<br />
union<br />
select '1','最低分',min(StudentResult) from Result where SubjectId=1</p>
<p>--一次性插入多条数据<br />
--1.先将数据复制到另外一个新表中，删除源数据表，再将新表的数据插入到源数据表中<br />
--1.select */字段&nbsp; into 新表 from 源表<br />
--1.新表是系统自动生成的，不能人为创建，如果新表名称已经存在就报错<br />
--2.新表的表结构与查询语句所获取的列一致，但是列的属性消失，只保留非空和标识列。其它全部消失，如主键，唯一键，关系，约束，默认值<br />
select * into newGrade from grade</p>
<p>truncate table grade<br />
select *&nbsp; from newGrade<br />
--select * into grade from newGrade<br />
--2.insert into&nbsp; 目标表&nbsp; select 字段列表/* from&nbsp; 数据源表<br />
--1、目标表必须先存在，如果没有就报错<br />
--2.查询的数据必须符合目标表的数据完整性<br />
--3.查询的数据列的数量和类型必须的目标的列的数量和对象完全对应<br />
insert into grade select classname from newGrade<br />
delete from admin<br />
--使用union一次性插入多条记录<br />
--insert into 表(字段列表)<br />
--select 值。。。。 用户自定义数据<br />
--union<br />
--select 值 。。。。<br />
insert into Admin<br />
select 'a','a'<br />
union all<br />
select 'a','a'<br />
union all<br />
select 'a','a'<br />
union all<br />
select 'a',null<br />
</p>
<p><strong>12.CASE函数用法</strong></p>
<p>相当于switch case---c#中的switch...case只能做等值判断<br />
这可以对字段值或者表达式进行判断，返回一个用户自定义的值，它会生成一个新列。<br />
2.要求then后面数据的类型一致<br />
1.第一种做等值判断的case..end</p>
<p>case 字段或者表达式<br />
when .值..then .自定义值<br />
when .值..then .自定义值<br />
.....<br />
&nbsp;else 如果不满足上面所有的when就满足这个else<br />
end<br />
--显示具体班级的名称<br />
select StudentNo,StudentName,<br />
case ClassId&nbsp; --如果case后面接有表达式或者字段，那么这种结构就只能做等值判断，真的相当于switch..case<br />
&nbsp; when 1 then '一班'<br />
&nbsp; when 2 then '2班' <br />
&nbsp; when 3 then '3班' <br />
&nbsp; when null&nbsp; then 'aa' --不能判断null值<br />
&nbsp; else&nbsp; '搞不清白'<br />
end,<br />
sex<br />
&nbsp;from Student<br />
--2.做范围判断，相当于if..else，它可以做null值判断<br />
--case&nbsp; --如果没有表达式或者字段就可实现范围判断<br />
-- when&nbsp; 表达式&nbsp; then 值&nbsp;&nbsp; --不要求表达式对同一字段进行判断<br />
-- when&nbsp; 表达式&nbsp; then 值&nbsp; <br />
-- .....<br />
--else&nbsp; 其它情况&nbsp; <br />
--end<br />
select StudentNo,StudentName,<br />
case<br />
&nbsp;when BornDate&gt;'2000-1-1' then '小屁孩'<br />
&nbsp;when BornDate&gt;'1990-1-1' then '小青年' <br />
&nbsp;when BornDate&gt;'1980-1-1' then '青年'&nbsp; <br />
&nbsp;--when Sex='女'&nbsp; then '是女的'<br />
&nbsp;when BornDate is null then '出生不详'<br />
&nbsp;else&nbsp; '中年'<br />
end<br />
&nbsp;from Student</p>
<p>--百分制转换为素质教育&nbsp; 90 -A&nbsp;&nbsp; 80--B&nbsp; 70 --C&nbsp; 60 --D&nbsp; &lt;60 E&nbsp; NULL--没有参加考试<br />
select StudentNo,SubjectId,<br />
case<br />
&nbsp;&nbsp;&nbsp; when StudentResult&gt;=90 then 'A'<br />
&nbsp;&nbsp;&nbsp; when StudentResult&gt;=80 then 'B'<br />
&nbsp;&nbsp;&nbsp; when StudentResult&gt;=70 then 'C'<br />
&nbsp;&nbsp;&nbsp; when StudentResult&gt;=60 then 'D'<br />
&nbsp;&nbsp;&nbsp; when StudentResult is null then '没有参加考试'<br />
&nbsp;&nbsp;&nbsp; else 'E'<br />
end 成绩,<br />
ExamDate<br />
&nbsp;from Result<br />
</p>
<p><strong>13.IF ELSE语法</strong></p>
<p>1.没有｛｝，使用begin..end.如果后面只有一句，可以不使用begin..end包含<br />
2.没有bool值，只能使用关系运算符表达式<br />
3.也可以嵌套和多重<br />
4.if后面的（）可以省略</p>
<p>declare @subjectname nvarchar(50)='office' --科目名称<br />
declare @subjectId int=(select Subjectid from Subject where SubjectName=@subjectname) --科目ID<br />
declare @avg int --平均分<br />
set @avg=(select AVG(StudentResult) from Result where SubjectId=@subjectId and StudentResult is not null) --获取平均分<br />
print @avg<br />
if @avg&gt;=60<br />
&nbsp;begin<br />
&nbsp;&nbsp; print '成绩不错，输出前三名：' <br />
&nbsp;&nbsp; select top 3 * from Result where SubjectId=@subjectId order by StudentResult desc <br />
&nbsp;end <br />
else<br />
&nbsp; begin<br />
&nbsp;&nbsp;&nbsp; print '成绩不好，输出后三名：' <br />
&nbsp;&nbsp;&nbsp; select top 3 * from Result where SubjectId=@subjectId order by StudentResult&nbsp; <br />
&nbsp; end<br />
</p>
<p><strong>14.WHILE循环语法</strong></p>
<p>1.没有{},使用begin..end<br />
2.没有bool值，需要使用条件表达式<br />
3.可以嵌套<br />
4.也可以使用break,continue</p>
<div class="phpstudycode">
<pre class="brush:sql;">
go
declare @subjectName nvarchar(50)='office' --科目名称
declare @subjectId int--科目ID
declare @classid int =(select classid from Subject where SubjectName=@subjectName) --查询当前科目属于那一个班级
set @subjectId=(select SubjectId from Subject where SubjectName=@subjectName) --获取科目ID
declare @totalCount int --总人数 :那一个班级需要考试这一科目 
set @totalCount=(select COUNT(*) from Student where ClassId=@classid)
print @totalcount --14
declare @unpassNum int --不及格人数
set @unpassNum=(select COUNT(distinct Studentno) from Result where SubjectId=@subjectId and StudentNo in(select StudentNo from Student where ClassId=@classid) and StudentResult&lt;60)
while(@unpassNum&gt;@totalCount/2)
begin
 --执行循环加分
 update Result set StudentResult+=2 where SubjectId=@subjectId and StudentNo in(select StudentNo from Student where ClassId=@classid) and StudentResult&lt;=98
 --重新计算不及格人数
 set @unpassNum=(select COUNT(distinct Studentno) from Result where SubjectId=@subjectId and StudentNo in(select StudentNo from  Student where ClassId=@classid) and StudentResult&lt;60)
end

go
declare @subjectName nvarchar(50)='office' --科目名称
declare @subjectId int--科目ID
declare @classid int =(select classid from Subject where SubjectName=@subjectName) --查询当前科目属于那一个班级
set @subjectId=(select SubjectId from Subject where SubjectName=@subjectName) --获取科目ID
declare @totalCount int --总人数
set @totalCount=(select COUNT(*) from Student where ClassId=@classid)
print @totalcount --14
declare @unpassNum int --不及格人数
while(1=1)
 begin
   set @unpassNum=(select COUNT(distinct Studentno) from Result where SubjectId=@subjectId and StudentNo in(select StudentNo  from  Student where ClassId=@classid) and StudentResult&lt;60)
  if(@unpassNum&gt;@totalCount/2)   
    update Result set StudentResult+=2 where SubjectId=@subjectId and StudentNo in(select StudentNo from Student where ClassId=@classid) and StudentResult&lt;=98
  else
     break
 end


</pre>
</div>
<p><strong>15.子查询</strong></p>
<p>子查询：一个查询中包含另外一个查询。被包含的查询就称为子查询，包含它的查询就称父查询。<br />
1.子查询的使用方式：使用（）包含子查询<br />
2.子查询分类：</p>
<p>独立子查询：子查询可以直接独立运行.<br />
查询比“王八”年龄大的学员信息<br />
select * from Student where BornDate&lt;(select BornDate from Student where StudentName='王八')<br />
相关子查询：子查询使用了父查询中的结果<br />
--子查询的三种使用方式<br />
--1.子查询做为条件,子查询接在关系运算符后面&nbsp; &gt;&nbsp; &lt; &gt;= &lt;= = &lt;&gt; !=,如果是接这关系运算符后面，必须保证 子查询只返回一个值<br />
--查询六期班的学员信息<br />
select * from Student where ClassId=(select ClassId from grade where classname='八期班')<br />
--子查询返回的值不止一个。当子查询跟随在 =、!=、&lt;、&lt;=、&gt;、&gt;= 之后，或子查询用作表达式时，这种情况是不允许的。<br />
select * from Student where ClassId=(select ClassId from grade)<br />
--查询八期班以外的学员信息<br />
--当子查询返回多个值(多行一列),可以使用in来指定这个范围<br />
select * from Student where ClassId in(select ClassId from grade where classname&lt;&gt;'八期班')<br />
--当没有用 EXISTS 引入子查询时，在选择列表中只能指定一个表达式。如果是多行多列或者一行多列就需要使用exists<br />
--使用 EXISTS 关键字引入子查询后，子查询的作用就相当于进行存在测试。外部查询的 WHERE 子句测试子查询返回的行是否存在<br />
select * from Student where&nbsp; EXISTS(select * from grade)<br />
select * from Student where&nbsp; ClassId in(select * from grade)</p>
<p>--2.子查询做为结果集--<br />
select top 5 * from Student --前五条<br />
--使用top分页<br />
select top 5 * from Student where StudentNo not in(select top 5 studentno from Student)<br />
--使用函数分页&nbsp; ROW_NUMBER() over(order by studentno),可以生成行号,排序的原因是因为不同的排序方式获取的记录顺序不一样<br />
select ROW_NUMBER() over(order by studentno),* from Student<br />
--查询拥有新生成行号的结果集&nbsp; 注意:1.子查询必须的别名&nbsp; 2.必须为子查询中所有字段命名,也就意味着需要为新生成的行号列命名<br />
select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;0 and temp.id&lt;=5<br />
select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;5 and temp.id&lt;=10<br />
select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;10 and temp.id&lt;=15</p>
<p>--3.子查询还可以做为列的值<br />
select (select studentname from student where studentno=result.studentno),(select subjectname from subject where subjectid=result.SubjectId), StudentResult from Result</p>
<p>--使用Row_number over()实现分页<br />
--1.先写出有行号的结果集<br />
select ROW_NUMBER() over(order by studentno),* from Student<br />
--2.查询有行号的结果集 子查询做为结果集必须添加别名，子查询的列必须都有名称<br />
select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where id&gt;0 and id&lt;=5<br />
--查询年龄比“廖杨”大的学员，显示这些学员的信息<br />
select * from Student where BornDate&lt;(select BornDate from Student where StudentName='廖杨')<br />
--查询二期班开设的课程<br />
select * from Subject where ClassId=(select ClassId from grade where classname='二期班')<br />
--查询参加最近一次“office”考试成绩最高分和最低分<br />
--1查询出科目 ID<br />
select subjectid fromSubjectwhereSubjectName='office'--2.查询出这一科目的考试日期select MAX(ExamDate)fromResultwhereSubjectId=(select subjectid fromSubjectwhereSubjectName='office')--3,写出查询的框架select MAX(StudentResult),MIN(StudentResult)fromResultwhereSubjectId=()andExamDate=()--4.使用子查询做为条件select MAX(StudentResult),MIN(StudentResult)fromResultwhereSubjectId=(select subjectid fromSubjectwhereSubjectName='office')andExamDate=(select MAX(ExamDate)fromResultwhereSubjectId=(select subjectid fromSubjectwhereSubjectName='office'))<br />
</p>
<p><strong>16.表连接Join</strong></p>
<p>--1.inner join :能够找到两个表中建立连接字段值相等的记录<br />
--查询学员信息显示班级名称<br />
<span style="color: #0000ff">select Student.StudentNo,Student.StudentName,grade.classname<br />
from Student<br />
inner join grade on Student.ClassId=grade.ClassId</span><br />
--左连接: 关键字前面的表是左表，后面的表是右表<br />
--左连接可以得到左表所有数据，如果建立关联的字段值在右表中不存在，那么右表的数据就以null值替换<br />
<span style="color: #0000ff">select PhoneNum.*,PhoneType.*<br />
from&nbsp;&nbsp; PhoneNum&nbsp; <br />
left join&nbsp; PhoneType on PhoneNum.pTypeId=PhoneType.ptId<br />
</span>--右连接: 关键字前面的表是左表，后面的表是右表<br />
--右连接可以得到右表所有数据，如果建立关联的字段值在右左表中不存在，那么左表的数据就以null值替换<br />
<span style="color: #0000ff">select PhoneNum.*,PhoneType.*<br />
from&nbsp;&nbsp; PhoneNum&nbsp; <br />
right join&nbsp; PhoneType on PhoneNum.pTypeId=PhoneType.ptId<br />
</span>--full join :可以得到左右连接的综合结果--去重复<br />
<span style="color: #0000ff">select PhoneNum.*,PhoneType.*<br />
from&nbsp;&nbsp; PhoneNum&nbsp; <br />
full join&nbsp; PhoneType on PhoneNum.pTypeId=PhoneType.ptId<br />
</span></p>
<p><strong>17.事务</strong><br />
</p>
<p>一种处理机制。以事务处理的操作，要么都能成功执行，要么都不执行。</p>
<p>事务的四个特点 ACID：</p>
<p>A：原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分<br />
C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致<br />
I：隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响<br />
D：持久性：如果事务一旦提交，就对数据的修改永久保留<br />
使用事务：</p>
<p>将你需要操作的sql命令包含在事务中。</p>
<p>1.在事务的开启和事务的提交之间<br />
2.在事务的开启和事务的回滚之间</p>
<p>三个关键语句：</p>
<p>开启事务：begin transaction<br />
提交事务：commit transaction<br />
回滚事务：rollback transaction<br />
declare @num int =0 --记录操作过程中可能出现的错误号<br />
begin transaction<br />
&nbsp; update bank set cmoney=cmoney-500 where name='aa'<br />
&nbsp; set @num=@num+@@ERROR<br />
&nbsp; --说明这一句的执行有错误&nbsp; 但是不能在语句执行的过程中进行提交或者回滚<br />
&nbsp; --语句块是一个整体，如果其中一句进行了提交或者回滚，那么后面的语句就不再属于当前事务，<br />
&nbsp; --事务不能控制后面的语句的执行<br />
</p>
<div class="phpstudycode">
<pre class="brush:sql;">
 update bank set cmoney=cmoney+500 where name='bb'
 set @num=@num+@@ERROR
 select * from bank
  if(@num&lt;&gt;0 ) --这个@@ERROR只能得到最近一一条sql语句的错误号
   begin 
   print '操作过程中有错误，操作将回滚' 
   rollback transaction
  end 
  else 
   begin 
   print '操作成功' 
   commit transaction 
  end
</pre>
</div>
<p>&nbsp;&nbsp;&nbsp; --事务一旦开启，就必须提交或者回滚<br />
&nbsp;&nbsp;&nbsp; --事务如果有提交或者回滚，必须保证它已经开启<br />
</p>
<p><strong>18.视图</strong></p>
<p>视图就是一张虚拟表，可以像使用子查询做为结果集一样使用视图。</p>
<p>select * from vw_getinfo<br />
使用代码创建视图。</p>
<p>语法：</p>
<p>create view vw_自定义名称<br />
as<br />
查询命令<br />
go<br />
--查询所有学员信息<br />
if exists(select * from sysobjects where name='vw_getAllStuInfo')<br />
&nbsp;drop view vw_getAllStuInfo<br />
go --上一个批处理结果的标记<br />
create view vw_getAllStuInfo<br />
as<br />
--可以通过聚合函数获取所以记录数<br />
&nbsp;select top (select COUNT(*) from Student) Student.StudentNo,Student.StudentName,grade.ClassId,grade.classname from Student<br />
inner join grade on Student.ClassId=grade.ClassId&nbsp; order by StudentName --视图中不能使用order by<br />
--select * from grade --只能创建一个查询语句<br />
--delete from grade where ClassId&gt;100 --在视图中不能包含增加删除修改<br />
go</p>
<p>--使用视图。。就像使用表一样<br />
select * from vw_getAllStuInfo <br />
--对视图进行增加删除和修改操作--可以对视图进行增加删除和修改操作,只是建议不要这么做:所发可以看到：如果操作针对单个表就可以成功，但是如果 多张的数据就会报错：不可更新，因为修改会影响多个基表。<br />
update vw_getAllStuInfo set classname='asdas' ,studentname='aa' where studentno=1<br />
</p>
<p><strong>19.触发器</strong></p>
<p>触发器：执行一个可以改变表数据的操作（增加删除和修改），会自动触发另外一系列（类似于存储过程中的模块）的操作。</p>
<p>语法：</p>
<p>create trigger tr_表名_操作名称<br />
on 表名 after|instead of 操作名称<br />
as<br />
go<br />
if exists(select * from sysobjects where name='tr_grade_insert')<br />
&nbsp;drop trigger tr_grade_insert<br />
go<br />
create trigger tr_grade_insert<br />
on grade for&nbsp; insert&nbsp; ---为grade表创建名称为tr_grade_insert的触发器，在执行insert操作之后触发<br />
as<br />
declare @cnt int <br />
set @cnt = (select count(*) from student)<br />
&nbsp;select * ,@cnt from student<br />
select * from grade <br />
go<br />
--触发器不是被调用的，而是被某一个操作触 发的，意味着执行某一个操作就会自动触发 触发器<br />
insert into grade values('fasdfdssa')<br />
---替换触 发器：本来需要执行某一个操作，结果不做了，使用触 发器中的代码语句块进行替代</p>
<p>if exists(select * from sysobjects where name='tr_grade_insert')<br />
&nbsp;drop trigger tr_grade_insert<br />
go<br />
create trigger tr_grade_insert<br />
on grade instead of insert&nbsp; ---为grade表创建名称为tr_grade_insert的触发器，在执行insert操作之后触发<br />
as<br />
declare @cnt int <br />
set @cnt = (select count(*) from student)<br />
&nbsp;select * ,@cnt from student<br />
select * from grade <br />
go</p>
<p>insert into grade values('aaaaaaaaaaaa')<br />
go</p>
<p>---触 发器的两个临时表：<br />
--inserted: 操作之后的新表:所有新表与原始的物理表没有关系，只与当前操作的数据有关<br />
--deleted:操作之前的旧表：所有新表与原始的物理表没有关系，只与当前操作的数据有关</p>
<p>if exists(select * from sysobjects where name='tr_grade_insert')<br />
&nbsp;drop trigger tr_grade_insert<br />
go<br />
create trigger tr_grade_insert<br />
on grade after insert <br />
as<br />
&nbsp;print '操作之前的表：操作之前，这一条记录还没有插入，所以没有数据'<br />
&nbsp;select * from deleted <br />
&nbsp;print '操作之后的表：已经成功插入一条记录，所有新表中有一条记录'<br />
&nbsp;select * from inserted&nbsp; <br />
go<br />
--测试：<br />
insert into grade values('aaaaa')</p>
<p>if exists(select * from sysobjects where name='tr_grade_update')<br />
&nbsp;drop trigger tr_grade_update<br />
go<br />
create trigger tr_grade_update<br />
on grade after update <br />
as<br />
&nbsp;print '操作之前的表：存储与这个修改操作相关的没有被修改之前的记录'<br />
&nbsp;select * from deleted <br />
&nbsp;print '操作之后的表：存储这个操作相关的被修改之后 记录'<br />
&nbsp;select * from inserted&nbsp; <br />
go<br />
--测试<br />
update grade set classname=classname+'aa' where&nbsp; ClassId&gt;15</p>
<p>if exists(select * from sysobjects where name='tr_grade_delete')<br />
&nbsp;drop trigger tr_grade_delete<br />
go<br />
create trigger tr_grade_delete<br />
on grade after delete <br />
as<br />
&nbsp;print '操作之前的表：存储与这个修改操作相关的没有被删除之前的记录'<br />
&nbsp;select * from deleted <br />
&nbsp;print '操作之后的表：存储这个操作相关的被删除之后 记录--没有记录'<br />
&nbsp;select * from inserted&nbsp; <br />
go</p>
<p>--测试<br />
delete from grade where ClassId&gt;15<br />
</p>
<p><strong>20.存储过程</strong></p>
<p>存储过程就相当于c#中的方法<br />
参数，返回值，参数默认值，参数：值的方式调用<br />
在调用的时候有三个对应：类型对应，数量对应，顺序对应。</p>
<p>创建语法：</p>
<p>create proc usp_用户自定义名称<br />
对应方法的形参 --(int age, out string name)<br />
as<br />
对应方法体:创建变量,逻辑语句,增加删除修改和查询..return返回值<br />
go<br />
调用语法：</p>
<p>exec 存储过程名称 实参，实参，实参 ...<br />
--获取所有学员信息<br />
if exists(select * from sysobjects where name='usp_getAllStuInfo')<br />
&nbsp;drop proc usp_getAllStuInfo <br />
go <br />
create procedure usp_getAllStuInfo<br />
as<br />
&nbsp;select * from Student<br />
go <br />
--调用存储过程，获取的有学员信息<br />
execute usp_getAllStuInfo</p>
<p>--exec sp_executesql&nbsp; 'select * from Student'</p>
<p>--查询指定性别的学员信息<br />
go<br />
if exists(select * from sysobjects where name='usp_getAllStuInfoBySex')<br />
&nbsp;drop proc usp_getAllStuInfoBySex <br />
go <br />
create procedure usp_getAllStuInfoBySex<br />
&nbsp;@sex nchar(1) --性别&nbsp; 参数不需要declare<br />
as<br />
&nbsp;select * from Student where Sex=@sex<br />
go<br />
--调用存储过程，获取指定性别的学员信息<br />
Exec usp_getAllStuInfoBySex '女'</p>
<p>--创建存储过程获取指定班级和性别的学员信息<br />
go<br />
if exists(select * from sysobjects where name='usp_getAllStuInfoBySexandClassName')<br />
&nbsp;drop proc usp_getAllStuInfoBySexandClassName <br />
go <br />
create procedure usp_getAllStuInfoBySexandClassName<br />
&nbsp;@classname nvarchar(50), --班级名称 <br />
&nbsp;@sex nchar(1)='男'--性别&nbsp;&nbsp; 有默认的参数建议写在参数列表的最后<br />
as<br />
&nbsp;declare&nbsp; @classid int ---班级ID<br />
set @classid=(select classid from grade where classname=@classname) --通过参数班级名称获取对应的班级ID <br />
&nbsp;select * from Student where Sex=@sex and ClassId=@classid<br />
go<br />
--执行存储过程获取指定班级和性别的学员信息<br />
--exec usp_getAllStuInfoBySexandClassName '八期班'<br />
exec usp_getAllStuInfoBySexandClassName default, '八期班'&nbsp; --有默认值的参数可以传递default<br />
exec usp_getAllStuInfoBySexandClassName @classname='八期班'&nbsp;&nbsp;&nbsp; --也可以通过参数=值的方式调用<br />
exec usp_getAllStuInfoBySexandClassName @classname='八期班'&nbsp; ,@sex='女'<br />
exec usp_getAllStuInfoBySexandClassName @classname='八期班',@sex='女'</p>
<p>--创建存储过程,获取指定性别的学员人数及总人数<br />
go<br />
if exists(select * from sysobjects where name='usp_getCountBySexandClassName')<br />
&nbsp;drop proc usp_getCountBySexandClassName <br />
go <br />
create procedure usp_getCountBySexandClassName<br />
@cnt int=100 output, --output标记说明它是一个输出参数。output意味着你向服务器请求这个参数的值，那么在执行的时候，服务器发现这个参数标记了output，就会将这个参数的值返回输出<br />
@totalnum int =200output, --总人数<br />
@className nvarchar(50), --输入参数没有默认值，在调用的时候必须传入值<br />
@sex nchar(1)='男'--输入参数有默认值，用户可以选择是否传入值<br />
as<br />
&nbsp;declare&nbsp; @classid int ---班级ID<br />
&nbsp;set @classid=(select classid from grade where classname=@classname) --通过参数班级名称获取对应的班级ID <br />
&nbsp;select * from Student where Sex=@sex and ClassId=@classid<br />
set @cnt= (select COUNT(*) from Student where Sex=@sex and ClassId=@classid) --获取指定班级和性别的总人数<br />
set @totalnum=(select COUNT(*) from Student) ----获取总人数<br />
go<br />
--调用存储过程,获取指定性别的学员人数及总人数<br />
declare @num int,@tnum int<br />
exec usp_getCountBySexandClassName @cnt=@num output ,@totalnum=@tnum output , @className='八期班'<br />
print @num<br />
print @tnum<br />
print '做完了'<br />
---获取指定班级的人数<br />
if exists(select * from sysobjects where name='usp_getCount')<br />
&nbsp;drop proc usp_getCount <br />
go <br />
create procedure usp_getCount<br />
&nbsp;@className nvarchar(50)='八期班'<br />
as<br />
declare @classid int=(select classid from grade where classname=@className)<br />
&nbsp;declare @cnt int<br />
set @cnt =(select COUNT(*) from Student where ClassId=@classid) <br />
--return 只能返回int整数值<br />
--return '总人数是'+cast(@cnt as varchar(2))<br />
return @cnt <br />
go</p>
<p>--调用存储过程，接收存储过程的返回值<br />
declare @count int<br />
--set @count=(exec usp_getCount)<br />
exec @count=usp_getCount '八期班'<br />
print @countif exists(select*from sysobjects where name='usp_getClassList')<br />
&nbsp;drop proc usp_getClassList <br />
go <br />
create procedure usp_getClassList<br />
asselect classid,classname from grade<br />
go<br />
</p>
<p><strong>21.分页存储过程</strong></p>
<p>if exists(select * from sysobjects where name='usp_getPageData')<br />
&nbsp;drop proc usp_getPageData <br />
go <br />
create procedure usp_getPageData<br />
@totalPage int output,--总页数<br />
@pageIndex int =1 ,--当前页码，默认是第一页<br />
@pageCount int =5 --每一页显示的记录数<br />
as<br />
select * from (select ROW_NUMBER() over(order by studentno) id,* from Student) temp where temp.id&gt;(@pageindex-1)*@pagecount and temp.id&lt;=(@pageindex*@pagecount)<br />
set @totalPage=CEILING((select COUNT(*) from Student)*1.0/@pageCount)<br />
go<br />
</p>
<p><strong>22.索引</strong></p>
<p>select * from sysindexes</p>
<p>--create&nbsp; index IX_Student_studentName<br />
--on 表名(字段名)</p>
<p>--clustered index:聚集索引&nbsp; nonclustered index--非聚集索引<br />
if exists(select * from sysindexes where name='IX_Student_studentName')<br />
&nbsp;drop index student.IX_Student_studentName<br />
go <br />
create clustered index IX_Student_studentName<br />
on student(studentname)</p>
<p>--如果是先创建主键再创建聚集索引就不可以，因为主键默认就是聚集索引<br />
--但是如果先创建聚集索引，那么还可以再创建主键，因为主键不一定需要是聚集的<br />
</p>
<p><strong>23.临时表</strong></p>
<p>--创建局部临时表<br />
create table #newGrade<br />
(<br />
&nbsp;classid int ,<br />
&nbsp;classname nvarchar(50) <br />
)<br />
---局部临时表只有在当前创建它的会话中使用，离开这个会话临时表就失效.如果关闭创建它的会话，那么临时表就会消失<br />
insert into #newGrade select * from&nbsp; grade <br />
select * from #newGrade<br />
select * into #newnewnew from grade<br />
select * into newGrade from #newgrade</p>
<p>--创建全局临时表:只要不关闭当前会话，全局临时表都可以使用，但是关闭当前会话，全局临时表也会消失<br />
create table ##newGrade<br />
(<br />
&nbsp;classid int ,<br />
&nbsp;classname nvarchar(50) <br />
)<br />
drop table ##newGrade<br />
select * into ##newGrade from grade<br />
select * from ##newGrade</p>
<p>--创建表变量<br />
declare @tb table(cid int,cname nvarchar(50))<br />
insert into @tb select * from grade<br />
select * from @tb</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/90220.html'>PHP获取一年中每个星期的开始和结束日期的方法</a><a>下一篇</a><a href='/php/biji/90222.html'>php去掉文件前几行的方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>