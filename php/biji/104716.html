<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>解读ASP.NET 5 & MVC6系列教程（11）：Routing路由_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="新版Routing功能介绍<br />
在ASP.NET 5和MVC6中，Routing功能被全部重写了，虽然用法有些类似，但和之前的Routing原理完全不太一样了，该Routing框架不仅可以支持MVC和Web API，还支持一般" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">解读ASP.NET 5 & MVC6系列教程（11）：Routing路由</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>新版Routing功能介绍<br />
在ASP.NET 5和MVC6中，Routing功能被全部重写了，虽然用法有些类似，但和之前的Routing原理完全不太一样了，该Routing框架不仅可以支持MVC和Web API，还支持一般</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><b>新版Routing功能介绍</b></p>
<p>在ASP.NET 5和MVC6中，Routing功能被全部重写了，虽然用法有些类似，但和之前的Routing原理完全不太一样了，该Routing框架不仅可以支持MVC和Web API，还支持一般的ASP.NET5程序。新版的改变有如下几个部分。</p>
<p>首先，Routing系统是基于ASP.NET 5的，是一个独立于MVC的路由框架，而不是基于MVC的。MVC只是在上面扩展了一个快捷方式而已。</p>
<p>其次，在ASP.NET 5中，MVC和Web API控制器没有区别了，即合二为一了。两者派生于同一个Controller基类。也就是说该Routing框架是适用于两者的，适用于MVC则意味着也适用于Web API。</p>
<p>最后，不管在基于约定的Route声明还是基于Attribute的Route声明，都可以使用内联约束和参数选项。例如，你可以约定路由中某个参数的数据类型，也可以让一个参数标记为可选类型，再或者给其提供一个默认值。</p>
<p><b>Routing框架的主要流程</b></p>
<p>基本的Routing框架是基于Middleware来实现的，这样就可以将其添加到HTTP的请求Pipeline中了，它可以喝其它任意Middleware一起进行组合使用，如静态文件处理程序、错误页、或者SignalR服务器。</p>
<p>在使用Routing框架之前，首要要了解Routing的作用，作用很简单：</p>
<p>对于HTTP请求，Routing系统负责找出与之匹配的route，创建route数据，并将该请求派送到该route对于的处理程序（Handler）上。Controller和Action的选择，只是MVC的Handler的一个具体实现，该实现使用route数据和HTTP请求中的其它信息来选择要执行的Controller和Action。在新版的MVC6中，该处理程序的名称为MvcRouteHandler。</p>
<p>路由系统的执行流程如下：</p>
<p>ASP.NET 5监听到一个HTTP请求。然后Routing Middleware就会尝试将route集合中的route匹配该请求。一旦成功匹配一个请求，就找出该route对应的handler。调用该handler上的RouteAsync方法（因为所有的handler都要实现该接口方法）。RoutingContext有一个IsHandled标记，如果该标记设置为true，则意味着该请求已经被这个handler成功处理了；如果设置为false，则意味着该handler无法处理该请求，系统会再为此匹配一个route。</p>
<p>和之前的Routing系统有点不同的是，老版的Routing系统一旦成功匹配一个路由，就将其交由其对应的Handler，不管对应的Handler能不能处理该请求，所以就会出现route匹配成功了，但是找不到对应的action，此时就会出现404错误，而新版对此作出了上述第4步骤的改进（重新将控制权交回给Routing系统，进行重新匹配），看起来还是非常不错的。</p>
<p><b>Route参数和约束条件的改进</b></p>
<p>在之前的route设置中，要约束一个参数的数据类型的话，我们需要使用类型如下代码：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
routes.MapRoute(
 "Product", 
 "Product/{productId}", 
 defaults: new { controller = "Product", action = "Details" },
 constraints: new { productId = @"\d+" });</pre>
</div>
<p>而在新版route中，就可以直接设置<code>Product/{productId:int}</code>了，约束条件遵守如下约定：</p>
<p><code>{parameter:constraint}</code></p>
<p>目前支持的约束如下：</p>
<table class="jbboder">
<thead>
<tr>
<th>约束</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>required</td>
<td>"Product/{ProductName:required}"</td>
<td>参数必选</td>
</tr>
<tr>
<td>alpha</td>
<td>"Product/{ProductName:alpha}"</td>
<td>匹配字母，大小写不限</td>
</tr>
<tr>
<td>int</td>
<td>"Product/{ProductId:int}"</td>
<td>匹配int类型</td>
</tr>
<tr>
<td>long</td>
<td>"Product/{ProductId:long}"</td>
<td>匹配long类型</td>
</tr>
<tr>
<td>bool</td>
<td>"Product/{ProductId:bool}"</td>
<td>匹配bool类型</td>
</tr>
<tr>
<td>double</td>
<td>"Product/{ProductId:double}"</td>
<td>匹配double类型</td>
</tr>
<tr>
<td>float</td>
<td>"Product/{ProductId:float}"</td>
<td>匹配float类型</td>
</tr>
<tr>
<td>guid</td>
<td>"Product/{ProductId:guid}"</td>
<td>匹配guid类型</td>
</tr>
<tr>
<td>decimal</td>
<td>"Product/{ProductId:decimal}"</td>
<td>匹配decimal类型</td>
</tr>
<tr>
<td>datetime</td>
<td>"Search/{datetime:datetime}"</td>
<td>匹配datetime类型</td>
</tr>
<tr>
<td>composite</td>
<td>"Product/{ProductId:composite}"</td>
<td>匹配composite类型</td>
</tr>
<tr>
<td>length</td>
<td>"Product/{ProductName:length(5)}"</td>
<td>长度必须是5个字符</td>
</tr>
<tr>
<td>length</td>
<td>"Product/{ProductName:length(5, 10)}"</td>
<td>长度在5-10个之间</td>
</tr>
<tr>
<td>maxlength</td>
<td>"Product/{productId:maxlength(10)}"</td>
<td>最大长度为10</td>
</tr>
<tr>
<td>minlength</td>
<td>"Product/{productId:minlength(3)}"</td>
<td>最小长度为3</td>
</tr>
<tr>
<td>min</td>
<td>"Product/{ProductID:min(3)}"</td>
<td>大于等于3</td>
</tr>
<tr>
<td>max</td>
<td>"Product/{ProductID:max(10)}"</td>
<td>小于等于10</td>
</tr>
<tr>
<td>range</td>
<td>"Product/{ProductID:range(5, 10)}"</td>
<td>对应的数组在5-10之间</td>
</tr>
<tr>
<td>Regex</td>
<td>"Product/{productId:regex(^\d{4}$)}"</td>
<td>符合指定的正则表达式</td>
</tr>
</tbody>
</table>
<p>而对于可选参数，则值需要在约束类型后面加一个问号即可，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
routes.MapRoute(
 "Product", 
 "Product/{productId:long&#63;}", 
 new { controller = "Product", action = "Details" });</pre>
</div>
<p>如果参数是必填的，需要保留一个默认值的话，则可以按照如下示例进行设置：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
routes.MapRoute(
 "Product", 
 "Product/{productId:long=1000}",
 new { controller = "Product", action = "Details" });</pre>
</div>
<p><b>通用Routing</b></p>
<p>关于示例使用，我们先不从MVC开始，而是先从普通的Routing使用方式开始，新版route添加的时候默认添加的是<code>TemplateRoute</code>实例，并且在该实例实例化的时候要设置一个<code>Handler</code>。</p>
<p>举例来说，我们先创建一个空的ASP.NET 5项目，并在project.json文件的dependencies节点中添加程序集<code>"Microsoft.AspNet.Routing": "1.0.0-beta3"</code>,，在<code>Startup.cs</code>的<code>Configure</code>方法里添加如下代码：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public void Configure(IApplicationBuilder app)
{
 RouteCollection routes = new RouteCollection();
 routes.Add(new TemplateRoute(new DebuggerRouteHandler("RouteHandlerA"), "", null));
 routes.Add(new TemplateRoute(new DebuggerRouteHandler("RouteHandlerB"), "test/{a}/{b:int}", null));
 routes.Add(new TemplateRoute(new DebuggerRouteHandler("RouteHandlerC"), "test2", null));

 app.UseRouter(routes); // 开启Routing功能
}</pre>
</div>
<p>在这里，我们设置HTTP请求处理的的Handler为<code>DebuggerRouteHandler</code>，该类继承于<code>IRouter</code>，实例代码如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class DebuggerRouteHandler : IRouter
{
 private string _name;

 public DebuggerRouteHandler(string name)
 {
 _name = name;
 }

 public string GetVirtualPath(VirtualPathContext context)
 {
 throw new NotImplementedException();
 }

 public async Task RouteAsync(RouteContext context)
 {
 var routeValues = string.Join("", context.RouteData.Values);
 var message = String.Format("{0} Values={1} ", _name, routeValues);
 await context.HttpContext.Response.WriteAsync(message);
 context.IsHandled = true;
 }
}</pre>
</div>
<p>上述类，继承<code>IRouter</code>以后，必须实现一个<code>RouteAsync</code>的方法，并且如果处理成功，则将<code>IsHandled</code>设置为<code>true</code>。</p>
<p>访问如下网址即可查看相应的结果：</p>
<div class="phpstudycode">
<pre class="brush:ps;">
正常：`http://localhost:5000/`
正常：`http://localhost:5000/test/yyy/12`
404 ：`http://localhost:5000/test/yyy/s`
正常：`http://localhost:5000/test2`
404 ：`http://localhost:5000/test3`</pre>
</div>
<p>注意：<code>TemplateRoute</code>和<code>DebuggerRouteHandler</code>都继承于<code>IRouter</code>，是实现前面所述的不出现404错误（继续匹配下一个路由）的核心。</p>
<p><b>MVC中的Routing</b></p>
<p>在MVC示例程序中，我们只需要配置在调用<code>app.UseMVC</code>方法的时候，使用委托中的<code>MapRoute</code>方法来定义各种route就可以了。在这里我们以空白项目为例，来看看MVC的route如何使用。</p>
<p>第一步：在project.json文件的dependencies节点中引用程序集<code>"Microsoft.AspNet.Mvc": "6.0.0-beta3"</code>，<br />
第二部：添加MVC的Middleware，并使用MVC，然后添加一条默认的路由，代码如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public void ConfigureServices(IServiceCollection services)
{
 services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
 app.UseMvc(routeBuilder =&gt;
 {
 routeBuilder.MapRoute(
  name: "default",
  template: "{controller}/{action}/{id&#63;}",
  defaults: new { controller = "Home", action = "Index" });
 });
}</pre>
</div>
<p>第三步：分别创建如下如下三种Controller，其中<code>ProductsController</code>继承于<code>Microsoft.AspNet.Mvc</code>下的<code>Controller</code>。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class ProductsController : Controller
{
 public IActionResult Index()
 {
 return Content("It Works with Controller Base Class!");
 }
}

public class DemoController
{
 public IActionResult Index()
 {
 return new ObjectResult("It Works without Controller Base Class!");
 }
}

public class APIController
{
 public object Index()
 {
 return new { Code = 100000, Data = "OK" };
 }
}</pre>
</div>
<p>访问<code>http://localhost:5000/products</code>和<code>http://localhost:5000/demo</code>，均能显示正常的输出结果；而访问<code>http://localhost:5000/api</code>的时候返回的则是json数据。</p>
<p>这就是我们在前面ASP.NET5新特性中所讲的MVC和API合二为一了，并且也可以不继承于Controller基类（但类名要以Controller结尾）。这种技术的核心是Controller的查找机制，关于如何在一个项目中查找合适的程序集，请参考《Controller与Action》章节。</p>
<p>新版MVC在判定Controller的时候，有2个条件：要么继承于Controller，要么是引用MVC程序集并且类名以Controller结尾。</p>
<p>所以，在创建MVC Controller和Web API Controller的时候，如果你不需要相关的上下文（如HTTPContext、ActionContext等）的话，则可以不必继承于Controller基类；但推荐都继承于Controller，因为可以多多利用基类的方法和属性，因为不管继承不继承，你定义的所有Controller类都要走MVC的各个生命周期，我们通过ActionFilter来验证一下：</p>
<p>第一步：在project.json文件的dependencies节点中引用程序集<code>"Microsoft.AspNet.Server.WebListener": "1.0.0-beta3"</code>。<br />
第二步：创建一个Aciton Filter，分别在Action执行前和执行后输出一行文字，代码如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class ActionFilterTest : IActionFilter
{
 public void OnActionExecuting(ActionExecutingContext context)
 {
  var typeName = context.Controller.GetType().FullName;
  Console.WriteLine(typeName + "." + context.ActionDescriptor.Name + ":Start");
 }

 public void OnActionExecuted(ActionExecutedContext context)
 {
  var typeName = context.Controller.GetType().FullName;
  Console.WriteLine(typeName + "." + context.ActionDescriptor.Name + ":END");
 }
}</pre>
</div>
<p>第三步：在ConfigureServices方法里注册该Action Filter。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
services.Configure&lt;MvcOptions&gt;(options =&gt;
{
 options.Filters.Add(typeof(ActionFilterTest));
});</pre>
</div>
<p>运行程序，并访问响应的路径，三种类型的代码均会按计划输出内容，输出内容如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
RouterTest.ProductsController.Index:Start
RouterTest.ProductsController.Index:End
RouterTest.DemoController.Index:Start
RouterTest.DemoController.Index:End
RouterTest.APIController.Index:Start
RouterTest.APIController.Index:End</pre>
</div>
<p>普通的ASP.NET5程序和MVC程序是可以在一起混合使用Routing功能的。</p>
<p><b>自定义Route</b></p>
<p>ASP.NET 5和MVC6都提供了丰富的Route自定义功能，关于普通Route的自定义，可以参考前面小节的DebuggerRouteHandler，这种方式需要实现自己的HTTP输出，相当于原来轻量级的IHttpHandler一样。本节，我们将这种在基于MVC的Route自定义功能，即定义的Route的Handler处理程序都是MvcRouteHandler。</p>
<p>在之前版本的MVC中，要自定义Route，一般都是继承于RouteBase基类或Route类；而在新版的MVC6中，要实现自定义Route，有三种方式，分别如下：</p>
<p>继承于TemplateRoute实现IRouter实现INamedRouter（注：INamedRouter和IRouter的唯一区别是多了一个名称）</p>
<p>本例中，我们以继承继承于TemplateRoute为例，首先创建一个继承于该类的子类<code>PromoTemplateRoute</code>，该类只匹配<code>/promo</code>目录下的路径。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class PromoTemplateRoute : TemplateRoute
{
 public PromoTemplateRoute(IRouter target, string routeTemplate, IInlineConstraintResolver inlineConstraintResolver)
  : base(target, routeTemplate, inlineConstraintResolver: inlineConstraintResolver)
 {
 }

 public PromoTemplateRoute(IRouter target,
       string routeTemplate,
       IDictionary&lt;string, object&gt; defaults,
       IDictionary&lt;string, object&gt; constraints,
       IDictionary&lt;string, object&gt; dataTokens,
       IInlineConstraintResolver inlineConstraintResolver)
  : base(target, routeTemplate, defaults, constraints, dataTokens, inlineConstraintResolver)
 {
 }

 public PromoTemplateRoute(IRouter target,
       string routeName,
       string routeTemplate,
       IDictionary&lt;string, object&gt; defaults,
       IDictionary&lt;string, object&gt; constraints,
       IDictionary&lt;string, object&gt; dataTokens,
       IInlineConstraintResolver inlineConstraintResolver)
  : base(target, routeName, routeTemplate, defaults, constraints, dataTokens, inlineConstraintResolver)
 { }

 public async override Task RouteAsync(RouteContext context)
 {
  var requestPath = context.HttpContext.Request.Path.Value &#63;&#63; string.Empty;
  if (!requestPath.StartsWith("/promo", StringComparison.OrdinalIgnoreCase))
  {
   return;
  }
  await base.RouteAsync(context);
 }
}</pre>
</div>
<p>为了方便使用，我们也比葫芦画瓢，创建一些扩展方法，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public static class RouteBuilderExtensions
{
 public static IRouteBuilder MapPromoRoute(this IRouteBuilder routeCollectionBuilder, string name, string template)
 {
  MapPromoRoute(routeCollectionBuilder, name, template, defaults: null);
  return routeCollectionBuilder;
 }

 public static IRouteBuilder MapPromoRoute(this IRouteBuilder routeCollectionBuilder, string name, string template, object defaults)
 {
  return MapPromoRoute(routeCollectionBuilder, name, template, defaults, constraints: null, dataTokens: null);
 }

 public static IRouteBuilder MapPromoRoute(this IRouteBuilder routeCollectionBuilder, string name, string template, object defaults, object constraints, object dataTokens)
 {
  var inlineConstraintResolver = routeCollectionBuilder.ServiceProvider.GetService&lt;IInlineConstraintResolver&gt;();
  routeCollectionBuilder.Routes.Add(
   new PromoTemplateRoute(
    routeCollectionBuilder.DefaultHandler,
    name,
    template,
    ObjectToDictionary(defaults),
    ObjectToDictionary(constraints),
    ObjectToDictionary(dataTokens),
    inlineConstraintResolver));

  return routeCollectionBuilder;
 }

 private static IDictionary&lt;string, object&gt; ObjectToDictionary(object value)
 {
  var dictionary = value as IDictionary&lt;string, object&gt;;
  if (dictionary != null)
  {
   return dictionary;
  }

  return new RouteValueDictionary(value);
 }
}</pre>
</div>
<p>使用的时候，则很简单，和之前的方式非常类似，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
routes.MapPromoRoute(
 name: "default2",
 template: "promo/{controller}/{action}/{id&#63;}",
 defaults: new { controller = "Home", action = "Index" });</pre>
</div>
<p>通过这种方式，我们可以在符合路由匹配条件的时候，使用<code>PromoTemplateRoute</code>类来处理一些自定义逻辑，比如添加一些额外的文件头信息等等。</p>
<p><b>基于Attribute的Routing</b></p>
<p>基于Attribute的Routing功能一直是MVC所期待的功能，在Web API已经通过<code>RoutePrefix</code>（Controller上使用）和<code>Route</code>（Action上使用）来实现了。该特性在MVC 6中进行了重写和增强，并且由于MVC和Web API合二而一了，所以在这两种Controller上都可以使用该特性。</p>
<p>举例来说：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("bookhome")]
public class HomeController : Controller
{
 public IActionResult Index()
 {
  return View();
 }

 [Route("about")]
 public IActionResult About()
 {
  ViewBag.Message = "Your application description page.";
  return View();
 }

 [Route("contactus")]
 public IActionResult Contact()
 {
  ViewBag.Message = "Your contact page.";
  return View();
 }
}</pre>
</div>
<p></p>
<p>在上述Controller上定义一个bookhome前缀，并且在About和Contact上又分别定义了action名称，所以上述3个Action的访问地址则是如下这种形式：</p>
<div class="phpstudycode">
<pre class="brush:ps;">
/bookhome
/bookhome/about
/bookhome/contactus</pre>
</div>
<p>在这里，我们需要注意，Controller和Action使用的<code>Attribute</code>都是<code>Route</code>，同时，在这些路由模板字符串中，依然可以使用内联参数，比如，我们可以定义类似这样的路由：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("products/{productId:int}")]</pre>
</div>
<p><b>Controller和Action标记位</b></p>
<p>另外，针对Route的模板字符串，不仅支持内联参数，还支持Controller和Action的标记位，即不用写死该Controller或Action的名称，使用一个<code>[controller]</code>或<code>[action]</code>的字符即可表示该Controller或Action的名称。比如，我们可以在Controller上定义这样的一个路由（Action上什么都不定义）：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book/[controller]/[action]")]</pre>
</div>
<p>这样访问首页的地址就变成了：<code>/book/Home/Index</code>。</p>
<p><b>Web API的等价Route定义</b></p>
<p>在Web API中，我们一般还要定义GET、POST这样的请求方式，为了方便，新版的HTTPGET等一系列方法都集成了Route功能，直接在构造函数传入Route模板即可，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[HttpGet("products/{productId:int}")]</pre>
</div>
<p>上述Route的定义，即表明，既要符合<code>products/{productId:int}</code>的路由规则，又要是GET请求。</p>
<p>其实HTTPGET这一系列Attribute也可以在普通的MVC Controller上使用，因为在MVC6中，MVC Controller和Web API Controller本身就是同一个东西，只不过MVC的返回类型都是IActionResult而已。Route定义，不仅仅支持GET请求，还支持POST等其它类型的请求，即不限制请求方式。在HttpXXX系列特性中，也是支持内联参数和[controller]、[action]标记位的，大可放心使用。目前可用的特性类有：HttpGet、HttpPost、HttpPut、HttpDelete、HttpPatch。</p>
<p><b>非要重要Route定义规则</b></p>
<p>基于Attribute的Route定义很方便，但也很危险，具体规则和危险性如下。</p>
<p><strong>规则1：Controller上定义了Route特性很危险</strong></p>
<p>一旦在Controller上定义了Route特性，该Controller下的所有路由规则都不受其它规则控制了，比如，如果你定义了类似这样的</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book")]
public class HomeController : Controller
{
 public IActionResult Index()
 {
  return View();
 }

 public IActionResult About()
 {
  ViewBag.Message = "Your application description page.";
  return View();
 }
}</pre>
</div>
<p>那么，上述2个Action你都再也没办法访问了，因为默认的action的名称根本就不会起作用，即<code>/book/index</code>和<code>/book/about</code>这两个路径无法路由到对应的Action方法上。而且<code>/book</code>也访问不了，因为有两个以上的Action，系统无法定位到其中一个Action上。</p>
<p>所以要让上述Action能访问，必须要在其中一个Action上定义再Route，例如：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book")]
public class HomeController : Controller
{
 public IActionResult Index()
 {
  return View();
 }

 [Route("about")]
 public IActionResult About()
 {
  ViewBag.Message = "Your application description page.";
  return View();
 }
}</pre>
</div>
<p>这样，就可以通过<code>/book/about</code>来访问About方法了，而访问<code>/book</code>则可以访问默认的index方法了，因为该index方法是默认唯一一个没有定义路由的方法，所以他就是/book路由规则的默认Action。如果，有3个Action的话，则必须要至少给两个Action定义Route，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book")]
public class HomeController : Controller
{
 [Route("index")]
 public IActionResult Index()
 {
  return View();
 }

 [Route("about")]
 public IActionResult About()
 {
  ViewBag.Message = "Your application description page.";
  return View();
 }
 public IActionResult Contact()
 {
  ViewBag.Message = "Your contact page.";
  return View();
 }
}</pre>
</div>
<p>此时，<code>Contact</code>方法就是默认<code>/book</code>路由的Action了，访问<code>/book</code>路径的话，就会显示Contact对应的页面。</p>
<p><strong>规则2：Route和HttpGet可以一起使用，但也很危险</strong></p>
<p>我们前面提到，在Action上即可以使用Route特性，也可以使用HttpGet特性，两者之间的不同，就是多了一个Http Method。很多同学可以要问两个特性在一起使用的时候会有问题么？</p>
<p>其实，这两个特性是可以在一起使用的，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book")]
public class HomeController : Controller
{
 [Route("Contact")]
 [HttpGet("home/Contact2")]
 public IActionResult Contact()
 {
  ViewBag.Message = "Your contact page.";

  return View();
 }
}</pre>
</div>
<p>这样<code>/book/contact</code>和<code>/book/home/contact2</code>这两个网址，都可以访问了。但如果这里定义HttpGet，情况就不一样了，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("Contact")]
[HttpPost("home/Contact2")]</pre>
</div>
<p>此时，访问该Action的方式，要么是以GET的方式访问<code>/book/contact</code>地址，要么是以POST的方式访问<code>/book/home/contact2</code>。所以为了避免出错，建议使用的时候不要讲两者混用，即便是要同时支持GET和POST，那也是建议用同类型的HttpXXX来定义这些路由，例如：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[HttpGet("Contact")]
[HttpPost("home/Contact2")]</pre>
</div>
<p>这样，看起来就清晰多了。</p>
<p><strong>规则3：多个Route和多个HttpXXX也可以一起使用，但也很危险</strong></p>
<p>在如下示例中，我们为HomeController定义了2个Route特性，而Contact定义了2个Route特性和1个HttpPost特性。</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book")]
[Route("tom")]
public class HomeController : Controller
{
 [Route("Contact")]
 [Route("ContactUS")]
 [HttpPost("home/Contact2")]
 public IActionResult Contact()
 {
  ViewBag.Message = "Your contact page.";
  return View();
 }
}</pre>
</div>
<p>那么，在上述代码生效后，我们将有六种访问来访问该Action，这六种方式分布如下：</p>
<div class="phpstudycode">
<pre class="brush:ps;">
GET：/book/contact
GET：/book/contactus
GET：/tom/contact
GET：/tom/contactus
POST：/book/home/contact2
POST：/tom/home/contact2</pre>
</div>
<p>但是，在视图文件中，通过<code>@Html.ActionLink("Contact", "Contact", "Home")</code>生成链接地址的话，则默认会使用第一个定义的Route，如果要强制指定顺序，则可以使用Order属性来定义排序值，默认会优先使用最小的值。示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("book", Order = 1)]
[Route("tom", Order = 0)]
public class HomeController : Controller
{
 [Route("Contact", Order = 1)]
 [Route("ContactUS", Order = 0)]
 [HttpPost("home/Contact2", Order = 2)]
 public IActionResult Contact()
 {
  ViewBag.Message = "Your contact page.";
  return View();
 }
}</pre>
</div>
<p><b>自定义内联参数约束</b></p>
<p>在前面的介绍中，我们知道任意类型的路由在定义的时候都支持不同的内联参数约束，因为这些约束是基于ASP.NET 5的，而不是基于MVC6的，并且这些约束还是可以扩展的，本节我们就来看看如何自定义一些扩展。</p>
<p><b>无参数约束</b></p>
<p>首先，我们来看一个比较简单的约束，即无参数约束，类似于<code>{productId:int}</code>这样的类型约束，假设我们要实现一个AABBCC字符串限定的约束，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("index/{productId:aabbcc}")]</pre>
</div>
<p></p>
<p>为了确保/index/112233和/index/aabbcc是符合约束的，而/index/aabbccdd是不符合约束的，我们首先要自定义一个约束类<code>AABBCCRouteConstraint</code>，并实现<code>IRouteConstraint</code>接口，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class AABBCCRouteConstraint : IRouteConstraint
{
 public bool Match(HttpContext httpContext, IRouter route, string routeKey, IDictionary&lt;string, object&gt; values, RouteDirection routeDirection)
 {
  bool b = false;

  object value;
  if (values.TryGetValue(routeKey, out value) && value != null)
  {
   if (value is string) // 获取传入的值，比如aabbcc或112233
   {
    string aabbcc = value.ToString();
    b = !string.IsNullOrWhiteSpace(aabbcc) && aabbcc.Length == 6 && aabbcc[0] == aabbcc[1] && aabbcc[2] == aabbcc[3] && aabbcc[4] == aabbcc[5];

   }
  }

  return b;
 }
}</pre>
</div>
<p>在该实现类中，要实现Match方法，根据传入的各种参数，判断是否符合定义的约束，并返回true或false，Match方法的参数中，其中<code>routeKey</code>是约束<code>{productId:aabbcc}</code>对应的参数名称（本例中是productId），values集合中会有该productId所对应的数字（如112233），在该方法通过响应的判断返回true和false。</p>
<p>下一步，就是要将该约束类注册到Routing系统的约束集合中，在<code>Startup.cs</code>的<code>ConfigureServices</code>方法中，执行如下语句：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
services.Configure&lt;RouteOptions&gt;(opt =&gt;
{
 opt.ConstraintMap.Add("aabbcc", typeof(AABBCCRouteConstraint));
});</pre>
</div>
<p><span style="color: #ff0000">注意，这里注册的</span><code>aabbcc</code><span style="color: #ff0000">就是前面我们所指定约束名称，完成上述步骤以后，即可实现类似</span><code>{productId:int}</code><span style="color: #ff0000">的功能了。</span></p>
<p><b>有参数约束</b></p>
<p>一般情况下，有些时候可能需要定义一些约束的值，比如<code>Length(1,10)</code>来表示1-10之间的字符串长度，举例来说，加入我们要定义一个4个参数的约束规则，如<code>abcd(1,10,20,30)</code>来表示一个特殊的验证项，则需要声明有4个参数的构造函数，示例如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
public class ABCDRouteConstraint : IRouteConstraint
{
 public int A { get; private set; }
 public int B { get; private set; }
 public int C { get; private set; }
 public int D { get; private set; }
 public ABCDRouteConstraint(int a, int b, int c, int d)
 {
  A = a;B = b;C = c;D = d;
 }

 public bool Match(HttpContext httpContext, IRouter route, string routeKey, IDictionary&lt;string, object&gt; values, RouteDirection routeDirection)
 {
  bool b = false;

  object value;
  if (values.TryGetValue(routeKey, out value) && value != null)
  {
   var valueString = value.ToString();//这里需要进行进一步的验证工作
   return true;
  }

  return b;
 }
}</pre>
</div>
<p>假如你在Action上了定义了如下约束：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("index/{productId:abcd(1,20,30,40)}")]</pre>
</div>
<p>那么，在注册该约束类型以后，系统启动厚扫描所有的Route进行注册的时候，会分析你定义的这4个值，然后会将这4个值赋值给该路由对应的约束实例上的A、B、C、D四个属性上，以便在HTTP请求过来的时候，分析URL上的值，看是否符合Match里定义的规则（在验证的时候就可以使用这4个属性值）。</p>
<p>默认约束的所有代码可以参考： https://github.com/aspnet/Routing/tree/dev/src/Microsoft.AspNet.Routing/Constraints</p>
<p>另外，如果定义了4个参数的约束，那么在action上定义路由的时候则必须符合参数的数据类型，如果不符合，系统启动的时候就会出错，示例错误如下：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("index/{productId:abcd}")] //没有为该对象定义无参数的构造函数

[Route("index/{productId:abcd(a)}")]
[Route("index/{productId:abcd('a')}")] //输入字符串的格式不正确

[Route("index/{productId:abcd(1,2,3)}")] //构造函数的参数个数和定义的参数个数不一致。</pre>
</div>
<p>如果你定义的参数类型是字符串类型，则下面2种形式的定义都是合法的：</p>
<div class="phpstudycode">
<pre class="brush:csharp;">
[Route("index/{productId:abcd(a,b,c,d)}")]
[Route("index/{productId:abcd('a','b','c','d')}")]</pre>
</div>
<p>虽然ASP.NET 5 和MVC6的路由使用方式很简单，但是相关的使用规则却很复杂，大家使用的时候需要多加注意。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/104715.html'>Win10系统如何启用文件夹导航窗格就是原来的树形结构目录</a><a>下一篇</a><a href='/php/biji/104717.html'>thinkphp框架下实现登录、注册、找回密码功能</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>