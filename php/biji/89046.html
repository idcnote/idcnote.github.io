<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>深入理解JavaScript系列（18）：面向对象编程之ECMAScript实现_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="介绍<br />
本章是关于ECMAScript面向对象实现的第2篇，第1篇我们讨论的是概论和CEMAScript的比较，如果你还没有读第1篇，在进行本章之前，我强烈建议你先读一下第1篇，因为本篇实在太长了（3" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">深入理解JavaScript系列（18）：面向对象编程之ECMAScript实现</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>介绍<br />
本章是关于ECMAScript面向对象实现的第2篇，第1篇我们讨论的是概论和CEMAScript的比较，如果你还没有读第1篇，在进行本章之前，我强烈建议你先读一下第1篇，因为本篇实在太长了（3</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p><strong>介绍</strong></p>
<p>本章是关于ECMAScript面向对象实现的第2篇，第1篇我们讨论的是概论和CEMAScript的比较，如果你还没有读第1篇，在进行本章之前，我强烈建议你先读一下第1篇，因为本篇实在太长了（35页）。</p>
<p>英文原文：http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/<br />
注：由于篇幅太长了，难免出现错误，时刻保持修正中。</p>
<p>在概论里，我们延伸到了ECMAScript，现在，当我们知道它OOP实现时，我们再来准确定义一下：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="16471" class="copybut" id="copybut16471" onclick="doCopy('code16471')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16471"><br />
ECMAScript is an object-oriented programming language supporting delegating inheritance based on prototypes.<br />
</div><br />
ECMAScript是一种面向对象语言，支持基于原型的委托式继承。<br />
我们将从最基本的数据类型来分析，首先要了解的是ECMAScript用原始值（primitive values）和对象（objects）来区分实体，因此有些文章里说的“在JavaScript里，一切都是对象”是错误的（不完全对），原始值就是我们这里要讨论的一些数据类型。</p>
<p><strong>数据类型</strong></p>
<p>虽然ECMAScript是可以动态转化类型的动态弱类型语言，它还是有数据类型的。也就是说，一个对象要属于一个实实在在的类型。<br />
标准规范里定义了9种数据类型，但只有6种是在ECMAScript程序里可以直接访问的,它们是：Undefined、Null、Boolean、String、Number、Object。</p>
<p>另外3种类型只能在实现级别访问（ECMAScript对象是不能使用这些类型的）并用于规范来解释一些操作行为、保存中间值。这3种类型是：Reference、List和Completion。</p>
<p>因此，Reference是用来解释delete、typeof、this这样的操作符，并且包含一个基对象和一个属性名称；List描述的是参数列表的行为（在new表达式和函数调用的时候）；Completion是用来解释行为break、continue、return和throw语句的。</p>
<p><strong>原始值类型<br />
</strong>回头来看6中用于ECMAScript程序的数据类型，前5种是原始值类型，包括Undefined、Null、Boolean、String、Number、Object。<br />
原始值类型例子：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="8185" class="copybut" id="copybut8185" onclick="doCopy('code8185')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code8185"><br />
var a = undefined;<br />
var b = null;<br />
var c = true;<br />
var d = 'test';<br />
var e = 10;<br />
</div></p>
<p>这些值是在底层上直接实现的，他们不是object，所以没有原型，没有构造函数。</p>
<p>大叔注：这些原生值和我们平时用的(Boolean、String、Number、Object)虽然名字上相似，但不是同一个东西。所以typeof(true)和typeof(Boolean)结果是不一样的，因为typeof(Boolean)的结果是function，所以函数Boolean、String、Number是有原型的（下面的读写属性章节也会提到）。</p>
<p>想知道数据是哪种类型用typeof是最好不过了，有个例子需要注意一下，如果用typeof来判断null的类型，结果是object，为什么呢？因为null的类型是定义为Null的。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="86159" class="copybut" id="copybut86159" onclick="doCopy('code86159')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code86159"><br />
alert(typeof null); // "object"<br />
</div><br />
显示"object"原因是因为规范就是这么规定的：对于Null值的typeof字符串值返回"object“。</p>
<p>规范没有想象解释这个，但是Brendan Eich (JavaScript发明人)注意到null相对于undefined大多数都是用于对象出现的地方，例如设置一个对象为空引用。但是有些文档里有些气人将之归结为bug，而且将该bug放在Brendan Eich也参与讨论的bug列表里，结果就是任其自然，还是把typeof null的结果设置为object（尽管262-3的标准是定义null的类型是Null，262-5已经将标准修改为null的类型是object了）。</p>
<p><strong>Object类型</strong></p>
<p>接着，Object类型（不要和Object构造函数混淆了，现在只讨论抽象类型）是描述 ECMAScript对象的唯一一个数据类型。</p>
<p>Object is an unordered collection of key-value pairs.<br />
对象是一个包含key-value对的无序集合</p>
<p>对象的key值被称为属性，属性是原始值和其他对象的容器。如果属性的值是函数我们称它为方法 。</p>
<p>例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="25680" class="copybut" id="copybut25680" onclick="doCopy('code25680')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code25680"><br />
var x = { // 对象"x"有3个属性: a, b, c<br />
&nbsp; a: 10, // 原始值<br />
&nbsp; b: {z: 100}, // 对象"b"有一个属性z<br />
&nbsp; c: function () { // 函数(方法)<br />
&nbsp;&nbsp;&nbsp; alert('method x.c');<br />
&nbsp; }<br />
};<br />
&nbsp;<br />
alert(x.a); // 10<br />
alert(x.b); // [object Object]<br />
alert(x.b.z); // 100<br />
x.c(); // 'method x.c'<br />
</div></p>
<p><strong>动态性</strong></p>
<p>正如我们在第17章中指出的，ES中的对象是完全动态的。这意味着，在程序执行的时候我们可以任意地添加，修改或删除对象的属性。</p>
<p>例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="7117" class="copybut" id="copybut7117" onclick="doCopy('code7117')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code7117"><br />
var foo = {x: 10};<br />
&nbsp;<br />
// 添加新属性<br />
foo.y = 20;<br />
console.log(foo); // {x: 10, y: 20}<br />
&nbsp;<br />
// 将属性值修改为函数<br />
foo.x = function () {<br />
&nbsp; console.log('foo.x');<br />
};<br />
&nbsp;<br />
foo.x(); // 'foo.x'<br />
&nbsp;<br />
// 删除属性<br />
delete foo.x;<br />
console.log(foo); // {y: 20}<br />
</div></p>
<p>有些属性不能被修改——（只读属性、已删除属性或不可配置的属性）。 我们将稍后在属性特性里讲解。</p>
<p>另外，ES5规范规定，静态对象不能扩展新的属性，并且它的属性页不能删除或者修改。他们是所谓的冻结对象，可以通过应用Object.freeze(o)方法得到。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="89363" class="copybut" id="copybut89363" onclick="doCopy('code89363')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code89363"><br />
var foo = {x: 10};<br />
&nbsp;<br />
// 冻结对象<br />
Object.freeze(foo);<br />
console.log(Object.isFrozen(foo)); // true<br />
&nbsp;<br />
// 不能修改<br />
foo.x = 100;<br />
&nbsp;<br />
// 不能扩展<br />
foo.y = 200;<br />
&nbsp;<br />
// 不能删除<br />
delete foo.x;<br />
&nbsp;<br />
console.log(foo); // {x: 10}<br />
</div></p>
<p>在ES5规范里，也使用Object.preventExtensions(o)方法防止扩展，或者使用Object.defineProperty(o)方法来定义属性：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="16066" class="copybut" id="copybut16066" onclick="doCopy('code16066')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16066"><br />
var foo = {x : 10};<br />
&nbsp;<br />
Object.defineProperty(foo, "y", {<br />
&nbsp; value: 20,<br />
&nbsp; writable: false, // 只读<br />
&nbsp; configurable: false // 不可配置<br />
});<br />
&nbsp;<br />
// 不能修改<br />
foo.y = 200;<br />
&nbsp;<br />
// 不能删除<br />
delete foo.y; // false<br />
&nbsp;<br />
// 防治扩展<br />
Object.preventExtensions(foo);<br />
console.log(Object.isExtensible(foo)); // false<br />
&nbsp;<br />
// 不能添加新属性<br />
foo.z = 30;<br />
&nbsp;<br />
console.log(foo); {x: 10, y: 20}<br />
</div></p>
<p><strong>内置对象、原生对象及宿主对象</strong></p>
<p>有必要需要注意的是规范还区分了这内置对象、元素对象和宿主对象。</p>
<p>内置对象和元素对象是被ECMAScript规范定义和实现的，两者之间的差异微不足道。所有ECMAScript实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到ECMAScript里的（例如，parseInt, Match等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如window、alert等。</p>
<p>注意，宿主对象可能是ES自身实现的，完全符合规范的语义。从这点来说，他们能称为“原生宿主”对象（尽快很理论），不过规范没有定义“原生宿主”对象的概念。</p>
<p><strong>Boolean，String和Number对象</strong></p>
<p>另外，规范也定义了一些原生的特殊包装类，这些对象是：</p>
<p>1.布尔对象<br />
2.字符串对象<br />
3.数字对象</p>
<p>这些对象的创建，是通过相应的内置构造器创建，并且包含原生值作为其内部属性，这些对象可以转换省原始值，反之亦然。</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="35957" class="copybut" id="copybut35957" onclick="doCopy('code35957')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code35957"><br />
var c = new Boolean(true);<br />
var d = new String('test');<br />
var e = new Number(10);<br />
&nbsp;<br />
// 转换成原始值<br />
// 使用不带new关键字的函数<br />
с = Boolean(c);<br />
d = String(d);<br />
e = Number(e);<br />
&nbsp;<br />
// 重新转换成对象<br />
с = Object(c);<br />
d = Object(d);<br />
e = Object(e);<br />
</div></p>
<p>此外，也有对象是由特殊的内置构造函数创建： Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是Object对象类型的值，他们彼此的区别是由内部属性管理的，我们在下面讨论这些内容。</p>
<p><strong>字面量Literal</strong></p>
<p>对于三个对象的值：对象（object）,数组（array）和正则表达式（regular expression），他们分别有简写的标示符称为：对象初始化器、数组初始化器、和正则表达式初始化器：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="2844" class="copybut" id="copybut2844" onclick="doCopy('code2844')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code2844"><br />
// 等价于new Array(1, 2, 3);<br />
// 或者array = new Array();<br />
// array[0] = 1;<br />
// array[1] = 2;<br />
// array[2] = 3;<br />
var array = [1, 2, 3];<br />
&nbsp;<br />
// 等价于<br />
// var object = new Object();<br />
// object.a = 1;<br />
// object.b = 2;<br />
// object.c = 3;<br />
var object = {a: 1, b: 2, c: 3};<br />
&nbsp;<br />
// 等价于new RegExp("^\\d+$", "g")<br />
var re = /^\d+$/g;<br />
</div></p>
<p>注意，如果上述三个对象进行重新赋值名称到新的类型上的话，那随后的实现语义就是按照新赋值的类型来使用，例如在当前的Rhino和老版本SpiderMonkey 1.7的实现上，会成功以new关键字的构造器来创建对象，但有些实现（当前Spider/TraceMonkey）字面量的语义在类型改变以后却不一定改变。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="2181" class="copybut" id="copybut2181" onclick="doCopy('code2181')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code2181"><br />
var getClass = Object.prototype.toString;<br />
&nbsp;<br />
Object = Number;<br />
&nbsp;<br />
var foo = new Object;<br />
alert([foo, getClass.call(foo)]); // 0, "[object Number]"<br />
&nbsp;<br />
var bar = {};<br />
&nbsp;<br />
// Rhino, SpiderMonkey 1.7中 - 0, "[object Number]"<br />
// 其它: still "[object Object]", "[object Object]"<br />
alert([bar, getClass.call(bar)]);<br />
&nbsp;<br />
// Array也是一样的效果<br />
Array = Number;<br />
&nbsp;<br />
foo = new Array;<br />
alert([foo, getClass.call(foo)]); // 0, "[object Number]"<br />
&nbsp;<br />
bar = [];<br />
&nbsp;<br />
// Rhino, SpiderMonkey 1.7中 - 0, "[object Number]"<br />
// 其它: still "", "[object Object]"<br />
alert([bar, getClass.call(bar)]);<br />
&nbsp;<br />
// 但对RegExp,字面量的语义是不被改变的。 semantics of the literal<br />
// isn't being changed in all tested implementations<br />
&nbsp;<br />
RegExp = Number;<br />
&nbsp;<br />
foo = new RegExp;<br />
alert([foo, getClass.call(foo)]); // 0, "[object Number]"<br />
&nbsp;<br />
bar = /(&#63;!)/g;<br />
alert([bar, getClass.call(bar)]); // /(&#63;!)/g, "[object RegExp]"<br />
</div></p>
<p>正则表达式字面量和RegExp对象</p>
<p>注意，下面2个例子在第三版的规范里，正则表达式的语义都是等价的，regexp字面量只在一句里存在，并且再解析阶段创建，但RegExp构造器创建的却是新对象，所以这可能会导致出一些问题，如lastIndex的值在测试的时候结果是错误的：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="77614" class="copybut" id="copybut77614" onclick="doCopy('code77614')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code77614"><br />
for (var k = 0; k &lt; 4; k++) {<br />
&nbsp; var re = /ecma/g;<br />
&nbsp; alert(re.lastIndex); // 0, 4, 0, 4<br />
&nbsp; alert(re.test("ecmascript")); // true, false, true, false<br />
}<br />
&nbsp;<br />
// 对比<br />
&nbsp;<br />
for (var k = 0; k &lt; 4; k++) {<br />
&nbsp; var re = new RegExp("ecma", "g");<br />
&nbsp; alert(re.lastIndex); // 0, 0, 0, 0<br />
&nbsp; alert(re.test("ecmascript")); // true, true, true, true<br />
}<br />
</div><br />
注：不过这些问题在第5版的ES规范都已经修正了，不管是基于字面量的还是构造器的，正则都是创建新对象。</p>
<p><strong>关联数组</strong></p>
<p>各种文字静态讨论，JavaScript对象（经常是用对象初始化器{}来创建）被称为哈希表哈希表或其它简单的称谓：哈希（Ruby或Perl里的概念）， 管理数组（PHP里的概念），词典 （Python里的概念）等。</p>
<p>只有这样的术语，主要是因为他们的结构都是相似的，就是使用“键-值”对来存储对象，完全符合“关联数组 ”或“哈希表 ”理论定义的数据结构。 此外，哈希表抽象数据类型通常是在实现层面使用。</p>
<p>但是，尽管术语上来描述这个概念，但实际上这个是错误，从ECMAScript来看：ECMAScript只有一个对象以及类型以及它的子类型，这和“键-值”对存储没有什么区别，因此在这上面没有特别的概念。 因为任何对象的内部属性都可以存储为键-值”对：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="51315" class="copybut" id="copybut51315" onclick="doCopy('code51315')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51315"><br />
var a = {x: 10};<br />
a['y'] = 20;<br />
a.z = 30;<br />
&nbsp;<br />
var b = new Number(1);<br />
b.x = 10;<br />
b.y = 20;<br />
b['z'] = 30;<br />
&nbsp;<br />
var c = new Function('');<br />
c.x = 10;<br />
c.y = 20;<br />
c['z'] = 30;<br />
&nbsp;<br />
// 等等，任意对象的子类型"subtype"<br />
</div></p>
<p>此外，由于在ECMAScript中对象可以是空的，所以"hash"的概念在这里也是不正确的：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="3653" class="copybut" id="copybut3653" onclick="doCopy('code3653')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code3653"><br />
Object.prototype.x = 10;<br />
&nbsp;<br />
var a = {}; // 创建空"hash"<br />
&nbsp;<br />
alert(a["x"]); // 10, 但不为空<br />
alert(a.toString); // function<br />
&nbsp;<br />
a["y"] = 20; // 添加新的键值对到 "hash"<br />
alert(a["y"]); // 20<br />
&nbsp;<br />
Object.prototype.y = 20; // 添加原型属性<br />
&nbsp;<br />
delete a["y"]; // 删除<br />
alert(a["y"]); // 但这里key和value依然有值 – 20<br />
</div></p>
<p>请注意， ES5标准可以让我们创建没原型的对象（使用Object.create(null)方法实现）对，从这个角度来说，这样的对象可以称之为哈希表：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="46638" class="copybut" id="copybut46638" onclick="doCopy('code46638')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code46638"><br />
var aHashTable = Object.create(null);<br />
console.log(aHashTable.toString); // 未定义<br />
</div><br />
此外，一些属性有特定的getter / setter方法&#8203;&#8203;，所以也可能导致混淆这个概念：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="70800" class="copybut" id="copybut70800" onclick="doCopy('code70800')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code70800"><br />
var a = new String("foo");<br />
a['length'] = 10;<br />
alert(a['length']); // 3<br />
</div></p>
<p>然而，即使认为“哈希”可能有一个“原型”（例如，在Ruby或Python里委托哈希对象的类），在ECMAScript里，这个术语也是不对的，因为2个表示法之间没有语义上的区别（即用点表示法a.b和a["b"]表示法）。</p>
<p>在ECMAScript中的“property属性”的概念语义上和"key"、数组索引、方法没有分开的，这里所有对象的属性读写都要遵循统一的规则：检查原型链。</p>
<p>在下面Ruby的例子中，我们可以看到语义上的区别：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="98313" class="copybut" id="copybut98313" onclick="doCopy('code98313')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code98313"><br />
a = {}<br />
a.class # Hash<br />
&nbsp;<br />
a.length # 0<br />
&nbsp;<br />
# new "key-value" pair<br />
a['length'] = 10;<br />
&nbsp;<br />
# 语义上，用点访问的是属性或方法，而不是key<br />
&nbsp;<br />
a.length # 1<br />
&nbsp;<br />
# 而索引器访问访问的是hash里的key<br />
&nbsp;<br />
a['length'] # 10<br />
&nbsp;<br />
# 就类似于在现有对象上动态声明Hash类<br />
# 然后声明新属性或方法<br />
&nbsp;<br />
class Hash<br />
&nbsp; def z<br />
&nbsp;&nbsp;&nbsp; 100<br />
&nbsp; end<br />
end<br />
&nbsp;<br />
# 新属性可以访问<br />
&nbsp;<br />
a.z # 100<br />
&nbsp;<br />
# 但不是"key"<br />
&nbsp;<br />
a['z'] # nil<br />
</div><br />
ECMA-262-3标准并没有定义“哈希”（以及类似）的概念。但是，有这样的结构理论的话，那可能以此命名的对象。</p>
<p><strong>对象转换</strong></p>
<p>将对象转化成原始值可以用valueOf方法，正如我们所说的，当函数的构造函数调用做为function（对于某些类型的），但如果不用new关键字就是将对象转化成原始值，就相当于隐式的valueOf方法调用：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="62660" class="copybut" id="copybut62660" onclick="doCopy('code62660')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code62660"><br />
var a = new Number(1);<br />
var primitiveA = Number(a); // 隐式"valueOf"调用<br />
var alsoPrimitiveA = a.valueOf(); // 显式调用<br />
&nbsp;<br />
alert([<br />
&nbsp; typeof a, // "object"<br />
&nbsp; typeof primitiveA, // "number"<br />
&nbsp; typeof alsoPrimitiveA // "number"<br />
]);<br />
</div><br />
这种方式允许对象参与各种操作，例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="96176" class="copybut" id="copybut96176" onclick="doCopy('code96176')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code96176"><br />
var a = new Number(1);<br />
var b = new Number(2);<br />
&nbsp;<br />
alert(a + b); // 3<br />
&nbsp;<br />
// 甚至<br />
&nbsp;<br />
var c = {<br />
&nbsp; x: 10,<br />
&nbsp; y: 20,<br />
&nbsp; valueOf: function () {<br />
&nbsp;&nbsp;&nbsp; return this.x + this.y;<br />
&nbsp; }<br />
};<br />
&nbsp;<br />
var d = {<br />
&nbsp; x: 30,<br />
&nbsp; y: 40,<br />
&nbsp; // 和c的valueOf功能一样<br />
&nbsp; valueOf: c.valueOf<br />
};<br />
&nbsp;<br />
alert(c + d); // 100<br />
</div></p>
<p>valueOf的默认值会根据根据对象的类型改变（如果不被覆盖的话），对某些对象，他返回的是this——例如：Object.prototype.valueOf()，还有计算型的值：Date.prototype.valueOf()返回的是日期时间：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="69069" class="copybut" id="copybut69069" onclick="doCopy('code69069')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code69069"><br />
var a = {};<br />
alert(a.valueOf() === a); // true, "valueOf"返回this<br />
&nbsp;<br />
var d = new Date();<br />
alert(d.valueOf()); // time<br />
alert(d.valueOf() === d.getTime()); // true<br />
</div><br />
此外,对象还有一个更原始的代表性——字符串展示。 这个toString方法是可靠的，它在某些操作上是自动使用的：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="76950" class="copybut" id="copybut76950" onclick="doCopy('code76950')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76950"><br />
var a = {<br />
&nbsp; valueOf: function () {<br />
&nbsp;&nbsp;&nbsp; return 100;<br />
&nbsp; },<br />
&nbsp; toString: function () {<br />
&nbsp;&nbsp;&nbsp; return '__test';<br />
&nbsp; }<br />
};<br />
&nbsp;<br />
// 这个操作里，toString方法自动调用<br />
alert(a); // "__test"<br />
&nbsp;<br />
// 但是这里，调用的却是valueOf()方法<br />
alert(a + 10); // 110<br />
&nbsp;<br />
// 但，一旦valueOf删除以后<br />
// toString又可以自动调用了<br />
delete a.valueOf;<br />
alert(a + 10); // "_test10"<br />
</div></p>
<p>Object.prototype上定义的toString方法具有特殊意义，它返回的我们下面将要讨论的内部[[Class]]属性值。</p>
<p>和转化成原始值（ToPrimitive）相比，将值转化成对象类型也有一个转化规范（ToObject）。</p>
<p>一个显式方法是使用内置的Object构造函数作为function来调用ToObject（有些类似通过new关键字也可以）：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="26748" class="copybut" id="copybut26748" onclick="doCopy('code26748')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code26748"><br />
var n = Object(1); // [object Number]<br />
var s = Object('test'); // [object String]<br />
&nbsp;<br />
// 一些类似，使用new操作符也可以<br />
var b = new Object(true); // [object Boolean]<br />
&nbsp;<br />
// 应用参数new Object的话创建的是简单对象<br />
var o = new Object(); // [object Object]<br />
&nbsp;<br />
// 如果参数是一个现有的对象<br />
// 那创建的结果就是简单返回该对象<br />
var a = [];<br />
alert(a === new Object(a)); // true<br />
alert(a === Object(a)); // true<br />
</div></p>
<p>关于调用内置构造函数，使用还是不适用new操作符没有通用规则，取决于构造函数。 例如Array或Function当使用new操作符的构造函数或者不使用new操作符的简单函数使用产生相同的结果的：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="3913" class="copybut" id="copybut3913" onclick="doCopy('code3913')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code3913"><br />
var a = Array(1, 2, 3); // [object Array]<br />
var b = new Array(1, 2, 3); // [object Array]<br />
var c = [1, 2, 3]; // [object Array]<br />
&nbsp;<br />
var d = Function(''); // [object Function]<br />
var e = new Function(''); // [object Function]<br />
</div><br />
有些操作符使用的时候，也有一些显示和隐式转化：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="98976" class="copybut" id="copybut98976" onclick="doCopy('code98976')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code98976"><br />
var a = 1;<br />
var b = 2;<br />
&nbsp;<br />
// 隐式<br />
var c = a + b; // 3, number<br />
var d = a + b + '5' // "35", string<br />
&nbsp;<br />
// 显式<br />
var e = '10'; // "10", string<br />
var f = +e; // 10, number<br />
var g = parseInt(e, 10); // 10, number<br />
&nbsp;<br />
// 等等<br />
</div></p>
<p><strong>属性的特性</strong></p>
<p>所有的属性（property） 都可以有很多特性（attributes）。</p>
<p>1.{ReadOnly}——忽略向属性赋值的写操作尝，但只读属性可以由宿主环境行为改变——也就是说不是“恒定值” ;<br />
2.{DontEnum}——属性不能被for..in循环枚举<br />
3.{DontDelete}——糊了delete操作符的行为被忽略（即删不掉）;<br />
4.{Internal}——内部属性，没有名字（仅在实现层面使用），ECMAScript里无法访问这样的属性。</p>
<p>注意，在ES5里{ReadOnly}，{DontEnum}和{DontDelete}被重新命名为[[Writable]]，[[Enumerable]]和[[Configurable]]，可以手工通过Object.defineProperty或类似的方法来管理这些属性。</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="87227" class="copybut" id="copybut87227" onclick="doCopy('code87227')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code87227"><br />
var foo = {};<br />
&nbsp;<br />
Object.defineProperty(foo, "x", {<br />
&nbsp; value: 10,<br />
&nbsp; writable: true, // 即{ReadOnly} = false<br />
&nbsp; enumerable: false, // 即{DontEnum} = true<br />
&nbsp; configurable: true // 即{DontDelete} = false<br />
});<br />
&nbsp;<br />
console.log(foo.x); // 10<br />
&nbsp;<br />
// 通过descriptor获取特性集attributes<br />
var desc = Object.getOwnPropertyDescriptor(foo, "x");<br />
&nbsp;<br />
console.log(desc.enumerable); // false<br />
console.log(desc.writable); // true<br />
// 等等<br />
</div></p>
<p><strong>内部属性和方法</strong></p>
<p>对象也可以有内部属性（实现层面的一部分），并且ECMAScript程序无法直接访问（但是下面我们将看到，一些实现允许访问一些这样的属性）。 这些属性通过嵌套的中括号[[ ]]进行访问。我们来看其中的一些，这些属性的描述可以到规范里查阅到。</p>
<p>每个对象都应该实现如下内部属性和方法：</p>
<p>1.[[Prototype]]——对象的原型（将在下面详细介绍）<br />
2.[[Class]]——字符串对象的一种表示（例如，Object Array ，Function Object，Function等）;用来区分对象<br />
3.[[Get]]——获得属性值的方法<br />
4.[[Put]]——设置属性值的方法<br />
5.[[CanPut]]——检查属性是否可写<br />
6.[[HasProperty]]——检查对象是否已经拥有该属性<br />
7.[[Delete]]——从对象删除该属性<br />
8.[[DefaultValue]]返回对象对于的原始值（调用valueOf方法，某些对象可能会抛出TypeError异常）。<br />
通过Object.prototype.toString()方法可以间接得到内部属性[[Class]]的值，该方法应该返回下列字符串： "[object " + [[Class]] + "]" 。例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="22475" class="copybut" id="copybut22475" onclick="doCopy('code22475')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code22475"><br />
var getClass = Object.prototype.toString;<br />
&nbsp;<br />
getClass.call({}); // [object Object]<br />
getClass.call([]); // [object Array]<br />
getClass.call(new Number(1)); // [object Number]<br />
// 等等<br />
</div><br />
这个功能通常是用来检查对象用的，但规范上说宿主对象的[[Class]]可以为任意值，包括内置对象的[[Class]]属性的值，所以理论上来看是不能100%来保证准确的。例如，document.childNodes.item(...)方法的[[Class]]属性，在IE里返回"String"，但其它实现里返回的确实"Function"。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="16730" class="copybut" id="copybut16730" onclick="doCopy('code16730')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16730"><br />
// in IE - "String", in other - "Function"<br />
alert(getClass.call(document.childNodes.item));<br />
</div></p>
<p><strong>构造函数</strong></p>
<p>因此，正如我们上面提到的，在ECMAScript中的对象是通过所谓的构造函数来创建的。</p>
<p>Constructor is a function that creates and initializes the newly created object.<br />
构造函数是一个函数，用来创建并初始化新创建的对象。<br />
对象创建（内存分配）是由构造函数的内部方法[[Construct]]负责的。该内部方法的行为是定义好的，所有的构造函数都是使用该方法来为新对象分配内存的。</p>
<p>而初始化是通过新建对象上下上调用该函数来管理的，这是由构造函数的内部方法[[Call]]来负责任的。</p>
<p>注意，用户代码只能在初始化阶段访问，虽然在初始化阶段我们可以返回不同的对象（忽略第一阶段创建的tihs对象）：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="60524" class="copybut" id="copybut60524" onclick="doCopy('code60524')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code60524"><br />
function A() {<br />
&nbsp; // 更新新创建的对象<br />
&nbsp; this.x = 10;<br />
&nbsp; // 但返回的是不同的对象<br />
&nbsp; return [1, 2, 3];<br />
}<br />
&nbsp;<br />
var a = new A();<br />
console.log(a.x, a); undefined, [1, 2, 3]<br />
</div></p>
<p>引用15章函数——创建函数的算法小节，我们可以看到该函数是一个原生对象，包含[[Construct]] ]和[[Call]] ]属性以及显示的prototype原型属性——未来对象的原型（注：NativeObject是对于native object原生对象的约定，在下面的伪代码中使用）。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="2585" class="copybut" id="copybut2585" onclick="doCopy('code2585')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code2585"><br />
F = new NativeObject();<br />
&nbsp;<br />
F.[[Class]] = "Function"<br />
&nbsp;<br />
.... // 其它属性<br />
&nbsp;<br />
F.[[Call]] = &lt;reference to function&gt; // function自身<br />
&nbsp;<br />
F.[[Construct]] = internalConstructor // 普通的内部构造函数<br />
&nbsp;<br />
.... // 其它属性<br />
&nbsp;<br />
// F构造函数创建的对象原型<br />
__objectPrototype = {};<br />
__objectPrototype.constructor = F // {DontEnum}<br />
F.prototype = __objectPrototype<br />
</div></p>
<p>[[Call]] ]是除[[Class]]属性（这里等同于"Function" ）之外区分对象的主要方式，因此，对象的内部[[Call]]属性作为函数调用。 这样的对象用typeof运算操作符的话返回的是"function"。然而它主要是和原生对象有关，有些情况的实现在用typeof获取值的是不一样的，例如：window.alert (...)在IE中的效果：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="49842" class="copybut" id="copybut49842" onclick="doCopy('code49842')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49842"><br />
// IE浏览器中 - "Object", "object", 其它浏览器 - "Function", "function"<br />
alert(Object.prototype.toString.call(window.alert));<br />
alert(typeof window.alert); // "Object"<br />
</div></p>
<p>内部方法[[Construct]]是通过使用带new运算符的构造函数来激活的，正如我们所说的这个方法是负责内存分配和对象创建的。如果没有参数，调用构造函数的括号也可以省略：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="61187" class="copybut" id="copybut61187" onclick="doCopy('code61187')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code61187"><br />
function A(x) { // constructor А<br />
&nbsp; this.x = x || 10;<br />
}<br />
&nbsp;<br />
// 不传参数的话，括号也可以省略<br />
var a = new A; // or new A();<br />
alert(a.x); // 10<br />
&nbsp;<br />
// 显式传入参数x<br />
var b = new A(20);<br />
alert(b.x); // 20<br />
</div><br />
我们也知道，构造函数（初始化阶段）里的shis被设置为新创建的对象 。</p>
<p>让我们研究一下对象创建的算法。</p>
<p><strong>对象创建的算法</strong></p>
<p>内部方法[[Construct]] 的行为可以描述成如下：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="53710" class="copybut" id="copybut53710" onclick="doCopy('code53710')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code53710"><br />
F.[[Construct]](initialParameters):<br />
&nbsp;<br />
O = new NativeObject();<br />
&nbsp;<br />
// 属性[[Class]]被设置为"Object"<br />
O.[[Class]] = "Object"<br />
&nbsp;<br />
// 引用F.prototype的时候获取该对象g<br />
var __objectPrototype = F.prototype;<br />
&nbsp;<br />
// 如果__objectPrototype是对象，就:<br />
O.[[Prototype]] = __objectPrototype<br />
// 否则:<br />
O.[[Prototype]] = Object.prototype;<br />
// 这里O.[[Prototype]]是Object对象的原型<br />
&nbsp;<br />
// 新创建对象初始化的时候应用了F.[[Call]]<br />
// 将this设置为新创建的对象O<br />
// 参数和F里的initialParameters是一样的<br />
R = F.[[Call]](initialParameters); this === O;<br />
// 这里R是[[Call]]的返回值<br />
// 在JS里看，像这样:<br />
// R = F.apply(O, initialParameters);<br />
&nbsp;<br />
// 如果R是对象<br />
return R<br />
// 否则<br />
return O<br />
</div></p>
<p>请注意两个主要特点：</p>
<p>1.首先，新创建对象的原型是从当前时刻函数的prototype属性获取的（这意味着同一个构造函数创建的两个创建对象的原型可以不同是因为函数的prototype属性也可以不同）。<br />
2.其次，正如我们上面提到的，如果在对象初始化的时候，[[Call]]返回的是对象，这恰恰是用于整个new操作符的结果：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="76141" class="copybut" id="copybut76141" onclick="doCopy('code76141')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code76141"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10 – 从原型上得到<br />
&nbsp;<br />
// 设置.prototype属性为新对象<br />
// 为什么显式声明.constructor属性将在下面说明<br />
A.prototype = {<br />
&nbsp; constructor: A,<br />
&nbsp; y: 100<br />
};<br />
&nbsp;<br />
var b = new A();<br />
// 对象"b"有了新属性<br />
alert(b.x); // undefined<br />
alert(b.y); // 100 – 从原型上得到<br />
&nbsp;<br />
// 但a对象的原型依然可以得到原来的结果<br />
alert(a.x); // 10 - 从原型上得到<br />
&nbsp;<br />
function B() {<br />
&nbsp; this.x = 10;<br />
&nbsp; return new Array();<br />
}<br />
&nbsp;<br />
// 如果"B"构造函数没有返回（或返回this）<br />
// 那么this对象就可以使用，但是下面的情况返回的是array<br />
var b = new B();<br />
alert(b.x); // undefined<br />
alert(Object.prototype.toString.call(b)); // [object Array]<br />
</div><br />
让我们来详细了解一下原型</p>
<p><strong>原型</strong></p>
<p>每个对象都有一个原型（一些系统对象除外）。原型通信是通过内部的、隐式的、不可直接访问[[Prototype]]原型属性来进行的，原型可以是一个对象，也可以是null值。</p>
<p><strong>属性构造函数(Property constructor)</strong></p>
<p>上面的例子有有2个重要的知识点，第一个是关于函数的constructor属性的prototype属性，在函数创建的算法里，我们知道constructor属性在函数创建阶段被设置为函数的prototype属性，constructor属性的值是函数自身的重要引用：</p>
<p><div class="codetitle"><span><a style="CURSOR: pointer" data="82291" class="copybut" id="copybut82291" onclick="doCopy('code82291')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code82291"><br />
function A() {}<br />
var a = new A();<br />
alert(a.constructor); // function A() {}, by delegation<br />
alert(a.constructor === A); // true<br />
</div></p>
<p>通常在这种情况下，存在着一个误区：constructor构造属性作为新创建对象自身的属性是错误的，但是，正如我们所看到的的，这个属性属于原型并且通过继承来访问对象。</p>
<p>通过继承constructor属性的实例，可以间接得到的原型对象的引用：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="10726" class="copybut" id="copybut10726" onclick="doCopy('code10726')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code10726"><br />
function A() {}<br />
A.prototype.x = new Number(10);<br />
&nbsp;<br />
var a = new A();<br />
alert(a.constructor.prototype); // [object Object]<br />
&nbsp;<br />
alert(a.x); // 10, 通过原型<br />
// 和a.[[Prototype]].x效果一样<br />
alert(a.constructor.prototype.x); // 10<br />
&nbsp;<br />
alert(a.constructor.prototype.x === a.x); // true<br />
</div></p>
<p>但请注意，函数的constructor和prototype属性在对象创建以后都可以重新定义的。在这种情况下，对象失去上面所说的机制。如果通过函数的prototype属性去编辑元素的prototype原型的话（添加新对象或修改现有对象），实例上将看到新添加的属性。</p>
<p>然而，如果我们彻底改变函数的prototype属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括constructor属性：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="51978" class="copybut" id="copybut51978" onclick="doCopy('code51978')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code51978"><br />
function A() {}<br />
A.prototype = {<br />
&nbsp; x: 10<br />
};<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10<br />
alert(a.constructor === A); // false!<br />
</div><br />
因此，对函数的原型引用需要手工恢复：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="54778" class="copybut" id="copybut54778" onclick="doCopy('code54778')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code54778"><br />
function A() {}<br />
A.prototype = {<br />
&nbsp; constructor: A,<br />
&nbsp; x: 10<br />
};<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10<br />
alert(a.constructor === A); // true<br />
</div></p>
<p>注意虽然手动恢复了constructor属性，和原来丢失的原型相比，{DontEnum}特性没有了，也就是说A.prototype里的for..in循环语句不支持了，不过第5版规范里，通过[[Enumerable]] 特性提供了控制可枚举状态enumerable的能力。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="72937" class="copybut" id="copybut72937" onclick="doCopy('code72937')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code72937"><br />
var foo = {x: 10};<br />
&nbsp;<br />
Object.defineProperty(foo, "y", {<br />
&nbsp; value: 20,<br />
&nbsp; enumerable: false // aka {DontEnum} = true<br />
});<br />
&nbsp;<br />
console.log(foo.x, foo.y); // 10, 20<br />
&nbsp;<br />
for (var k in foo) {<br />
&nbsp; console.log(k); // only "x"<br />
}<br />
&nbsp;<br />
var xDesc = Object.getOwnPropertyDescriptor(foo, "x");<br />
var yDesc = Object.getOwnPropertyDescriptor(foo, "y");<br />
&nbsp;<br />
console.log(<br />
&nbsp; xDesc.enumerable, // true<br />
&nbsp; yDesc.enumerable&nbsp; // false<br />
);<br />
</div></p>
<p><strong>显式prototype和隐式[[Prototype]]属性</strong></p>
<p>通常，一个对象的原型通过函数的prototype属性显式引用是不正确的，他引用的是同一个对象，对象的[[Prototype]]属性：</p>
<p>a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype</p>
<p>此外， 实例的[[Prototype]]值确实是在构造函数的prototype属性上获取的。</p>
<p>然而，提交prototype属性不会影响已经创建对象的原型（只有在构造函数的prototype属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="91904" class="copybut" id="copybut91904" onclick="doCopy('code91904')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code91904"><br />
// 在修改A.prototype原型之前的情况<br />
a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype<br />
&nbsp;<br />
// 修改之后<br />
A.prototype ----&gt; New prototype // 新对象会拥有这个原型<br />
a.[[Prototype]] ----&gt; Prototype // 引导的原来的原型上<br />
</div></p>
<p>例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="81886" class="copybut" id="copybut81886" onclick="doCopy('code81886')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code81886"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10<br />
&nbsp;<br />
A.prototype = {<br />
&nbsp; constructor: A,<br />
&nbsp; x: 20<br />
&nbsp; y: 30<br />
};<br />
&nbsp;<br />
// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值<br />
alert(a.x); // 10<br />
alert(a.y) // undefined<br />
&nbsp;<br />
var b = new A();<br />
&nbsp;<br />
// 但新对象是从新原型上获取的值<br />
alert(b.x); // 20<br />
alert(b.y) // 30<br />
</div><br />
因此，有的文章说“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。</p>
<p>这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。</p>
<p><strong>非标准的__proto__属性</strong></p>
<p>然而，有些实现（例如SpiderMonkey），提供了不标准的__proto__显式属性来引用对象的原型：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="38497" class="copybut" id="copybut38497" onclick="doCopy('code38497')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code38497"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10<br />
&nbsp;<br />
var __newPrototype = {<br />
&nbsp; constructor: A,<br />
&nbsp; x: 20,<br />
&nbsp; y: 30<br />
};<br />
&nbsp;<br />
// 引用到新对象<br />
A.prototype = __newPrototype;<br />
&nbsp;<br />
var b = new A();<br />
alert(b.x); // 20<br />
alert(b.y); // 30<br />
&nbsp;<br />
// "a"对象使用的依然是旧的原型<br />
alert(a.x); // 10<br />
alert(a.y); // undefined<br />
&nbsp;<br />
// 显式修改原型<br />
a.__proto__ = __newPrototype;<br />
&nbsp;<br />
// 现在"а"对象引用的是新对象<br />
alert(a.x); // 20<br />
alert(a.y); // 30<br />
</div><br />
注意，ES5提供了Object.getPrototypeOf(O)方法，该方法直接返回对象的[[Prototype]]属性——实例的初始原型。 然而，和__proto__相比，它只是getter，它不允许set值。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="68664" class="copybut" id="copybut68664" onclick="doCopy('code68664')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code68664"><br />
var foo = {};<br />
Object.getPrototypeOf(foo) == Object.prototype; // true<br />
</div></p>
<p><strong>对象独立于构造函数<br />
</strong>因为实例的原型独立于构造函数和构造函数的prototype属性，构造函数完成了自己的主要工作（创建对象）以后可以删除。原型对象通过引用[[Prototype]]属性继续存在：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="4722" class="copybut" id="copybut4722" onclick="doCopy('code4722')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code4722"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10<br />
&nbsp;<br />
// 设置A为null - 显示引用构造函数<br />
A = null;<br />
&nbsp;<br />
// 但如果.constructor属性没有改变的话，<br />
// 依然可以通过它创建对象<br />
var b = new a.constructor();<br />
alert(b.x); // 10<br />
&nbsp;<br />
// 隐式的引用也删除掉<br />
delete a.constructor.prototype.constructor;<br />
delete b.constructor.prototype.constructor;<br />
&nbsp;<br />
// 通过A的构造函数再也不能创建对象了<br />
// 但这2个对象依然有自己的原型<br />
alert(a.x); // 10<br />
alert(b.x); // 10<br />
</div></p>
<p><strong>instanceof操作符的特性<br />
</strong>我们是通过构造函数的prototype属性来显示引用原型的，这和instanceof操作符有关。该操作符是和原型链一起工作的，而不是构造函数，考虑到这一点，当检测对象的时候往往会有误解：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="43433" class="copybut" id="copybut43433" onclick="doCopy('code43433')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code43433"><br />
if (foo instanceof Foo) {<br />
&nbsp; ...<br />
}<br />
</div><br />
这不是用来检测对象foo是否是用Foo构造函数创建的，所有instanceof运算符只需要一个对象属性——foo.[[Prototype]]，在原型链中从Foo.prototype开始检查其是否存在。instanceof运算符是通过构造函数里的内部方法[[HasInstance]]来激活的。</p>
<p>让我们来看看这个例子：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="80414" class="copybut" id="copybut80414" onclick="doCopy('code80414')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code80414"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
var a = new A();<br />
alert(a.x); // 10<br />
&nbsp;<br />
alert(a instanceof A); // true<br />
&nbsp;<br />
// 如果设置原型为null<br />
A.prototype = null;<br />
&nbsp;<br />
// ..."a"依然可以通过a.[[Prototype]]访问原型<br />
alert(a.x); // 10<br />
&nbsp;<br />
// 不过，instanceof操作符不能再正常使用了<br />
// 因为它是从构造函数的prototype属性来实现的<br />
alert(a instanceof A); // 错误，A.prototype不是对象<br />
</div></p>
<p>另一方面，可以由构造函数来创建对象，但如果对象的[[Prototype]]属性和构造函数的prototype属性的值设置的是一样的话，instanceof检查的时候会返回true：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="69473" class="copybut" id="copybut69473" onclick="doCopy('code69473')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code69473"><br />
function B() {}<br />
var b = new B();<br />
&nbsp;<br />
alert(b instanceof B); // true<br />
&nbsp;<br />
function C() {}<br />
&nbsp;<br />
var __proto = {<br />
&nbsp; constructor: C<br />
};<br />
&nbsp;<br />
C.prototype = __proto;<br />
b.__proto__ = __proto;<br />
&nbsp;<br />
alert(b instanceof C); // true<br />
alert(b instanceof B); // false<br />
</div></p>
<p><strong>原型可以存放方法并共享属性<br />
</strong>大部分程序里使用原型是用来存储对象的方法、默认状态和共享对象的属性。</p>
<p>事实上，对象可以拥有自己的状态 ，但方法通常是一样的。 因此，为了内存优化，方法通常是在原型里定义的。 这意味着，这个构造函数创建的所有实例都可以共享找个方法。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="49179" class="copybut" id="copybut49179" onclick="doCopy('code49179')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code49179"><br />
function A(x) {<br />
&nbsp; this.x = x || 100;<br />
}<br />
&nbsp;<br />
A.prototype = (function () {<br />
&nbsp;<br />
&nbsp; // 初始化上下文<br />
&nbsp; // 使用额外的对象<br />
&nbsp;<br />
&nbsp; var _someSharedVar = 500;<br />
&nbsp;<br />
&nbsp; function _someHelper() {<br />
&nbsp;&nbsp;&nbsp; alert('internal helper: ' + _someSharedVar);<br />
&nbsp; }<br />
&nbsp;<br />
&nbsp; function method1() {<br />
&nbsp;&nbsp;&nbsp; alert('method1: ' + this.x);<br />
&nbsp; }<br />
&nbsp;<br />
&nbsp; function method2() {<br />
&nbsp;&nbsp;&nbsp; alert('method2: ' + this.x);<br />
&nbsp;&nbsp;&nbsp; _someHelper();<br />
&nbsp; }<br />
&nbsp;<br />
&nbsp; // 原型自身<br />
&nbsp; return {<br />
&nbsp;&nbsp;&nbsp; constructor: A,<br />
&nbsp;&nbsp;&nbsp; method1: method1,<br />
&nbsp;&nbsp;&nbsp; method2: method2<br />
&nbsp; };<br />
&nbsp;<br />
})();<br />
&nbsp;<br />
var a = new A(10);<br />
var b = new A(20);<br />
&nbsp;<br />
a.method1(); // method1: 10<br />
a.method2(); // method2: 10, internal helper: 500<br />
&nbsp;<br />
b.method1(); // method1: 20<br />
b.method2(); // method2: 20, internal helper: 500<br />
&nbsp;<br />
// 2个对象使用的是原型里相同的方法<br />
alert(a.method1 === b.method1); // true<br />
alert(a.method2 === b.method2); // true<br />
</div></p>
<p><strong>读写属性</strong></p>
<p>正如我们提到，读取和写入属性值是通过内部的[[Get]]和[[Put]]方法。这些内部方法是通过属性访问器激活的：点标记法或者索引标记法：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="10062" class="copybut" id="copybut10062" onclick="doCopy('code10062')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code10062"><br />
// 写入<br />
foo.bar = 10; // 调用了[[Put]]<br />
&nbsp;<br />
console.log(foo.bar); // 10, 调用了[[Get]]<br />
console.log(foo['bar']); // 效果一样<br />
</div><br />
让我们用伪代码来看一下这些方法是如何工作的：</p>
<p><strong>[[Get]]方法</strong></p>
<p>[[Get]]也会从原型链中查询属性，所以通过对象也可以访问原型中的属性。</p>
<p>O.[[Get]](P):<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="27411" class="copybut" id="copybut27411" onclick="doCopy('code27411')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code27411"> <br />
// 如果是自己的属性，就返回<br />
if (O.hasOwnProperty(P)) {<br />
&nbsp; return O.P;<br />
}<br />
&nbsp;<br />
// 否则，继续分析原型<br />
var __proto = O.[[Prototype]];<br />
&nbsp;<br />
// 如果原型是null，返回undefined<br />
// 这是可能的：最顶层Object.prototype.[[Prototype]]是null<br />
if (__proto === null) {<br />
&nbsp; return undefined;<br />
}<br />
&nbsp;<br />
// 否则，对原型链递归调用[[Get]]，在各层的原型中查找属性<br />
// 直到原型为null<br />
return __proto.[[Get]](P)<br />
</div><br />
请注意，因为[[Get]]在如下情况也会返回undefined：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="28480" class="copybut" id="copybut28480" onclick="doCopy('code28480')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code28480"><br />
if (window.someObject) {<br />
&nbsp; ...<br />
}<br />
</div><br />
这里，在window里没有找到someObject属性，然后会在原型里找，原型的原型里找，以此类推，如果都找不到，按照定义就返回undefined。</p>
<p>注意：in操作符也可以负责查找属性（也会查找原型链）：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="25275" class="copybut" id="copybut25275" onclick="doCopy('code25275')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code25275"><br />
if ('someObject' in window) {<br />
&nbsp; ...<br />
}<br />
</div><br />
这有助于避免一些特殊问题：比如即便someObject存在，在someObject等于false的时候，第一轮检测就通不过。</p>
<p><strong>[[Put]]方法</strong></p>
<p>[[Put]]方法可以创建、更新对象自身的属性，并且掩盖原型里的同名属性。</p>
<p>O.[[Put]](P, V):<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="34888" class="copybut" id="copybut34888" onclick="doCopy('code34888')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code34888"> <br />
// 如果不能给属性写值，就退出<br />
if (!O.[[CanPut]](P)) {<br />
&nbsp; return;<br />
}<br />
&nbsp;<br />
// 如果对象没有自身的属性，就创建它<br />
// 所有的attributes特性都是false<br />
if (!O.hasOwnProperty(P)) {<br />
&nbsp; createNewProperty(O, P, attributes: {<br />
&nbsp;&nbsp;&nbsp; ReadOnly: false,<br />
&nbsp;&nbsp;&nbsp; DontEnum: false,<br />
&nbsp;&nbsp;&nbsp; DontDelete: false,<br />
&nbsp;&nbsp;&nbsp; Internal: false<br />
&nbsp; });<br />
}<br />
&nbsp;<br />
// 如果属性存在就设置值，但不改变attributes特性<br />
O.P = V<br />
&nbsp;<br />
return;<br />
</div><br />
例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="59165" class="copybut" id="copybut59165" onclick="doCopy('code59165')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code59165"><br />
Object.prototype.x = 100;<br />
&nbsp;<br />
var foo = {};<br />
console.log(foo.x); // 100, 继承属性<br />
&nbsp;<br />
foo.x = 10; // [[Put]]<br />
console.log(foo.x); // 10, 自身属性<br />
&nbsp;<br />
delete foo.x;<br />
console.log(foo.x); // 重新是100,继承属性<br />
请注意，不能掩盖原型里的只读属性，赋值结果将忽略，这是由内部方法[[CanPut]]控制的。</p>
<p>// 例如，属性length是只读的，我们来掩盖一下length试试<br />
&nbsp;<br />
function SuperString() {<br />
&nbsp; /* nothing */<br />
}<br />
&nbsp;<br />
SuperString.prototype = new String("abc");<br />
&nbsp;<br />
var foo = new SuperString();<br />
&nbsp;<br />
console.log(foo.length); // 3, "abc"的长度<br />
&nbsp;<br />
// 尝试掩盖<br />
foo.length = 5;<br />
console.log(foo.length); // 依然是3<br />
</div><br />
但在ES5的严格模式下，如果掩盖只读属性的话，会保存TypeError错误。</p>
<p><strong>属性访问器</strong></p>
<p>内部方法[[Get]]和[[Put]]在ECMAScript里是通过点符号或者索引法来激活的，如果属性标示符是合法的名字的话，可以通过“.”来访问，而索引方运行动态定义名称。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="45683" class="copybut" id="copybut45683" onclick="doCopy('code45683')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code45683"><br />
var a = {testProperty: 10};<br />
&nbsp;<br />
alert(a.testProperty); // 10, 点<br />
alert(a['testProperty']); // 10, 索引<br />
&nbsp;<br />
var propertyName = 'Property';<br />
alert(a['test' + propertyName]); // 10, 动态属性通过索引的方式<br />
</div></p>
<p>这里有一个非常重要的特性——属性访问器总是使用ToObject规范来对待“.”左边的值。这种隐式转化和这句“在JavaScript中一切都是对象”有关系，（然而，当我们已经知道了，JavaScript里不是所有的值都是对象）。</p>
<p>如果对原始值进行属性访问器取值，访问之前会先对原始值进行对象包装（包括原始值），然后通过包装的对象进行访问属性，属性访问以后，包装对象就会被删除。</p>
<p>例如：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="59569" class="copybut" id="copybut59569" onclick="doCopy('code59569')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code59569"><br />
var a = 10; // 原始值<br />
&nbsp;<br />
// 但是可以访问方法（就像对象一样）<br />
alert(a.toString()); // "10"<br />
&nbsp;<br />
// 此外，我们可以在a上创建一个心属性<br />
a.test = 100; // 好像是没问题的<br />
&nbsp;<br />
// 但，[[Get]]方法没有返回该属性的值，返回的却是undefined<br />
alert(a.test); // undefined<br />
</div><br />
那么，为什么整个例子里的原始值可以访问toString方法，而不能访问新创建的test属性呢？</p>
<p>答案很简单：</p>
<p>首先，正如我们所说，使用属性访问器以后，它已经不是原始值了，而是一个包装过的中间对象（整个例子是使用new Number(a)），而toString方法这时候是通过原型链查找到的：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="17912" class="copybut" id="copybut17912" onclick="doCopy('code17912')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code17912"><br />
// 执行a.toString()的原理:<br />
&nbsp;<br />
1. wrapper = new Number(a);<br />
2. wrapper.toString(); // "10"<br />
3. delete wrapper;<br />
</div><br />
接下来，[[Put]]方法创建新属性时候，也是通过包装装的对象进行的：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="42884" class="copybut" id="copybut42884" onclick="doCopy('code42884')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code42884"><br />
// 执行a.test = 100的原理：<br />
&nbsp;<br />
1. wrapper = new Number(a);<br />
2. wrapper.test = 100;<br />
3. delete wrapper;<br />
</div></p>
<p>我们看到，在第3步的时候，包装的对象以及删除了，随着新创建的属性页被删除了——删除包装对象本身。</p>
<p>然后使用[[Get]]获取test值的时候，再一次创建了包装对象，但这时候包装的对象已经没有test属性了，所以返回的是undefined：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="41411" class="copybut" id="copybut41411" onclick="doCopy('code41411')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code41411"><br />
// 执行a.test的原理:<br />
&nbsp;<br />
1. wrapper = new Number(a);<br />
2. wrapper.test; // undefined<br />
</div><br />
这种方式解释了原始值的读取方式，另外，任何原始值如果经常用在访问属性的话，时间效率考虑，都是直接用一个对象替代它；与此相反，如果不经常访问，或者只是用于计算的话，到可以保留这种形式。</p>
<p><strong>继承</strong></p>
<p>我们知道，ECMAScript是使用基于原型的委托式继承。链和原型在原型链里已经提到过了。其实，所有委托的实现和原型链的查找分析都浓缩到[[Get]]方法了。</p>
<p>如果你完全理解[[Get]]方法，那JavaScript中的继承这个问题将不解自答了。</p>
<p>经常在论坛上谈论JavaScript中的继承时，我都是用一行代码来展示，事实上，我们不需要创建任何对象或函数，因为该语言已经是基于继承的了，代码如下：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="72387" class="copybut" id="copybut72387" onclick="doCopy('code72387')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code72387"><br />
alert(1..toString()); // "1"<br />
</div><br />
我们已经知道了[[Get]]方法和属性访问器的原理了，我们来看看都发生了什么：</p>
<p>1.首先，从原始值1，通过new Number(1)创建包装对象<br />
2.然后toString方法是从这个包装对象上继承得到的</p>
<p>为什么是继承的？ 因为在ECMAScript中的对象可以有自己的属性，包装对象在这种情况下没有toString方法。 因此它是从原理里继承的，即Number.prototype。</p>
<p>注意有个微妙的地方，在上面的例子中的两个点不是一个错误。第一点是代表小数部分，第二个才是一个属性访问器：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="79459" class="copybut" id="copybut79459" onclick="doCopy('code79459')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code79459"><br />
1.toString(); // 语法错误！<br />
&nbsp;<br />
(1).toString(); // OK<br />
&nbsp;<br />
1..toString(); // OK<br />
&nbsp;<br />
1['toString'](); // OK<br />
</div></p>
<p><strong>原型链</strong></p>
<p>让我们展示如何为用户定义对象创建原型链，非常简单：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="84800" class="copybut" id="copybut84800" onclick="doCopy('code84800')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code84800"><br />
function A() {<br />
&nbsp; alert('A.[[Call]] activated');<br />
&nbsp; this.x = 10;<br />
}<br />
A.prototype.y = 20;<br />
&nbsp;<br />
var a = new A();<br />
alert([a.x, a.y]); // 10 (自身), 20 (继承)<br />
&nbsp;<br />
function B() {}<br />
&nbsp;<br />
// 最近的原型链方式就是设置对象的原型为另外一个新对象<br />
B.prototype = new A();<br />
&nbsp;<br />
// 修复原型的constructor属性，否则的话是A了 <br />
B.prototype.constructor = B;<br />
&nbsp;<br />
var b = new B();<br />
alert([b.x, b.y]); // 10, 20, 2个都是继承的<br />
&nbsp;<br />
// [[Get]] b.x:<br />
// b.x (no) --&gt;<br />
// b.[[Prototype]].x (yes) - 10<br />
&nbsp;<br />
// [[Get]] b.y<br />
// b.y (no) --&gt;<br />
// b.[[Prototype]].y (no) --&gt;<br />
// b.[[Prototype]].[[Prototype]].y (yes) - 20<br />
&nbsp;<br />
// where b.[[Prototype]] === B.prototype,<br />
// and b.[[Prototype]].[[Prototype]] === A.prototype<br />
</div></p>
<p>这种方法有两个特性：</p>
<p>首先，B.prototype将包含x属性。乍一看这可能不对，你可能会想x属性是在A里定义的并且B构造函数也是这样期望的。尽管原型继承正常情况是没问题的，但B构造函数有时候可能不需要x属性，与基于class的继承相比，所有的属性都复制到后代子类里了。</p>
<p>尽管如此，如果有需要（模拟基于类的继承）将x属性赋给B构造函数创建的对象上，有一些方法，我们后来来展示其中一种方式。</p>
<p>其次，这不是一个特征而是缺点——子类原型创建的时候，构造函数的代码也执行了，我们可以看到消息"A.[[Call]] activated"显示了两次——当用A构造函数创建对象赋给B.prototype属性的时候，另外一场是a对象创建自身的时候！</p>
<p>下面的例子比较关键，在父类的构造函数抛出的异常：可能实际对象创建的时候需要检查吧，但很明显，同样的case，也就是就是使用这些父对象作为原型的时候就会出错。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="68778" class="copybut" id="copybut68778" onclick="doCopy('code68778')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code68778"><br />
function A(param) {<br />
&nbsp; if (!param) {<br />
&nbsp;&nbsp;&nbsp; throw 'Param required';<br />
&nbsp; }<br />
&nbsp; this.param = param;<br />
}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
var a = new A(20);<br />
alert([a.x, a.param]); // 10, 20<br />
&nbsp;<br />
function B() {}<br />
B.prototype = new A(); // Error<br />
</div></p>
<p>此外，在父类的构造函数有太多代码的话也是一种缺点。</p>
<p>解决这些“功能”和问题，程序员使用原型链的标准模式（下面展示），主要目的就是在中间包装构造函数的创建，这些包装构造函数的链里包含需要的原型。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="16844" class="copybut" id="copybut16844" onclick="doCopy('code16844')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code16844"><br />
function A() {<br />
&nbsp; alert('A.[[Call]] activated');<br />
&nbsp; this.x = 10;<br />
}<br />
A.prototype.y = 20;<br />
&nbsp;<br />
var a = new A();<br />
alert([a.x, a.y]); // 10 (自身), 20 (集成)<br />
&nbsp;<br />
function B() {<br />
&nbsp; // 或者使用A.apply(this, arguments)<br />
&nbsp; B.superproto.constructor.apply(this, arguments);<br />
}<br />
&nbsp;<br />
// 继承：通过空的中间构造函数将原型连在一起<br />
var F = function () {};<br />
F.prototype = A.prototype; // 引用<br />
B.prototype = new F();<br />
B.superproto = A.prototype; // 显示引用到另外一个原型上, "sugar"<br />
&nbsp;<br />
// 修复原型的constructor属性，否则的就是A了<br />
B.prototype.constructor = B;<br />
&nbsp;<br />
var b = new B();<br />
alert([b.x, b.y]); // 10 (自身), 20 (集成)<br />
</div></p>
<p>注意，我们在b实例上创建了自己的x属性，通过B.superproto.constructor调用父构造函数来引用新创建对象的上下文。</p>
<p>我们也修复了父构造函数在创建子原型的时候不需要的调用，此时，消息"A.[[Call]] activated"在需要的时候才会显示。</p>
<p>为了在原型链里重复相同的行为（中间构造函数创建，设置superproto，恢复原始构造函数），下面的模板可以封装成一个非常方面的工具函数，其目的是连接原型的时候不是根据构造函数的实际名称。<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="46088" class="copybut" id="copybut46088" onclick="doCopy('code46088')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code46088"><br />
function inherit(child, parent) {<br />
&nbsp; var F = function () {};<br />
&nbsp; F.prototype = parent.prototype<br />
&nbsp; child.prototype = new F();<br />
&nbsp; child.prototype.constructor = child;<br />
&nbsp; child.superproto = parent.prototype;<br />
&nbsp; return child;<br />
}<br />
</div></p>
<p>因此，继承：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="31798" class="copybut" id="copybut31798" onclick="doCopy('code31798')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code31798"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
function B() {}<br />
inherit(B, A); // 连接原型<br />
&nbsp;<br />
var b = new B();<br />
alert(b.x); // 10, 在A.prototype查找到<br />
</div><br />
也有很多语法形式（包装而成），但所有的语法行都是为了减少上述代码里的行为。</p>
<p>例如，如果我们把中间的构造函数放到外面，就可以优化前面的代码（因此，只有一个函数被创建），然后重用它：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="1226" class="copybut" id="copybut1226" onclick="doCopy('code1226')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code1226"><br />
var inherit = (function(){<br />
&nbsp; function F() {}<br />
&nbsp; return function (child, parent) {<br />
&nbsp;&nbsp;&nbsp; F.prototype = parent.prototype;<br />
&nbsp;&nbsp;&nbsp; child.prototype = new F;<br />
&nbsp;&nbsp;&nbsp; child.prototype.constructor = child;<br />
&nbsp;&nbsp;&nbsp; child.superproto = parent.prototype;<br />
&nbsp;&nbsp;&nbsp; return child;<br />
&nbsp; };<br />
})();<br />
</div></p>
<p>由于对象的真实原型是[[Prototype]]属性，这意味着F.prototype可以很容易修改和重用，因为通过new F创建的child.prototype可以从child.prototype的当前值里获取[[Prototype]]：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="66382" class="copybut" id="copybut66382" onclick="doCopy('code66382')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code66382"><br />
function A() {}<br />
A.prototype.x = 10;<br />
&nbsp;<br />
function B() {}<br />
inherit(B, A);<br />
&nbsp;<br />
B.prototype.y = 20;<br />
&nbsp;<br />
B.prototype.foo = function () {<br />
&nbsp; alert("B#foo");<br />
};<br />
&nbsp;<br />
var b = new B();<br />
alert(b.x); // 10, 在A.prototype里查到<br />
&nbsp;<br />
function C() {}<br />
inherit(C, B);<br />
&nbsp;<br />
// 使用"superproto"语法糖<br />
// 调用父原型的同名方法<br />
&nbsp;<br />
C.ptototype.foo = function () {<br />
&nbsp; C.superproto.foo.call(this);<br />
&nbsp; alert("C#foo");<br />
};<br />
&nbsp;<br />
var c = new C();<br />
alert([c.x, c.y]); // 10, 20<br />
&nbsp;<br />
c.foo(); // B#foo, C#foo<br />
</div></p>
<p>注意，ES5为原型链标准化了这个工具函数，那就是Object.create方法。ES3可以使用以下方式实现：<br />
<div class="codetitle"><span><a style="CURSOR: pointer" data="70914" class="copybut" id="copybut70914" onclick="doCopy('code70914')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code70914"><br />
Object.create ||<br />
Object.create = function (parent, properties) {<br />
&nbsp; function F() {}<br />
&nbsp; F.prototype = parent;<br />
&nbsp; var child = new F;<br />
&nbsp; for (var k in properties) {<br />
&nbsp;&nbsp;&nbsp; child[k] = properties[k].value;<br />
&nbsp; }<br />
&nbsp; return child;<br />
}</p>
<p>// 用法<br />
var foo = {x: 10};<br />
var bar = Object.create(foo, {y: {value: 20}});<br />
console.log(bar.x, bar.y); // 10, 20<br />
</div><br />
此外，所有模仿现在基于类的经典继承方式都是根据这个原则实现的，现在可以看到，它实际上不是基于类的继承，而是连接原型的一个很方便的代码重用。</p>
<p><strong>结论</strong></p>
<p>本章内容已经很充分和详细了，希望这些资料对你有用，并且消除你对ECMAScript的疑问，如果你有任何问题，请留言，我们一起讨论。</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/89045.html'>js实现弹窗插件功能实例代码分享</a><a>下一篇</a><a href='/php/biji/89047.html'>jQuery判断指定id的对象是否存在的方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>