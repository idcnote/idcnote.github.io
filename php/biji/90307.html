<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>SQLite3 API 编程手册_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="前序：... 1一、 版本... 1二、 基本编译... 2三、 SQLITE操作入门... 2（1） 基本流程... 2（2） SQL语句操作... 4（3） 操作二进制... 8（4） 事务处理... 10四、 给数据库加密... 10五、" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">SQLite3 API 编程手册</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>前序：... 1一、 版本... 1二、 基本编译... 2三、 SQLITE操作入门... 2（1） 基本流程... 2（2） SQL语句操作... 4（3） 操作二进制... 8（4） 事务处理... 10四、 给数据库加密... 10五、</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P>前序：... 1<BR>一、 版本... 1<BR>二、 基本编译... 2<BR>三、 SQLITE操作入门... 2<BR>（1） 基本流程... 2<BR>（2） SQL语句操作... 4<BR>（3） 操作二进制... 8<BR>（4） 事务处理... 10<BR>四、 给数据库加密... 10<BR>五、 后记... 25</P>
<P>前序：<BR>Sqlite3 的确很好用。小巧、速度快。但是因为非微软的产品，帮助文档总觉得不够。这些天再次研究它，又有一些收获，这里把我对 sqlite3 的研究列出来，以备忘记。</P>
<P>这里要注明，我是一个跨平台专注者，并不喜欢只用 windows 平台。我以前的工作就是为 unix 平台写代码。下面我所写的东西，虽然没有验证，但是我已尽量不使用任何 windows 的东西，只使用标准 C 或标准C++。但是，我没有尝试过在别的系统、别的编译器下编译，因此下面的叙述如果不正确，则留待以后修改。</P>
<P>下面我的代码仍然用 VC 编写，因为我觉得VC是一个很不错的IDE，可以加快代码编写速度（例如配合 Vassist ）。下面我所说的编译环境，是VC2003。如果读者觉得自己习惯于 unix 下用 vi 编写代码速度较快，可以不用管我的说明，只需要符合自己习惯即可，因为我用的是标准 C 或 C++ 。不会给任何人带来不便。</P>
<P>一、 版本<BR>从 www.sqlite.org 网站可下载到最新的 sqlite 代码和编译版本。我写此文章时，最新代码是 3.3.17 版本。</P>
<P>很久没有去下载 sqlite 新代码，因此也不知道 sqlite 变化这么大。以前很多文件，现在全部合并成一个 sqlite3.c 文件。如果单独用此文件，是挺好的，省去拷贝一堆文件还担心有没有遗漏。但是也带来一个问题：此文件太大，快接近7万行代码，VC开它整个机器都慢下来了。如果不需要改它代码，也就不需要打开 sqlite3.c 文件，机器不会慢。但是，下面我要写通过修改 sqlite 代码完成加密功能，那时候就比较痛苦了。如果个人水平较高，建议用些简单的编辑器来编辑，例如 UltraEdit 或 Notepad 。速度会快很多。</P>
<P>二、 基本编译<BR>这个不想多说了，在 VC 里新建 dos 控制台空白工程，把 sqlite3.c 和 sqlite3.h 添加到工程，再新建一个 main.cpp 文件。在里面写:</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="29613" class="copybut" id="copybut29613" onclick="doCopy('code29613')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code29613"><BR>extern "C"<BR>{<BR>#include "./sqlite3.h"<BR>};<BR>int main( int , char** )<BR>{<BR>return 0;<BR>}<BR></div></P>
<P>为什么要 extern “C” ？如果问这个问题，我不想说太多，这是C++的基础。要在 C++ 里使用一段 C 的代码，必须要用 extern “C” 括起来。C++跟 C虽然语法上有重叠，但是它们是两个不同的东西，内存里的布局是完全不同的，在C++编译器里不用extern “C”括起C代码，会导致编译器不知道该如何为 C 代码描述内存布局。</P>
<P>可能在 sqlite3.c 里人家已经把整段代码都 extern “C” 括起来了，但是你遇到一个 .c 文件就自觉的再括一次，也没什么不好。</P>
<P>基本工程就这样建立起来了。编译，可以通过。但是有一堆的 warning。可以不管它。</P>
<P>三、 SQLITE操作入门<BR>sqlite提供的是一些C函数接口，你可以用这些函数操作数据库。通过使用这些接口，传递一些标准 sql 语句（以 char * 类型）给 sqlite 函数，sqlite 就会为你操作数据库。</P>
<P>sqlite 跟MS的access一样是文件型数据库，就是说，一个数据库就是一个文件，此数据库里可以建立很多的表，可以建立索引、触发器等等，但是，它实际上得到的就是一个文件。备份这个文件就备份了整个数据库。</P>
<P>sqlite 不需要任何数据库引擎，这意味着如果你需要 sqlite 来保存一些用户数据，甚至都不需要安装数据库(如果你做个小软件还要求人家必须装了sqlserver 才能运行，那也太黑心了)。</P>
<P>下面开始介绍数据库基本操作。</P>
<P>（1） 基本流程<BR>i.1 关键数据结构</P>
<P>sqlite 里最常用到的是 sqlite3 * 类型。从数据库打开开始，sqlite就要为这个类型准备好内存，直到数据库关闭，整个过程都需要用到这个类型。当数据库打开时开始，这个类型的变量就代表了你要操作的数据库。下面再详细介绍。</P>
<P>i.2 打开数据库</P>
<P>int sqlite3_open( 文件名, sqlite3 ** );</P>
<P>用这个函数开始数据库操作。</P>
<P>需要传入两个参数，一是数据库文件名，比如：c://DongChunGuang_Database.db。</P>
<P>文件名不需要一定存在，如果此文件不存在，sqlite 会自动建立它。如果它存在，就尝试把它当数据库文件来打开。</P>
<P>sqlite3 ** 参数即前面提到的关键数据结构。这个结构底层细节如何，你不要关它。</P>
<P>函数返回值表示操作是否正确，如果是 SQLITE_OK 则表示操作正常。相关的返回值sqlite定义了一些宏。具体这些宏的含义可以参考 sqlite3.h 文件。里面有详细定义（顺便说一下，sqlite3 的代码注释率自称是非常高的，实际上也的确很高。只要你会看英文，sqlite 可以让你学到不少东西）。</P>
<P>下面介绍关闭数据库后，再给一段参考代码。</P>
<P>i.3 关闭数据库</P>
<P>int sqlite3_close(sqlite3 *);</P>
<P>前面如果用 sqlite3_open 开启了一个数据库，结尾时不要忘了用这个函数关闭数据库。</P>
<P>下面给段简单的代码：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="21327" class="copybut" id="copybut21327" onclick="doCopy('code21327')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code21327"><BR>extern "C"<BR>{<BR>#include "./sqlite3.h"<BR>};<BR>int main( int , char** )<BR>{<BR>sqlite3 * db = NULL; //声明sqlite关键结构指针<BR>int result;<BR>//打开数据库<BR>//需要传入 db 这个指针的指针，因为 sqlite3_open 函数要为这个指针分配内存，还要让db指针指向这个内存区<BR>result = sqlite3_open( “c://Dcg_database.db”, &db );<BR>if( result != SQLITE_OK )<BR>{<BR>//数据库打开失败<BR>return -1;<BR>}<BR>//数据库操作代码<BR>//…<BR>//数据库打开成功<BR>//关闭数据库<BR>sqlite3_close( db );<BR>return 0;<BR>}<BR></div></P>
<P>这就是一次数据库操作过程。</P>
<P>（2） SQL语句操作<BR>本节介绍如何用sqlite 执行标准 sql 语法。</P>
<P>i.1 执行sql语句<BR>int sqlite3_exec(sqlite3*, const char *sql, sqlite3_callback, void *, char **errmsg );</P>
<P>这就是执行一条 sql 语句的函数。</P>
<P>第1个参数不再说了，是前面open函数得到的指针。说了是关键数据结构。</P>
<P>第2个参数const char *sql 是一条 sql 语句，以/0结尾。</P>
<P>第3个参数sqlite3_callback 是回调，当这条语句执行之后，sqlite3会去调用你提供的这个函数。（什么是回调函数，自己找别的资料学习）</P>
<P>第4个参数void * 是你所提供的指针，你可以传递任何一个指针参数到这里，这个参数最终会传到回调函数里面，如果不需要传递指针给回调函数，可以填NULL。等下我们再看回调函数的写法，以及这个参数的使用。</P>
<P>第5个参数char ** errmsg 是错误信息。注意是指针的指针。sqlite3里面有很多固定的错误信息。执行 sqlite3_exec 之后，执行失败时可以查阅这个指针（直接 printf(“%s/n”,errmsg)）得到一串字符串信息，这串信息告诉你错在什么地方。sqlite3_exec函数通过修改你传入的指针的指针，把你提供的指针指向错误提示信息，这样sqlite3_exec函数外面就可以通过这个 char*得到具体错误提示。</P>
<P>说明：通常，sqlite3_callback 和它后面的 void * 这两个位置都可以填 NULL。填NULL表示你不需要回调。比如你做 insert 操作，做 delete 操作，就没有必要使用回调。而当你做 select 时，就要使用回调，因为 sqlite3 把数据查出来，得通过回调告诉你查出了什么数据。</P>
<P>i.2 exec 的回调</P>
<P>typedef int (*sqlite3_callback)(void*,int,char**, char**);</P>
<P>你的回调函数必须定义成上面这个函数的类型。下面给个简单的例子：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="99301" class="copybut" id="copybut99301" onclick="doCopy('code99301')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code99301"><BR>//sqlite3的回调函数<BR>// sqlite 每查到一条记录，就调用一次这个回调<BR>int LoadMyInfo( void * para, int n_column, char ** column_value, char ** column_name )<BR>{<BR>//para是你在 sqlite3_exec 里传入的 void * 参数<BR>//通过para参数，你可以传入一些特殊的指针（比如类指针、结构指针），然后在这里面强制转换成对应的类型（这里面是void*类型，必须强制转换成你的类型才可用）。然后操作这些数据<BR>//n_column是这一条记录有多少个字段 (即这条记录有多少列)<BR>// char ** column_value 是个关键值，查出来的数据都保存在这里，它实际上是个1维数组（不要以为是2维数组），每一个元素都是一个 char * 值，是一个字段内容（用字符串来表示，以/0结尾）<BR>//char ** column_name 跟 column_value是对应的，表示这个字段的字段名称<BR>//这里，我不使用 para 参数。忽略它的存在.<BR>int i;<BR>printf( “记录包含 %d 个字段/n”, n_column );<BR>for( i = 0 ; i &lt; n_column; i ++ )<BR>{<BR>printf( “字段名:%s &szlig;&gt; 字段值:%s/n”, column_name[i], column_value[i] );<BR>}<BR>printf( “------------------/n“ );<BR>return 0;<BR>}<BR>int main( int , char ** )<BR>{<BR>sqlite3 * db;<BR>int result;<BR>char * errmsg = NULL;<BR>result = sqlite3_open( “c://Dcg_database.db”, &db );<BR>if( result != SQLITE_OK )<BR>{<BR>//数据库打开失败<BR>return -1;<BR>}</P>
<P>//数据库操作代码<BR>//创建一个测试表，表名叫 MyTable_1，有2个字段： ID 和 name。其中ID是一个自动增加的类型，以后insert时可以不去指定这个字段，它会自己从0开始增加<BR>result = sqlite3_exec( db, “create table MyTable_1( ID integer primary key autoincrement, name nvarchar(32) )”, NULL, NULL, errmsg );<BR>if(result != SQLITE_OK )<BR>{<BR>printf( “创建表失败，错误码:%d，错误原因:%s/n”, result, errmsg );<BR>}</P>
<P>//插入一些记录<BR>result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘走路' )”, 0, 0, errmsg );<BR>if(result != SQLITE_OK )<BR>{<BR>printf( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );<BR>}<BR>result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘骑单车' )”, 0, 0, errmsg );<BR>if(result != SQLITE_OK )<BR>{<BR>printf( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );<BR>}<BR>result = sqlite3_exec( db, “insert into MyTable_1( name ) values ( ‘坐汽车' )”, 0, 0, errmsg );<BR>if(result != SQLITE_OK )<BR>{<BR>printf( “插入记录失败，错误码:%d，错误原因:%s/n”, result, errmsg );<BR>}</P>
<P>//开始查询数据库<BR>result = sqlite3_exec( db, “select * from MyTable_1”, LoadMyInfo, NULL, errmsg );</P>
<P>//关闭数据库<BR>sqlite3_close( db );<BR>return 0;<BR>}<BR></div></P>
<P>通过上面的例子，应该可以知道如何打开一个数据库，如何做数据库基本操作。</P>
<P>有这些知识，基本上可以应付很多数据库操作了。</P>
<P>i.3 不使用回调查询数据库</P>
<P>上面介绍的 sqlite3_exec 是使用回调来执行 select 操作。还有一个方法可以直接查询而不需要回调。但是，我个人感觉还是回调好，因为代码可以更加整齐，只不过用回调很麻烦，你得声明一个函数，如果这个函数是类成员函数，你还不得不把它声明成 static 的（要问为什么？这又是C++基础了。C++成员函数实际上隐藏了一个参数：this，C++调用类的成员函数的时候，隐含把类指针当成函数的第一个参数传递进去。结果，这造成跟前面说的 sqlite 回调函数的参数不相符。只有当把成员函数声明成 static 时，它才没有多余的隐含的this参数）。</P>
<P>虽然回调显得代码整齐，但有时候你还是想要非回调的 select 查询。这可以通过 sqlite3_get_table 函数做到。</P>
<P>int sqlite3_get_table(sqlite3*, const char *sql, char ***resultp, int *nrow, int *ncolumn, char **errmsg );</P>
<P>第1个参数不再多说，看前面的例子。<BR>第2个参数是 sql 语句，跟 sqlite3_exec 里的 sql 是一样的。是一个很普通的以/0结尾的char *字符串。<BR>第3个参数是查询结果，它依然一维数组（不要以为是二维数组，更不要以为是三维数组）。它内存布局是：第一行是字段名称，后面是紧接着是每个字段的值。下面用例子来说事。<BR>第4个参数是查询出多少条记录（即查出多少行）。<BR>第5个参数是多少个字段（多少列）。<BR>第6个参数是错误信息，跟前面一样，这里不多说了。</P>
<P>下面给个简单例子:</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="38822" class="copybut" id="copybut38822" onclick="doCopy('code38822')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code38822"><BR>int main( int , char ** )<BR>{<BR>sqlite3 * db;<BR>int result;<BR>char * errmsg = NULL;<BR>char **dbResult; //是 char ** 类型，两个*号<BR>int nRow, nColumn;<BR>int i , j;<BR>int index;<BR>result = sqlite3_open( “c://Dcg_database.db”, &db );<BR>if( result != SQLITE_OK )<BR>{</P>
<P>//数据库打开失败<BR>return -1;<BR>}</P>
<P>//数据库操作代码<BR>//假设前面已经创建了 MyTable_1 表<BR>//开始查询，传入的 dbResult 已经是 char **，这里又加了一个 & 取地址符，传递进去的就成了 char ***<BR>result = sqlite3_get_table( db, “select * from MyTable_1”, &dbResult, &nRow, &nColumn, &errmsg );<BR>if( SQLITE_OK == result )<BR>{<BR>//查询成功</P>
<P>index = nColumn; //前面说过 dbResult 前面第一行数据是字段名称，从 nColumn 索引开始才是真正的数据<BR>printf( “查到%d条记录/n”, nRow );<BR>for( i = 0; i &lt; nRow ; i++ )<BR>{<BR>printf( “第 %d 条记录/n”, i+1 );<BR>for( j = 0 ; j &lt; nColumn; j++ )<BR>{<BR>printf( “字段名:%s &szlig;&gt; 字段值:%s/n”, dbResult[j], dbResult [index] );<BR>++index; // dbResult 的字段值是连续的，从第0索引到第 nColumn - 1索引都是字段名称，从第 nColumn 索引开始，后面都是字段值，它把一个二维的表（传统的行列表示法）用一个扁平的形式来表示<BR>}<BR>printf( “-------/n” );<BR>}<BR>}<BR>//到这里，不论数据库查询是否成功，都释放 char** 查询结果，使用 sqlite 提供的功能来释放<BR>sqlite3_free_table( dbResult );</P>
<P>//关闭数据库<BR>sqlite3_close( db );<BR>return 0;<BR>}<BR></div></P>
<P>到这个例子为止，sqlite3 的常用用法都介绍完了。</P>
<P>用以上的方法，再配上 sql 语句，完全可以应付绝大多数数据库需求。</P>
<P>但有一种情况，用上面方法是无法实现的：需要insert、select 二进制。当需要处理二进制数据时，上面的方法就没办法做到。下面这一节说明如何插入二进制数据</P>
<P>（2） 操作二进制<BR>sqlite 操作二进制数据需要用一个辅助的数据类型：sqlite3_stmt * 。</P>
<P>这个数据类型记录了一个“sql语句”。为什么我把 “sql语句” 用双引号引起来？因为你可以把 sqlite3_stmt * 所表示的内容看成是 sql语句，但是实际上它不是我们所熟知的sql语句。它是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。</P>
<P>正因为这个结构已经被解析了，所以你可以往这个语句里插入二进制数据。当然，把二进制数据插到 sqlite3_stmt 结构里可不能直接 memcpy ，也不能像 std::string 那样用 + 号。必须用 sqlite 提供的函数来插入。</P>
<P>&nbsp;</P>
<P>i.1 写入二进制</P>
<P>下面说写二进制的步骤。</P>
<P>要插入二进制，前提是这个表的字段的类型是 blob 类型。我假设有这么一张表：</P>
<P>create table Tbl_2( ID integer, file_content blob )</P>
<P>首先声明</P>
<P>sqlite3_stmt * stat;</P>
<P>然后，把一个 sql 语句解析到 stat 结构里去：</P>
<P>sqlite3_prepare( db, “insert into Tbl_2( ID, file_content) values( 10, ? )”, -1, &stat, 0 );</P>
<P>上面的函数完成 sql 语句的解析。第一个参数跟前面一样，是个 sqlite3 * 类型变量，第二个参数是一个 sql 语句。</P>
<P>这个 sql 语句特别之处在于 values 里面有个 ? 号。在sqlite3_prepare函数里，?号表示一个未定的值，它的值等下才插入。</P>
<P>第三个参数我写的是-1，这个参数含义是前面 sql 语句的长度。如果小于0，sqlite会自动计算它的长度（把sql语句当成以/0结尾的字符串）。<BR>第四个参数是 sqlite3_stmt 的指针的指针。解析以后的sql语句就放在这个结构里。<BR>第五个参数我也不知道是干什么的。为0就可以了。</P>
<P>如果这个函数执行成功（返回值是 SQLITE_OK 且 stat 不为NULL ），那么下面就可以开始插入二进制数据。</P>
<P>sqlite3_bind_blob( stat, 1, pdata, (int)(length_of_data_in_bytes), NULL ); // pdata为数据缓冲区，length_of_data_in_bytes为数据大小，以字节为单位</P>
<P>这个函数一共有5个参数。</P>
<P>第1个参数：是前面prepare得到的 sqlite3_stmt * 类型变量。<BR>第2个参数：?号的索引。前面prepare的sql语句里有一个?号，假如有多个?号怎么插入？方法就是改变 bind_blob 函数第2个参数。这个参数我写1，表示这里插入的值要替换 stat 的第一个?号（这里的索引从1开始计数，而非从0开始）。如果你有多个?号，就写多个 bind_blob 语句，并改变它们的第2个参数就替换到不同的?号。如果有?号没有替换，sqlite为它取值null。<BR>第3个参数：二进制数据起始指针。<BR>第4个参数：二进制数据的长度，以字节为单位。<BR>第5个参数：是个析够回调函数，告诉sqlite当把数据处理完后调用此函数来析够你的数据。这个参数我还没有使用过，因此理解也不深刻。但是一般都填NULL，需要释放的内存自己用代码来释放。</P>
<P>bind完了之后，二进制数据就进入了你的“sql语句”里了。你现在可以把它保存到数据库里：</P>
<P>int result = sqlite3_step( stat );</P>
<P>通过这个语句，stat 表示的sql语句就被写到了数据库里。</P>
<P>最后，要把 sqlite3_stmt 结构给释放：</P>
<P>sqlite3_finalize( stat ); //把刚才分配的内容析构掉<br><br>i.2 读出二进制</P>
<P>下面说读二进制的步骤。</P>
<P>跟前面一样，先声明 sqlite3_stmt * 类型变量：</P>
<P>sqlite3_stmt * stat;</P>
<P>然后，把一个 sql 语句解析到 stat 结构里去：</P>
<P>sqlite3_prepare( db, “select * from Tbl_2”, -1, &stat, 0 );</P>
<P>当 prepare 成功之后（返回值是 SQLITE_OK ），开始查询数据。</P>
<P>int result = sqlite3_step( stat );</P>
<P>这一句的返回值是 SQLITE_ROW 时表示成功（不是 SQLITE_OK ）。</P>
<P>你可以循环执行 sqlite3_step 函数，一次 step 查询出一条记录。直到返回值不为 SQLITE_ROW 时表示查询结束。</P>
<P>然后开始获取第一个字段：ID 的值。ID是个整数，用下面这个语句获取它的值：</P>
<P>int id = sqlite3_column_int( stat, 0 ); //第2个参数表示获取第几个字段内容，从0开始计算，因为我的表的ID字段是第一个字段，因此这里我填0</P>
<P>下面开始获取 file_content 的值，因为 file_content 是二进制，因此我需要得到它的指针，还有它的长度：</P>
<P>const void * pFileContent = sqlite3_column_blob( stat, 1 );</P>
<P>int len = sqlite3_column_bytes( stat, 1 );</P>
<P>这样就得到了二进制的值。</P>
<P>把 pFileContent 的内容保存出来之后，不要忘了释放 sqlite3_stmt 结构：</P>
<P>sqlite3_finalize( stat ); //把刚才分配的内容析构掉</P>
<P>i.3 重复使用 sqlite3_stmt 结构</P>
<P>如果你需要重复使用 sqlite3_prepare 解析好的 sqlite3_stmt 结构，需要用函数： sqlite3_reset。</P>
<P>result = sqlite3_reset(stat);</P>
<P>这样， stat 结构又成为 sqlite3_prepare 完成时的状态，你可以重新为它 bind 内容。</P>
<P>（4） 事务处理</P>
<P>sqlite 是支持事务处理的。如果你知道你要同步删除很多数据，不仿把它们做成一个统一的事务。</P>
<P>通常一次 sqlite3_exec 就是一次事务，如果你要删除1万条数据，sqlite就做了1万次：开始新事务-&gt;删除一条数据-&gt;提交事务-&gt;开始新事务-&gt;… 的过程。这个操作是很慢的。因为时间都花在了开始事务、提交事务上。</P>
<P>你可以把这些同类操作做成一个事务，这样如果操作错误，还能够回滚事务。</P>
<P>事务的操作没有特别的接口函数，它就是一个普通的 sql 语句而已：</P>
<P>分别如下：</P>
<P><div class="codetitle"><span><a style="CURSOR: pointer" data="20259" class="copybut" id="copybut20259" onclick="doCopy('code20259')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code20259"><BR>int result;<BR>result = sqlite3_exec( db, "begin transaction", 0, 0, &zErrorMsg ); //开始一个事务<BR>result = sqlite3_exec( db, "commit transaction", 0, 0, &zErrorMsg ); //提交事务<BR>result = sqlite3_exec( db, "rollback transaction", 0, 0, &zErrorMsg ); //回滚事务<BR></div></P>
<P>一、 给数据库加密</P>
<P>前面所说的内容网上已经有很多资料，虽然比较零散，但是花点时间也还是可以找到的。现在要说的这个——数据库加密，资料就很难找。也可能是我操作水平不够，找不到对应资料。但不管这样，我还是通过网上能找到的很有限的资料，探索出了给sqlite数据库加密的完整步骤。</P>
<P>这里要提一下，虽然 sqlite 很好用，速度快、体积小巧。但是它保存的文件却是明文的。若不信可以用 NotePad 打开数据库文件瞧瞧，里面 insert 的内容几乎一览无余。这样赤裸裸的展现自己，可不是我们的初衷。当然，如果你在嵌入式系统、智能手机上使用 sqlite，最好是不加密，因为这些系统运算能力有限，你做为一个新功能提供者，不能把用户有限的运算能力全部花掉。</P>
<P>Sqlite为了速度而诞生。因此Sqlite本身不对数据库加密，要知道，如果你选择标准AES算法加密，那么一定有接近50%的时间消耗在加解密算法上，甚至更多（性能主要取决于你算法编写水平以及你是否能使用cpu提供的底层运算能力，比如MMX或sse系列指令可以大幅度提升运算速度）。</P>
<P>Sqlite免费版本是不提供加密功能的，当然你也可以选择他们的收费版本，那你得支付2000块钱，而且是USD。我这里也不是说支付钱不好，如果只为了数据库加密就去支付2000块，我觉得划不来。因为下面我将要告诉你如何为免费的Sqlite扩展出加密模块——自己动手扩展，这是Sqlite允许，也是它提倡的。</P>
<P>那么，就让我们一起开始为 sqlite3.c 文件扩展出加密模块。</P>
<P><BR>i.1 必要的宏</P>
<P>通过阅读 Sqlite 代码（当然没有全部阅读完，6万多行代码，没有一行是我习惯的风格，我可没那么多眼神去看），我搞清楚了两件事：</P>
<P>Sqlite是支持加密扩展的；</P>
<P>需要 #define 一个宏才能使用加密扩展。</P>
<P>这个宏就是</P>
<P>SQLITE_HAS_CODEC。</P>
<P><BR>你在代码最前面（也可以在 sqlite3.h 文件第一行）定义：</P>
<P>#ifndef SQLITE_HAS_CODEC</P>
<P>#define SQLITE_HAS_CODEC</P>
<P>#endif</P>
<P><BR>如果你在代码里定义了此宏，但是还能够正常编译，那么应该是操作没有成功。因为你应该会被编译器提示有一些函数无法链接才对。如果你用的是 VC 2003，你可以在“解决方案”里右键点击你的工程，然后选“属性”，找到“C/C ”，再找到“命令行”，在里面手工添加“/D "SQLITE_HAS_CODEC"”。</P>
<P>定义了这个宏，一些被 Sqlite 故意屏蔽掉的代码就被使用了。这些代码就是加解密的接口。</P>
<P>尝试编译，vc会提示你有一些函数无法链接，因为找不到他们的实现。</P>
<P>如果你也用的是VC2003，那么会得到下面的提示：</P>
<P>error LNK2019: 无法解析的外部符号 _sqlite3CodecGetKey ，该符号在函数 _attachFunc 中被引用</P>
<P>error LNK2019: 无法解析的外部符号 _sqlite3CodecAttach ，该符号在函数 _attachFunc 中被引用</P>
<P>error LNK2019: 无法解析的外部符号 _sqlite3_activate_see，该符号在函数 _sqlite3Pragma 中被引用</P>
<P><BR>error LNK2019: 无法解析的外部符号 _sqlite3_key ，该符号在函数 _sqlite3Pragma 中被引用</P>
<P>fatal error LNK1120: 4 个无法解析的外部命令</P>
<P><BR>这是正常的，因为Sqlite只留了接口而已，并没有给出实现。</P>
<P>下面就让我来实现这些接口。</P>
<P><BR>i.2 自己实现加解密接口函数</P>
<P>如果真要我从一份 www.sqlite.org 网上down下来的 sqlite3.c 文件，直接摸索出这些接口的实现，我认为我还没有这个能力。</P>
<P>好在网上还有一些代码已经实现了这个功能。通过参照他们的代码以及不断编译中vc给出的错误提示，最终我把整个接口整理出来。</P>
<P>实现这些预留接口不是那么容易，要重头说一次怎么回事很困难。我把代码都写好了，直接把他们按我下面的说明拷贝到 sqlite3.c 文件对应地方即可。我在下面也提供了sqlite3.c 文件，可以直接参考或取下来使用。</P>
<P><BR>这里要说一点的是，我另外新建了两个文件：crypt.c和crypt.h。</P>
<P>其中crypt.h如此定义：</P>
<P>#ifndef DCG_SQLITE_CRYPT_FUNC_</P>
<P><BR>#define DCG_SQLITE_CRYPT_FUNC_</P>
<P><BR>***********/</P>
<P>int My_DeEncrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned int len_of_key );</P>
<P><BR>#endif</P>
<P>&nbsp;</P>
<P>其中的 crypt.c 如此定义：</P>
<P>#include "./crypt.h"</P>
<P>#include "memory.h"</P>
<P>int My_Encrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned int len_of_key )</P>
<P><BR>{</P>
<P>return 0;</P>
<P>}</P>
<P><BR>int My_DeEncrypt_Func( unsigned char * pData, unsigned int data_len, const char * key, unsigned int len_of_key )</P>
<P>{</P>
<P>return 0;</P>
<P>}</P>
<P>这个文件很容易看，就两函数，一个加密一个解密。传进来的参数分别是待处理的数据、数据长度、密钥、密钥长度。</P>
<P>处理时直接把结果作用于 pData 指针指向的内容。</P>
<P>你需要定义自己的加解密过程，就改动这两个函数，其它部分不用动。扩展起来很简单。</P>
<P>这里有个特点，data_len 一般总是 1024 字节。正因为如此，你可以在你的算法里使用一些特定长度的加密算法，比如AES要求被加密数据一定是128位（16字节）长。这个1024不是碰巧，而是 Sqlite 的页定义是1024字节，在sqlite3.c文件里有定义:</P>
<P># define SQLITE_DEFAULT_PAGE_SIZE 1024</P>
<P>你可以改动这个值，不过还是建议没有必要不要去改它。</P>
<P><BR>上面写了两个扩展函数，如何把扩展函数跟 Sqlite 挂接起来，这个过程说起来比较麻烦。我直接贴代码。</P>
<P>分3个步骤。</P>
<P>首先，在 sqlite3.c 文件顶部，添加下面内容：</P>
<P><BR>#ifdef SQLITE_HAS_CODEC</P>
<P>#include "./crypt.h"</P>
<P>void sqlite3pager_free_codecarg(void *pArg);</P>
<P>#endif</P>
<P>这个函数之所以要在 sqlite3.c 开头声明，是因为下面在 sqlite3.c 里面某些函数里要插入这个函数调用。所以要提前声明。</P>
<P><BR>其次，在sqlite3.c文件里搜索“sqlite3PagerClose”函数，要找到它的实现代码（而不是声明代码）。</P>
<P>实现代码里一开始是：</P>
<P>#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT</P>
<P><BR>ThreadData *pTsd = sqlite3ThreadData();</P>
<P>assert( pPager );</P>
<P>assert( pTsd && pTsd-&gt;nAlloc );</P>
<P>#endif</P>
<P><BR>需要在这部分后面紧接着插入：</P>
<P><BR>#ifdef SQLITE_HAS_CODEC</P>
<P>sqlite3pager_free_codecarg(pPager-&gt;pCodecArg);</P>
<P>#endif</P>
<P><BR>这里要注意，sqlite3PagerClose 函数大概也是 3.3.17版本左右才改名的，以前版本里是叫 “sqlite3pager_close”。因此你在老版本sqlite代码里搜索“sqlite3PagerClose”是搜不到的。</P>
<P>类似的还有“sqlite3pager_get”、“sqlite3pager_unref”、“sqlite3pager_write”、“sqlite3pager_pagecount”等都是老版本函数，它们在 pager.h 文件里定义。新版本对应函数是在 sqlite3.h 里定义（因为都合并到 sqlite3.c和sqlite3.h两文件了）。所以，如果你在使用老版本的sqlite，先看看 pager.h 文件，这些函数不是消失了，也不是新蹦出来的，而是老版本函数改名得到的。</P>
<P>&nbsp;</P>
<P>最后，往sqlite3.c 文件下找。找到最后一行：</P>
<P>&nbsp;</P>
<P>在这一行后面，接上本文最下面的代码段。</P>
<P>这些代码很长，我不再解释，直接接上去就得了。</P>
<P>唯一要提的是 DeriveKey 函数。这个函数是对密钥的扩展。比如，你要求密钥是128位，即是16字节，但是如果用户只输入 1个字节呢？2个字节呢？或输入50个字节呢？你得对密钥进行扩展，使之符合16字节的要求。</P>
<P>DeriveKey 函数就是做这个扩展的。有人把接收到的密钥求md5，这也是一个办法，因为md5运算结果固定16字节，不论你有多少字符，最后就是16字节。这是md5算法的特点。但是我不想用md5，因为还得为它添加包含一些 md5 的.c或.cpp文件。我不想这么做。我自己写了一个算法来扩展密钥，很简单的算法。当然，你也可以使用你的扩展方法，也而可以使用 md5 算法。只要修改 DeriveKey 函数就可以了。</P>
<P>在 DeriveKey 函数里，只管申请空间构造所需要的密钥，不需要释放，因为在另一个函数里有释放过程，而那个函数会在数据库关闭时被调用。参考我的 DeriveKey 函数来申请内存。</P>
<P><BR>这里我给出我已经修改好的 sqlite3.c 和 sqlite3.h 文件。</P>
<P>如果太懒，就直接使用这两个文件，编译肯定能通过，运行也正常。当然，你必须按我前面提的，新建 crypt.h 和 crypt.c 文件，而且函数要按我前面定义的要求来做。</P>
<P>i.3 加密使用方法：</P>
<P>现在，你代码已经有了加密功能。</P>
<P>你要把加密功能给用上，除了改 sqlite3.c 文件、给你工程添加 SQLITE_HAS_CODEC 宏，还得修改你的数据库调用函数。</P>
<P>前面提到过，要开始一个数据库操作，必须先 sqlite3_open 。</P>
<P>加解密过程就在 sqlite3_open 后面操作。</P>
<P>假设你已经 sqlite3_open 成功了，紧接着写下面的代码：</P>
<P>int i;</P>
<P>//添加、使用密码</P>
<P>i = sqlite3_key( db, "dcg", 3 );</P>
<P>//修改密码</P>
<P>i = sqlite3_rekey( db, "dcg", 0 );</P>
<P><BR>用 sqlite3_key 函数来提交密码。</P>
<P>第1个参数是 sqlite3 * 类型变量，代表着用 sqlite3_open 打开的数据库（或新建数据库）。</P>
<P>第2个参数是密钥。</P>
<P>第3个参数是密钥长度。</P>
<P>用 sqlite3_rekey 来修改密码。参数含义同 sqlite3_key。</P>
<P><BR>实际上，你可以在sqlite3_open函数之后，到 sqlite3_close 函数之前任意位置调用 sqlite3_key 来设置密码。</P>
<P>但是如果你没有设置密码，而数据库之前是有密码的，那么你做任何操作都会得到一个返回值：SQLITE_NOTADB，并且得到错误提示：“file is encrypted or is not a database”。</P>
<P>只有当你用 sqlite3_key 设置了正确的密码，数据库才会正常工作。</P>
<P>如果你要修改密码，前提是你必须先 sqlite3_open 打开数据库成功，然后 sqlite3_key 设置密钥成功，之后才能用 sqlite3_rekey 来修改密码。</P>
<P>如果数据库有密码，但你没有用 sqlite3_key 设置密码，那么当你尝试用 sqlite3_rekey 来修改密码时会得到 SQLITE_NOTADB 返回值。</P>
<P>如果你需要清空密码，可以使用：</P>
<P>//修改密码</P>
<P>i = sqlite3_rekey( db, NULL, 0 );</P>
<P>来完成密码清空功能。</P>
<P>&nbsp;</P>
<P>i.4 sqlite3.c 最后添加代码段</P>
<P><BR><div class="codetitle"><span><a style="CURSOR: pointer" data="2506" class="copybut" id="copybut2506" onclick="doCopy('code2506')"><U>复制代码</U></a></span> 代码如下:</div><div class="codebody" id="code2506"><BR>#ifdef SQLITE_HAS_CODEC<BR>#define CRYPT_OFFSET 8<BR>typedef struct _CryptBlock<BR>{<BR>BYTE* ReadKey; // 读数据库和写入事务的密钥<BR>BYTE* WriteKey; // 写入数据库的密钥<BR>int PageSize; // 页的大小<BR>BYTE* Data;<BR>} CryptBlock, *LPCryptBlock;<BR>#ifndef DB_KEY_LENGTH_BYTE<BR>#define DB_KEY_LENGTH_BYTE 16<BR>#endif<BR>#ifndef DB_KEY_PADDING<BR>#define DB_KEY_PADDING 0x33<BR>#endif<BR>void sqlite3CodecGetKey(sqlite3* db, int nDB, void** Key, int* nKey)<BR>{<BR>return ;<BR>}<BR>int sqlite3CodecAttach(sqlite3 *db, int nDb, const void *pKey, int nKeyLen);<BR>void sqlite3_activate_see(const char* right )<BR>{<BR>return;<BR>}<BR>int sqlite3_key(sqlite3 *db, const void *pKey, int nKey);<BR>int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey);<br><br>// 从用户提供的缓冲区中得到一个加密密钥<BR>// 用户提供的密钥可能位数上满足不了要求，使用这个函数来完成密钥扩展<BR>static unsigned char * DeriveKey(const void *pKey, int nKeyLen);<BR>//创建或更新一个页的加密算法索引.此函数会申请缓冲区.<BR>static LPCryptBlock CreateCryptBlock(unsigned char* hKey, Pager *pager, LPCryptBlock pExisting);<BR>//加密/解密函数, 被pager调用<BR>void * sqlite3Codec(void *pArg, unsigned char *data, Pgno nPageNum, int nMode);<BR>//设置密码函数<BR>int __stdcall sqlite3_key_interop(sqlite3 *db, const void *pKey, int nKeySize);<BR>// 修改密码函数<BR>int __stdcall sqlite3_rekey_interop(sqlite3 *db, const void *pKey, int nKeySize);<BR>//销毁一个加密块及相关的缓冲区,密钥.<BR>static void DestroyCryptBlock(LPCryptBlock pBlock);<BR>static void * sqlite3pager_get_codecarg(Pager *pPager);<BR>void sqlite3pager_set_codec(Pager *pPager,void *(*xCodec)(void*,void*,Pgno,int),void *pCodecArg );<br><br>//加密/解密函数, 被pager调用<BR>void * sqlite3Codec(void *pArg, unsigned char *data, Pgno nPageNum, int nMode)<BR>{<BR>LPCryptBlock pBlock = (LPCryptBlock)pArg;<BR>unsigned int dwPageSize = 0;<BR>if (!pBlock) return data;<BR>// 确保pager的页长度和加密块的页长度相等.如果改变,就需要调整.<BR>if (nMode != 2)<BR>{<BR>PgHdr *pageHeader;<BR>pageHeader = DATA_TO_PGHDR(data);<BR>if (pageHeader-&gt;pPager-&gt;pageSize != pBlock-&gt;PageSize)<BR>{<BR>CreateCryptBlock(0, pageHeader-&gt;pPager, pBlock);<BR>}<BR>}<br><br>switch(nMode)<BR>{<BR>case 0: // Undo a "case 7" journal file encryption<BR>case 2: //重载一个页<BR>case 3: //载入一个页<BR>if (!pBlock-&gt;ReadKey) break;<br><br>dwPageSize = pBlock-&gt;PageSize;<BR>My_DeEncrypt_Func(data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE );<br><br>break;<BR>case 6: //加密一个主数据库文件的页<BR>if (!pBlock-&gt;WriteKey) break;<BR>memcpy(pBlock-&gt;Data CRYPT_OFFSET, data, pBlock-&gt;PageSize);<BR>data = pBlock-&gt;Data CRYPT_OFFSET;<br><br>dwPageSize = pBlock-&gt;PageSize;<BR>My_Encrypt_Func(data , dwPageSize, pBlock-&gt;WriteKey, DB_KEY_LENGTH_BYTE );<BR>break;<BR>case 7: //加密事务文件的页<BR>if (!pBlock-&gt;ReadKey) break;<BR>memcpy(pBlock-&gt;Data CRYPT_OFFSET, data, pBlock-&gt;PageSize);<BR>data = pBlock-&gt;Data CRYPT_OFFSET;<BR>dwPageSize = pBlock-&gt;PageSize;<BR>My_Encrypt_Func( data, dwPageSize, pBlock-&gt;ReadKey, DB_KEY_LENGTH_BYTE );<BR>break;<BR>}<BR>return data;<BR>}<br><br>//<BR>销毁一个加密块及相关的缓冲区,密钥.<BR>static void DestroyCryptBlock(LPCryptBlock pBlock)<BR>{<BR>//销毁读密钥.<BR>if (pBlock-&gt;ReadKey){<BR>sqliteFree(pBlock-&gt;ReadKey);<BR>}<BR>//如果写密钥存在并且不等于读密钥,也销毁.<BR>if (pBlock-&gt;WriteKey && pBlock-&gt;WriteKey != pBlock-&gt;ReadKey){<BR>sqliteFree(pBlock-&gt;WriteKey);<BR>}<BR>if(pBlock-&gt;Data){<BR>sqliteFree(pBlock-&gt;Data);<BR>}<BR>//释放加密块.<BR>sqliteFree(pBlock);<BR>}<BR>static void * sqlite3pager_get_codecarg(Pager *pPager)<BR>{<BR>return (pPager-&gt;xCodec) ? pPager-&gt;pCodecArg: NULL;<BR>}<BR>// 从用户提供的缓冲区中得到一个加密密钥<BR>static unsigned char * DeriveKey(const void *pKey, int nKeyLen)<BR>{<BR>unsigned char * hKey = NULL;<BR>int j;<BR>if( pKey == NULL || nKeyLen == 0 )<BR>{<BR>return NULL;<BR>}<BR>hKey = sqliteMalloc( DB_KEY_LENGTH_BYTE 1 );<BR>if( hKey == NULL )<BR>{<BR>return NULL;<BR>}<BR>hKey[ DB_KEY_LENGTH_BYTE ] = 0;<BR>if( nKeyLen &lt; DB_KEY_LENGTH_BYTE )<BR>{<BR>memcpy( hKey, pKey, nKeyLen ); //先拷贝得到密钥前面的部分<BR>j = DB_KEY_LENGTH_BYTE - nKeyLen;<BR>//补充密钥后面的部分<BR>memset( hKey nKeyLen, DB_KEY_PADDING, j );<BR>}<BR>else<BR>{ //密钥位数已经足够,直接把密钥取过来<BR>memcpy( hKey, pKey, DB_KEY_LENGTH_BYTE );<BR>}<BR>return hKey;<BR>}<br><br>//创建或更新一个页的加密算法索引.此函数会申请缓冲区.<BR>static LPCryptBlock CreateCryptBlock(unsigned char* hKey, Pager *pager, LPCryptBlock pExisting)<BR>{<BR>LPCryptBlock pBlock;<br><br>if (!pExisting) //创建新加密块<BR>{<BR>pBlock = sqliteMalloc(sizeof(CryptBlock));<BR>memset(pBlock, 0, sizeof(CryptBlock));<BR>pBlock-&gt;ReadKey = hKey;<BR>pBlock-&gt;WriteKey = hKey;<BR>pBlock-&gt;PageSize = pager-&gt;pageSize;<BR>pBlock-&gt;Data = (unsigned char*)sqliteMalloc(pBlock-&gt;PageSize CRYPT_OFFSET);<BR>}<BR>else //更新存在的加密块<BR>{<BR>pBlock = pExisting;<BR>if ( pBlock-&gt;PageSize != pager-&gt;pageSize && !pBlock-&gt;Data){<BR>sqliteFree(pBlock-&gt;Data);<BR>pBlock-&gt;PageSize = pager-&gt;pageSize;<BR>pBlock-&gt;Data = (unsigned char*)sqliteMalloc(pBlock-&gt;PageSize CRYPT_OFFSET);<BR>}<BR>}<br><br>memset(pBlock-&gt;Data, 0, pBlock-&gt;PageSize CRYPT_OFFSET);<BR>return pBlock;<BR>}<br><br>void sqlite3pager_set_codec(<BR>Pager *pPager,<BR>void *(*xCodec)(void*,void*,Pgno,int),<BR>void *pCodecArg<BR>)<BR>{<BR>pPager-&gt;xCodec = xCodec;<BR>pPager-&gt;pCodecArg = pCodecArg;<BR>}<BR>int sqlite3_key(sqlite3 *db, const void *pKey, int nKey)<BR>{<BR>return sqlite3_key_interop(db, pKey, nKey);<BR>}<BR>int sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey)<BR>{<BR>return sqlite3_rekey_interop(db, pKey, nKey);<BR>}<BR>int sqlite3CodecAttach(sqlite3 *db, int nDb, const void *pKey, int nKeyLen)<BR>{<BR>int rc = SQLITE_ERROR;<BR>unsigned char* hKey = 0;<BR>//如果没有指定密匙,可能标识用了主数据库的加密或没加密.<BR>if (!pKey || !nKeyLen)<BR>{<BR>if (!nDb)<BR>{<BR>return SQLITE_OK; //主数据库, 没有指定密钥所以没有加密.<BR>}<BR>else //附加数据库,使用主数据库的密钥.<BR>{<BR>//获取主数据库的加密块并复制密钥给附加数据库使用<BR>LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(sqlite3BtreePager(db-&gt;aDb[0].pBt));<BR>if (!pBlock) return SQLITE_OK; //主数据库没有加密<BR>if (!pBlock-&gt;ReadKey) return SQLITE_OK; //没有加密<BR>memcpy(pBlock-&gt;ReadKey, &hKey, 16);<BR>}<BR>}<BR>else //用户提供了密码,从中创建密钥.<BR>{<BR>hKey = DeriveKey(pKey, nKeyLen);<BR>}<BR>//创建一个新的加密块,并将解码器指向新的附加数据库.<BR>if (hKey)<BR>{<BR>LPCryptBlock pBlock = CreateCryptBlock(hKey, sqlite3BtreePager(db-&gt;aDb[nDb].pBt), NULL);<BR>sqlite3pager_set_codec(sqlite3BtreePager(db-&gt;aDb[nDb].pBt), sqlite3Codec, pBlock);<BR>rc = SQLITE_OK;<BR>}<BR>return rc;<BR>}<BR>// Changes the encryption key for an existing database.<BR>int __stdcall sqlite3_rekey_interop(sqlite3 *db, const void *pKey, int nKeySize)<BR>{<BR>Btree *pbt = db-&gt;aDb[0].pBt;<BR>Pager *p = sqlite3BtreePager(pbt);<BR>LPCryptBlock pBlock = (LPCryptBlock)sqlite3pager_get_codecarg(p);<BR>unsigned char * hKey = DeriveKey(pKey, nKeySize);<BR>int rc = SQLITE_ERROR;<BR>if (!pBlock && !hKey) return SQLITE_OK;<BR>//重新加密一个数据库,改变pager的写密钥, 读密钥依旧保留.<BR>if (!pBlock) //加密一个未加密的数据库<BR>{<BR>pBlock = CreateCryptBlock(hKey, p, NULL);<BR>pBlock-&gt;ReadKey = 0; // 原始数据库未加密<BR>sqlite3pager_set_codec(sqlite3BtreePager(pbt), sqlite3Codec, pBlock);<BR>}<BR>else // 改变已加密数据库的写密钥<BR>{<BR>pBlock-&gt;WriteKey = hKey;<BR>}<BR>// 开始一个事务<BR>rc = sqlite3BtreeBeginTrans(pbt, 1);<BR>if (!rc)<BR>{<BR>// 用新密钥重写所有的页到数据库。<BR>Pgno nPage = sqlite3PagerPagecount(p);<BR>Pgno nSkip = PAGER_MJ_PGNO(p);<BR>void *pPage;<BR>Pgno n;<BR>for(n = 1; rc == SQLITE_OK && n &lt;= nPage; n )<BR>{<BR>if (n == nSkip) continue;<BR>rc = sqlite3PagerGet(p, n, &pPage);<BR>if(!rc)<BR>{<BR>rc = sqlite3PagerWrite(pPage);<BR>sqlite3PagerUnref(pPage);<BR>}<BR>}<BR>}<BR>// 如果成功，提交事务。<BR>if (!rc)<BR>{<BR>rc = sqlite3BtreeCommit(pbt);<BR>}<BR>// 如果失败，回滚。<BR>if (rc)<BR>{<BR>sqlite3BtreeRollback(pbt);<BR>}<br><br>&nbsp;<BR>// 如果成功，销毁先前的读密钥。并使读密钥等于当前的写密钥。<BR>if (!rc)<BR>{<BR>if (pBlock-&gt;ReadKey)<BR>{<BR>sqliteFree(pBlock-&gt;ReadKey);<BR>}<BR>pBlock-&gt;ReadKey = pBlock-&gt;WriteKey;<BR>}<BR>else// 如果失败，销毁当前的写密钥，并恢复为当前的读密钥。<BR>{<BR>if (pBlock-&gt;WriteKey)<BR>{<BR>sqliteFree(pBlock-&gt;WriteKey);<BR>}<BR>pBlock-&gt;WriteKey = pBlock-&gt;ReadKey;<BR>}<br><br>// 如果读密钥和写密钥皆为空，就不需要再对页进行编解码。<BR>// 销毁加密块并移除页的编解码器<BR>if (!pBlock-&gt;ReadKey && !pBlock-&gt;WriteKey)<BR>{<BR>sqlite3pager_set_codec(p, NULL, NULL);<BR>DestroyCryptBlock(pBlock);<BR>}<BR>return rc;<BR>}<BR>int __stdcall sqlite3_key_interop(sqlite3 *db, const void *pKey, int nKeySize)<BR>{<BR>return sqlite3CodecAttach(db, 0, pKey, nKeySize);<BR>}<br><br>// 释放与一个页相关的加密块<BR>void sqlite3pager_free_codecarg(void *pArg)<BR>{<BR>if (pArg)<BR>DestroyCryptBlock((LPCryptBlock)pArg);<BR>}<BR>#endif //#ifdef SQLITE_HAS_CODEC<BR></div></P>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/90306.html'>Android输入法弹出时覆盖输入框问题的解决方法</a><a>下一篇</a><a href='/php/biji/90308.html'>CSS3制作文字半透明倒影效果的两种实现方式</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>