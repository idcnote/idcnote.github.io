<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>分布式集群LINUX平台下_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="分布式集群LINUX平台下<br />
正如你所看到的一样，你的机器在绝大多数时间是空闲的，如果你在Windows下用任务管理器或其他的Linux平台的工具（例如top，xload）观察CPU，你会看到CPU的使用率" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/122.html"></a></li><li><a href="/php/phpbiji/123.html"></a></li><li><a href="/php/phpbiji/124.html"></a></li><li><a href="/php/phpbiji/125.html"></a></li><li><a href="/php/phpbiji/126.html"></a></li><li><a href="/php/phpbiji/127.html"></a></li><li><a href="/php/phpbiji/128.html"></a></li><li><a href="/php/phpbiji/129.html"></a></li><li><a href="/php/phpbiji/130.html"></a></li><li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">分布式集群LINUX平台下</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>分布式集群LINUX平台下<br />
正如你所看到的一样，你的机器在绝大多数时间是空闲的，如果你在Windows下用任务管理器或其他的Linux平台的工具（例如top，xload）观察CPU，你会看到CPU的使用率</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><P _fckxhtmljob="1">分布式集群LINUX平台下</P>
<P _fckxhtmljob="1">正如你所看到的一样，你的机器在绝大多数时间是空闲的，如果你在Windows下用任务管理器或其他的Linux平台的工具（例如top，xload）观察CPU，你会看到CPU的使用率常见在1～2%。</P>
<P _fckxhtmljob="1">事实上，如果你有更多的计算机，这种浪费会加剧，在一个有300台计算机的部门里，CPU的空闲率是惊人的。然而这些部门还是需要强大的服务器用来编译或模拟计算，这样的情况还会加剧，不止需要一台，因为随着用户的增加，即使是8个CPU的服务器，满负荷时也不能把任务交给另外的空闲服务器，因为用户很少会改变习惯去登陆另外一台服务器。如果能利用现有的计算资源，把空闲的CPU利用起来，或者能让服务器智能的迁移负荷，就是你看下去的理由。 <BR _fckxhtmljob="1">集群的基本单位是单独的计算机，称为节点(node)。其可增长的特性，称为延展性(Scale)，也就是向集群中加入计算机。集群没有严格的定义，可以说就是许多利用高速联接的，具有高速运算能力的，具有单一用户界面的计算机组合。这并不是集群的定义，而是表面现象的描述。集群中的节点需要硬件尽可能的一致，不一致的硬件集群称为异构集群，虽然这并不能改变集群的特性，但是异构导致集群会花费额外的时间来处理由于异构带来的延迟，另一方面这也是集群的优势，任何其他的多CPU系统都是严格要求CPU是一致的，集群就有足够的自由度增减节点，不受类型的限制。 <BR _fckxhtmljob="1">　　本文选择MOSIX作为集群的方案，并使用无盘节点。架构集群并没有想象中那样复杂，参考下面的步骤可以一步步的架构集群，整个的方案并不是很昂贵，而且便于扩展。使用RedHat是因为在中国这是最有权威的版本，不论是初学者还是专业工作者，都可以在RedHat Linux中定制自己的版本。使用终端服务器LTSP是因为结构简单，便于快速扩展。使用的硬件是可以改进的，比如使用双CPU的主板和至强处理器，这样单一机柜中处理器就密集到48块CPU，本例中可以使用24块CPU。除了CPU以外，还可以使用千兆网卡或光纤网卡，交换机可以使用光纤交换机，内存总数可以达到48GB。但是随着硬件的升级，整体价格就会过高，而性能的提升并不是按比例的，因此本例的配置是性价比较好的组合。MOSIX是利用给内核源代码加补丁的办法，增加内核的功能来达到内核级的集群支持，通过编译后的内核启动的系统间类似SMP多处理器的系统，从外面的角度看只有一台有很多处理器的庞大机器，但是内部是用很多机器架构成的。而MOSIX集群的特点是对用户透明，原有的应用程序不需要修改代码即可以在集群中分布计算。 <BR _fckxhtmljob="1">　　有几种情况是不需要使用集群系统的，使用类似网格计算的脚本就可以完成计算，比如三维动画的渲染，这类计算可以使用不同的节点，不需要对称的硬件，不需要一致的操作系统（需要应用具有支持不同操作系统的版本），只需要按照处理器来分割渲染的任务段，在每个节点上运行相应的任务段，然后合成所有节点的计算结果。因为计算数据是离散的（结果的连续是视觉的连续），因此用类似网格计算的脚本也可以完成。这类计算不需要使用集群也可以完成。 <BR _fckxhtmljob="1">　　下面本文将告诉你如何准备硬件和软机环境。首先是规划你的计算环境。 <BR _fckxhtmljob="1">硬件环境： <BR _fckxhtmljob="1">　　49U标准机柜，安装1U的交换机，24台2U机架式机箱。 <BR _fckxhtmljob="1">　　1U的24口100MB交换机（不是集线器） <BR _fckxhtmljob="1">　　Intel P4 2GHz CPU，1GB DDR，Intel 845D主板，软驱，NVIDIA显卡（能启动X Windows就可以），2U机架式机箱，3C905B 10/100MB自适应网卡，网关需要配置光驱，80GB硬盘和双网卡。 <BR _fckxhtmljob="1">　　5类线，按照693A压3米网线24根。 <BR _fckxhtmljob="1">　　显示器，键盘，鼠标仅在安装时使用。 <BR _fckxhtmljob="1">　　软件环境和必要的安装包（除特殊说明外，高版本不一定适用）： <BR _fckxhtmljob="1">　　Redhat 7.2 CD1 和CD2安装光盘 www.redhat.com <BR _fckxhtmljob="1">　　dhcp-3.0.1rc9-1.i386.rpm是支持启动内核调用的DHCP版本www.redhat.com <BR _fckxhtmljob="1">　　dhcpcd-1.3.22pl1-7.i386.rpm是DHCPD守护进程www.redhat.com <BR _fckxhtmljob="1">　　mknbi-1.2-6.noarch.rpm是制作客户端启动内核的必要软件包www.redhat.com <BR _fckxhtmljob="1">　　MOSIX-1.6.0.tar.gz是原始的MOSIX文件，最新的版本是1.7.0 www.mosix.com <BR _fckxhtmljob="1">　　MOSKRN-1.6.0.tar.gz是原始MOSIX内核文件，最新的版本是1.7.0 www.moxis.com <BR _fckxhtmljob="1">　　openmosix-kernel-2.4.18-openmosix2.i386.rpm是MOSIX分支版本的通用内核，最新的版本是2.4.19 www.openmosix.org <BR _fckxhtmljob="1">　　openmosix-kernel-2.4.18-openmosix2.i686.rpm是MOSIX分支版本的新处理器内核，最新的版本是2.4.19 www.openmosix.org <BR _fckxhtmljob="1">　　openmosix-kernel-smp-2.4.18-openmosix2.i686.rpm是MOSIX分支版本的多处理器内核，最新的版本是2.4.19 www.openmosix.org <BR _fckxhtmljob="1">　　openmosix-kernel-2.4.18-openmosix2.src.rpm是MOSIX分支版本的源代码www.openmosix.org <BR _fckxhtmljob="1">　　openmosix-tools-0.2.2-1.i386.rpm是MOSIX分支版本的客户端工具www.openmosix.org <BR _fckxhtmljob="1">　　ltsp_core-3.0-11.i386.rpm是LTSP的核心文件www.ltsp.org <BR _fckxhtmljob="1">　　ltsp_kernel-3.0-3.i386.rpm是LTSP的内核www.ltsp.org <BR _fckxhtmljob="1">　　ltsp_floppyd-3.0.0-2.i386.rpm是LTSP的软盘工具www.ltsp.org <BR _fckxhtmljob="1">　　ltsp_initrd_kit-3.0.1-i386.tgz是LTSP的启动制作工具www.ltsp.org <BR _fckxhtmljob="1">　　linux_kernel-2.4.18.tar.gz是需要编译的内核源码www.kernel.org <BR _fckxhtmljob="1">网络配置环境： <BR _fckxhtmljob="1">　　网关对外网卡配置10.193.15.169，子网掩码255.255.255.0给内部网使用，用于登录和提交进程。 网关对内网卡配置192.168.0.254，子网掩码255.255.255.0，网关为10.193.15.169给集群用于DHCP服务器，NFS服务器，LTSP服务器。 <BR _fckxhtmljob="1">　　网关对内网卡配置DHCP，分配地址从192.168.0.100到192.168.0.253，子网掩码255.255.255.0，都是C类。 <BR _fckxhtmljob="1">　　当以上条件都具备时，可以开始架构MOSIX集群。 <BR _fckxhtmljob="1">　　1.安装所有硬件，并能确保可以从光盘启动网关服务器系统，节点可以使用软盘启动，检查BIOS的启动设置，并确认可以正确启动。将所有节点和交换机安装到机柜上，用网线连接交换机和各节点，网关需要额外的网线连接到局域网，因为可以称集群计算环境为计算场(Computing Farm)，因此对应局域网称集群系统的网络为计算网络。连接好电源后，使用两套显示器和键盘鼠标，分别连接一台节点机和网关服务器。 <BR _fckxhtmljob="1">　　2.安装RedHat 7.2版本在具有两块网卡的网关服务器上，分区使用自动分区（比较简单，本文不讨论Linux其他问题），选择定制安装，但不要安装所有的软件包，除缺省的选择外，需要额外选择软件开发和内核开发两组软件包，安装时没有选择的软件包，可以在系统正常启动后参考“如何编译内核”中的软件包来安装。安装到网络配置时，按照网络环境配置IP地址，需要配置DNS的需要修改对外网卡的设置，使用小写mosix为主机名。安装完后需要验证网关服务器可以正常启动，按照个人喜好来设定系统，推荐使用文本模式，图形模式资源消耗较大。另外需要连接到RedHat网站升级有缺陷的软件包，减少系统漏洞，注意别把内核也升级了，并不是因为本文的操作，而是内核升级后，系统很可能启动失败，本文将自己编译内核。升级完成后重启，再次确认系统没有任何错误。 <BR _fckxhtmljob="1">　　3.安装MOSIX包(openmosix的安装是另外的分支)需要很多步骤，注意操作步骤的准确性： <BR _fckxhtmljob="1">　　A，将所有下载的软件包上载到服务器的/usr/src/tmp目录下，确认下载的软件包是完整的，确认md5的校验结果一致： <BR _fckxhtmljob="1">　　su -　　cd /usr/src/　　makdir tmp　　md5 package_file_name <BR _fckxhtmljob="1">　　B，将RedHat 7.2 CD2放入到光驱。参考以下操作确认编译内核需要的软件包已经存在： <BR _fckxhtmljob="1">　　mount /dev/cdrom /mnt/cdrom　　cd /mnt/redhat/RPM　　rpm -Uvh kernel-headers*　　rpm -Uvh kernel-source*　　rpm -Uvh kernel-doc*　　rpm -Uvh dev86*　　rpm -Uvh make-*　　rpm -Uvh glibc-devel*　　rpm -Uvh cpp*　　rpm -Uvh ncurses-devel*　　rpm -Uvh binutils*　　rpm -Uvh gcc-2*　　rpm -Uvh tftp*　　cd /usr/src　　umount /mnt/cdrom <BR _fckxhtmljob="1">　　C，安装需要的软件包，展开所有的tar.gz软件包： <BR _fckxhtmljob="1">　　tar xvfz MOSIX-1.6.0.tar.gz 　　tar xvfz MOSKRN-1.6.0.tar.gz 　　tar xvfz linux-2.4.18.tar.gz <BR _fckxhtmljob="1">　　D，如果展开文件没有错误，将各个软件展开目录移到正确的位置： <BR _fckxhtmljob="1">　　mv MOSIX-1.6.0 /usr/src/　　mv MOSKRN-1.6.0 /usr/src/ 　　mv linux /usr/src/linux-2.4.18 <BR _fckxhtmljob="1">　　 <BR _fckxhtmljob="1">　　E，为了避免以往MOSIX脚本的错误，需要确认以下步骤： <BR _fckxhtmljob="1">　　chmod goa+x /usr/src/MOSIX-1.6.0/inst/add_kernel_to_grub 　　mkdir /usr/local/man <BR _fckxhtmljob="1">　　F，下面才是真正有趣和让人着迷的步骤，首先要创建编译内核配置文件的目录，这是个好习惯，因为每次的编译配置不一定相同，后面排错也会提到相关的问题： <BR _fckxhtmljob="1">　　cd /usr/src 　　mkdir config.backup　　cd /usr/src/linux-2.4.7-10/configs　　cp kernel-2.4.7-i686.config /usr/src/config.backup/kernel-2.4.8.config <BR _fckxhtmljob="1">　　G，将配置文件复制到待编译内核的目录： <BR _fckxhtmljob="1">　　cd /usr/src/　　cp config.backup/kernel-2.4.18.config linux-2.4.18/.config <BR _fckxhtmljob="1">　　H，根据你的情况修改Makefiles的EXTRAVERSION部分，原值为18，可改为mosix来标明编译后的内核版本，并可以区分模块的版本。 <BR _fckxhtmljob="1">　　cd /usr/src/linux-2.4.18　　vi Makefile　　EXTRAVERSION = 18 <BR _fckxhtmljob="1">　　 <BR _fckxhtmljob="1">　　I，开始安装MOSIX 1.6.0 <BR _fckxhtmljob="1">　　cd /usr/src/MOSIX-1.6.0　　./mosix.install </P>
<P _fckxhtmljob="1">　 </P>
<P _fckxhtmljob="1">　　J，安装开始后会有一些问题，除新内核加入LILO或GRUB一问回答为G以外的问题都用回车使用缺省选择（大写的字母为缺省值）。问题依次为内核源代码的路径，新内核的启动选项添加在那个启动程序中，内核所包含的库文件连接，MOSIX服务的启动级别，创建MFS装载目录，启动那种内核编译配置菜单，是否显示内核编译详细过程，是否显示用户级编译详细过程。随后系统开始给内核源代码加补丁，启动内核编译配置菜单。 </P>
<P _fckxhtmljob="1">　　K，在内核编译配置菜单中，你可以看到新增加的MOSIX选项。 </P>
<P _fckxhtmljob="1">　　L，选择进入MOSIX选项并添加直接文件系统访问 (Direct File-System Access) 和MOSIX文件系统 (MOSIX File-System)。用ESC键推出当前选单。 </P>
<P _fckxhtmljob="1">　　M，添加块设备 (Block devices) 的内存虚拟盘的支持 (RAM disk support) 和使用初始化进程初始化内存虚拟盘 (Initial RAM disk (initrd) support)两项。 </P>
<P _fckxhtmljob="1">　　N，在网络选项 (Networking options) 中增加对IP内核级自动配置 (IP: kernel level autoconfiguration)，IP动态地址支持 (IP: DHCP support)，IP启动地址绑定支持 (IP: BOOTP support)。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　O，建议除去SCSI的支持，本例中没采用SCSI设备，并且可以避免内核编译失败。建议除去声卡支持。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　P，在网络文件系统 (Network File System) 中增加NFS支持根文件系统(Root file system on NFS)。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　Q，最后多按一次ESC键，提示保存配置文件，选择Yes。系统将开始编译内核，编译模块，安装内核，安装模块。该过程可能会产生一些警告，只要编译没退出，并正常完成回到提示符状态就完成了编译。 </P>
<P _fckxhtmljob="1">　　R，先不要忙于重启，需要修改/boot/grub/grub.conf文件中MOSIX的内核路径一行，原路径为/boot/vmlinuz-2.4.18-mosix，修改为/vmlinuz-2.4.18-mosix。修改完后键入reboot可以重新启动。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　S，这时的启动菜单中出现Mosix 1.6.0 (2.4.1，选择该项启动MOSIX系统。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　T，系统启动中会出现若干错误，图中第一个是由于没有创建/mfs引起的，第二个是由于MOSIX更改了sshd服务的权限，而没启动另外的MOSIX的sshd引起的。第一次启动MOSIX系统，会要求配置mosix.map文件，回车选择缺省的编辑器进入编辑。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　U，配置文件修改完成后，系统会提示节点的IP地址有变化时需要修改mosix.map文件中的节点号。因为网关服务器是192.168.0.254因此定义为节点1，其他的节点从192.168.0.1开始共有253个节点，节点号从2开始。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　V，进入系统后，启动MOSIX，显示初始化MOSIX，MOSIX配置完成。 <BR _fckxhtmljob="1">　　service mosix start </P>
<P _fckxhtmljob="1">　 </P>
<P _fckxhtmljob="1">　　4.因为MOSIX有另外的分支openmosix，因为版权问题不同（后面将会介绍），openmosix更开放一些，而且openmosix的安装相对简单，推荐没有经验的初学者使用，下面是openmosix的安装和基于openmosix的客户端配置。注意：MOSIX和openmosix虽然都是MOSIX原理下的软件，但是互相是不能通讯的，因此一个集群系统里要统一使用一种平台。openmosix是使用rpm为安装包的，事实上只是把编译好的内核直接挂接到系统里，并没有经过你自己的编译，对于初学者而言要方便许多。以下操作是在刚安装完RedHat Linux 7.2的系统上完成的，除openmosix的软件包外，不需要其他任何的软件包，缺省目录在/usr/src/下。可根据情况安装SMP版本，openmosix-kernel-2.4.18-openmosix2.i386.rpm版本适合于所有X86体系的处理器，openmosix-kernel-2.4.18-openmosix2.i686.rpm版本适合本例，openmosix-kernel-2.4.18-openmosix2.src.rpm是包含kernel-2.4.18和openmosix内核补丁的源代码。当安装完成后启动时就可以看到openmosix的启动项。 <BR _fckxhtmljob="1">　　cd /usr/src/　　rpm -Uvh openmosix-kernel-2.4.18-openmosix2.i686.rpm　　rpm -Uvh openmosix-kernel-2.4.18-openmosix2.src.rpm　　rpm -Uvh openmosix-tools-0.2.2-1.i386.rpm <BR _fckxhtmljob="1">　　5.下面是利LTSP配置客户端系统，首先需要安装必要的软件包。并将文件安装放到到适当的路径下。 <BR _fckxhtmljob="1">　　rpm -Uvh dhcp-3.0.1rc9-1.i386.rpm　　rpm -Uvh dhcpcd-1.3.22pl1-7.i386.rpm　　rpm -Uvh mknbi-1.2-6.noarch.rpm　　rpm -Uvh ltsp_core-3.0-11.i386.rpm 　　rpm -Uvh ltsp_kernel-3.0-3.i386.rpm 　　rpm -Uvh ltsp_floppyd-3.0.0-2.i386.rpm 　　rpm -Uvh ltsp_initrd_kit-3.0.1-i386.tgz 　　mv ltsp_initrd_kit /usr/src/ <BR _fckxhtmljob="1">　　 <BR _fckxhtmljob="1">　　6.因为使用的是openmosix，你需要单独展开的linux-2.4.18.tar.gz文件和openmosix的补丁文件，需要将openmosix的补丁加入，你在安装openmosix-kernel-2.4.18-openmosix2.src.rpm时，源文件会存在于/usr/src/redhat/SOURCES/目录下，同时还有内核补丁文件。 <BR _fckxhtmljob="1">　　cd /usr/src/redhat/SOURCES/　　tar xvfz linux-2.4.18.tar.gz　　mv /usr/src/redhat/SOURCES/linux /usr/src/linux-2.4.18-om2 <BR _fckxhtmljob="1">　　7.将内核补丁文件展开并加入内核源文件，并作编译前准备，将旧的内核编译中间结果清理干净： <BR _fckxhtmljob="1">　　cp /usr/src/redhat/SOURCE/openMosix-2.4.18-2.gz /usr/src/linux-2.4.18-om2/　　gunzip /usr/src/linux-2.4.18-om2/openMosix-2.4.18-2.gz　　cd /usr/src/linux-2.4.18-om2　　patch -Np1 &lt; openMosix-2.4.18-2　　make mrproper <BR _fckxhtmljob="1">　　8.修改Makefile文件的EXTRAVERSION部分，加入-om2标记： <BR _fckxhtmljob="1">　　vi Makefile　　EXTRAVERSION = -om2 <BR _fckxhtmljob="1">　　9.将LTSP的内核编译配置文件备份并放到内核编译目录下： <BR _fckxhtmljob="1">　　cp /opt/ltsp/kernel-configs/config.2.4.9-ltsp-5　　　　 /usr/src/config.backup/　　cp /opt/ltsp/kernel-configs/config.2.4.9-ltsp-5 　　　　/usr/src/linux-2.4.18-om2/.config <BR _fckxhtmljob="1">　　10.启动内核编译配置菜单，注意选择openmosix选项中的进程迁移(process migration support)，直接文件系统访问( Direct File-System Access)，openmosix文件系统(OpenMosix File-System)，注意不要选择内核调试(Kernel Debugger)。其他的配置根据具体需要，没有SCSI硬盘可以去掉SCSI选项，不需要声卡，也可以去掉。 <BR _fckxhtmljob="1">　　make menuconfig <BR _fckxhtmljob="1">　　11. 编译内核一般分为编译库(make dep)，编译启动映象(make bzImage)，编译模块(make modules) 和安装模块(make modules_install)。系统可以连续完成几步操作： <BR _fckxhtmljob="1">　　make dep &amp;&amp; make bzImage &amp;&amp; make modules &amp;&amp; make modules_install <BR _fckxhtmljob="1">　　12. 如果系统没有提示错误并中止，将会显示新的内核映象的大小，模块编译完成并安装等信息。编译完成的内核将作为客户端的内核系统，因此需要将模块复制到LTSP的目录下： <BR _fckxhtmljob="1">　　cp -R /lib/modules/2.4.18-om2 /opt/ltsp/i386/lib/modules/ <BR _fckxhtmljob="1">　　13.完成后将创建符合无盘启动的系统，使用LTSP的初始化工具就可以完成，进入/usr/src/ltsp_initrd_kit目录，修改buildk文件的最后部分，用#注释掉原有prepare_kernel部分，并添加适合本例的命令。 <BR _fckxhtmljob="1">　　cd /usr/src/ltsp_initrd_kit/　　vi buildk　　# prepare_kernel /usr/src/linux-2.4.9-ltsp 2.4.9-ltsp-5　　# prepare_kernel /usr/src/linux-2.4.9-ltsp-lpp 2.4.9-ltsp-lpp-5 lpp　　prepare_kernel /usr/src/linux-2.4.18-om2 2.4.18-om2 <BR _fckxhtmljob="1">　　14. 修改完后运行buildk将会在/tftpboot/lts/下创建新的内核启动文件。 <BR _fckxhtmljob="1">　　./buildk <BR _fckxhtmljob="1">　　15. 建议创建内核启动文件连接，这样不必频繁修改配置文件的内容，下次只要改变文件名就可以更换内核了。 <BR _fckxhtmljob="1">　　cd /tftpboot/ltsp/　　ln -s vmlinuz-2.4.18-om2 vmlinuz-openmosix <BR _fckxhtmljob="1">　　16. 修改/etc/dhcpd.conf文件，使动态地址分配支持新的启动内核。修改内核启动文件的名称和路径，如果该文件不存在，可以参考后面的配置文件。 <BR _fckxhtmljob="1">　　cd /etc/　　vi dhcpd.conf　　filename "/lts/vmlinuz-openmosix"; <BR _fckxhtmljob="1">　　17. 随后你可以添加自动分配主机名，这样每台客户机启动时自动生成主机名，注意主机名要和你的hosts文件对应。本例中自动生成的主机名将是node001到node253，数字部分是根据IP地址补齐三位数得到的。 <BR _fckxhtmljob="1">　　vi dhcpd.conf　　filename "/lts/vmlinuz-openmosix";　　option host-name = concat("node" , binary-to-ascii( 10, 8, "",　　　　 substring(reverse( 1, leased-address), 0, 1))); </P>
<P _fckxhtmljob="1">　　18. 检查重要的服务进程是否启动，并使新配置文件生效。 <BR _fckxhtmljob="1">　　chkconfig tftp on　　chkconfig dhcpd on　　service dhcpd restart　　service xinetd restart <BR _fckxhtmljob="1">　　19. 创建mosix.map文件，并保持服务器和客户端的一致。 <BR _fckxhtmljob="1">　　cd /etc/　　vi mosix.map　　1 192.168.0.254 1　　2 192.168.0.1 253　　cp /etc/mosix.map /opt/ltsp/i386/etc/ <BR _fckxhtmljob="1">　　20. 复制openmosix的工具到客户端的目录中。 <BR _fckxhtmljob="1">　　cp /sbin/setpe /opt/ltsp/i386/sbin/　　cp /bin/mosrun /opt/ltsp/i386/bin/　　cp /bin/mosmon /opt/ltsp/i386/bin/　　cp /bin/mosctl /opt/ltsp/i386/bin/　　cp /bin/migrate /opt/ltsp/i386/bin/ <BR _fckxhtmljob="1">　　21. 因为/opt/ltsp/i386目录最后是客户端的根文件系统，需要的工具都可以复制到相应的目录中。因为/opt/ltsp/i386/etc/hosts文件是连接，因此需要先删除后复制新文件。 <BR _fckxhtmljob="1">　　cp /bin/touch /opt/ltsp/i386/bin　　rm -f /opt/ltsp/i386/etc/hosts　　cp /etc/hosts /opt/ltsp/i386/etc/　　cp /etc/rc.d/init.d/openmosix /opt/ltsp/i386/etc/rc.openmosix <BR _fckxhtmljob="1">　　 <BR _fckxhtmljob="1">　　22. 创建客户端的/mfs目录： <BR _fckxhtmljob="1">　　mkdir /opt/ltsp/i386/mfs <BR _fckxhtmljob="1">　　23. 修改客户端文件系统配置文件，加入mfs的配置： <BR _fckxhtmljob="1">　　cd /opt/ltsp/i386/etc　　vi fstab　　none /mfs mfs dfsa = 1 0 0 <BR _fckxhtmljob="1">　　24. 修改客户端启动进程脚本，加入启动openmosix的配置，禁止客户端提交集群计算的设置，和装载/mfs文件系统的配置。 <BR _fckxhtmljob="1">　　vi /opt/ltsp/i386/etc/rc.local　　　　# OpenMosix startup section　　# we don't want any terminal processes to migrate　　echo 1 &gt; /proc/mosix/admin/lstay　　# start mosix　　/etc/rc.openmosix start　　# mount mfs filesystem. doesn't work when done earlier　　mount /mfs　　# End OpenMosix Startup Section <BR _fckxhtmljob="1">　　25.配置完成后准备软盘制作以太启网启动盘。访问www.Rom-O-matic.net网站，选择网卡类型生成以太网启动芯片的映象，保存到Linux上，使用cat生成启动软盘。本例中使用3C905B。放入一张空白三寸软盘。 <BR _fckxhtmljob="1">　　cat eb-5[1].0.7-3c905b-tpo100.lzdsk &gt; /dev/fd0 <BR _fckxhtmljob="1">　　26. 修改LTSP客户端启动配置文件/opt/ltsp/i386/etc/lts.conf，禁止启动X Windows，修改参数X_USBMOUSE_BUTTONS = 3，即启动文本界面。 <BR _fckxhtmljob="1">　　27. 确认/etc/exports文件包含共享客户端根文件系统和交换区内容： <BR _fckxhtmljob="1">　　more /etc/exports　　/opt/ltsp/i386 　　　　192.168.0.0/255.255.255.0(ro,no_root_squash)　　/var/opt/ltsp/swapfiles　　　　192.168.0.0/255.255.255.0(rw,no_root_squash) <BR _fckxhtmljob="1">　　28. 将以太启动软盘放入客户端，开机并确认正常启动，正常获得动态地址，加载内核成功，初始化脚本正常运行，主机名自动生成，openmosix正常初始化，没有任何错误提示。 <BR _fckxhtmljob="1">　　29. 回到服务器，通过检查/mfs文件系统来检查mfs文件系统。 </P>
<P _fckxhtmljob="1">　　30. 启动mosmon监控程序来检查通讯是否有效，这是刚加入3个节点时，启动setiathome计算的状态。将下载的应用展开在/dw目录下，注意命令的格式。 <BR _fckxhtmljob="1">　　mosrun -j1-3 /mfs/1/dw/setiathome1 -nolock </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　 <BR _fckxhtmljob="1">　　31. 制作启动盘，陆续加入节点，MOSIX集群就创建完了。 <BR _fckxhtmljob="1">　　典型的配置文件 <BR _fckxhtmljob="1">/etc/mosix.map1 192.168.0.254 12 192.168.0.1 253 </P>
<P _fckxhtmljob="1">　 <BR _fckxhtmljob="1">/etc/dhcpd.confdefault-lease-time 21600;max-lease-time 21600;ddns-update-style none;allow booting;allow bootp;option subnet-mask 255.255.255.0;option broadcast-address 192.168.0.255;option routers 192.168.0.254;option domain-name-servers 192.168.0.254;option domain-name "mosix";option root-path "192.168.0.254:/opt/ltsp/i386";shared-network NODES { subnet 192.168.0.0 netmask 255.255.255.0 { range dynamic-bootp 192.168.0.100 192.168.0.253; use-host-decl-names on; option log-servers 192.168.0.254; if substring (option vendor-class-identifier, 0, 9) = "PXEClient" { filename "/lts/pxe/pxelinux.bin"; } else { filename "/lts/vmlinuz-2.4.18-mosix"; option host-name = concat("node" , binary-to-ascii( 10, 8, "", substring(reverse( 1, leased-address), 0, 1))); } }}group { use-host-decl-names on; option log-servers 192.168.0.254; host node001 { hardware ethernet 00:E0:06:E8:00:84; fixed-address 192.168.0.1; filename "/lts/boot/bootp/vmlinuz.eepro100.bootp"; } host node002 { hardware ethernet 00:D0:09:30:6A:1C; fixed-address 192.168.0.2; filename "/lts/boot/bootp/vmlinuz.tulip.bootp"; } host node003 { hardware ethernet 00:D0:09:30:28:B2; fixed-address 192.168.0.3; # kernels are specified in /tftpboot/lts/boot/pxe/pxelinux.cfg/ filename "/lts/boot/pxe/pxelinux.bin"; }} </P>
<P _fckxhtmljob="1">　 <BR _fckxhtmljob="1">/etc/exports/opt/ltsp/i386 192.168.0.0/255.255.255.0(ro,no_root_squash)/var/opt/ltsp/swapfiles 192.168.0.0/255.255.255.0(rw,no_root_squash) <BR _fckxhtmljob="1">/etc/hosts 和 /opt/ltsp/i386/etc/hosts192.168.0.254 mosix192.168.0.1 node001192.168.0.2 node002192.168.0.3 node003192.168.0.4 node004 <BR _fckxhtmljob="1">　　省略一部分 <BR _fckxhtmljob="1">192.168.0.253 node253127.0.0.1 localhost.localdomain localhost/opt/ltsp/i386/etc/fstabnone /mfs mfs dfsa=1 0 0 </P>
<P _fckxhtmljob="1">　 <BR _fckxhtmljob="1">/opt/ltsp/i386/etc/lts.conf [Default] SERVER = 192.168.0.254 XSERVER = off X_MOUSE_PROTOCOL = "PS/2" X_MOUSE_DEVICE = "/dev/psaux" X_MOUSE_RESOLUTION = 400 X_MOUSE_BUTTONS = 3 X_USBMOUSE_PROTOCOL= "PS/2" X_USBMOUSE_DEVICE = "/dev/input/mice" X_USBMOUSE_RESOLUTION = 400 X_USBMOUSE_BUTTONS = 3 USE_XFS = N LOCAL_APPS = N RUNLEVEL = 3 SOUND = Y VOLUME = 75 <BR _fckxhtmljob="1">常见问题和解决方法 <BR _fckxhtmljob="1">　　内核编译失败怎么办？ <BR _fckxhtmljob="1">　　编译内核是MOSIX集群的最大操作，对于没有编译过内核的人会遇到很多编译失败的问题。对于经常出现的问题和解决办法如下： <BR _fckxhtmljob="1">　　编译失败在SCSI设备时，如果没有SCSI设备，在编译配置菜单中除去SCSI选项。 <BR _fckxhtmljob="1">　　编译失败在SiS芯片时，如果没使用SiS芯片组的主板，在编译菜单中除去SiS芯片支持选项。 <BR _fckxhtmljob="1">　　更改编译文件后仍然编译失败时，注意将上一次编译的中间文件清理干净，使用如下命令（不要忘记备份.config文件）： <BR _fckxhtmljob="1">　　cd /usr/src/linux-2.4.18-om2　　cp .config /usr/src/config.backup/config-newkernel　　make mrproper <BR _fckxhtmljob="1">　　DHCP为什么不能正确读取配置文件？ <BR _fckxhtmljob="1">　　确认你的DHCP版本要3.0.1以上，可以到RedHat的网站上下载。另外检查/etc/dhcpd.conf文件配置是否有错误，可以参考本例的文件。 <BR _fckxhtmljob="1">　　配置完启动时出现sshd加载失败时怎么办？ <BR _fckxhtmljob="1">　　该情况出现在MOSIX修改sshd的属性后出现，你可以加载MOSIX的ssd守护进程，操作如下： <BR _fckxhtmljob="1">　　chkconfig sshd.pre-mosix on　　service sshd.pre-mosix start <BR _fckxhtmljob="1">　　首次启动MOSIX时提示Host name lookup failure是什么原因？ <BR _fckxhtmljob="1">　　这是由于/etc/hosts文件没有正确标出主机名对应的地址造成的，修改/etc/hosts文件正确就可以。 <BR _fckxhtmljob="1">　　首次启动MOSIX时提示以下错误： <BR _fckxhtmljob="1">　　setpe: the supplied table is well-formatted, <BR _fckxhtmljob="1">　　but my IP address (127.0.0.1) is not there! <BR _fckxhtmljob="1">是什么原因？ <BR _fckxhtmljob="1">　　这是由于RedHat Linux 的host文件缺省只有127.0.0.1对应主机名，可以将/etc/hosts文件中的127.0.0.1 mosix localhost分开描述： <BR _fckxhtmljob="1">　　vi /etc/hosts　　192.168.0.254 mosix　　127.0.0.1 localhost <BR _fckxhtmljob="1">　　制作LTSP启动内核映象失败 <BR _fckxhtmljob="1">　　注意使用的LTSP初始化工具是ltsp_initrd_kit-3.0.1-i386.tgz版本，其他的版本因为修改了初始化脚本，目前没有方法可以初始化成功。 <BR _fckxhtmljob="1">　　另外制作启动内核映象时必须有mknbi-1.2-6.noarch.rpm包，从RedHat的网站上可以下载最新的版本。 <BR _fckxhtmljob="1">　　配置ltsp客户端DHCP启动失败 <BR _fckxhtmljob="1">　　检查/etc/dhcpd.conf文件指向的启动内核路径正确，确认物理连接正确，确认软盘未损坏，确认LTSP内核启动文件正常编译。确认安装并启动了tftp守护进程，确认/etc/exports文件共享了正确的客户端根文件系统路径。 <BR _fckxhtmljob="1">　　配置ltsp客户端启动X Windows失败 <BR _fckxhtmljob="1">　　如果需要在客户端启动X Windows，需要安装LTSP的X包，并根据显示卡的不同安装不同的X服务器版本。 <BR _fckxhtmljob="1">　　rpm -Uvh ltsp_x_core-3.0.1-1.i386.rpm　　rpm -Uvh ltsp_x_fonts-3.0.0-0.i386.rpm <BR _fckxhtmljob="1">　　下载连接是：http://sourceforge.net/project/showfiles.php?group_id=17723 <BR _fckxhtmljob="1">　　如果并不需要启动X Windws，需要修改/opt/ltsp/i386/etc/lts.conf文件中X_USBMOUSE_BUTTONS = 3即可启动文本界面。 <BR _fckxhtmljob="1">　　LTSP客户端启动后找不到主机名或不能解析主机名 <BR _fckxhtmljob="1">　　确认/opt/ltsp/i386/hosts文件不是符号连接，并且和/etc/hosts文件一致，确认/etc/dhcpd.conf文件中加入自动生成主机名配置，确认生成的主机名与hosts文件中的一致。 <BR _fckxhtmljob="1">　　LTSP客户端启动后不能启动mosix <BR _fckxhtmljob="1">　　确认/etc/mosix.map和/opt/ltsp/i386/etc/mosix.map文件一致。 <BR _fckxhtmljob="1">　　启动mosix后没找到mfs目录 <BR _fckxhtmljob="1">　　手动创建/mfs目录： <BR _fckxhtmljob="1">　　mkdir /mfs　　mkdir /opt/ltsp/i386/mfs </P>
<P _fckxhtmljob="1">　 <BR _fckxhtmljob="1">背景资料： <BR _fckxhtmljob="1">相关名词 <BR _fckxhtmljob="1">　　SMP：对称多处理器 <BR _fckxhtmljob="1">　　LTSP：Linux终端服务器项目 (Linux Terminal Server Project) <BR _fckxhtmljob="1">　　Kernel：内核 <BR _fckxhtmljob="1">　　Ramdisk：内存虚拟盘 <BR _fckxhtmljob="1">　　Etherboot：以太启动 <BR _fckxhtmljob="1">　　Bootrom：网卡启动芯片 <BR _fckxhtmljob="1">大型主机(Mainframes)，超级计算机(Supercomputers)和集群(Clusters) <BR _fckxhtmljob="1">　　纵观计算机的历史，最先让人了解的就是大型主机和超级计算机，这是计算机历史的一部分，没有这些大家伙，就没有今天的个人电脑。这些大家伙通常是一个或几个有强大研发队伍和资金的厂商完成，最初的目的是军方或政府的需要，很多大学的研发也促成了这些大家伙更强大。一般情况下，大型主机和超级计算机都使用超过8个，多达上百个的CPU和自己的专用操作系统，计算机历史上很多的重要成员都和这些大家伙有关，IBM，DEC，Cray，SGI，HAL。大型主机已经成为历史，而超级计算机成了各国技术实力的争夺焦点，但是目前个人电脑的发展使集群成为竞争超级计算机的强大对手，集群的CPU数和浮点能力和超级计算机的差距已经越来越近。 <BR _fckxhtmljob="1">Cluster <BR _fckxhtmljob="1">　　集群系统，也有成为机群和群集系统的。集群主要分为三类：容错集群(Fail-over Cluster)，负载均衡集群(Load balancing Cluster)，高性能计算集群(High Performance Computing)。 <BR _fckxhtmljob="1">　　容错集群是指两台主机通过两个或两个以上网路连接的系统，其中一个连接称为心跳线（heartbeat），利用每台主机上的服务进程监控对方主机的状态，一旦发现对方主机宕机或出现不能正常工作的情况，心跳线会反映给互为备份的另外一台主机，该主机则会接替出问题的主机。典型的使用场景是空军的雷达追踪系统。 <BR _fckxhtmljob="1">　　负载均衡集群一般用于相应网络请求的网页服务器，代理服务器。这种集群可以在接到请求时，检查接受请求较少，不繁忙的服务器，并把请求转到这些服务器上。从检查其他服务器状态这一点上看，负载均衡和容错集群很接近，不同之处是数量上更多。 <BR _fckxhtmljob="1">　　高性能计算集群是指具有响应大量计算的性能，可以作为数据中心使用的计算机的集合。比如压缩mp3，气象云图的分析等。 <BR _fckxhtmljob="1">集群模式 <BR _fckxhtmljob="1">　　(N)UMA非一致性内存访问(Non-)Uniform Memory Access一般是指通过执行特殊的程序代码对内存的共享访问。在Linux内核中，可以执行对访问时间内的不同内存区域进行交叉访问，也就是内核进程可以使用接近CPU使用时的内存。对正在使用内存区域的访问，才可以共享。线性的内存访问是无法共享的。 <BR _fckxhtmljob="1">　　PVM/MPI是指并行虚拟机(Parallel Virrual Machine)和信息传递界面(Message Passing Interface)。在Beowulf的世界里最常提到的就是这两个概念，该软件包已经提供了多平台的版本。通过开放式的标准信息传递库，并行机之间可以通讯，事实上PVM也是一组库，程序可以使用这些编译库来改造程序适应并行系统。但是这些都要相应的修改源程序，系统内核事实上并没有发生改变。 <BR _fckxhtmljob="1">　　其他模式：Turbo Linux EnFuzion，Platform等网格计算(Grid Computing)不必讨论这类集群不是单纯意义的集群，以Enfuzion为例，EnFuzion是Turbo Linux收购的一个软件改良版（前身就叫Cluster)，因为使用了Java，可以跨平台，使用驻留系统服务来监控集群间的通讯，事实上是任务分发和监控器，依赖于计算数据离散性，对于数据不可分的程序，无能为力。也就是说每个节点都运行相同的程序，但处理的数据是不同的，该集群提供了控制这些程序的界面，跨平台性也只是依赖于计算的应用有跨平台版本，而其只提供跨平台的监控。主要集中在CPU空闲的监控和计算的再分配。 <BR _fckxhtmljob="1">数据可分和程序可分 <BR _fckxhtmljob="1">　　集群计算中最重要的就是分布，根据不同的应用，分为两种：数据可分和程序可分。 <BR _fckxhtmljob="1">　　数据可分是指数据间没有必然联系或联系在结果的基础上，比如mp3的压缩，每个单独的mp3互不关联，或者有限元计算的某个步骤，单一的曲面计算生成结果再参加后面的关联计算，更着名的是SETI@home通过分析射电望远镜的信号寻找外星人，这是典型的将中间分析结果传递给下一部分析，这就是数据可分，这最适合网格计算。 <BR _fckxhtmljob="1">　　程序可分，用过ANSYS的人都知道商业软件分为单处理器和多处理器版本，因为计算量大，所以支持SMP的计算软件和使用单一CPU的软件是不同的，多CPU共同运算时也要考虑到内存的访问，处理通讯和负载均衡，除非操作系统支持，不然使用DOS和Windows9x很难用到第二个CPU（甚至不可见），有了操作系统的支持，应用程序也要支持，即使操作系统支持并行，应用程序不可分的话，只能使用1/n（n=CPU数量）的处理能力，典型的例子就是2CPU的WindowsNT/2000下使用单处理器版本的ANSYS，处理器进程显示50%，但是2CPU共同生效。而使用多处理器版本时，2CPU都可以在98%的使用率。因此程序可分是集群重要的应用基础，即使程序本身不可分，而集群支持子进程的迁移，也意味着类似SMP系统支持程序可分。 </P>
<P _fckxhtmljob="1">需要强大计算的应用 <BR _fckxhtmljob="1">　　财务与社会行为分析，使用数学模型模拟的计算。 <BR _fckxhtmljob="1">　　音乐，图象等多媒体数据处理，例如mp3压缩，动画渲染，后期处理。 <BR _fckxhtmljob="1">　　流体力学，有限元分析，例如乐高玩具的数字模拟强度分析。 <BR _fckxhtmljob="1">　　编译，数据库挖掘。 <BR _fckxhtmljob="1">　　医学研究，例如AIDS和DNA的结构分析，成功运作的有UD(United Devices http://www.ud.com/home.htm) <BR _fckxhtmljob="1">　　天文研究，例如SETI@home，在家寻找外星人项目(http://setiathome.ssl.berkeley.edu/index.html)。天气和海浪预报。 <BR _fckxhtmljob="1">　　电子电路数字模拟分析，例如研发新的处理器。 <BR _fckxhtmljob="1">　　穷举解密，例如破解DES密码(http://www.distributed.net/index.html.en)。 <BR _fckxhtmljob="1">正在研发的分布式计算系统 <BR _fckxhtmljob="1">　　 <BR _fckxhtmljob="1">　　相关连接：www.beowulf.org <BR _fckxhtmljob="1">　　Plan 9 <BR _fckxhtmljob="1">　　1993年源于贝尔实验室(Computing Sciences Research Center of Bell Laboratories) 开发的新分布式操作系统，建立在Unix和C与C++基础上，支持的处理器有Intel x86, Sparc, Alpha, Power PC, 和ARM。目前没有象KDE漂亮的图形界面，使用上接近UNIX，标准UNIX工具也可以使用，但是从设计原理和基础上不同于UNIX，核心已经完全重写并设计成网络操作系统，就像设计完UNIX后的补充，其中设计元素包括用户端的终端，存储固定文件的服务器和提供更快CPU的计算服务器，提供用户验证和网关特性。 <BR _fckxhtmljob="1">　　目前吸引人的焦点是Plan 9的文件系统可以支持所有的系统服务进程，也就是说所有任何用户可以使用的资源在文件系统中都可以找到唯一的命名，已经可以称为命名空间了。通过网络层的协议9P来访问所有的资源，这一点类似NFS，但不同之处是对用户不透明。支持异构的网络：以太网，光纤和普通调制解调器，还有ISDN的连接。 <BR _fckxhtmljob="1">　　较早的Plan 9更像文件系统，现在的系统支持更多的用户并发。标准情况下，用户可以运行任意的从他们的终端上或CPU服务器上启动应用，应用将会从文件服务器上获取数据，并且可以小到在笔记本上运行。因为具备了高可配置性，因此摆脱了客户机服务器体系的中心控制模式。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　相关连接：http://plan9.bell-labs.com/plan9dist/ <BR _fckxhtmljob="1">　　其他的网格计算 <BR _fckxhtmljob="1">　　http://www.gridcomputingplanet.com/ 网格计算的信息站点 <BR _fckxhtmljob="1">　　http://wwws.sun.com/software/gridware/ SUN的网格计算软件 <BR _fckxhtmljob="1">　　http://www.turbolinux.com/enfuzion TurboLinux的EnFuzion <BR _fckxhtmljob="1">　　如何编译内核 <BR _fckxhtmljob="1">　　首先你的手中要有一个Linux的分发版本，RedHat是个不错的选择，为了具有普遍性，下面的操作是在RedHat 7.2的基础上完成的。 <BR _fckxhtmljob="1">　　当你安装完Linux后，你需要确认下列的rpm包已经存在（*是指不同的版本），你可以使用rpm -Uvh来安装（绝大多数文件在CD2中） ： <BR _fckxhtmljob="1">　　mount /dev/cdrom /mnt/cdrom　　cd /mnt/redhat/RPM　　rpm -Uvh kernel-headers*　　rpm -Uvh kernel-source*　　rpm -Uvh kernel-doc*　　rpm -Uvh dev86*　　rpm -Uvh make-*　　rpm -Uvh glibc-devel*　　rpm -Uvh cpp*　　rpm -Uvh ncurses-devel*　　rpm -Uvh binutils*　　rpm -Uvh gcc-2*　　cd /usr/src　　umount /mnt/cdrom <BR _fckxhtmljob="1">　　如果你从www.kernel.org上下载了Linux稳定的内核2.4.18，可以将他解开并移到/usr/src目录下： <BR _fckxhtmljob="1">　　tar xvfz linux-2.4.18.tar.gz　　mv linux /usr/src/linux-2.4.18 <BR _fckxhtmljob="1">　　你可以修改Makefile文件来改变编译的内核名称，RedHat 7.2的内核版本是2.4.7.10，首先要清理编译的过程文件，将当前版本内核配置文件作为新编译内核版本的配置使用，编译中的错误输出到指定文件 <BR _fckxhtmljob="1">　　cd /usr/src/linux-2.4.18　　make mrproper　　cp -p /usr/src/linux-2.4/config/kernel-*-i686.config .config　　make oldconfig　　make dep　　make bzImage 2 &gt; errors　　make modules 2 &gt; mod-errors　　cp -p arch/i386/boot/bzImage /boot/vmlinuz-2.4.18　　cp -p System.map /boot/System.map-2.4.18　　make modules_install <BR _fckxhtmljob="1">　　编译内核的初始化文件： <BR _fckxhtmljob="1">　　new-kernel-pkg -install -mkinitrd -depmod 2.4.18　　mkdir /mnt/initrd　　gzip -dc /boot/initrd-2.4.8.img &gt; /tmp/initrd.img　　mount -o loop /tmp/initrd.img /mnt/initrd　　ls -R /mnt/initrd　　umount /mnt/initrd <BR _fckxhtmljob="1">　　修改GRUB的启动配置(/boot/grub/grub.conf)文件，加入新编译内核的条目： <BR _fckxhtmljob="1">　　vi /boot/grub/grub.conf　　title Red Hat Linux (2.4.1 root (hd0,0) kernel /vmlinuz-2.4.18 ro root=/dev/hda2 <BR _fckxhtmljob="1">　　下次启动时就可以选择了。 <BR _fckxhtmljob="1">www.Rom-O-matic.net <BR _fckxhtmljob="1">　　动态创建以太网启动映象。目前的版本是5.0.7。使用的原理就是用软盘启动来模拟网卡的启动芯片。主页是交互式的，通过下拉菜单，可以选择网卡的类型和映象类型。在配置菜单中还可以设置支持的启动类型和其他的参数，最后点击Get ROM将提示保存映象文件。把保存的结果传到Linux上，使用cat命令将映象文件创建以太启动软盘。 </P>
<P _fckxhtmljob="1"><BR _fckxhtmljob="1">　　LTSP的启动过程 <BR _fckxhtmljob="1">　　LTSP的启动过程需要很多步骤，了解这些步骤可以很好排除出现的问题： <BR _fckxhtmljob="1">　　以下的例子硬件环境是 <BR _fckxhtmljob="1">　　客户端DELL Gx1 PII 350MB 128MB 3C905B ATI rage128 <BR _fckxhtmljob="1">　　服务器端运行RedHat 7.2和DHCP服务 <BR _fckxhtmljob="1">　　网络地址范围192.168.0.0网段，子网掩码是255.255.255.0 <BR _fckxhtmljob="1">　　客户端开机自检 <BR _fckxhtmljob="1">　　在开机自检的过程中，BIOS将检测扩展的芯片，也就是网卡上增加的用于以太网启动的启动芯片(bootrom)，BIOS可以检测到网卡上的启动芯片。 一旦开机自检完成，执行步骤将到以太启动代码。 以太启动代码检测网卡类型，当检测正确时，初始化网卡。 <BR _fckxhtmljob="1">　　以太启动代码将在本地网段中发申请DHCP的广播，网卡的MAC地址将包括在该广播中。 <BR _fckxhtmljob="1">　　服务器端的DHCPD守护进程将收到来自客户端的广播申请，检查配置文件中与接受到客户端MAC地址相匹配的参数。 <BR _fckxhtmljob="1">　　DHCPD守护进程发送回复的数据包，该数据包中包括：该客户端的IP地址，本网段的子网掩码，下载内核的路径，需要装载的根文件系统的路径，传递内核命令行执行的参数。 <BR _fckxhtmljob="1">　　以太启动代码将从服务器接受这些数据，随后开始按照提供的数据配置网卡的TCP/IP设置。 <BR _fckxhtmljob="1">　　使用TFTP(Trivial File Transfer Protocol直接文件传输协议)，以太启动代码可以从服务器上下载内核。 <BR _fckxhtmljob="1">　　一旦内核下载到客户端完成，以太启动代码将把内核放到内存正确的位置。 <BR _fckxhtmljob="1">　　完成必要步骤之后，控制权交到内核控制，内核将开始初始化整个系统和全部的可识别外围设备。 <BR _fckxhtmljob="1">　　下面才是真正的开始。因为内核是文件系统的镜像，需要象调入内存的虚拟盘中，并作为根文件系统临时装载到系统中。用内核命令行表示root=/dev/ram0引导内核镜像作为根文件系统装载。 <BR _fckxhtmljob="1">　　正常情况下，内核完成启动过程后，将启动init进程。需要指明内核如何调入shell脚本，用init=/linuxrc命令行表示。 <BR _fckxhtmljob="1">　　/linuxrc脚本将扫描PCI总线，搜索网卡等。每种类型的PCI驱动都会在/etc/niclist中寻找匹配的参数。一旦发现匹配的，该网卡类型的模块将返回给内核用来加载。对于ISA接口的卡，驱动模块必须被内核以命令行方式加载，并且需要特别指定中断和占用的地址。 <BR _fckxhtmljob="1">　　一旦网卡被识别，/linuxrc脚本将加载前面返回的内核模块。 <BR _fckxhtmljob="1">　　dhclient将随后运行来从DHCP服务器来的确认请求。这里需要特别区分确认的类型，从以太启动得到的确认将被内核取消，内核将忽略任何曾经特殊指定过根路径的NFS（网络文件系统）服务器。如果你的NFS服务器和TFTP服务器不是同一台时，这一点非常重要。也就是说这是系统不再依赖TFTP服务器而是开始使用NFS服务器来装载文件系统了。</P>
<P _fckxhtmljob="1">&nbsp;</P>
本文作者:
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/25438.html'>利用ASP规划聊天室</a><a>下一篇</a><a href='/php/biji/25441.html'>除MSSQL数据库text字段中恶意脚本的删方法</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>