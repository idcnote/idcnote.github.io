<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>C语言中的链接编写教程_PHP教程_IDC笔记</title>
    <meta name="keywords" content="PHP,PHP笔记,PHP教程" />
    <meta name="description" content="链接<br />
<br />
  链接就是将不同部分的代码和数据收集和组合成为一个单一文件的过程,这个文件可被加载或拷贝到存储器执行.<br />
<br />
  链接可以执行与编译时(源代码被翻译成机器代码时),也" />
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author" />
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP简介			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jianjie/1.html">PHP简介</a></li><li><a href="/php/jianjie/2.html">PHP用途</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP基本语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yufa/3.html">分离HTML</a></li><li><a href="/php/yufa/4.html">指令分隔符</a></li><li><a href="/php/yufa/5.html">PHP注释</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类型			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpleixing/6.html">PHP类型简介</a></li><li><a href="/php/phpleixing/7.html">PHP类型之布尔类型</a></li><li><a href="/php/phpleixing/8.html">PHP类型之整型</a></li><li><a href="/php/phpleixing/9.html">PHP类型之浮点型</a></li><li><a href="/php/phpleixing/10.html">PHP类型之字符串</a></li><li><a href="/php/phpleixing/11.html">PHP类型之数组</a></li><li><a href="/php/phpleixing/12.html">PHP类型之对象</a></li><li><a href="/php/phpleixing/13.html">PHP类型之资源类型</a></li><li><a href="/php/phpleixing/14.html">PHP类型之NULL</a></li><li><a href="/php/phpleixing/15.html">PHP类型之伪类型</a></li><li><a href="/php/phpleixing/16.html">PHP类型之类型判别</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP变量			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbianliang/17.html">PHP变量之基础</a></li><li><a href="/php/phpbianliang/18.html">PHP变量之预定义变量</a></li><li><a href="/php/phpbianliang/19.html">PHP变量之变量范围</a></li><li><a href="/php/phpbianliang/20.html">PHP变量之可变变量</a></li><li><a href="/php/phpbianliang/21.html">PHP变量之外部变量</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP运算符			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yunsuanfu/22.html">PHP运算符优先级</a></li><li><a href="/php/yunsuanfu/23.html">算术运算符</a></li><li><a href="/php/yunsuanfu/24.html">赋值运算符</a></li><li><a href="/php/yunsuanfu/25.html">位运算符</a></li><li><a href="/php/yunsuanfu/26.html">比较运算符</a></li><li><a href="/php/yunsuanfu/27.html">错误控制运算符</a></li><li><a href="/php/yunsuanfu/28.html">执行运算符</a></li><li><a href="/php/yunsuanfu/29.html">递增/递减运算符</a></li><li><a href="/php/yunsuanfu/30.html">逻辑运算符</a></li><li><a href="/php/yunsuanfu/31.html">字符串运算符</a></li><li><a href="/php/yunsuanfu/32.html">数组运算符</a></li><li><a href="/php/yunsuanfu/33.html">类型运算符</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP控制结构			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/jiegou/34.html">PHP控制结构之if</a></li><li><a href="/php/jiegou/35.html">PHP控制结构之else</a></li><li><a href="/php/jiegou/36.html">PHP控制结构之elseif/else if</a></li><li><a href="/php/jiegou/37.html">PHP控制结构之替代语法</a></li><li><a href="/php/jiegou/38.html">PHP控制结构之while</a></li><li><a href="/php/jiegou/39.html">PHP控制结构之do-while</a></li><li><a href="/php/jiegou/40.html">PHP控制结构之for</a></li><li><a href="/php/jiegou/41.html">PHP控制结构之foreach</a></li><li><a href="/php/jiegou/42.html">PHP控制结构之break</a></li><li><a href="/php/jiegou/43.html">PHP控制结构之continue</a></li><li><a href="/php/jiegou/44.html">PHP控制结构之switch</a></li><li><a href="/php/jiegou/45.html">PHP控制结构之declare</a></li><li><a href="/php/jiegou/46.html">PHP控制结构之return</a></li><li><a href="/php/jiegou/47.html">PHP控制结构之require</a></li><li><a href="/php/jiegou/48.html">PHP控制结构之include</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/hanshu/52.html">用户自定义函数</a></li><li><a href="/php/hanshu/53.html">函数的参数</a></li><li><a href="/php/hanshu/54.html">返回值</a></li><li><a href="/php/hanshu/55.html">可变函数</a></li><li><a href="/php/hanshu/56.html">内部（内置）函数</a></li><li><a href="/php/hanshu/57.html">匿名函数</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP类与对象			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpduixiang/58.html">类与对象前言</a></li><li><a href="/php/phpduixiang/59.html">基本概念</a></li><li><a href="/php/phpduixiang/60.html">属性</a></li><li><a href="/php/phpduixiang/61.html">类常量</a></li><li><a href="/php/phpduixiang/62.html">自动加载对象</a></li><li><a href="/php/phpduixiang/63.html">构造函数和析构函数</a></li><li><a href="/php/phpduixiang/64.html">访问控制</a></li><li><a href="/php/phpduixiang/65.html">对象继承</a></li><li><a href="/php/phpduixiang/66.html">Static关键字</a></li><li><a href="/php/phpduixiang/67.html">抽象类</a></li><li><a href="/php/phpduixiang/68.html">接口</a></li><li><a href="/php/phpduixiang/69.html">Traits</a></li><li><a href="/php/phpduixiang/70.html">重载</a></li><li><a href="/php/phpduixiang/71.html">对象迭代</a></li><li><a href="/php/phpduixiang/72.html">设计模式</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP异常处理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/yichang/81.html">异常处理</a></li><li><a href="/php/yichang/82.html">扩展PHP内置的异常处理类</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> PHP函数库按分类			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpku/83.html">数组</a></li><li><a href="/php/phpku/84.html">Classes/Objects</a></li><li><a href="/php/phpku/85.html">Date/Time</a></li><li><a href="/php/phpku/86.html">Directories</a></li><li><a href="/php/phpku/87.html">错误处理</a></li><li><a href="/php/phpku/88.html">Program execution</a></li><li><a href="/php/phpku/89.html">Filesystem</a></li><li><a href="/php/phpku/90.html">Filter</a></li><li><a href="/php/phpku/91.html">Function Handling</a></li><li><a href="/php/phpku/92.html">PHP 选项/信息</a></li><li><a href="/php/phpku/93.html">Mail</a></li><li><a href="/php/phpku/94.html">Math</a></li><li><a href="/php/phpku/95.html">Misc.</a></li><li><a href="/php/phpku/96.html">Network</a></li><li><a href="/php/phpku/97.html">输出控制</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> php基础			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/php/phpbiji/108377.html"></a></li><li><a href="/php/phpbiji/108376.html"></a></li><li><a href="/php/phpbiji/108380.html"></a></li><li><a href="/php/phpbiji/108379.html"></a></li><li><a href="/php/phpbiji/108378.html"></a></li><li><a href="/php/phpbiji/108381.html"></a></li><li><a href="/php/phpbiji/108382.html"></a></li><li><a href="/php/phpbiji/108384.html"></a></li><li><a href="/php/phpbiji/108383.html"></a></li><li><a href="/php/phpbiji/108385.html"></a></li><li><a href="/php/phpbiji/108386.html"></a></li><li><a href="/php/phpbiji/108388.html"></a></li><li><a href="/php/phpbiji/108387.html"></a></li><li><a href="/php/phpbiji/108389.html"></a></li><li><a href="/php/phpbiji/108391.html"></a></li>		</ul>
	</li>
		<li>
	    <a href="/php/biji/" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>PHP笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">C语言中的链接编写教程</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>链接<br />
<br />
  链接就是将不同部分的代码和数据收集和组合成为一个单一文件的过程,这个文件可被加载或拷贝到存储器执行.<br />
<br />
  链接可以执行与编译时(源代码被翻译成机器代码时),也</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p></p>
<p><strong>链接<br />
</strong>&nbsp; 链接就是将不同部分的代码和数据收集和组合成为一个单一文件的过程,这个文件可被加载或拷贝到存储器执行.<br />
&nbsp; 链接可以执行与编译时(源代码被翻译成机器代码时),也可以执行与加载时(在程序被加载器加载到存储器并执行时),甚至执行与运行时,由应用程序来执行.在现代系统中,链接是由链接器自动执行的.<br />
&nbsp; 链接器分为:静态链接器和动态链接器两种.<br />
<strong>静态链接器<br />
</strong>&nbsp; 静态链接器以一组可重定位目标文件和命令行参数作为输入,生成一个完全链接的可以加载和运行的可执行目标文件作为输出.</p>
<p>&nbsp; 静态链接器主要完成两个任务:<br />
&nbsp; 1&gt;符号解析:目标文件定义和引用符号.符号解析的目的在于将每个符号引用和一个符号定义联系起来.<br />
&nbsp; 2&gt;重定位:编译器和汇编器生成从地址零开始的代码和数据节.链接器通过把每个符号定义和一个存储器位置联系起来,然后修改所有对这些符号的引用,使得他们执行这个存储位置,从而重定位这些节.</p>
<p>&nbsp; 目标文件:<br />
&nbsp; 目标文件有三种形式:<br />
&nbsp; 1&gt;可重定位的目标文件:<br />
&nbsp; 包含二进制代码和数据,其形式可以再编译时与其他可定位目标文件合并起来,创建一个可执行目标文件.<br />
&nbsp; 2&gt;可执行目标文件:<br />
&nbsp; 包含二进制代码和数据,其形式可以被直接拷贝到存储器并执行.<br />
&nbsp; 3&gt;共享目标文件:<br />
&nbsp; 一种特殊的可重定位目标文件,可以再加载或运行时,被动态地夹在到存储器并执行.<br />
&nbsp; 编译器和汇编器生成可重定位目标文件(包括共享目标文件),链接器生成可执行目标文件.</p>
<p><strong>&nbsp; 可重定位目标文件:<br />
</strong>&nbsp; EF头L以一个16字节的序列开始,这个序列描述了字的大小和生成该文件的系统字节顺序.ELF头剩下的部分包含帮助链接器解析和解释目标文件的信息.其中包括ELF头的大小,目标文件的类型(比如,可重定位,可执行,共享目标文件),机器类型,节头部表的文件偏移,以及节头部表中的表目大小和数量.不同节的位置和大小是节头部表描述的,其中目标文件中的每个节都有一个固定大小的表目.ELF格式的可重定位目标文件结构如下图:</p>
<p></p>
<p>.text:已编译程序的机器代码<br />
.rodata:只读数据<br />
.data:已初始化的全局C变量<br />
.bss:未初始化的全局C变量.在目标文件中这个节不占实际空间,仅是一个占位符.<br />
.sysmtab:一个符号表,存放在程序中被定义和引用的函数和全局变量的信息.<br />
.rel.text:当链接器把这个目标文件和其他文件结合时,.text节中的许多位置都需要修改.一般而言,任何调用外部函数或者引用全局变量的指令都要修改.另一个方面,调用本地函数的指令则不需要修改.<br />
.rel.data:被模块定义或引用的任何全局变量的信息.<br />
.debug:一个调试符号表<br />
.line:原始C源程序中的行号和.text节中机器指令之间的映射.<br />
.strtab:一个字符串表,其中内容包括.symtab和.debug节中的符号表,以及节头部中的节名字.</p>
<p>&nbsp;</p>
<p><strong>&nbsp; 符号和符号表<br />
</strong>&nbsp; 每个可重定位目标模块m都有一个符号表,它包含m所定义和引用的符号的信息.在链接器上下文中,有三种不同的符号:<br />
&nbsp; 1&gt;由m定义并能被其他模块引用的全局符号.全局链接器符号对应于非静态的C函数以及被定义为不带C的static属性的全局变量.<br />
&nbsp; 2&gt;由其他模块定义并被模块m引用的全局符号.这些符号成为外部符号,对应于定义在其他模块中的C函数和变量.<br />
&nbsp; 3&gt;只被模块m定义和引用的本地符号.有的本地符号链接器符号对应于带static属性的C函数和全局变量.这些符号在模块m中的任何地方都可见,但是不能被其他模块引用.目标文件中对应于模块m的节和相应的源文件的名字也能获得本地符号.</p>
<p>&nbsp; 符号表式有汇编器构造的,使用编译器输出到汇编语言.s文件中的符号.sysmab节中包含ELF符号表.这张符号表包含一个关于表目的数组.表目的格式如下:</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
typedef struct{
 int name; //string table offset
 int value; //section offset, or VM address
 int size; //object size in bytes
 char type:4, //data, func, section, or src file
    binding:4; //local or global
 char reserved; //unused
 char section; //section header index, ABS, UNDEF, or COMMON
}Elf_Symbol;

</pre>
</div>
<p><strong>符号解析<br />
</strong>&nbsp; 链接器解析符号引用的方法是将每个引用和它输入的可重定位目标文件按的符号表中的一个确定的符号定义联系起来.<br />
&nbsp; 对于那些和引用定义在相同模块的本地符号的引用,符号解析式非常简单明了的.编译器只允许每个模块中的每个本地符号只有一个定义.编译器还确保静态本地变量,它们会有本地链接器符号,拥有唯一的名字.<br />
&nbsp; 对于全局符号的引用解析,当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时,它会假设该符号式在其他某个模块中定义的,生成一个链接器符号表表目,并把它交给链接器处理.如果链接器在它的任何输入模块中都找不到这个被引用的符号,它就输出一条错误信息并终止.<br />
&nbsp; 在编译时,编译器输出的每个全局符号给汇编器,或者是强,或者是弱,而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中.函数和以初始化的全局变量是强符号,未初始化的全局变量是弱符号.<br />
&nbsp; 根据符号的强弱,有如下规则:<br />
&nbsp; 1&gt;不允许有多个强符号<br />
&nbsp; 2&gt;如果有一个强符号和多个弱符号,则选择强符号<br />
&nbsp; 3&gt;如果有多个弱符号,则任选一个弱符号</p>
<p><strong>&nbsp; 与静态库链接<br />
</strong>&nbsp; 所有编译系统都提供一种机制,将所有相关的目标模块打包为一个单独的文件,称为静态库,它可以用做链接器的输入.当链接器构造一个输出的可执行文件时,它只拷贝静态库里被应用程序引用的目标模块.<br />
&nbsp; 在unix系统中,静态库以一种称为存档的特殊文件格式存放在磁盘中.存档文件是一组连接起来的可重定位目标文件的集合,有一个头部描述每个成员目标文件的大小和位置.</p>
<p><strong>&nbsp; 链接器如何使用静态库来解析引用<br />
</strong>&nbsp; 在符号解析阶段,链接器从左到右按照它们在编译驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件.在这次扫描中,链接器位置一个可重定位目标文件集合E,这个集合中的文件会被合并起来形成可执行文件,和一个未解析的符号集合U,以及一个在前面输入文件中已定义的符号结合D.初始时,E,U,D都是空的.<br />
&nbsp; 1&gt;对于命令行上的每个输入文件f,链接器会判断f是一个目标文件还是一个存档文件.如果是一个目标文件,那么链接器把f添加到E,修改U和D来反映f中的符号定义和引用,并继续下一个输入文件.<br />
&nbsp; 2&gt;如果f是一个存档文件,那么链接器就尝试匹配U中未解析的符号由存档文件成员定义的符号.如果某个存档文件成员m,定义了一个符号来解析U中的一个引用,那么就将m加到E中,并且链接器修改U和D来反映m中的符号定义和引用.对存档文件中的所有成员目标文件都反复进行这个过程,知道U和D都不再发生变化.在此时,任何不包含在E中的成员目标文件都会被丢弃,而链接器将继续到下一个输入文件.<br />
&nbsp; 3&gt;如果当链接器完成对输入命令行的扫描后,U是非空的,那么链接器就会输出一个错误并终止.否则,它会合并重定位E中的目标文件,从而构建输出的可执行文件.</p>
<p>&nbsp; 这种方式,导致了在输入命令时要考虑到,静态库和目标文件的位置,库文件放在目标文件的后面,如果库文件之间有引用关系,则被引用的库放在后面.</p>
<p><strong>重定位<br />
</strong>&nbsp; 当链接器完成了符号解析这一步时,它就把代码中的每个符号引用和确定的一个符号定义(也就是,它的一个输入目标模块中的一个符号表表目)联系起来.此时,链接器就知道它的输入目标模块中的代码节和数据解的确切大小.然后就开始重定位步骤.重定位由两步组成:<br />
&nbsp; 1&gt;重定位节和符号定义:<br />
&nbsp; 在这一步中,链接器将所有相同类型的节合并为一个新的聚合节.然后,链接器将运行时存储器地址赋值给新的聚合节,赋给输入模块定义的每个节,以及赋给输入模块定义的每个符号.当这一步完成时,程序中的每个指令和全局变量都一个唯一的运行时存储器地址.<br />
&nbsp; 2&gt;重定位节中的符号引用:<br />
&nbsp; 在这一步中,链接器修改代码节和数据节中对每个符号的引用,使得它们指向正确的运行时地址.为了执行这一步,链接器依赖于称为重定位表目的可重定位目标模块中的数据结构.</p>
<p>&nbsp; 重定位表目:<br />
&nbsp; 当汇编器生成一个目标模块时,它并不知道数据和代码最终将存放在存储器中的什么位置.它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置.所以,无论何时汇编器遇到对最终位置未知的目标引用,它就会生成一个重定位表目,告诉链接器在将目标文件合并为可执行文件时,如何修改这个引用.代码的重定位表目放在.rel.text中.已初始化数据的重定位表目放在rel.data中.<br />
&nbsp; ELF重定位表目的格式如下:<br />
&nbsp; typedef struct{<br />
&nbsp;&nbsp;&nbsp; int offset;&nbsp; //offset of the reference to relocate<br />
&nbsp;&nbsp;&nbsp; int symbol:24,&nbsp; //symbol the reference point to<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type:8;&nbsp; //relocation type<br />
&nbsp; } Elf32_Rel;</p>
<p>&nbsp; ELF定义了11中不同的重定位类型,其中最基本的两种重定位类型是:R_386_PC32(重定位一个使用32PC相关的地址引用)和R_386_32(重定位一个使用32位绝对地址的引用).</p>
<p><strong>动态链接器<br />
</strong>&nbsp; 共享库是一个目标模块,在运行时,可以加载到任意的存储器地址,并在存储器中和一个程序链接起来.这个过程称为动态链接,是由动态链接器完成的.<br />
&nbsp; 共享库的共享在两个方面有所不同.首先,在任何给定的文件系统中,对于一个库只有一个.so文件.所有引用该库德可执行目标文件共享这个.so文件中的代码和数据,而不是像静态库德内容那样被拷贝和嵌入到引用它们的可执行的文件中.其次,在存储器中,一个共享库的.text节只有一个副本可以被不同的正在运行的进程共享.</p>
<p><strong>&nbsp; 多目标文件的链接<br />
</strong>stack.c</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
#include &lt;stdio.h&gt; 
   
  #define STACKSIZE 1000 
   
  typedef struct stack { 
    int data[STACKSIZE]; 
    int top; 
  } stack; 
   
  stack s; 
  int count = 0; 
   
  void pushStack(int d) 
  { 
    s.data[s.top ++] = d; 
    count ++; 
  } 
   
  int popStack() 
  { 
    return s.data[-- s.top]; 
  } 
   
  int isEmpty() 
  { 
    return s.top == 0; 
  } 
</pre>
</div>
<p><br />
link.c</p>
<p>&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
  #include &lt;stdio.h&gt; 
   
  int a, b; 
   
  int main() 
  { 
    a = b = 1; 
   
    pushStack(a); 
    pushStack(b); 
    pushStack(a); 
   
    while (！ isEmpty()) { 
      printf("%d\n", popStack()); 
    } 
     
    return 0; 
  } 
</pre>
</div>
<p><br />
编译方式：</p>
<div class="phpstudycode">
<pre class="brush:bash;">
gcc -Wall stack.c link.c -o main

</pre>
</div>
<p>提示出错信息如下：<br />
</p>
<p></p>
<p>但是代码是可以执行的</p>
<p><strong>定义和声明</strong></p>
<p>static和extern修饰函数<br />
上述编译出现错误的原因是：编译器在处理函数调用代码时没有找到函数原型，只好根据函数调用代码做隐式声明，把这三个函数声明为：</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
  int pushStack(int); 
  int popStack(void); 
  int isEmpty(void); 

</pre>
</div>
<p><br />
编译器往往不知道去哪里找函数定义，像上面的例子，我让编译器编译main.c，而这几个函数定义却在stack.c里，编译器无法知道，因此可以用extern声明。修改link.c如下：</p>
<p>&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
  #include &lt;stdio.h&gt; 
   
  int a, b; 
   
  extern void pushStack(int d); 
  extern int popStack(void); 
  extern int isEmpty(void); 
   
  int main() 
  { 
    a = b = 1; 
   
    pushStack(a); 
    pushStack(b); 
    pushStack(a); 
   
    while (! isEmpty()) { 
      printf("%d\n", popStack()); 
    } 
     
    return 0; 
  } 
</pre>
</div>
<p><br />
这样编译器就不会报警了。这里extern关键字表示这个标识符具有External Linkage.pushStack这个标识符具有External Linkage指的是：如果link.c和stack.c链接在一起，如果pushStack在link.c和stack.c中都声明(在stack.c中的声明同时也是定义)，那么这些声明指的是同一个函数，链接后是同一个GLOBAL符号，代表同一个地址。函数声明中的extern可以省略不写，不屑extern的函数声明也表示这个函数具有External Linkage。</p>
<p>如果用static关键字修饰一个函数声明，则表示该标识符具有Internal Linkage,例如有以下两个程序文件：</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
  /* foo.c */ 
   
  static void foo(void) {} 


  /*main.c*/ 
   
  void foo(void); 
   
  int main(void) { foo(); return 0;} 

</pre>
</div>
<p><br />
编译链接在一起会出错，原因是：</p>
<p>虽然在foo.c中定义了函数foo，但是这个函数是static属性，只具有internal Linkage。如果把foo.c编译成目标文件，函数名foo在其中是一个LOCAL的符号，不参与链接过程，所以在链接时，main.c中用到一个External Linkage的foo函数，链接器却找不到它的定义在哪，无法确定它的地址，也就无法做符号解析，只好报错。</p>
<p>凡是被多次声明的变量或函数，必须有且只有一个声明是定义，如果有多个定义，或者一个定义都没有，链接器就无法完成链接</p>
<p><strong><br />
static和extern修饰变量<br />
</strong>如果我想在link.c中访问stack.c中定义的int变量count，则可以用extern声明</p>
<p>&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
 #include &lt;stdio.h&gt; 
   
  int a, b; 
   
  extern void pushStack(int d); 
  extern int popStack(void); 
  extern int isEmpty(void); 
  extern int count; 
   
  int main() 
  { 
    a = b = 1; 
   
    pushStack(a); 
    pushStack(b); 
    pushStack(a); 
   
    printf("%d\n", count); 
   
    while (! isEmpty()) { 
      printf("%d\n", popStack()); 
    } 
     
    return 0; 
  } 
</pre>
</div>
<p><br />
变量count具有external linkage，它的存储空间是在stack.c中分配的，所以link.c中的变量声明extern int count;不是变量定义，因为它不分配存储空间。</p>
<p>如果不想在stack.c外让外界访问到count，则可以用static关键字将count声明为Internal Linkage<br />
区别<br />
变量生命和函数声明有一点不同，函数声明的extern可写可不写，而变量声明如果不写extern，意思就完全变了。如果上面的例子不写extern就表示在main函数中定义一个全局变量count。</p>
<p>用static关键字声明具有Internal Linkage的函数和关键字是处于保护内部状态的目的，也是一种封装(Encapsulation)的思想。一个模块中，有些函数是提供给外界使用的，也称为导出(Export)给外界使用，这些函数用extern声明为External Linkage的。</p>
<p><br />
<strong>头文件<br />
</strong>为了防止每次函数extern声明，例如又有一个foo.c也使用pushStack等函数，又需要在foo.c中写多个extern声明，为了避免这种重复麻烦的操作，可以自己定义一个stack.h头文件：</p>
<p>&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
 #ifndef STACK_H 
  #define STACK_H 
   
  #define STACKSIZE 1000 
   
  typedef struct stack { 
    int data[STACKSIZE]; 
    int top; 
  } stack; 
   
  extern void pushStack(int d); 
  extern int popStack(void); 
  extern int isEmpty(void); 
   
  #endif 
</pre>
</div>
<p><br />
这样，在link.c里就只需要包含这个头文件就可以了，而不需要写三个函数声明了：</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<div class="phpstudycode">
<pre class="brush:cpp;">
 #include &lt;stdio.h&gt; 
  #include "stack.h" 
   
  int a, b; 
   
  extern int count; 
   
  int main() 
  { 
    a = b = 1; 
   
    pushStack(a); 
    pushStack(b); 
    pushStack(a); 
   
    printf("%d\n", count); 
   
    while (! isEmpty()) { 
      printf("%d\n", popStack()); 
    } 
     
    return 0; 
  } 
</pre>
</div>
<p><br />
为什么#include &lt;stdio.h&gt;用角括号，而#include "stack.h"用引号？原因：</p>
<ul>
<li>&nbsp;&nbsp;&nbsp; 对于用角括号包含的头文件，gcc首先查找-I选项指定的目录，然后查找系统的头文件目录(通常是/usr/include)</li>
<li>&nbsp;&nbsp;&nbsp; 对于用“”包含的头文件，gcc首先查找包含头文件的.c文件所在的目录，然后查找-I选项指定的目录，然后查找系统的头文件目录</li>
</ul>
<p><br />
用#ifndef #define #endif是为了防止头文件的重复包含，头文件重复包含的问题如下：</p>
<ul>
<li>&nbsp;&nbsp;&nbsp; 使预处理的速度变慢了，要处理很多本来不需要处理的头文件</li>
<li>&nbsp;&nbsp;&nbsp; 如果a.h包含了b.h,然后b.h又包含了a.h的情况，预处理就陷入死循环了</li>
<li>&nbsp;&nbsp;&nbsp; 头文件按有些代码不允许重复出现</li>
</ul>
<p><br />
头文件中的变量和函数声明一定不能是定义。如果头文件中出现变量或函数定义，这个头文件又被多个.c文件包含，那么这些.c文件就不能链接在一起</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span></span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/php/biji/87335.html'>理解java中的深复制和浅复制</a><a>下一篇</a><a href='/php/biji/87337.html'>jQuery改变form表单的action,并进行提交的实现代码</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>