<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Django Rest_Framework的使用_IDC笔记</title>
    <meta name="keywords" content=",Python教程"/>
    <meta name="description" content="Django Rest_Framework
一、Rest_Framework的基本介绍
程序的客户端有很多：硬件设备，游戏，APP，软件，其他的外部服务端。
1. Web应用模式
在开发Web应用中，有两种应用模式：


前后端"/>
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author"/>
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/python/1.html">Python环境搭建</a></li><li><a href="/python/python/2.html">Python解释器及IDLE教程</a></li><li><a href="/python/python/3.html">Pycharm安装及使用教程</a></li><li><a href="/python/python/4.html">学习方向及教程规划</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python基础语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/basic/5.html">第一个Python实例</a></li><li><a href="/python/basic/6.html">Python编码规范</a></li><li><a href="/python/basic/7.html">Python标识符和关键字</a></li><li><a href="/python/basic/9.html">Python基本数据类型介绍</a></li><li><a href="/python/basic/8.html">Python变量</a></li><li><a href="/python/basic/10.html">基本数据类型之字符串</a></li><li><a href="/python/basic/11.html">布尔类型和强制类型转换</a></li><li><a href="/python/basic/12.html">Python的输入和输出方法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python入门语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/syntax/13.html">python算术运算符和关系运算符</a></li><li><a href="/python/syntax/14.html">python算术运算符和关系运算符</a></li><li><a href="/python/syntax/15.html">python位运算符</a></li><li><a href="/python/syntax/16.html">Python控制结构详解</a></li><li><a href="/python/syntax/17.html">python基础ifelse选择结构详解</a></li><li><a href="/python/syntax/18.html">python选择结构的嵌套</a></li><li><a href="/python/syntax/20.html">Python基础for循环语句详解</a></li><li><a href="/python/syntax/19.html">Pyhon基础while循环语句详解</a></li><li><a href="/python/syntax/21.html">python循环嵌套</a></li><li><a href="/python/syntax/24.html">Python序列的加法和乘法操作详解</a></li><li><a href="/python/syntax/23.html">Python序列详解（包括索引和切片）</a></li><li><a href="/python/syntax/22.html">python基础break语句详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python核心语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/core/25.html">Python序列常用的内置函数详解</a></li><li><a href="/python/core/26.html">Python列表list的基础操作与代码实现</a></li><li><a href="/python/core/27.html">Python列表list操作(遍历查找增加删除修改)实例详解</a></li><li><a href="/python/core/28.html">列表的排序和逆序</a></li><li><a href="/python/core/29.html">列表推导式</a></li><li><a href="/python/core/30.html">python二维列表</a></li><li><a href="/python/core/31.html">python元组的操作详解</a></li><li><a href="/python/core/32.html">python字典及基础操作</a></li><li><a href="/python/core/33.html">python字典常用函数（clear、get、items、keys、values、pop）</a></li><li><a href="/python/core/34.html">字典-混合字典和字典推导式</a></li><li><a href="/python/core/35.html">python集合类型介绍</a></li><li><a href="/python/core/36.html">集合的运算（交集、并集和差集）</a></li><li><a href="/python/core/37.html">Python字符串基础操作</a></li><li><a href="/python/core/38.html">Python字符串常用方法</a></li><li><a href="/python/core/39.html">字符串的测试方法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/functions/42.html">python函数的创建和调用</a></li><li><a href="/python/functions/43.html">python函数的参数传递</a></li><li><a href="/python/functions/44.html">python函数的返回值</a></li><li><a href="/python/functions/46.html">python匿名函数</a></li><li><a href="/python/functions/47.html">python三大基础函数</a></li><li><a href="/python/functions/48.html">python递归函数</a></li><li><a href="/python/functions/49.html">python内置函数</a></li><li><a href="/python/functions/45.html">python变量的作用域</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 面向对象编程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/programming/50.html">python面向对象编程</a></li><li><a href="/python/programming/51.html">python类的定义和构造方法及参数传递</a></li><li><a href="/python/programming/52.html">python类方法</a></li><li><a href="/python/programming/53.html">python继承实例讲解</a></li><li><a href="/python/programming/54.html">模块概述</a></li><li><a href="/python/programming/55.html">Python创建和引入模块实例详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python模块			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/modular/56.html">Python引入math模块及库函数大全</a></li><li><a href="/python/modular/57.html">random模块</a></li><li><a href="/python/modular/58.html">datetime模块</a></li><li><a href="/python/modular/59.html">Python如何安装第三方模块？</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 异常处理和程序调试			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/exception/60.html">异常问题和常见异常</a></li><li><a href="/python/exception/61.html">Python异常处理语句try,except实例详解</a></li><li><a href="/python/exception/62.html">Python异常处理语句实例详解二</a></li><li><a href="/python/exception/63.html">Python程序调试图文教程</a></li><li><a href="/python/exception/64.html">使用assert断言对Ptyhon程序调试分析</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 文件及目录操作			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/file/65.html">python文件操作</a></li><li><a href="/python/file/66.html">python读取文件</a></li><li><a href="/python/file/67.html">python中os模块和os.path模块</a></li><li><a href="/python/file/68.html">目录管理</a></li><li><a href="/python/file/69.html">Python项目管理操作</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> GUI编程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/program/70.html">GUI编程</a></li><li><a href="/python/program/71.html">Tkinter模块(1)-简介和Label</a></li><li><a href="/python/program/72.html">Tkinter模块(2)-Frame和Button</a></li><li><a href="/python/program/73.html">Tkinter模块(3)-Entry</a></li><li><a href="/python/program/74.html">Tkinter模块(4)-Radio和Check</a></li><li><a href="/python/program/75.html">Tkinter模块(5)-Canvas</a></li><li><a href="/python/program/76.html">Tkinter模块(6)-练习</a></li><li><a href="/python/program/77.html">wxPython模块(1)-简介和初始化</a></li><li><a href="/python/program/78.html">wxPython模块(2)-文本控件</a></li><li><a href="/python/program/79.html">wxPython模块(3)-按钮和复选框</a></li><li><a href="/python/program/80.html">wxPython(4)-布局</a></li><li><a href="/python/program/81.html">wxPython(5)-事件管理</a></li><li><a href="/python/program/82.html">wxPython(6)-下拉列表和菜单</a></li><li><a href="/python/program/83.html">综合案例</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 进程和线程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/processes/84.html">Python进程和线程的区别</a></li><li><a href="/python/processes/85.html">Python如何创建线程</a></li><li><a href="/python/processes/87.html">Python临界区与线程安全（线程通信）</a></li><li><a href="/python/processes/86.html">Python线程管理</a></li><li><a href="/python/processes/89.html">Python进程间通信代码详解</a></li><li><a href="/python/processes/88.html">Python创建进程的方式详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 数据库管理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/database/91.html">MySQL下载安装图文教程</a></li><li><a href="/python/database/90.html">数据库概述</a></li><li><a href="/python/database/92.html">Navicat for MySQL管理软件安装使用图文教程</a></li><li><a href="/python/database/93.html">对象和游标</a></li><li><a href="/python/database/95.html">SQlite数据库(2)</a></li><li><a href="/python/database/94.html">SQlite数据库(1)</a></li><li><a href="/python/database/96.html">PyMySQL数据库的使用</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python算法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/algorithm/97.html">python枚举算法</a></li><li><a href="/python/algorithm/98.html">python递归算法</a></li><li><a href="/python/algorithm/99.html">python分治算法</a></li><li><a href="/python/algorithm/101.html">python试探算法</a></li><li><a href="/python/algorithm/100.html">python贪心算法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 爬虫			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/reptile/102.html">python爬虫概述</a></li><li><a href="/python/reptile/103.html">python爬虫协议</a></li><li><a href="/python/reptile/104.html">python爬虫技术基础(1)-网络请求</a></li><li><a href="/python/reptile/106.html">python正则表达式(1)</a></li><li><a href="/python/reptile/105.html">python爬虫技术基础(2)header是处理及网络超时</a></li><li><a href="/python/reptile/108.html">BeautifulSoup(1)</a></li><li><a href="/python/reptile/107.html">python正则表达式(2)</a></li><li><a href="/python/reptile/109.html">BeautifulSoup(2)</a></li><li><a href="/python/reptile/110.html">Python爬虫入门抓取天气信息</a></li>		</ul>
	</li>
		<li>
	    <a href="/python/biji" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>Python笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Django Rest_Framework的使用</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>Django Rest_Framework
一、Rest_Framework的基本介绍
程序的客户端有很多：硬件设备，游戏，APP，软件，其他的外部服务端。
1. Web应用模式
在开发Web应用中，有两种应用模式：


前后端</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><h1 id="django-rest_framework">Django Rest_Framework</h1>
<h2 id="一、rest_framework的基本介绍">一、Rest_Framework的基本介绍</h2>
<p>程序的客户端有很多：硬件设备，游戏，APP，软件，其他的外部服务端。</p>
<h3 id="1-web应用模式">1. Web应用模式</h3>
<p>在开发Web应用中，有两种应用模式：</p>
<ol>
<li>
<p>前后端不分离[客户端看到的内容和所有界面效果都是由服务端提供出来的。]</p>
<p>这种情况下，前端页面中会出现很多涉及到服务端的模板语法。</p>
</li>
</ol>
<p><img alt="前后端不分离" loading="lazy"></p>
<ol start="2">
<li>
<p>前后端分离【把前端的界面效果(html，css，js分离到另一个项目中，python服务端只需要返回数据即可)】</p>
<p>前端形成一个独立的网站，服务端构成一个独立的网站</p>
</li>
</ol>
<p><img alt="前后端分离" loading="lazy"></p>
<p>django，一般都是做web网站，如果可以利用django实现前后端分离，则django就可以完成地铁站的运营调度系统，路由的终端系统，pos机的服务端系统，游戏的服务端后台，软件的服务端后台。</p>
<h3 id="2-api接口">2. api接口</h3>
<p>为了在团队内部形成共识、防止个人习惯差异引起的混乱，我们需要找到一种大家都觉得很好的接口实现规范，而且这种规范能够让后端写的接口，用途一目了然，减少双方之间的合作成本。</p>
<p>目前市面上大部分公司开发人员使用的接口服务架构主要有：restful、rpc，soap。</p>
<p>rpc: 翻译成中文:远程过程调用[远程服务调用].</p>
<p>服务端提供单一的请求数据的api地址：http://api.renran.cn/</p>
<p>post请求</p>
<p>，enthod=get_all_student&amp;class=301&amp;sex=1</p>
<p>优势：</p>
<ol>
<li>不需要管当前操作是什么http请求，也不需要操作url地址的编写，对接简单</li>
</ol>
<p>缺点：</p>
<ol>
<li>接口多了,对应函数名和参数就多了,前端在请求api接口时,就会比较难找.容易出现重复的接口</li>
</ol>
<p>restful: 翻译成中文: 资源状态转换.</p>
<p>把后端所有的数据/文件都看成资源.</p>
<p>那么接口请求数据,本质上来说就是对资源的操作了.</p>
<p>web项目中操作资源,无非就是增删查改.所以要求在地址栏中声明要操作的资源是什么,然后通过http请求动词来说明对资源进行哪一种操作.</p>
<p>POST http://www.renran.cn/api/students/   添加学生数据</p>
<p>GET    http://www.renran.cn/api/students/   获取所有学生</p>
<p>DELETE http://www.renran.cn/api/students/<pk>/   删除id=pk的一个学生</pk></p>
<p>PUT   http://www.renran.cn/api/students/<pk>/       修改一个学生的全部信息 [id,name,sex,age,]</pk></p>
<p>PATCH  http://www.renran.cn/api/students/<pk>/    修改一个学生的部分信息[age]</pk></p>
<p>优点：</p>
<pre><code>1. 维护开发简单，可以保证后期的开发不会出现太多重复接口
</code></pre>
<p>缺点：</p>
<ol>
<li>有部分接口不会有明确的增删查改这种区分的，所以会出现一些不伦不类的接口。会因为这些语义不明，不伦不类的接口导致后期的维护成本上升。</li>
<li>因为restful把对于资源的操作都理解成了增删查改，建议使用http，所以restful接口天生局限于web开发。</li>
</ol>
<h3 id="3-restful-api规范">3. RESTful API规范</h3>
<p><img alt="restful" loading="lazy"></p>
<p>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中。</p>
<p>RESTful是一种定义Web API接口的设计风格，尤其适用于前后端分离的应用模式中。</p>
<p>这种风格的理念认为后端开发任务就是提供数据的，对外提供的是数据资源的访问接口，所以在定义接口时，客户端访问的URL路径就表示这种要操作的数据资源。</p>
<p>而对于数据资源分别使用POST、DELETE、GET、UPDATE等请求动作来表达对数据的增删查改。</p>
<table>
<thead><tr>
<th>请求方法</th>
<th>请求地址</th>
<th>后端操作</th>
</tr></thead>
<tbody>
<tr>
<td>GET</td>
<td>/students</td>
<td>获取所有学生</td>
</tr>
<tr>
<td>POST</td>
<td>/students</td>
<td>增加学生</td>
</tr>
<tr>
<td>GET</td>
<td>/students/<pk></pk>
</td>
<td>获取主键为pk的学生</td>
</tr>
<tr>
<td>PUT/PATCH</td>
<td>/students/<pk></pk>
</td>
<td>修改主键为pk的学生</td>
</tr>
<tr>
<td>DELETE</td>
<td>/students/<pk></pk>
</td>
<td>删除主键为pk的学生</td>
</tr>
</tbody>
</table>
<p>事实上，我们可以使用任何一个框架都可以实现符合restful规范的API接口。</p>
<p>参考文档：http://www.runoob.com/w3cnote/restful-architecture.html</p>
<p>接口实施过程中，会存在幂等性。所谓幂等性是指代客户端发起多次请求是否对于服务端里面的资源产生不同结果。如果多次请求，服务端结果还是一样，则属于幂等接口，如果多次请求，服务端产生结果是不一样的，则属于非幂等接口。在http请求，get/put/patch/delete都属于幂等性接口，post属于非幂等接口。</p>
<p>为什么要考虑幂等性？主要就是接口操作的安全性问题。</p>
<p>delete /api/students/1</p>
<p>get /api/students/</p>
<p>post  /api/students/</p>
<h3 id="4-序列化">4. 序列化</h3>
<p>api接口开发，最核心最常见的一个过程就是序列化，所谓序列化就是把<strong>数据转换格式</strong>，序列化可以分两个阶段：</p>
<p><strong>序列化</strong>： 把我们识别的数据转换成指定的格式提供给别人。</p>
<p>例如：我们在django中获取到的数据默认是模型对象，但是模型对象数据无法直接提供给前端或别的平台使用，所以我们需要把数据进行序列化，变成字符串或者json数据，提供给前端或者其他平台。</p>
<p><strong>反序列化</strong>：把别人提供的数据转换/还原成我们需要的格式。</p>
<p>例如：前端js提供过来的json数据，对于python而言就是字符串，我们需要进行反序列化换成模型类对象，这样我们才能把数据保存到数据库中。</p>
<h3 id="5-django-rest_framework">5. Django Rest_Framework</h3>
<p>核心思想: 缩减编写api接口的代码</p>
<p>Django REST framework是一个建立在Django基础之上的Web 应用开发框架,本质上就是一个内置在django里面的子应用，可以快速的开发REST API接口应用。</p>
<p>在REST framework中，提供了序列化器对象Serialzier的定义，可以帮助我们简化序列化与反序列化的过程，不仅如此，还提供丰富的类视图、扩展类、视图集来简化视图的编写工作。REST framework还提供了认证、权限、限流、过滤、分页、接口文档等功能支持。REST framework提供了一个用于测试API接口 的可视化Web界面【可以浏览器直接访问接口，drf的api接口测试页面非常美观】。</p>
<p><img alt="drf_logo" loading="lazy"></p>
<p>中文文档：/d/file/p/20221107/
<p>github: https://github.com/encode/django-rest-framework/tree/master</p>
<h4 id="特点">特点</h4>
<ul>
<li>提供了定义序列化器Serializer的方法，可以快速根据 Django ORM 或者其它库自动序列化/反序列化；</li>
<li>提供了丰富的类视图、Mixin扩展类，简化视图的编写；</li>
<li>丰富的定制层级：函数视图、类视图、视图集合到自动生成 API，满足各种需要；</li>
<li>多种身份认证和权限认证方式的支持；[jwt   Json web token]</li>
<li>内置了限流系统；</li>
<li>直观的 API web 界面；【方便我们调试开发api接口】</li>
<li>可扩展性，插件丰富</li>
</ul>
<h3 id="6-环境安装与配置">6. 环境安装与配置</h3>
<p>DRF需要以下依赖：</p>
<ul>
<li>Python (2.7, 3.2以上)</li>
<li>Django (1.10, 1.11, 2.0以上)</li>
</ul>
<p><strong>DRF是以Django扩展应用的方式提供的，所以我们可以直接利用已有的Django环境而无需从新创建。（若没有Django环境，需要先创建环境安装Django）</strong></p>
<h4 id="61-安装drf">6.1 安装DRF</h4>
<p>前提是已经安装了django，建议安装在虚拟环境</p>
<p>windows的复制粘贴在linux终端是无效的，在ubuntu终端下粘贴的快捷键是 shift+insert</p>
<pre><code class="language-python"># mkvirtualenv drfdemo -p python3
# pip install django==2.2.0  -i /d/file/p/20221107/simple

pip install djangorestframework -i /d/file/p/20221107/simple

# 因为我们需要接下来，需要开发api接口肯定要操作数据，所以安装pymysql
pip install pymysql -i /d/file/p/20221107/simple
</code></pre>
<p>linux的终端下 粘贴内容 快捷键： shift+insert</p>
<h5 id="611-创建django项目">6.1.1 创建django项目</h5>
<pre><code>cd ~/Desktop
django-admin startproject drfdemo
</code></pre>
<p><img alt="1557022536078" loading="lazy"></p>
<p>使用pycharm打开项目，设置虚拟环境的解析器，并修改manage.py中的后缀参数。</p>
<p><img alt="1592883758431" loading="lazy"></p>
<h4 id="62-添加rest_framework应用">6.2 添加rest_framework应用</h4>
<p>在<strong>settings.py</strong>的<strong>INSTALLED_APPS</strong>中添加"rest_framework"。</p>
<pre><code class="language-python">INSTALLED_APPS = [
    ...
    "rest_framework",
]
</code></pre>
<p>接下来就可以使用DRF提供的功能进行api接口开发了。在项目中如果使用rest_framework框架实现API接口，主要有以下三个步骤：</p>
<ul>
<li>将请求的数据（如JSON格式）转换为模型类对象</li>
<li>通过模型类对象进行数据库操作，完成客户端请求的增删查改</li>
<li>将模型类对象转换为响应的数据（如JSON格式）</li>
</ul>
<p>接下来，我们快速体验下四天后我们学习完成drf以后的开发代码。接下来代码不需要理解，看步骤。</p>
<h4 id="63-体验drf完全简写代码的过程">6.3 体验drf完全简写代码的过程</h4>
<h5 id="630-创建子应用">6.3.0 创建子应用</h5>
<pre><code class="language-pythpn"># 项目根目录下创建子应用，用于展示当前例子。

python manage.py startapp students
</code></pre>
<h5 id="631-创建模型操作类">6.3.1. 创建模型操作类</h5>
<p>子应用的models.py文件中创建模型对象。</p>
<pre><code class="language-python">from django.db import models

# Create your models here.
class Student(models.Model):
    # 表字段声明
    # 字段名=models.数据类型(字段约束)
    name = models.CharField(null=False, max_length=32, verbose_name="姓名")
    sex  = models.BooleanField(default=True, verbose_name="性别")
    age  = models.IntegerField(verbose_name="年龄")
    class_num = models.CharField(max_length=5, verbose_name="班级编号")
    description = models.TextField(max_length=1000, verbose_name="个性签名")

    # 表信息
    class Meta:
        # 设置表名
        db_table="tb_students"
        verbose_name="学生"
        verbose_name_plural=verbose_name

    # 模型的操作方法
    def __str__(self):
        return self.name
</code></pre>
<p>为了方便测试，所以我们可以先创建一个数据库。</p>
<pre><code>create database students charset=utf8;
</code></pre>
<p><img alt="1557023744365" loading="lazy"></p>
<h5 id="6311-执行数据迁移">6.3.1.1 执行数据迁移</h5>
<p>把students子应用添加到INSTALL_APPS中</p>
<p><img alt="1557023819604" loading="lazy"></p>
<p>初始化数据库连接</p>
<pre><code>安装pymysql
pip install pymysql
</code></pre>
<p>主引用中<code>__init__.py</code>设置使用pymysql作为数据库驱动</p>
<pre><code class="language-python">import pymysql

pymysql.install_as_MySQLdb()
</code></pre>
<p>settings.py配置文件中设置mysql的账号密码</p>
<pre><code class="language-python">DATABASES = {
    # "default": {
    #     "ENGINE": "django.db.backends.sqlite3",
    #     "NAME": os.path.join(BASE_DIR, "db.sqlite3"),
    # },
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "NAME": "students",
        "HOST": "127.0.0.1",
        "PORT": 3306,
        "USER": "root",
        "PASSWORD":"123",
    },
}
</code></pre>
<p>终端下，执行数据迁移。</p>
<pre><code>python manage.py makemigrations
python manage.py migrate
</code></pre>
<p>错误列表</p>
<pre><code class="language-python"># 执行数据迁移 python manage.py makemigrations 报错如下：
</code></pre>
<p><img alt="1557024349366" loading="lazy"></p>
<p>解决方案：</p>
<pre><code class="language-python">注释掉 backends/mysql/base.py中的35和36行代码。
</code></pre>
<p><img alt="1557025991751" loading="lazy"></p>
<pre><code class="language-python"># 执行数据迁移发生以下错误：
</code></pre>
<p><img alt="1557026113769" loading="lazy"></p>
<p>解决方法：</p>
<p>backends/mysql/operations.py146行里面把decode换成encode：</p>
<p><img alt="1592885187223" loading="lazy"></p>
<h5 id="632-创建序列化器">6.3.2. 创建序列化器</h5>
<p>在students应用目录中新建serializers.py用于保存该应用的序列化器。</p>
<p>创建一个StudentModelSerializer用于序列化与反序列化。</p>
<pre><code class="language-python"># 创建序列化器类，回头会在试图中被调用
from rest_framework import serializers
from .models import Student
class StudentModelSerializer(serializers.ModelSerializer):
    class Meta:
        model = Student
        fields = "__all__"
</code></pre>
<ul>
<li>
<strong>model</strong> 指明该序列化器处理的数据字段从模型类BookInfo参考生成</li>
<li>
<strong>fields</strong> 指明该序列化器包含模型类中的哪些字段，"<strong>all</strong>"指明包含所有字段</li>
</ul>
<h5 id="633-编写视图">6.3.3. 编写视图</h5>
<p>在students应用的views.py中创建视图StudentViewSet，这是一个视图集合。</p>
<pre><code class="language-python">from rest_framework.viewsets import ModelViewSet
from .models import Student
from .serializers import StudentModelSerializer
# Create your views here.
class StudentViewSet(ModelViewSet):
    queryset = Student.objects.all()
    serializer_class = StudentModelSerializer
</code></pre>
<ul>
<li>
<strong>queryset</strong> 指明该视图集在查询数据时使用的查询集</li>
<li>
<strong>serializer_class</strong> 指明该视图在进行序列化或反序列化时使用的序列化器</li>
</ul>
<h5 id="634-定义路由">6.3.4. 定义路由</h5>
<p>在students应用的urls.py中定义路由信息。</p>
<pre><code class="language-python">from . import views
from rest_framework.routers import DefaultRouter

# 路由列表
urlpatterns = []

router = DefaultRouter()  # 可以处理视图的路由器
router.register("students", views.StudentViewSet)  # 向路由器中注册视图集

urlpatterns += router.urls  # 将路由器中的所以路由信息追加到django的路由列表中
</code></pre>
<p>最后把students子应用中的路由文件加载到总路由文件中.</p>
<pre><code class="language-python">from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("student/",include("students.urls")),
]

</code></pre>
<h5 id="635-运行测试">6.3.5. 运行测试</h5>
<p>运行当前程序（与运行Django一样）</p>
<pre><code class="language-shell">python manage.py runserver
</code></pre>
<p>在浏览器中输入网址127.0.0.1:8000，可以看到DRF提供的API Web浏览页面：</p>
<p><img alt="1557027948031" loading="lazy"></p>
<p>1）点击链接127.0.0.1:8000/stu/students 可以访问<strong>获取所有数据的接口</strong>，呈现如下页面：</p>
<p><img alt="1557027878963" loading="lazy"></p>
<p>2）在页面底下表单部分填写学生信息，可以访问<strong>添加新学生的接口</strong>，保存学生信息：</p>
<p><img alt="1557027999506" loading="lazy"></p>
<p>点击POST后，返回如下页面信息：</p>
<p><img alt="1557028072470" loading="lazy"></p>
<p>3）在浏览器中输入网址127.0.0.1:8000/stu/students/5/，可以访问<strong>获取单一学生信息的接口</strong>（id为5的学生），呈现如下页面：</p>
<p><img alt="1557028115925" loading="lazy"></p>
<p>4）在页面底部表单中填写学生信息，可以访问<strong>修改学生的接口</strong>：</p>
<p><img alt="1557028168350" loading="lazy"></p>
<p>点击PUT，返回如下页面信息：</p>
<p><img alt="1557028208243" loading="lazy"></p>
<p>5）点击DELETE按钮，可以访问<strong>删除学生的接口</strong>：</p>
<p><img alt="1557028242637" loading="lazy"></p>
<p>返回，如下页面：</p>
<p><img alt="1557028266190" loading="lazy"></p>
<h3 id="7-序列化器-serializer">7. 序列化器-Serializer</h3>
<p>作用：</p>
<pre><code>1. 序列化,序列化器会把模型对象转换成字典,经过response以后变成json字符串
2. 反序列化,把客户端发送过来的数据,经过request以后变成字典,序列化器可以把字典转成模型
3. 反序列化,完成数据校验功能
</code></pre>
<h4 id="71-定义序列化器">7.1 定义序列化器</h4>
<p>Django REST framework中的Serializer使用类来定义，须继承自rest_framework.serializers.Serializer。</p>
<p>接下来，为了方便演示序列化器的使用，我们先创建一个新的子应用sers</p>
<pre><code>python manage.py startapp sers
</code></pre>
<p>我们已有了一个数据库模型类students/Student</p>
<pre><code class="language-python">from django.db import models

# Create your models here.
class Student(models.Model):
    # 模型字段
    name = models.CharField(max_length=100,verbose_name="姓名",help_text="提示文本:账号不能为空！")
    sex = models.BooleanField(default=True,verbose_name="性别")
    age = models.IntegerField(verbose_name="年龄")
    class_null = models.CharField(max_length=5,verbose_name="班级编号")
    description = models.TextField(verbose_name="个性签名")

    class Meta:
        db_table="tb_student"
        verbose_name = "学生"
        verbose_name_plural = verbose_name
</code></pre>
<p>我们想为这个模型类提供一个序列化器，可以定义如下：</p>
<pre><code class="language-python">from rest_framework import serializers

# 声明序列化器，所有的序列化器都要直接或者间接继承于 Serializer
# 其中，ModelSerializer是Serializer的子类，ModelSerializer在Serializer的基础上进行了代码简化
class StudentSerializer(serializers.Serializer):
    """学生信息序列化器"""
    # 1. 需要进行数据转换的字段
    id = serializers.IntegerField()
    name = serializers.CharField()
    age = serializers.IntegerField()
    sex = serializers.BooleanField()
    description = serializers.CharField()

    # 2. 如果序列化器集成的是ModelSerializer，则需要声明调用的模型信息

    # 3. 验证代码

    # 4. 编写添加和更新模型的代码
</code></pre>
<p><strong>注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。</strong>serializer是独立于数据库之外的存在。</p>
<p><strong>常用字段类型</strong>：</p>
<table>
<thead><tr>
<th>字段</th>
<th>字段构造方式</th>
</tr></thead>
<tbody>
<tr>
<td><strong>BooleanField</strong></td>
<td>BooleanField()</td>
</tr>
<tr>
<td><strong>NullBooleanField</strong></td>
<td>NullBooleanField()</td>
</tr>
<tr>
<td><strong>CharField</strong></td>
<td>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</td>
</tr>
<tr>
<td><strong>EmailField</strong></td>
<td>EmailField(max_length=None, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td><strong>RegexField</strong></td>
<td>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td><strong>SlugField</strong></td>
<td>SlugField(max<em>length=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9</em>-]+</td>
</tr>
<tr>
<td><strong>URLField</strong></td>
<td>URLField(max_length=200, min_length=None, allow_blank=False)</td>
</tr>
<tr>
<td><strong>UUIDField</strong></td>
<td>UUIDField(format="hex_verbose")  format:  1) <code>"hex_verbose"</code> 如<code>"5ce0e9a5-5ffa-654b-cee0-1238041fb31a"</code>  2） <code>"hex"</code> 如 <code>"5ce0e9a55ffa654bcee01238041fb31a"</code>  3）<code>"int"</code> - 如: <code>"123456789012312313134124512351145145114"</code>  4）<code>"urn"</code> 如: <code>"urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a"</code>
</td>
</tr>
<tr>
<td><strong>IPAddressField</strong></td>
<td>IPAddressField(protocol="both", unpack_ipv4=False, **options)</td>
</tr>
<tr>
<td><strong>IntegerField</strong></td>
<td>IntegerField(max_value=None, min_value=None)</td>
</tr>
<tr>
<td><strong>FloatField</strong></td>
<td>FloatField(max_value=None, min_value=None)</td>
</tr>
<tr>
<td><strong>DecimalField</strong></td>
<td>DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) max_digits: 最多位数 decimal_palces: 小数点位置</td>
</tr>
<tr>
<td><strong>DateTimeField</strong></td>
<td>DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td><strong>DateField</strong></td>
<td>DateField(format=api_settings.DATE_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td><strong>TimeField</strong></td>
<td>TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</td>
</tr>
<tr>
<td><strong>DurationField</strong></td>
<td>DurationField()</td>
</tr>
<tr>
<td><strong>ChoiceField</strong></td>
<td>ChoiceField(choices) choices与Django的用法相同</td>
</tr>
<tr>
<td><strong>MultipleChoiceField</strong></td>
<td>MultipleChoiceField(choices)</td>
</tr>
<tr>
<td><strong>FileField</strong></td>
<td>FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td><strong>ImageField</strong></td>
<td>ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
</tr>
<tr>
<td><strong>ListField</strong></td>
<td>ListField(child=, min_length=None, max_length=None)</td>
</tr>
<tr>
<td><strong>DictField</strong></td>
<td>DictField(child=)</td>
</tr>
</tbody>
</table>
<p><strong>选项参数：</strong></p>
<table>
<thead><tr>
<th>参数名称</th>
<th>作用</th>
</tr></thead>
<tbody>
<tr>
<td><strong>max_length</strong></td>
<td>最大长度</td>
</tr>
<tr>
<td><strong>min_lenght</strong></td>
<td>最小长度</td>
</tr>
<tr>
<td><strong>allow_blank</strong></td>
<td>是否允许为空</td>
</tr>
<tr>
<td><strong>trim_whitespace</strong></td>
<td>是否截断空白字符</td>
</tr>
<tr>
<td><strong>max_value</strong></td>
<td>最小值</td>
</tr>
<tr>
<td><strong>min_value</strong></td>
<td>最大值</td>
</tr>
</tbody>
</table>
<p>通用参数：</p>
<table>
<thead><tr>
<th>参数名称</th>
<th>说明</th>
</tr></thead>
<tbody>
<tr>
<td><strong>read_only</strong></td>
<td>表明该字段仅用于序列化输出，默认False</td>
</tr>
<tr>
<td><strong>write_only</strong></td>
<td>表明该字段仅用于反序列化输入，默认False</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td>表明该字段在反序列化时必须输入，默认True</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>反序列化时使用的默认值</td>
</tr>
<tr>
<td><strong>allow_null</strong></td>
<td>表明该字段是否允许传入None，默认False</td>
</tr>
<tr>
<td><strong>validators</strong></td>
<td>该字段使用的验证器</td>
</tr>
<tr>
<td><strong>error_messages</strong></td>
<td>包含错误编号与错误信息的字典</td>
</tr>
<tr>
<td><strong>label</strong></td>
<td>用于HTML展示API页面时，显示的字段名称</td>
</tr>
<tr>
<td><strong>help_text</strong></td>
<td>用于HTML展示API页面时，显示的字段帮助提示信息</td>
</tr>
</tbody>
</table>
<h4 id="72-创建serializer对象">7.2 创建Serializer对象</h4>
<p>定义好Serializer类后，就可以创建Serializer对象了。</p>
<p>Serializer的构造方法为：</p>
<pre><code class="language-python">Serializer(instance=None, data=empty, **kwarg)
</code></pre>
<p>说明：</p>
<p>1）用于序列化时，将模型类对象传入<strong>instance</strong>参数</p>
<p>2）用于反序列化时，将要被反序列化的数据传入<strong>data</strong>参数</p>
<p>3）除了instance和data参数外，在构造Serializer对象时，还可通过<strong>context</strong>参数额外添加数据，如</p>
<pre><code class="language-python">serializer = AccountSerializer(account, context={"request": request})
</code></pre>
<p><strong>通过context参数附加的数据，可以通过Serializer对象的context属性获取。</strong></p>
<ol>
<li>使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以。</li>
<li>序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。</li>
<li>序列化器的字段声明类似于我们前面使用过的表单系统。</li>
<li>开发restful api时，序列化器会帮我们把模型数据转换成字典.</li>
<li>drf提供的视图会帮我们把字典转换成json,或者把客户端发送过来的数据转换字典.</li>
</ol>
<h4 id="73-序列化器的使用">7.3 序列化器的使用</h4>
<p>序列化器的使用分两个阶段：</p>
<ol>
<li>在客户端请求时，使用序列化器可以完成对数据的反序列化。</li>
<li>在服务器响应时，使用序列化器可以完成对数据的序列化。</li>
</ol>
<h5 id="731-序列化">7.3.1 序列化</h5>
<h6 id="7311-基本使用">7.3.1.1 基本使用</h6>
<p>1） 先查询出一个学生对象</p>
<pre><code class="language-python">from students.models import Student

student = Student.objects.get(id=3)
</code></pre>
<p>2） 构造序列化器对象</p>
<pre><code class="language-python">from .serializers import StudentSerializer

serializer = StudentSerializer(instance=student)
</code></pre>
<p>3）获取序列化数据</p>
<p>通过data属性可以获取序列化后的数据</p>
<pre><code class="language-python">serializer.data
# {"id": 4, "name": "小张", "age": 18, "sex": True, "description": "猴赛雷"}
</code></pre>
<p>完整视图代码：</p>
<pre><code class="language-python">from django.views import View
from students.models import Student
from .serializers import StudentSerializer
from django.http.response import JsonResponse
class StudentView(View):
    """使用序列化器序列化转换单个模型数据"""
    def get(self,request,pk):
        # 获取数据
        student = Student.objects.get(pk=pk)
        # 数据转换[序列化过程]
        serializer = StudentSerializer(instance=student)
        print(serializer.data)
        # 响应数据
        return JsonResponse(serializer.data)
</code></pre>
<p>4）如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加<strong>many=True</strong>参数补充说明</p>
<pre><code class="language-python">    """使用序列化器序列化转换多个模型数据"""
    def get(self,request):
        # 获取数据
        student_list = Student.objects.all()

        # 转换数据[序列化过程]
        # 如果转换多个模型对象数据，则需要加上many=True
        serializer = StudentSerializer(instance=student_list,many=True)
        print( serializer.data ) # 序列化器转换后的数据

        # 响应数据给客户端
        # 返回的json数据，如果是列表，则需要声明safe=False
        return JsonResponse(serializer.data,safe=False)
    
    
    # 访问结果：
    # [OrderedDict([("id", 1), ("name", "xiaoming"), ("age", 20), ("sex", True), ("description", "测试")]), OrderedDict([("id", 2), ("name", "xiaohui"), ("age", 22), ("sex", True), ("description", "后面来的测试")]), OrderedDict([("id", 4), ("name", "小张"), ("age", 18), ("sex", True), ("description", "猴赛雷")])]

</code></pre>
<h5 id="732--反序列化">7.3.2  反序列化</h5>
<h6 id="7321-数据验证">7.3.2.1 数据验证</h6>
<p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p>
<p>在获取反序列化的数据前，必须调用<strong>is_valid()</strong>方法进行验证，验证成功返回True，否则返回False。</p>
<p>验证失败，可以通过序列化器对象的<strong>errors</strong>属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的<strong>NON_FIELD_ERRORS_KEY</strong>来控制错误字典中的键名。</p>
<p>验证成功，可以通过序列化器对象的<strong>validated_data</strong>属性获取数据。</p>
<p>在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</p>
<p>如我们前面定义过的BookInfoSerializer</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    id = serializers.IntegerField(label="ID", read_only=True)
    btitle = serializers.CharField(label="名称", max_length=20)
    bpub_date = serializers.DateField(label="发布日期", required=False)
    bread = serializers.IntegerField(label="阅读量", required=False)
    bcomment = serializers.IntegerField(label="评论量", required=False)
    image = serializers.ImageField(label="图片", required=False)
</code></pre>
<p>通过构造序列化器对象，并将要反序列化的数据传递给data构造参数，进而进行验证</p>
<pre><code class="language-python">from booktest.serializers import BookInfoSerializer
data = {"bpub_date": 123}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False
serializer.errors
# {"btitle": [ErrorDetail(string="This field is required.", code="required")], "bpub_date": [ErrorDetail(string="Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].", code="invalid")]}
serializer.validated_data  # {}

data = {"btitle": "python"}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.errors  # {}
serializer.validated_data  #  OrderedDict([("btitle", "python")])
</code></pre>
<p>is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递<strong>raise_exception=True</strong>参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。</p>
<pre><code class="language-python"># Return a 400 response if the data was invalid.
serializer.is_valid(raise_exception=True)
</code></pre>
<p>如果觉得这些还不够，需要再补充定义验证行为，可以使用以下三种方法：</p>
<ol>
<li>validate_字段名</li>
</ol>
<p>对<code>&lt;field_name&gt;</code>字段进行验证，如</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

    def validate_btitle(self, value):
        if "django" not in value.lower():
            raise serializers.ValidationError("图书不是关于Django的")
        return value
</code></pre>
<p>测试</p>
<pre><code class="language-python">from booktest.serializers import BookInfoSerializer
data = {"btitle": "python"}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # False   
serializer.errors
#  {"btitle": [ErrorDetail(string="图书不是关于Django的", code="invalid")]}
</code></pre>
<ol start="2">
<li>validate</li>
</ol>
<p>在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

    def validate(self, attrs):
        bread = attrs["bread"]
        bcomment = attrs["bcomment"]
        if bread &lt; bcomment:
            raise serializers.ValidationError("阅读量小于评论量")
        return attrs
</code></pre>
<p>测试</p>
<pre><code class="language-python">from booktest.serializers import BookInfoSerializer
data = {"btitle": "about django", "bread": 10, "bcomment": 20}
s = BookInfoSerializer(data=data)
s.is_valid()  # False
s.errors
#  {"non_field_errors": [ErrorDetail(string="阅读量小于评论量", code="invalid")]}
</code></pre>
<ol start="3">
<li>validators</li>
</ol>
<p>在字段中添加validators选项参数，也可以补充验证行为，如</p>
<pre><code class="language-python">def about_django(value):
    if "django" not in value.lower():
        raise serializers.ValidationError("图书不是关于Django的")

class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    id = serializers.IntegerField(label="ID", read_only=True)
    btitle = serializers.CharField(label="名称", max_length=20, validators=[about_django])
    bpub_date = serializers.DateField(label="发布日期", required=False)
    bread = serializers.IntegerField(label="阅读量", required=False)
    bcomment = serializers.IntegerField(label="评论量", required=False)
    image = serializers.ImageField(label="图片", required=False)
</code></pre>
<p>测试：</p>
<pre><code class="language-python">from booktest.serializers import BookInfoSerializer
data = {"btitle": "python"}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # False   
serializer.errors
#  {"btitle": [ErrorDetail(string="图书不是关于Django的", code="invalid")]}
</code></pre>
<h6 id="7322--反序列化-保存数据">7.3.2.2  反序列化-保存数据</h6>
<p>前面的验证数据成功后,我们可以使用序列化器来完成数据反序列化的过程.这个过程可以把数据转成模型类对象.</p>
<p>可以通过实现create()和update()两个方法来实现。</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

    def create(self, validated_data):
        """新建"""
        return BookInfo(**validated_data)

    def update(self, instance, validated_data):
        """更新，instance为要更新的对象实例"""
        instance.btitle = validated_data.get("btitle", instance.btitle)
        instance.bpub_date = validated_data.get("bpub_date", instance.bpub_date)
        instance.bread = validated_data.get("bread", instance.bread)
        instance.bcomment = validated_data.get("bcomment", instance.bcomment)
        return instance
</code></pre>
<p>如果需要在返回数据对象的时候，也将数据保存到数据库中，则可以进行如下修改</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.Serializer):
    """图书数据序列化器"""
    ...

    def create(self, validated_data):
        """新建"""
        return BookInfo.objects.create(**validated_data)

    def update(self, instance, validated_data):
        """更新，instance为要更新的对象实例"""
        instance.btitle = validated_data.get("btitle", instance.btitle)
        instance.bpub_date = validated_data.get("bpub_date", instance.bpub_date)
        instance.bread = validated_data.get("bread", instance.bread)
        instance.bcomment = validated_data.get("bcomment", instance.bcomment)
        instance.save()
        return instance
</code></pre>
<p>实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了</p>
<pre><code class="language-python">book = serializer.save()
</code></pre>
<p>如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。</p>
<pre><code class="language-python">from db.serializers import BookInfoSerializer
data = {"btitle": "封神演义"}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.save()  # &lt;BookInfo: 封神演义&gt;

from db.models import BookInfo
book = BookInfo.objects.get(id=2)
data = {"btitle": "倚天剑"}
serializer = BookInfoSerializer(book, data=data)
serializer.is_valid()  # True
serializer.save()  # &lt;BookInfo: 倚天剑&gt;
book.btitle  # "倚天剑"
</code></pre>
<h6 id="7323-附加说明">7.3.2.3 附加说明</h6>
<p>1） 在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到</p>
<pre><code class="language-python"># request.user 是django中记录当前登录用户的模型对象
serializer.save(owner=request.user)
</code></pre>
<p>2）默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新</p>
<pre><code class="language-python"># Update `comment` with partial data
serializer = CommentSerializer(comment, data={"content": u"foo bar"}, partial=True)
</code></pre>
<h5 id="733-模型类序列化器">7.3.3 模型类序列化器</h5>
<p>如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。</p>
<p>ModelSerializer与常规的Serializer相同，但提供了：</p>
<ul>
<li>基于模型类自动生成一系列字段</li>
<li>基于模型类自动为Serializer生成validators，比如unique_together</li>
<li>包含默认的create()和update()的实现</li>
</ul>
<h6 id="7331-定义">7.3.3.1 定义</h6>
<p>比如我们创建一个BookInfoSerializer</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    """图书数据序列化器"""
    class Meta:
        model = BookInfo
        fields = "__all__"
</code></pre>
<ul>
<li>model 指明参照哪个模型类</li>
<li>fields 指明为模型类的哪些字段生成</li>
</ul>
<p>我们可以在python manage.py shell中查看自动生成的BookInfoSerializer的具体实现</p>
<pre><code class="language-python">&gt;&gt;&gt; from booktest.serializers import BookInfoSerializer
&gt;&gt;&gt; serializer = BookInfoSerializer()
&gt;&gt;&gt; serializer
BookInfoSerializer():
    id = IntegerField(label="ID", read_only=True)
    btitle = CharField(label="名称", max_length=20)
    bpub_date = DateField(allow_null=True, label="发布日期", required=False)
    bread = IntegerField(label="阅读量", max_value=2147483647, min_value=-2147483648, required=False)
    bcomment = IntegerField(label="评论量", max_value=2147483647, min_value=-2147483648, required=False)
    image = ImageField(allow_null=True, label="图片", max_length=100, required=False)
</code></pre>
<h6 id="7332-指定字段">7.3.3.2 指定字段</h6>
<ol>
<li>使用<strong>fields</strong>来明确字段，<code>__all__</code>表名包含所有字段，也可以写明具体哪些字段，如</li>
</ol>
<pre><code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    """图书数据序列化器"""
    class Meta:
        model = BookInfo
        fields = ("id", "btitle", "bpub_date")
</code></pre>
<ol start="2">
<li>使用<strong>exclude</strong>可以明确排除掉哪些字段</li>
</ol>
<pre><code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    """图书数据序列化器"""
    class Meta:
        model = BookInfo
        exclude = ("image",)
</code></pre>
<ol start="3">
<li>显示指明字段，如：</li>
</ol>
<pre><code class="language-python">class HeroInfoSerializer(serializers.ModelSerializer):
    hbook = BookInfoSerializer()

    class Meta:
        model = HeroInfo
        fields = ("id", "hname", "hgender", "hcomment", "hbook")
</code></pre>
<ol start="4">
<li>指明只读字段</li>
</ol>
<p>可以通过<strong>read_only_fields</strong>指明只读字段，即仅用于序列化输出的字段</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    """图书数据序列化器"""
    class Meta:
        model = BookInfo
        fields = ("id", "btitle", "bpub_date"， "bread", "bcomment")
        read_only_fields = ("id", "bread", "bcomment")
</code></pre>
<h6 id="7333-添加额外参数">7.3.3.3 添加额外参数</h6>
<p>我们可以使用<strong>extra_kwargs</strong>参数为ModelSerializer添加或修改原有的选项参数</p>
<pre><code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    """图书数据序列化器"""
    class Meta:
        model = BookInfo
        fields = ("id", "btitle", "bpub_date", "bread", "bcomment")
        extra_kwargs = {
            "bread": {"min_value": 0, "required": True},
            "bcomment": {"min_value": 0, "required": True},
        }

# BookInfoSerializer():
#    id = IntegerField(label="ID", read_only=True)
#    btitle = CharField(label="名称", max_length=20)
#    bpub_date = DateField(allow_null=True, label="发布日期", required=False)
#    bread = IntegerField(label="阅读量", max_value=2147483647, min_value=0, required=True)
#    bcomment = IntegerField(label="评论量", max_value=2147483647, min_value=0, required=True)
</code></pre>
<h2 id="二、http请求、视图、路由routers">二、http请求、视图、路由Routers</h2>
<p>什么时候声明的序列化器需要继承序列化器基类Serializer，什么时候继承模型序列化器类ModelSerializer？</p>
<pre><code>继承序列化器类Serializer
	字段声明
	验证
	添加/保存数据功能
继承模型序列化器类ModelSerializer
	字段声明[可选,看需要]
	Meta声明
	验证
	添加/保存数据功能[可选]
</code></pre>
<p>看表字段大小，看使用哪个更加节省代码了。</p>
<h3 id="1-http请求处理">1. http请求处理</h3>
<p>drf除了在数据序列化部分简写代码以外，还在视图中提供了简写操作。所以在django原有的django.views.View类基础上，drf封装了多个视图子类出来提供给我们使用。</p>
<p>Django REST framwork 提供的视图的主要作用：</p>
<ul>
<li>控制序列化器的执行（检验、保存、转换数据）</li>
<li>控制数据库查询的执行</li>
<li>调用请求类和响应类[这两个类也是由drf帮我们再次扩展了一些功能类。]</li>
</ul>
<p>为了方便我们学习，所以先创建一个子应用req</p>
<pre><code class="language-python">python manage.py startapp req
</code></pre>
<p>注册子引用：</p>
<pre><code class="language-python">INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # 注册 rest_framework　的子应用
    "rest_framework",

    "students",
    "sers",
    "unsers",
    "homework",
    "req",     # 请求与响应
]

</code></pre>
<p>注册路由</p>
<pre><code class="language-python"># 子应用路由
from django.urls import path
from . import views
urlpatterns = [

]


# 总路由
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("students/", include("students.urls")),
    path("sers/", include("sers.urls")),
    path("unsers/", include("unsers.urls")),
    path("req/", include("req.urls")),
]

</code></pre>
<h4 id="11-请求与响应">1.1. 请求与响应</h4>
<h5 id="111-request">1.1.1 Request</h5>
<p>REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的<strong>Request</strong>类的对象。[在drf中，原生的django的http请求对象，通过<code>request._request</code>]</p>
<p>REST framework 提供了<strong>Parser</strong>解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON、表单等）将请求数据进行parse解析，解析为类字典[QueryDict]对象保存到<strong>Request</strong>对象中。</p>
<p><strong>Request对象的数据是自动根据前端发送数据的格式进行解析之后的结果。</strong></p>
<p>无论前端发送的哪种格式的数据，我们都可以以统一的方式读取数据。</p>
<h5 id="1111-常用属性">1.1.1.1 常用属性</h5>
<h6 id="1）data">1）.data</h6>
<p><code>request.data</code> 返回解析之后的<mark>请求体</mark>数据。类似于Django中标准的<code>request.POST</code>和 <code>request.FILES</code>属性，但提供如下特性：</p>
<ul>
<li>包含了解析之后的文件和非文件数据</li>
<li>包含了对POST、PUT、PATCH请求方式解析后的数据</li>
<li>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</li>
</ul>
<p>相当于drf的request.data替代了 django的request.POST，request.FILES，request.body、</p>
<h6 id="2）query_params">2）.query_params</h6>
<p><code>request.query_params</code>返回解析之后的<mark>查询字符串</mark>数据</p>
<p><code>request.query_params</code>与Django原生的<code>request.GET</code>相同，只是更换了更正确的名称而已。</p>
<h4 id="112-response">1.1.2 Response</h4>
<pre><code>rest_framework.response.Response
</code></pre>
<p>REST framework提供了一个响应类<code>Response</code>，使用该类构造响应对象时，响应的具体数据内容会被转换（renderer渲染器）成符合前端需求的类型。</p>
<p>REST framework提供了<code>Renderer</code> 渲染器，用来根据请求头中的<code>Accept</code>（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据，我们可以通过配置来修改默认响应格式。【简而言之，就是Renderer能通过请求找的Accept查询出客户端支持和希望的数据类型，把视图的结果以客户端能识别的格式返回】</p>
<p>可以在<strong>rest_framework.settings.py</strong>查找所有的drf默认配置项</p>
<pre><code class="language-python">REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": (  # 默认响应渲染类
        "rest_framework.renderers.JSONRenderer",  # json渲染器
        "rest_framework.renderers.BrowsableAPIRenderer",  # 浏览器API渲染器
    )
}
</code></pre>
<h5 id="1121-构造方式">1.1.2.1 构造方式</h5>
<pre><code class="language-python">Response(data, status=None, template_name=None, headers=None, content_type=None)
</code></pre>
<p><code>data</code>数据不要是render处理之后的数据，只需传递python的内建类型数据即可，REST framework会使用<code>renderer</code>渲染器处理<code>data</code>。</p>
<p><code>data</code>不能是复杂结构的数据，如Django的模型类对象，对于这样的数据我们可以使用<code>Serializer</code>序列化器序列化处理后（转为了Python字典类型）再传递给<code>data</code>参数。</p>
<p>参数说明：</p>
<ul>
<li>
<code>data</code>: 为响应准备的序列化处理后的数据；</li>
<li>
<code>status</code>: 状态码，默认200；</li>
<li>
<code>template_name</code>: 模板名称，如果使用<code>HTMLRenderer</code> 时需指明；</li>
<li>
<code>headers</code>: 用于存放响应头信息的字典；</li>
<li>
<code>content_type</code>: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数。</li>
</ul>
<h5 id="1122-常用属性">1.1.2.2 常用属性</h5>
<h6 id="1）data-2">1）.data</h6>
<p>传给response对象的序列化后，但尚未render处理的数据</p>
<h6 id="2）status_code">2）.status_code</h6>
<p>状态码的数字</p>
<h6 id="3）content">3）.content</h6>
<p>经过renderer处理后的响应数据</p>
<h5 id="1123-状态码">1.1.2.3 状态码</h5>
<p>为了方便设置状态码，REST framewrok在<code>rest_framework.status</code>模块中提供了常用状态码常量。</p>
<h6 id="1）信息告知---1xx">1）信息告知 - 1xx</h6>
<pre><code class="language-python">HTTP_100_CONTINUE
HTTP_101_SWITCHING_PROTOCOLS
</code></pre>
<h6 id="2）成功---2xx">2）成功 - 2xx</h6>
<pre><code class="language-python">HTTP_200_OK
HTTP_201_CREATED
HTTP_202_ACCEPTED
HTTP_203_NON_AUTHORITATIVE_INFORMATION
HTTP_204_NO_CONTENT
HTTP_205_RESET_CONTENT
HTTP_206_PARTIAL_CONTENT
HTTP_207_MULTI_STATUS
</code></pre>
<h6 id="3）重定向---3xx">3）重定向 - 3xx</h6>
<pre><code class="language-python">HTTP_300_MULTIPLE_CHOICES
HTTP_301_MOVED_PERMANENTLY
HTTP_302_FOUND
HTTP_303_SEE_OTHER
HTTP_304_NOT_MODIFIED
HTTP_305_USE_PROXY
HTTP_306_RESERVED
HTTP_307_TEMPORARY_REDIRECT
</code></pre>
<h6 id="4）客户端错误---4xx">4）客户端错误 - 4xx</h6>
<pre><code class="language-python">HTTP_400_BAD_REQUEST
HTTP_401_UNAUTHORIZED
HTTP_402_PAYMENT_REQUIRED
HTTP_403_FORBIDDEN
HTTP_404_NOT_FOUND
HTTP_405_METHOD_NOT_ALLOWED
HTTP_406_NOT_ACCEPTABLE
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
HTTP_408_REQUEST_TIMEOUT
HTTP_409_CONFLICT
HTTP_410_GONE
HTTP_411_LENGTH_REQUIRED
HTTP_412_PRECONDITION_FAILED
HTTP_413_REQUEST_ENTITY_TOO_LARGE
HTTP_414_REQUEST_URI_TOO_LONG
HTTP_415_UNSUPPORTED_MEDIA_TYPE
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
HTTP_417_EXPECTATION_FAILED
HTTP_422_UNPROCESSABLE_ENTITY
HTTP_423_LOCKED
HTTP_424_FAILED_DEPENDENCY
HTTP_428_PRECONDITION_REQUIRED
HTTP_429_TOO_MANY_REQUESTS
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
</code></pre>
<h6 id="5）服务器错误---5xx">5）服务器错误 - 5xx</h6>
<pre><code class="language-python">HTTP_500_INTERNAL_SERVER_ERROR
HTTP_501_NOT_IMPLEMENTED
HTTP_502_BAD_GATEWAY
HTTP_503_SERVICE_UNAVAILABLE
HTTP_504_GATEWAY_TIMEOUT
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
HTTP_507_INSUFFICIENT_STORAGE
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
</code></pre>
<p>为了方便演示，所以视图里面的内容知识，我们另外创建一个子应用来展示</p>
<pre><code class="language-bash">python manage.py startapp demo
</code></pre>
<p>注册子应用</p>
<pre><code class="language-python">INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # 注册 rest_framework　的子应用
    "rest_framework",

    "students",
    "sers",
    "unsers",
    "homework",
    "req",     # 请求与响应
    "demo",     # 视图类的学习
]
</code></pre>
<p>注册路由</p>
<pre><code class="language-python">from django.contrib import admin
from django.urls import path,include
# 新版的django把url拆分成了2个路由函数
# django.urls.path 专门编写字符串路由
# django.urls.re_path 专门编写正则路由
urlpatterns = [
    path("admin/", admin.site.urls),
    path("students/", include("students.urls")),
    path("sers/", include("sers.urls")),
    path("unsers/", include("unsers.urls")),
    path("req/", include("req.urls")),
    path("demo/",include("demo.urls")),
]
</code></pre>
<h3 id="1-视图">1. 视图</h3>
<p>Django REST framwork 提供的视图的主要作用：</p>
<ul>
<li>控制序列化器的执行（检验、保存、转换数据）</li>
<li>控制数据库查询的执行[数据库的删除/查询代码写在视图中，更新和添加写在序列化器]</li>
</ul>
<h4 id="12-视图">1.2 视图</h4>
<p>REST framework 提供了众多的通用视图基类与扩展类，以简化视图的编写。</p>
<h4 id="121-2个视图基类">1.2.1 2个视图基类</h4>
<h5 id="1211-apiview">1.2.1.1 APIView</h5>
<pre><code>rest_framework.views.APIView
</code></pre>
<p><code>APIView</code>是REST framework提供的所有视图的基类，继承自Django的<code>View</code>父类。</p>
<p>drf的<code>APIView</code>在继承django<code>View</code>的基础上，新增了以下内容：</p>
<ul>
<li>传入到视图方法中的是REST framework的<code>Request</code>对象，而不是Django的<code>HttpRequeset</code>对象；</li>
<li>视图方法可以返回REST framework的<code>Response</code>对象，视图会为响应数据设置（renderer）符合前端要求的格式；</li>
<li>任何<code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li>
<li>重写了as_view()，在进行dispatch()路由分发前，会对http请求进行身份认证、权限检查、访问流量控制。</li>
</ul>
<p>支持定义的类属性</p>
<ul>
<li>
<strong>authentication_classes</strong> 列表或元组，身份认证类</li>
<li>
<strong>permissoin_classes</strong> 列表或元组，权限检查类</li>
<li>
<strong>throttle_classes</strong> 列表或元祖，流量控制类</li>
</ul>
<p>在<code>APIView</code>中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。</p>
<p>举例：</p>
<pre><code class="language-python"># Create your views here.
"""APIView是drf里面提供的所有视图类的父类
   APIView提供的功能/属性/方法是最少的,所以使用APIView基本类似我们使用django的View
"""
"""
GET   /students/ 获取多个学生信息
POST  /students/ 添加一个学生信息

GET    /students/&lt;pk&gt;/  获取一个学生信息 
PUT    /students/&lt;pk&gt;/  修改一个学生信息
DELETE /students/&lt;pk&gt;/  删除一个学生信息
"""
from rest_framework.views import APIView
from students.models import Student
from .serializers import StudentModelSerializer
from rest_framework.response import Response
from rest_framework import status

class Student1APIView(APIView):
    def get(self,request):
        """获取所有学生信息"""
        # 1. 获取学生信息的数据模型
        student_list = Student.objects.all()
        # 2. 调用序列化器
        serializer = StudentModelSerializer(instance=student_list, many=True)
        # 3. 返回数据
        return Response(serializer.data)
    def post(self,request):
        """添加一个学生信息"""
        # 1. 调用序列化器对用户提交的数据进行验证
        serializer = StudentModelSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # 2. 调用序列化器进行数据库操作
        instance = serializer.save() # save()方法返回的是添加成功以后的模型对象

        serializer = StudentModelSerializer(instance=instance)

        # 3. 返回新增数据
        return Response(serializer.data, status=status.HTTP_201_CREATED)


class Student2APIView(APIView):
    def get(self,request,pk):
        """获取一个学生信息"""
        # 1. 根据pk获取模型对象
        student = Student.objects.get(pk=pk)
        # 2. 序列化器转换数据
        serializer = StudentModelSerializer(instance=student)
        # 3. 响应数据
        return Response(serializer.data)

    def put(self,request,pk):
        """修改一个学生信息"""
        # 1. 通过pk查询学生信息
        student = Student.objects.get(pk=pk)

        # 3. 调用序列化器对客户端发送过来的数据进行验证
        serializer = StudentModelSerializer(instance=student, data=request.data)
        serializer.is_valid(raise_exception=True)
        # 4. 保存数据
        instance = serializer.save() #?这里实际上调用的序列化器里面的update方法

        serializer = StudentModelSerializer(instance=instance)

        # 5. 返回结果
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def delete(self, request, pk):
        # 1. 通过pk查询学生信息
        Student.objects.get(pk=pk).delete()
        return Response({"message":"ok"}, status=status.HTTP_204_NO_CONTENT)
</code></pre>
<h5 id="1212-genericapiview">1.2.1.2 GenericAPIView</h5>
<p>通用视图类主要作用就是把视图中的独特的代码抽取出来，让视图方法中的代码更加通用，方便把通用代码进行简写。</p>
<pre><code>rest_framework.generics.GenericAPIView
</code></pre>
<p>继承自<code>APIView</code>，<strong>主要增加了操作序列化器和数据库查询的方法，作用是为下面Mixin扩展类的执行提供方法支持。通常在使用时，可搭配一个或多个Mixin扩展类。</strong></p>
<p>提供的关于序列化器使用的属性与方法</p>
<ul>
<li>
<p>属性：</p>
<ul>
<li>
<strong>serializer_class</strong> 指明视图使用的序列化器</li>
</ul>
</li>
<li>
<p>方法：</p>
<ul>
<li>
<p><strong>get_serializer_class(self)</strong></p>
<p>当出现一个视图类中调用多个序列化器时,那么可以通过条件判断在get_serializer_class方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了。</p>
<p>返回序列化器类，默认返回<code>serializer_class</code>，可以重写，例如：</p>
<pre><code class="language-python">def get_serializer_class(self):
    if self.request.user.is_staff:
        return FullAccountSerializer
    return BasicAccountSerializer
</code></pre>
</li>
<li>
<h5 id="get_serializerself-args-kwargs">get_serializer(self, <em>args, *</em>kwargs)</h5>
<p>返回序列化器对象，主要用来提供给Mixin扩展类使用，如果我们在视图中想要获取序列化器对象，也可以直接调用此方法。</p>
<p><strong>注意，该方法在提供序列化器对象的时候，会向序列化器对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。</strong></p>
<ul>
<li>
<strong>request</strong> 当前视图的请求对象</li>
<li>
<strong>view</strong> 当前请求的类视图对象</li>
<li>format 当前请求期望返回的数据格式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>提供的关于数据库查询的属性与方法</p>
<ul>
<li>
<p>属性：</p>
<ul>
<li>
<strong>queryset</strong> 指明使用的数据查询集</li>
</ul>
</li>
<li>
<p>方法：</p>
<ul>
<li>
<p><strong>get_queryset(self)</strong></p>
<p>返回视图使用的查询集，主要用来提供给Mixin扩展类使用，是列表视图与详情视图获取数据的基础，默认返回<code>queryset</code>属性，可以重写，例如：</p>
<pre><code class="language-python">def get_queryset(self):
    user = self.request.user
    return user.accounts.all()
</code></pre>
</li>
<li>
<p><strong>get_object(self)</strong></p>
<p>返回单个视图模型类对象，主要用来提供给Mixin扩展类使用。</p>
<p>在试图中可以调用该方法获取详情信息的模型类对象。</p>
<p><strong>若详情访问的模型类对象不存在，会返回404。</strong></p>
<p>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p>
<p>举例：</p>
<pre><code class="language-python"># url(r"^books/(?P&lt;pk&gt;d+)/$", views.BookDetailView.as_view()),
class BookDetailView(GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request, pk):
        book = self.get_object() # get_object()方法根据pk参数查找queryset中的数据对象
        serializer = self.get_serializer(book)
        return Response(serializer.data)
</code></pre>
</li>
</ul>
</li>
</ul>
<p>其他可以设置的属性</p>
<ul>
<li>
<strong>pagination_class</strong> 指明分页控制类</li>
<li>
<strong>filter_backends</strong> 指明过滤控制后端</li>
</ul>
<p>为了方便学习上面的GenericAPIView通用视图类，我们新建一个子应用。</p>
<pre><code class="language-python">python manage.py startapp gen
</code></pre>
<p>代码：</p>
<pre><code class="language-python">from rest_framework.generics import GenericAPIView

from students.models import Student
from .serializers import StudentModelSerializer, StudentModel2Serializer
from rest_framework.response import Response

class StudentsGenericAPIView(GenericAPIView):
    # 本次视图类中要操作的数据[必填]
    queryset = Student.objects.all()
    # 本次视图类中要调用的默认序列化器[选填]
    serializer_class = StudentModelSerializer

    def get(self, request):
        """获取所有学生信息"""
        serializer = self.get_serializer(instance=self.get_queryset(), many=True)

        return Response(serializer.data)

    def post(self,request):

        data = request.data

        serializer = self.get_serializer(data=data)

        serializer.is_valid(raise_exception=True)

        instance = serializer.save()

        serializer = self.get_serializer(instance=instance)

        return Response(serializer.data)


class StudentGenericAPIView(GenericAPIView):
    queryset = Student.objects.all()

    serializer_class = StudentModelSerializer

    def get_serializer_class(self):
        """重写获取序列化器类的方法"""
        if self.request.method == "GET":
            return StudentModel2Serializer
        else:
            return StudentModelSerializer

    # 在使用GenericAPIView视图获取或操作单个数据时,视图方法中的代表主键的参数最好是pk
    def get(self,request,pk):
        """获取一条数据"""
        serializer = self.get_serializer(instance=self.get_object())

        return Response(serializer.data)

    def put(self,request,pk):

        data = request.data

        serializer = self.get_serializer(instance=self.get_object(),data=data)

        serializer.is_valid(raise_exception=True)

        serializer.save()

        serializer = self.get_serializer(instance=self.get_object())

        return Response(serializer.data)

</code></pre>
<p>序列化器类：</p>
<pre><code class="language-python">from rest_framework import serializers

from students.models import Student

class StudentModelSerializer(serializers.ModelSerializer):
    class Meta:
        model= Student
        fields = "__all__"


class StudentModel2Serializer(serializers.ModelSerializer):
    class Meta:
        model= Student
        fields = ("name","class_null")

</code></pre>
<h4 id="122-5个视图扩展类">1.2.2 5个视图扩展类</h4>
<p>作用：</p>
<p>提供了几种后端视图（对数据资源进行曾删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。</p>
<p>这五个扩展类需要搭配GenericAPIView父类，因为五个扩展类的实现需要调用GenericAPIView提供的序列化器与数据库查询的方法。</p>
<h5 id="1）listmodelmixin">1）ListModelMixin</h5>
<p>列表视图扩展类，提供<code>list(request, *args, **kwargs)</code>方法快速实现列表视图，返回200状态码。</p>
<p>该Mixin的list方法会对数据进行过滤和分页。</p>
<p>源代码：</p>
<pre><code class="language-python">class ListModelMixin(object):
    """
    List a queryset.
    """
    def list(self, request, *args, **kwargs):
        # 过滤
        queryset = self.filter_queryset(self.get_queryset())
        # 分页
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        # 序列化
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

</code></pre>
<p>举例：</p>
<pre><code class="language-python">from rest_framework.mixins import ListModelMixin

class BookListView(ListModelMixin, GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request):
        return self.list(request)

</code></pre>
<h5 id="2）createmodelmixin">2）CreateModelMixin</h5>
<p>创建视图扩展类，提供<code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p>
<p>如果序列化器对前端发送的数据验证失败，返回400错误。</p>
<p>源代码：</p>
<pre><code class="language-python">class CreateModelMixin(object):
    """
    Create a model instance.
    """
    def create(self, request, *args, **kwargs):
        # 获取序列化器
        serializer = self.get_serializer(data=request.data)
        # 验证
        serializer.is_valid(raise_exception=True)
        # 保存
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

    def get_success_headers(self, data):
        try:
            return {"Location": str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}

</code></pre>
<h5 id="3）retrievemodelmixin">3）RetrieveModelMixin</h5>
<p>详情视图扩展类，提供<code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p>
<p>如果存在，返回200， 否则返回404。</p>
<p>源代码：</p>
                                                                                                        
                                                </div></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/python/biji/211.html'>pytest-pyppeteer：在pytest中运行pyppeteer</a><a>下一篇</a><a href='/python/biji/213.html'>函数递归</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>