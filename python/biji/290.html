<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>DjangoRESTframework_IDC笔记</title>
    <meta name="keywords" content=",Python教程"/>
    <meta name="description" content="目录1. DjangoRESTframework
1.1 web应用模式
1 前后端不分离
2 前后端分离"/>
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author"/>
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/python/1.html">Python环境搭建</a></li><li><a href="/python/python/2.html">Python解释器及IDLE教程</a></li><li><a href="/python/python/3.html">Pycharm安装及使用教程</a></li><li><a href="/python/python/4.html">学习方向及教程规划</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python基础语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/basic/5.html">第一个Python实例</a></li><li><a href="/python/basic/6.html">Python编码规范</a></li><li><a href="/python/basic/7.html">Python标识符和关键字</a></li><li><a href="/python/basic/9.html">Python基本数据类型介绍</a></li><li><a href="/python/basic/8.html">Python变量</a></li><li><a href="/python/basic/10.html">基本数据类型之字符串</a></li><li><a href="/python/basic/11.html">布尔类型和强制类型转换</a></li><li><a href="/python/basic/12.html">Python的输入和输出方法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python入门语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/syntax/13.html">python算术运算符和关系运算符</a></li><li><a href="/python/syntax/14.html">python算术运算符和关系运算符</a></li><li><a href="/python/syntax/15.html">python位运算符</a></li><li><a href="/python/syntax/16.html">Python控制结构详解</a></li><li><a href="/python/syntax/17.html">python基础ifelse选择结构详解</a></li><li><a href="/python/syntax/18.html">python选择结构的嵌套</a></li><li><a href="/python/syntax/20.html">Python基础for循环语句详解</a></li><li><a href="/python/syntax/19.html">Pyhon基础while循环语句详解</a></li><li><a href="/python/syntax/21.html">python循环嵌套</a></li><li><a href="/python/syntax/24.html">Python序列的加法和乘法操作详解</a></li><li><a href="/python/syntax/23.html">Python序列详解（包括索引和切片）</a></li><li><a href="/python/syntax/22.html">python基础break语句详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python核心语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/core/25.html">Python序列常用的内置函数详解</a></li><li><a href="/python/core/26.html">Python列表list的基础操作与代码实现</a></li><li><a href="/python/core/27.html">Python列表list操作(遍历查找增加删除修改)实例详解</a></li><li><a href="/python/core/28.html">列表的排序和逆序</a></li><li><a href="/python/core/29.html">列表推导式</a></li><li><a href="/python/core/30.html">python二维列表</a></li><li><a href="/python/core/31.html">python元组的操作详解</a></li><li><a href="/python/core/32.html">python字典及基础操作</a></li><li><a href="/python/core/33.html">python字典常用函数（clear、get、items、keys、values、pop）</a></li><li><a href="/python/core/34.html">字典-混合字典和字典推导式</a></li><li><a href="/python/core/35.html">python集合类型介绍</a></li><li><a href="/python/core/36.html">集合的运算（交集、并集和差集）</a></li><li><a href="/python/core/37.html">Python字符串基础操作</a></li><li><a href="/python/core/38.html">Python字符串常用方法</a></li><li><a href="/python/core/39.html">字符串的测试方法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/functions/42.html">python函数的创建和调用</a></li><li><a href="/python/functions/43.html">python函数的参数传递</a></li><li><a href="/python/functions/44.html">python函数的返回值</a></li><li><a href="/python/functions/46.html">python匿名函数</a></li><li><a href="/python/functions/47.html">python三大基础函数</a></li><li><a href="/python/functions/48.html">python递归函数</a></li><li><a href="/python/functions/49.html">python内置函数</a></li><li><a href="/python/functions/45.html">python变量的作用域</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 面向对象编程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/programming/50.html">python面向对象编程</a></li><li><a href="/python/programming/51.html">python类的定义和构造方法及参数传递</a></li><li><a href="/python/programming/52.html">python类方法</a></li><li><a href="/python/programming/53.html">python继承实例讲解</a></li><li><a href="/python/programming/54.html">模块概述</a></li><li><a href="/python/programming/55.html">Python创建和引入模块实例详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python模块			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/modular/56.html">Python引入math模块及库函数大全</a></li><li><a href="/python/modular/57.html">random模块</a></li><li><a href="/python/modular/58.html">datetime模块</a></li><li><a href="/python/modular/59.html">Python如何安装第三方模块？</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 异常处理和程序调试			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/exception/60.html">异常问题和常见异常</a></li><li><a href="/python/exception/61.html">Python异常处理语句try,except实例详解</a></li><li><a href="/python/exception/62.html">Python异常处理语句实例详解二</a></li><li><a href="/python/exception/63.html">Python程序调试图文教程</a></li><li><a href="/python/exception/64.html">使用assert断言对Ptyhon程序调试分析</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 文件及目录操作			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/file/65.html">python文件操作</a></li><li><a href="/python/file/66.html">python读取文件</a></li><li><a href="/python/file/67.html">python中os模块和os.path模块</a></li><li><a href="/python/file/68.html">目录管理</a></li><li><a href="/python/file/69.html">Python项目管理操作</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> GUI编程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/program/70.html">GUI编程</a></li><li><a href="/python/program/71.html">Tkinter模块(1)-简介和Label</a></li><li><a href="/python/program/72.html">Tkinter模块(2)-Frame和Button</a></li><li><a href="/python/program/73.html">Tkinter模块(3)-Entry</a></li><li><a href="/python/program/74.html">Tkinter模块(4)-Radio和Check</a></li><li><a href="/python/program/75.html">Tkinter模块(5)-Canvas</a></li><li><a href="/python/program/76.html">Tkinter模块(6)-练习</a></li><li><a href="/python/program/77.html">wxPython模块(1)-简介和初始化</a></li><li><a href="/python/program/78.html">wxPython模块(2)-文本控件</a></li><li><a href="/python/program/79.html">wxPython模块(3)-按钮和复选框</a></li><li><a href="/python/program/80.html">wxPython(4)-布局</a></li><li><a href="/python/program/81.html">wxPython(5)-事件管理</a></li><li><a href="/python/program/82.html">wxPython(6)-下拉列表和菜单</a></li><li><a href="/python/program/83.html">综合案例</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 进程和线程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/processes/84.html">Python进程和线程的区别</a></li><li><a href="/python/processes/85.html">Python如何创建线程</a></li><li><a href="/python/processes/87.html">Python临界区与线程安全（线程通信）</a></li><li><a href="/python/processes/86.html">Python线程管理</a></li><li><a href="/python/processes/89.html">Python进程间通信代码详解</a></li><li><a href="/python/processes/88.html">Python创建进程的方式详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 数据库管理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/database/91.html">MySQL下载安装图文教程</a></li><li><a href="/python/database/90.html">数据库概述</a></li><li><a href="/python/database/92.html">Navicat for MySQL管理软件安装使用图文教程</a></li><li><a href="/python/database/93.html">对象和游标</a></li><li><a href="/python/database/95.html">SQlite数据库(2)</a></li><li><a href="/python/database/94.html">SQlite数据库(1)</a></li><li><a href="/python/database/96.html">PyMySQL数据库的使用</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python算法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/algorithm/97.html">python枚举算法</a></li><li><a href="/python/algorithm/98.html">python递归算法</a></li><li><a href="/python/algorithm/99.html">python分治算法</a></li><li><a href="/python/algorithm/101.html">python试探算法</a></li><li><a href="/python/algorithm/100.html">python贪心算法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 爬虫			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/reptile/102.html">python爬虫概述</a></li><li><a href="/python/reptile/103.html">python爬虫协议</a></li><li><a href="/python/reptile/104.html">python爬虫技术基础(1)-网络请求</a></li><li><a href="/python/reptile/106.html">python正则表达式(1)</a></li><li><a href="/python/reptile/105.html">python爬虫技术基础(2)header是处理及网络超时</a></li><li><a href="/python/reptile/108.html">BeautifulSoup(1)</a></li><li><a href="/python/reptile/107.html">python正则表达式(2)</a></li><li><a href="/python/reptile/109.html">BeautifulSoup(2)</a></li><li><a href="/python/reptile/110.html">Python爬虫入门抓取天气信息</a></li>		</ul>
	</li>
		<li>
	    <a href="/python/biji" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>Python笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">DjangoRESTframework</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>目录1. DjangoRESTframework
1.1 web应用模式
1 前后端不分离
2 前后端分离</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>&nbsp;</p>
<div class="toc">
<div class="toc-container-header">目录</div>
<ul>
	<li>1. DjangoRESTframework
	<ul>
		<li>1.1 web应用模式
		<ul>
			<li>1 前后端不分离</li>
			<li>2 前后端分离</li>
		</ul></li>
		<li>1.1 认识RESTful</li>
		<li>1.2 使用Django开发REST 接口</li>
		<li>1.3 Django REST framework 简介</li>
	</ul></li>
	<li>2. DRF工程搭建
	<ul>
		<li>2.1 环境安装与配置</li>
		<li>2.2 使用</li>
	</ul></li>
	<li>3. Serializer序列化器
	<ul>
		<li>3.1 定义Serializer
		<ul>
			<li>1. 定义方法</li>
			<li>2. 字段与选项
			<ul>
				<li>通用参数：</li>
			</ul></li>
			<li>3. 创建Serializer对象</li>
		</ul></li>
		<li>3.2 序列化使用
		<ul>
			<li>1 基本使用</li>
			<li>2 关联对象嵌套序列化
			<ul>
				<li>1） PrimaryKeyRelatedField</li>
				<li>2) StringRelatedField</li>
				<li>3）使用关联对象的序列化器</li>
				<li>many参数</li>
			</ul></li>
		</ul></li>
		<li>3.3 反序列化使用
		<ul>
			<li>1. 验证
			<ul>
				<li>1）validate_<field_name></field_name></li>
				<li>2）validate</li>
				<li>3）validators</li>
			</ul></li>
			<li>2. 保存
			<ul>
				<li>说明：</li>
			</ul></li>
		</ul></li>
		<li>3.4 模型类序列化器ModelSerializer
		<ul>
			<li>1. 定义</li>
			<li>2. 指定字段</li>
			<li>3. 添加额外参数</li>
		</ul></li>
	</ul></li>
	<li>4. 视图
	<ul>
		<li>4.1 Request 与 Response
		<ul>
			<li>1. Request</li>
			<li>常用属性
			<ul>
				<li>1）.data</li>
				<li>2）.query_params</li>
			</ul></li>
			<li>2. Response</li>
			<li>构造方式</li>
			<li>3. 状态码
			<ul>
				<li>1）信息告知 - 1xx</li>
				<li>2）成功 - 2xx</li>
				<li>3）重定向 - 3xx</li>
				<li>4）客户端错误 - 4xx</li>
				<li>5）服务器错误 - 5xx</li>
			</ul></li>
		</ul></li>
		<li>4.2 视图概览</li>
		<li>4.3 视图说明
		<ul>
			<li>1. 两个基类
			<ul>
				<li>1）APIView
				<ul>
					<li>支持定义的属性：</li>
				</ul></li>
				<li>2）GenericAPIView
				<ul>
					<li>支持定义的属性：</li>
					<li>提供的方法：</li>
					<li>get_serializer(self, *args, **kwargs)</li>
				</ul></li>
			</ul></li>
			<li>2. 五个扩展类
			<ul>
				<li>1）ListModelMixin</li>
				<li>2）CreateModelMixin</li>
				<li>3） RetrieveModelMixin</li>
				<li>4）UpdateModelMixin</li>
				<li>5）DestroyModelMixin</li>
			</ul></li>
			<li>3. 几个可用子类视图
			<ul>
				<li>1） CreateAPIView</li>
				<li>2）ListAPIView</li>
				<li>3）RetireveAPIView</li>
				<li>4）DestoryAPIView</li>
				<li>5）UpdateAPIView</li>
				<li>6）RetrieveUpdateAPIView</li>
				<li>7）RetrieveUpdateDestoryAPIView</li>
			</ul></li>
		</ul></li>
		<li>4.4 视图集ViewSet
		<ul>
			<li>1. action属性</li>
			<li>2. 常用视图集父类
			<ul>
				<li>1） ViewSet</li>
				<li>2）GenericViewSet</li>
				<li>3）ModelViewSet</li>
				<li>4）ReadOnlyModelViewSet</li>
			</ul></li>
			<li>3. 视图集中定义附加action动作</li>
			<li>4. 视图集的继承关系</li>
		</ul></li>
		<li>4.5 路由Routers
		<ul>
			<li>1. 使用方法</li>
			<li>2. 视图集中包含附加action的</li>
			<li>3. 路由router形成URL的方式</li>
		</ul></li>
	</ul></li>
	<li>5. 其他功能
	<ul>
		<li>5.1 版本</li>
		<li>5.2 认证Authentication</li>
		<li>5.3 权限Permissions
		<ul>
			<li>使用</li>
			<li>提供的权限</li>
			<li>举例</li>
		</ul></li>
		<li>5.4 限流Throttling
		<ul>
			<li>使用</li>
			<li>可选限流类</li>
			<li>实例</li>
		</ul></li>
		<li>5.5 过滤Filtering</li>
		<li>5.6 排序
		<ul>
			<li>使用方法：</li>
		</ul></li>
		<li>5.7 分页Pagination
		<ul>
			<li>可选分页器
			<ul>
				<li>1） PageNumberPagination</li>
				<li>2）LimitOffsetPagination</li>
			</ul></li>
		</ul></li>
		<li>5.78 异常处理 Exceptions
		<ul>
			<li>REST framework定义的异常</li>
		</ul></li>
		<li>5.9 自动生成接口文档
		<ul>
			<li>1. 安装依赖</li>
			<li>2. 设置接口文档访问路径</li>
			<li>3. 文档描述说明的定义位置</li>
			<li>4. 访问接口文档网页
			<ul>
				<li>两点说明：</li>
			</ul></li>
		</ul></li>
		<li>5.10 JWT
		<ul>
			<li>1 介绍</li>
			<li>2 安装</li>
			<li>3 案例</li>
		</ul></li>
		<li>5.11 跨域
		<ul>
			<li>1 解决跨域：CORS</li>
			<li>2 跨域时，发送了2次请求？</li>
			<li>3 总结</li>
		</ul></li>
		<li>5.12 paramiko</li>
	</ul></li>
</ul></div>
<h1 id="1-djangorestframework">1. DjangoRESTframework</h1>
<h2 id="11-web应用模式">1.1 web应用模式</h2>
<p>在开发Web应用中，有两种应用模式：</p>
<ul>
	<li>前后端不分离</li>
	<li>前后端分离</li>
</ul>
<h3 id="1-前后端不分离">1 前后端不分离</h3>
<p><img alt="前后端不分离" loading="lazy" src="/d/file/p/20221107/1600214882695043.png" /></p>
<p>在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。</p>
<p>这种应用模式比较适合纯网页应用，但是当后端对接App时，App可能并不需要后端返回一个HTML网页，而仅仅是数据本身，所以后端原本返回网页的接口不再适用于前端App应用，为了对接App后端还需再开发一套接口。</p>
<h3 id="2-前后端分离">2 前后端分离</h3>
<p><img alt="前后端分离" loading="lazy" src="/d/file/p/20221107/1600214883348608.png" /></p>
<p>在前后端分离的应用模式中，后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端自己决定，网页有网页的处理方式，App有App的处理方式，但无论哪种前端，所需的数据基本相同，后端仅需开发一套逻辑对外提供数据即可。</p>
<p>在前后端分离的应用模式中 ，前端与后端的耦合度相对较低。</p>
<p>在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个<strong>接口</strong>，或者<strong>API</strong>，前端通过访问接口来对数据进行增删改查。</p>
<h2 id="11-认识restful">1.1 认识RESTful</h2>
<pre>
<code class="language-python">1.给别人提供一个URL，根据URL请求方式的不同，做不同操作。
	get,获取
	post,增加
	put，全部更新
	patch,局部更新
	delete,删除
2.数据传输基于json格式。
</code></pre>
<h2 id="12-使用django开发rest-接口">1.2 使用Django开发REST 接口</h2>
<p>Django框架中使用的图书英雄案例来写一套支持图书数据增删改查的REST API接口,</p>
<p>在此案例中，前后端均发送JSON格式数据。</p>
<pre>
<code class="language-python"># models
from django.db import models

class BookInfo(models.Model):
    btitle = models.CharField(max_length=20, verbose_name=&quot;名称&quot;)
    bpub_date = models.DateField(verbose_name=&quot;发布日期&quot;, null=True)
    bread = models.IntegerField(default=0, verbose_name=&quot;阅读量&quot;)
    bcomment = models.IntegerField(default=0, verbose_name=&quot;评论量&quot;)
    image = models.ImageField(upload_to=&quot;booktest&quot;, verbose_name=&quot;图片&quot;, null=True)
</code></pre>
<pre>
<code class="language-python"># urls.py
urlpatterns = [
    url(r&quot;^books/$&quot;, views.BooksAPIVIew.as_view()),
    url(r&quot;^books/(?P&lt;pk&gt;d+)/$&quot;, views.BookAPIView.as_view())
]
</code></pre>
<pre>
<code class="language-python"># views.py

from datetime import datetime

class BooksAPIVIew(View):
    &quot;&quot;&quot;
    查询所有图书、增加图书
    &quot;&quot;&quot;
    def get(self, request):
        &quot;&quot;&quot;
        查询所有图书
        路由：GET /books/
        &quot;&quot;&quot;
        queryset = BookInfo.objects.all()
        book_list = []
        for book in queryset:
            book_list.append({
                &quot;id&quot;: book.id,
                &quot;btitle&quot;: book.btitle,
                &quot;bpub_date&quot;: book.bpub_date,
                &quot;bread&quot;: book.bread,
                &quot;bcomment&quot;: book.bcomment,
                &quot;image&quot;: book.image.url if book.image else &quot;&quot;
            })
        return JsonResponse(book_list, safe=False)

    def post(self, request):
        &quot;&quot;&quot;
        新增图书
        路由：POST /books/ 
        &quot;&quot;&quot;
        json_bytes = request.body
        json_str = json_bytes.decode()
        book_dict = json.loads(json_str)

        # 此处详细的校验参数省略

        book = BookInfo.objects.create(
            btitle=book_dict.get(&quot;btitle&quot;),
            bpub_date=datetime.strptime(book_dict.get(&quot;bpub_date&quot;), &quot;%Y-%m-%d&quot;).date()
        )

        return JsonResponse({
            &quot;id&quot;: book.id,
            &quot;btitle&quot;: book.btitle,
            &quot;bpub_date&quot;: book.bpub_date,
            &quot;bread&quot;: book.bread,
            &quot;bcomment&quot;: book.bcomment,
            &quot;image&quot;: book.image if book.image else &quot;&quot;
        }, status=201)


class BookAPIView(View):
    def get(self, request, pk):
        &quot;&quot;&quot;
        获取单个图书信息
        路由： GET  /books/&lt;pk&gt;/
        &quot;&quot;&quot;
        try:
            book = BookInfo.objects.get(pk=pk)
        except BookInfo.DoesNotExist:
            return HttpResponse(status=404)

        return JsonResponse({
            &quot;id&quot;: book.id,
            &quot;btitle&quot;: book.btitle,
            &quot;bpub_date&quot;: book.bpub_date,
            &quot;bread&quot;: book.bread,
            &quot;bcomment&quot;: book.bcomment,
            &quot;image&quot;: book.image.url if book.image else &quot;&quot;
        })

    def put(self, request, pk):
        &quot;&quot;&quot;
        修改图书信息
        路由： PUT  /books/&lt;pk&gt;
        &quot;&quot;&quot;
        try:
            book = BookInfo.objects.get(pk=pk)
        except BookInfo.DoesNotExist:
            return HttpResponse(status=404)

        json_bytes = request.body
        json_str = json_bytes.decode()
        book_dict = json.loads(json_str)

        # 此处详细的校验参数省略

        book.btitle = book_dict.get(&quot;btitle&quot;)
        book.bpub_date = datetime.strptime(book_dict.get(&quot;bpub_date&quot;), &quot;%Y-%m-%d&quot;).date()
        book.save()

        return JsonResponse({
            &quot;id&quot;: book.id,
            &quot;btitle&quot;: book.btitle,
            &quot;bpub_date&quot;: book.bpub_date,
            &quot;bread&quot;: book.bread,
            &quot;bcomment&quot;: book.bcomment,
            &quot;image&quot;: book.image.url if book.image else &quot;&quot;
        })

    def delete(self, request, pk):
        &quot;&quot;&quot;
        删除图书
        路由： DELETE /books/&lt;pk&gt;/
        &quot;&quot;&quot;
        try:
            book = BookInfo.objects.get(pk=pk)
        except BookInfo.DoesNotExist:
            return HttpResponse(status=404)

        book.delete()

        return HttpResponse(status=204)
</code></pre>
<p>使用Postman测试上述接口</p>
<p>1） 获取所有图书数据</p>
<p>GET 方式访问 http://127.0.0.1:8000/books/， 返回状态码200，数据如下</p>
<pre>
<code class="language-python">[
    {
        &quot;id&quot;: 1,
        &quot;btitle&quot;: &quot;射雕英雄传&quot;,
        &quot;bpub_date&quot;: &quot;1980-05-01&quot;,
        &quot;bread&quot;: 12,
        &quot;bcomment&quot;: 34,
        &quot;image&quot;: &quot;&quot;
    },
    {
        &quot;id&quot;: 2,
        &quot;btitle&quot;: &quot;天龙八部&quot;,
        &quot;bpub_date&quot;: &quot;1986-07-24&quot;,
        &quot;bread&quot;: 36,
        &quot;bcomment&quot;: 40,
        &quot;image&quot;: &quot;&quot;
    }
]
</code></pre>
<p>2）获取单一图书数据</p>
<p>GET 访问 http://127.0.0.1:8000/books/5/ ，返回状态码200， 数据如下</p>
<pre>
<code class="language-python">{
    &quot;id&quot;: 5,
    &quot;btitle&quot;: &quot;西游记&quot;,
    &quot;bpub_date&quot;: &quot;1988-01-01&quot;,
    &quot;bread&quot;: 10,
    &quot;bcomment&quot;: 10,
    &quot;image&quot;: &quot;booktest/xiyouji.png&quot;
}
</code></pre>
<p>3）新增图书数据</p>
<p>POST 访问http://127.0.0.1:8000/books/，发送JSON数据：</p>
<pre>
<code class="language-python">{
    &quot;btitle&quot;: &quot;三国演义&quot;,
    &quot;bpub_date&quot;: &quot;1990-02-03&quot;
}
</code></pre>
<p>返回状态码201，数据如下</p>
<pre>
<code class="language-json">{
    &quot;id&quot;: 8,
    &quot;btitle&quot;: &quot;三国演义&quot;,
    &quot;bpub_date&quot;: &quot;1990-02-03&quot;,
    &quot;bread&quot;: 0,
    &quot;bcomment&quot;: 0,
    &quot;image&quot;: &quot;&quot;
}
</code></pre>
<p>4）修改图书数据</p>
<p>PUT 访问http://127.0.0.1:8000/books/8/，发送JSON数据：</p>
<pre>
<code class="language-json">{
    &quot;btitle&quot;: &quot;三国演义（第二版）&quot;,
    &quot;bpub_date&quot;: &quot;1990-02-03&quot;
}
</code></pre>
<p>返回状态码200，数据如下</p>
<pre>
<code class="language-json">{
    &quot;id&quot;: 8,
    &quot;btitle&quot;: &quot;三国演义（第二版）&quot;,
    &quot;bpub_date&quot;: &quot;1990-02-03&quot;,
    &quot;bread&quot;: 0,
    &quot;bcomment&quot;: 0,
    &quot;image&quot;: &quot;&quot;
}
</code></pre>
<p>5）删除图书数据</p>
<p>DELETE 访问http://127.0.0.1:8000/books/8/，返回204状态码</p>
<h2 id="13-django-rest-framework-简介">1.3 Django REST framework 简介</h2>
<ol>
	<li>在序列化与反序列化时，虽然操作的数据不尽相同，但是执行的过程却是相似的，也就是说这部分代码是可以复用简化编写的。</li>
	<li>在开发REST API的视图中，虽然每个视图具体操作的数据不同，但增、删、改、查的实现流程基本套路化，所以这部分代码也是可以复用简化编写的：
	<ul>
		<li><strong>增</strong>：校验请求数据 -&gt; 执行反序列化过程 -&gt; 保存数据库 -&gt; 将保存的对象序列化并返回</li>
		<li><strong>删</strong>：判断要删除的数据是否存在 -&gt; 执行数据库删除</li>
		<li><strong>改</strong>：判断要修改的数据是否存在 -&gt; 校验请求的数据 -&gt; 执行反序列化过程 -&gt; 保存数据库 -&gt; 将保存的对象序列化并返回</li>
		<li><strong>查</strong>：查询数据库 -&gt; 将数据序列化并返回</li>
	</ul></li>
</ol>
<h1 id="2-drf工程搭建">2. DRF工程搭建</h1>
<pre>
<code class="language-python">记忆：请求到来之后，先执行视图的dispatch方法。
免除csrf认证
1. 视图（APIView、ListAPIView、ListModelMinx）
2. 版本处理
3. 认证
4. 权限
5. 节流（频率限制）
6. 解析器
7. 筛选器
8. 分页
9. 序列化
10. 渲染
</code></pre>
<h2 id="21-环境安装与配置">2.1 环境安装与配置</h2>
<p>DRF需要以下依赖：</p>
<ul>
	<li>Python (2.7, 3.2, 3.3, 3.4, 3.5, 3.6)</li>
	<li>Django (1.10, 1.11, 2.0)</li>
</ul>
<p><strong>DRF是以Django扩展应用的方式提供的</strong></p>
<pre>
<code class="language-python">pip install djangorestframework -i https:
//pypi.douban.com/simple/
</code></pre>
<h2 id="22-使用">2.2 使用</h2>
<ul>
	<li>
	<p>注册：在<strong>settings.py</strong>的<strong>INSTALLED_APPS</strong>中添加&quot;rest_framework&quot;。</p>
	<pre>
<code class="language-python">INSTALLED_APPS = [
    &quot;rest_framework&quot;
]
</code></pre></li>
</ul>
<h1 id="3-serializer序列化器">3. Serializer序列化器</h1>
<p>序列化器的作用：</p>
<ol>
	<li><strong>进行数据的校验</strong></li>
	<li><strong>对数据对象进行转换</strong></li>
</ol>
<h2 id="31-定义serializer">3.1 定义Serializer</h2>
<h3 id="1-定义方法">1. 定义方法</h3>
<p>继承自rest_framework.serializers.Serializer。</p>
<p>数据库模型类BookInfo</p>
<pre>
<code class="language-python">class BookInfo(models.Model):
    btitle = models.CharField(max_length=20, verbose_name=&quot;名称&quot;)
    bpub_date = models.DateField(verbose_name=&quot;发布日期&quot;, null=True)
    bread = models.IntegerField(default=0, verbose_name=&quot;阅读量&quot;)
    bcomment = models.IntegerField(default=0, verbose_name=&quot;评论量&quot;)
    image = models.ImageField(upload_to=&quot;booktest&quot;, verbose_name=&quot;图片&quot;, null=True)
</code></pre>
<p>我们想为这个模型类提供一个序列化器，可以定义如下：</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&quot;ID&quot;, read_only=True)
    btitle = serializers.CharField(label=&quot;名称&quot;, max_length=20)
    bpub_date = serializers.DateField(label=&quot;发布日期&quot;, required=False)
    bread = serializers.IntegerField(label=&quot;阅读量&quot;, required=False)
    bcomment = serializers.IntegerField(label=&quot;评论量&quot;, required=False)
    image = serializers.ImageField(label=&quot;图片&quot;, required=False)
</code></pre>
<p><strong>注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。</strong>serializer是独立于数据库之外的存在。</p>
<h3 id="2-字段与选项">2. 字段与选项</h3>
<p><strong>常用字段类型</strong>：</p>
<table>
	<thead>
		<tr>
			<th>字段</th>
			<th>字段构造方式</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><strong>BooleanField</strong></td>
			<td>BooleanField()</td>
		</tr>
		<tr>
			<td><strong>NullBooleanField</strong></td>
			<td>NullBooleanField()</td>
		</tr>
		<tr>
			<td><strong>CharField</strong></td>
			<td>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</td>
		</tr>
		<tr>
			<td><strong>EmailField</strong></td>
			<td>EmailField(max_length=None, min_length=None, allow_blank=False)</td>
		</tr>
		<tr>
			<td><strong>RegexField</strong></td>
			<td>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</td>
		</tr>
		<tr>
			<td><strong>SlugField</strong></td>
			<td>SlugField(max<em>length=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9</em>-]+</td>
		</tr>
		<tr>
			<td><strong>URLField</strong></td>
			<td>URLField(max_length=200, min_length=None, allow_blank=False)</td>
		</tr>
		<tr>
			<td><strong>UUIDField</strong></td>
			<td>UUIDField(format=&quot;hex_verbose&quot;) format: 1) <code>&quot;hex_verbose&quot;</code> 如<code>&quot;5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code> 2） <code>&quot;hex&quot;</code> 如 <code>&quot;5ce0e9a55ffa654bcee01238041fb31a&quot;</code> 3）<code>&quot;int&quot;</code> - 如: <code>&quot;123456789012312313134124512351145145114&quot;</code> 4）<code>&quot;urn&quot;</code> 如: <code>&quot;urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code></td>
		</tr>
		<tr>
			<td><strong>IPAddressField</strong></td>
			<td>IPAddressField(protocol=&quot;both&quot;, unpack_ipv4=False, **options)</td>
		</tr>
		<tr>
			<td><strong>IntegerField</strong></td>
			<td>IntegerField(max_value=None, min_value=None)</td>
		</tr>
		<tr>
			<td><strong>FloatField</strong></td>
			<td>FloatField(max_value=None, min_value=None)</td>
		</tr>
		<tr>
			<td><strong>DecimalField</strong></td>
			<td>DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) max_digits: 最多位数 decimal_palces: 小数点位置</td>
		</tr>
		<tr>
			<td><strong>DateTimeField</strong></td>
			<td>DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)</td>
		</tr>
		<tr>
			<td><strong>DateField</strong></td>
			<td>DateField(format=api_settings.DATE_FORMAT, input_formats=None)</td>
		</tr>
		<tr>
			<td><strong>TimeField</strong></td>
			<td>TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</td>
		</tr>
		<tr>
			<td><strong>DurationField</strong></td>
			<td>DurationField()</td>
		</tr>
		<tr>
			<td><strong>ChoiceField</strong></td>
			<td>ChoiceField(choices) choices与Django的用法相同</td>
		</tr>
		<tr>
			<td><strong>MultipleChoiceField</strong></td>
			<td>MultipleChoiceField(choices)</td>
		</tr>
		<tr>
			<td><strong>FileField</strong></td>
			<td>FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
		</tr>
		<tr>
			<td><strong>ImageField</strong></td>
			<td>ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td>
		</tr>
		<tr>
			<td><strong>ListField</strong></td>
			<td>ListField(child=, min_length=None, max_length=None)</td>
		</tr>
		<tr>
			<td><strong>DictField</strong></td>
			<td>DictField(child=)</td>
		</tr>
	</tbody>
</table>
<p><strong>选项参数：</strong></p>
<table>
	<thead>
		<tr>
			<th>参数名称</th>
			<th>作用</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><strong>max_length</strong></td>
			<td>最大长度</td>
		</tr>
		<tr>
			<td><strong>min_lenght</strong></td>
			<td>最小长度</td>
		</tr>
		<tr>
			<td><strong>allow_blank</strong></td>
			<td>是否允许为空</td>
		</tr>
		<tr>
			<td><strong>trim_whitespace</strong></td>
			<td>是否截断空白字符</td>
		</tr>
		<tr>
			<td><strong>max_value</strong></td>
			<td>最小值</td>
		</tr>
		<tr>
			<td><strong>min_value</strong></td>
			<td>最大值</td>
		</tr>
	</tbody>
</table>
<h4 id="通用参数：">通用参数：</h4>
<table>
	<thead>
		<tr>
			<th>参数名称</th>
			<th>说明</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><strong>read_only</strong></td>
			<td>表明该字段仅用于序列化输出，默认False</td>
		</tr>
		<tr>
			<td><strong>write_only</strong></td>
			<td>表明该字段仅用于反序列化输入，默认False</td>
		</tr>
		<tr>
			<td><strong>required</strong></td>
			<td>表明该字段在反序列化时必须输入，默认True</td>
		</tr>
		<tr>
			<td><strong>default</strong></td>
			<td>反序列化时使用的默认值</td>
		</tr>
		<tr>
			<td><strong>allow_null</strong></td>
			<td>表明该字段是否允许传入None，默认False</td>
		</tr>
		<tr>
			<td><strong>validators</strong></td>
			<td>该字段使用的验证器</td>
		</tr>
		<tr>
			<td><strong>error_messages</strong></td>
			<td>包含错误编号与错误信息的字典</td>
		</tr>
		<tr>
			<td><strong>label</strong></td>
			<td>用于HTML展示API页面时，显示的字段名称</td>
		</tr>
		<tr>
			<td><strong>help_text</strong></td>
			<td>用于HTML展示API页面时，显示的字段帮助提示信息</td>
		</tr>
	</tbody>
</table>
<h3 id="3-创建serializer对象">3. 创建Serializer对象</h3>
<p>定义好Serializer类后，就可以创建Serializer对象了。</p>
<p>Serializer的构造方法为：</p>
<pre>
<code class="language-python">Serializer(instance=None, data=empty, **kwarg)
</code></pre>
<p>说明：</p>
<p>1）用于序列化时，将模型类对象传入<strong>instance</strong>参数</p>
<p>2）用于反序列化时，将要被反序列化的数据传入<strong>data</strong>参数</p>
<p>3）除了instance和data参数外，在构造Serializer对象时，还可通过<strong>context</strong>参数额外添加数据，如</p>
<pre>
<code class="language-python">serializer = AccountSerializer(account, context={&quot;request&quot;: request})
</code></pre>
<p><strong>通过context参数附加的数据，可以通过Serializer对象的context属性获取。</strong></p>
<h2 id="32-序列化使用">3.2 序列化使用</h2>
<p>我们在django shell中来学习序列化器的使用。</p>
<pre>
<code class="language-shell">python manage.py shell
</code></pre>
<h3 id="1-基本使用">1 基本使用</h3>
<p>1） 先查询出一个图书对象</p>
<pre>
<code class="language-python">from booktest.models import BookInfo

book = BookInfo.objects.get(id=2)
</code></pre>
<p>2） 构造序列化器对象</p>
<pre>
<code class="language-python">from booktest.serializers import BookInfoSerializer

serializer = BookInfoSerializer(book)
</code></pre>
<p>3）获取序列化数据</p>
<p>通过data属性可以获取序列化后的数据</p>
<pre>
<code class="language-python">serializer.data
# {&quot;id&quot;: 2, &quot;btitle&quot;: &quot;天龙八部&quot;, &quot;bpub_date&quot;: &quot;1986-07-24&quot;, &quot;bread&quot;: 36, &quot;bcomment&quot;: 40, &quot;image&quot;: None}
</code></pre>
<p>4）如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加<strong>many=True</strong>参数补充说明</p>
<pre>
<code class="language-python">book_qs = BookInfo.objects.all()
serializer = BookInfoSerializer(book_qs, many=True)
serializer.data
# [OrderedDict([(&quot;id&quot;, 2), (&quot;btitle&quot;, &quot;天龙八部&quot;), (&quot;bpub_date&quot;, &quot;1986-07-24&quot;), (&quot;bread&quot;, 36), (&quot;bcomment&quot;, 40), (&quot;image&quot;, N]), OrderedDict([(&quot;id&quot;, 3), (&quot;btitle&quot;, &quot;笑傲江湖&quot;), (&quot;bpub_date&quot;, &quot;1995-12-24&quot;), (&quot;bread&quot;, 20), (&quot;bcomment&quot;, 80), (&quot;image&quot;ne)]), OrderedDict([(&quot;id&quot;, 4), (&quot;btitle&quot;, &quot;雪山飞狐&quot;), (&quot;bpub_date&quot;, &quot;1987-11-11&quot;), (&quot;bread&quot;, 58), (&quot;bcomment&quot;, 24), (&quot;ima None)]), OrderedDict([(&quot;id&quot;, 5), (&quot;btitle&quot;, &quot;西游记&quot;), (&quot;bpub_date&quot;, &quot;1988-01-01&quot;), (&quot;bread&quot;, 10), (&quot;bcomment&quot;, 10), (&quot;im&quot;, &quot;booktest/xiyouji.png&quot;)])]
</code></pre>
<h3 id="2-关联对象嵌套序列化">2 关联对象嵌套序列化</h3>
<p>如果需要序列化的数据中包含有其他关联对象，则对关联对象数据的序列化需要指明。</p>
<p>例如，在定义英雄数据的序列化器时，外键hbook（即所属的图书）字段如何序列化？</p>
<p>我们先定义HeroInfoSerialzier除外键字段外的其他部分：</p>
<pre>
<code class="language-python">class HeroInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;英雄数据序列化器&quot;&quot;&quot;
    GENDER_CHOICES = (
        (0, &quot;male&quot;),
        (1, &quot;female&quot;)
    )
    id = serializers.IntegerField(label=&quot;ID&quot;, read_only=True)
    hname = serializers.CharField(label=&quot;名字&quot;, max_length=20)
    hgender = serializers.ChoiceField(choices=GENDER_CHOICES, label=&quot;性别&quot;, required=False)
    hcomment = serializers.CharField(label=&quot;描述信息&quot;, max_length=200, required=False, allow_null=True)
</code></pre>
<p>对于关联字段，可以采用以下几种方式：</p>
<h4 id="1）-primarykeyrelatedfield">1） PrimaryKeyRelatedField</h4>
<p>此字段将被序列化为关联对象的主键。</p>
<pre>
<code class="language-python">hbook = serializers.PrimaryKeyRelatedField(label=&quot;图书&quot;, read_only=True)
</code></pre>
<p>指明字段时需要包含read_only=True或者queryset参数：</p>
<ul>
	<li>包含read_only=True参数时，该字段将不能用作反序列化使用</li>
</ul>
<p>使用效果：</p>
<pre>
<code class="language-python">from booktest.serializers import HeroInfoSerializer
from booktest.models import HeroInfo
hero = HeroInfo.objects.get(id=6)
serializer = HeroInfoSerializer(hero)
serializer.data
# {&quot;id&quot;: 6, &quot;hname&quot;: &quot;乔峰&quot;, &quot;hgender&quot;: 1, &quot;hcomment&quot;: &quot;降龙十八掌&quot;, &quot;hbook&quot;: 2}
</code></pre>
<h4 id="2-stringrelatedfield">2) StringRelatedField</h4>
<p>此字段将被序列化为关联对象的字符串表示方式（即__str__方法的返回值）</p>
<pre>
<code class="language-python">hbook = serializers.StringRelatedField(label=&quot;图书&quot;)
</code></pre>
<p>使用效果</p>
<pre>
<code class="language-python">{&quot;id&quot;: 6, &quot;hname&quot;: &quot;乔峰&quot;, &quot;hgender&quot;: 1, &quot;hcomment&quot;: &quot;降龙十八掌&quot;, &quot;hbook&quot;: &quot;天龙八部&quot;}
</code></pre>
<h4 id="3）使用关联对象的序列化器">3）使用关联对象的序列化器</h4>
<pre>
<code class="language-python">hbook = BookInfoSerializer()
</code></pre>
<p>使用效果</p>
<pre>
<code class="language-python">{&quot;id&quot;: 6, &quot;hname&quot;: &quot;乔峰&quot;, &quot;hgender&quot;: 1, &quot;hcomment&quot;: &quot;降龙十八掌&quot;, &quot;hbook&quot;: OrderedDict([(&quot;id&quot;, 2), (&quot;btitle&quot;, &quot;天龙八部&quot;)te&quot;, &quot;1986-07-24&quot;), (&quot;bread&quot;, 36), (&quot;bcomment&quot;, 40), (&quot;image&quot;, None)])}
</code></pre>
<h4 id="many参数">many参数</h4>
<p>如果关联的对象数据不是只有一个，而是包含多个数据，如想序列化图书BookInfo数据，每个BookInfo对象关联的英雄HeroInfo对象可能有多个，此时关联字段类型的指明仍可使用上述几种方式，只是在声明关联字段时，多补充一个many=True参数即可。</p>
<p>此处仅拿PrimaryKeyRelatedField类型来举例，其他相同。</p>
<p>在BookInfoSerializer中添加关联字段：</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&quot;ID&quot;, read_only=True)
    btitle = serializers.CharField(label=&quot;名称&quot;, max_length=20)
    bpub_date = serializers.DateField(label=&quot;发布日期&quot;, required=False)
    bread = serializers.IntegerField(label=&quot;阅读量&quot;, required=False)
    bcomment = serializers.IntegerField(label=&quot;评论量&quot;, required=False)
    image = serializers.ImageField(label=&quot;图片&quot;, required=False)
    heroinfo_set = serializers.PrimaryKeyRelatedField(read_only=True, many=True)  # 新增
</code></pre>
<p>使用效果：</p>
<pre>
<code class="language-python">from booktest.serializers import BookInfoSerializer
from booktest.models import BookInfo
book = BookInfo.objects.get(id=2)
serializer = BookInfoSerializer(book)
serializer.data
# {&quot;id&quot;: 2, &quot;btitle&quot;: &quot;天龙八部&quot;, &quot;bpub_date&quot;: &quot;1986-07-24&quot;, &quot;bread&quot;: 36, &quot;bcomment&quot;: 40, &quot;image&quot;: None, &quot;heroinfo_set&quot;: [6,8, 9]}
</code></pre>
<h2 id="33-反序列化使用">3.3 反序列化使用</h2>
<h3 id="1-验证">1. 验证</h3>
<p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p>
<p>在获取反序列化的数据前，必须调用<strong>is_valid()</strong>方法进行验证，验证成功返回True，否则返回False。</p>
<p>验证失败，可以通过序列化器对象的<strong>errors</strong>属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的<strong>NON_FIELD_ERRORS_KEY</strong>来控制错误字典中的键名。</p>
<p>验证成功，可以通过序列化器对象的<strong>validated_data</strong>属性获取数据。</p>
<p>在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</p>
<p>如我们前面定义过的BookInfoSerializer</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&quot;ID&quot;, read_only=True)
    btitle = serializers.CharField(label=&quot;名称&quot;, max_length=20)
    bpub_date = serializers.DateField(label=&quot;发布日期&quot;, required=False)
    bread = serializers.IntegerField(label=&quot;阅读量&quot;, required=False)
    bcomment = serializers.IntegerField(label=&quot;评论量&quot;, required=False)
    image = serializers.ImageField(label=&quot;图片&quot;, required=False)
</code></pre>
<p>通过构造序列化器对象，并将要反序列化的数据传递给data构造参数，进而进行验证</p>
<pre>
<code class="language-python">from booktest.serializers import BookInfoSerializer
data = {&quot;bpub_date&quot;: 123}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # 返回False
serializer.errors
# {&quot;btitle&quot;: [ErrorDetail(string=&quot;This field is required.&quot;, code=&quot;required&quot;)], &quot;bpub_date&quot;: [ErrorDetail(string=&quot;Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].&quot;, code=&quot;invalid&quot;)]}
serializer.validated_data  # {}

data = {&quot;btitle&quot;: &quot;python&quot;}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.errors  # {}
serializer.validated_data  #  OrderedDict([(&quot;btitle&quot;, &quot;python&quot;)])
</code></pre>
<p>is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递<strong>raise_exception=True</strong>参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。</p>
<pre>
<code class="language-python"># Return a 400 response if the data was invalid.
serializer.is_valid(raise_exception=True)
</code></pre>
<p>如果觉得这些还不够，需要再补充定义验证行为，可以使用以下三种方法：</p>
<h4 id="1）validate_field_name">1）<code>validate_&lt;field_name&gt;</code></h4>
<p>对<code>&lt;field_name&gt;</code>字段进行验证，如</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def validate_btitle(self, value):
        if &quot;django&quot; not in value.lower():
            raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)
        return value
</code></pre>
<p>测试</p>
<pre>
<code class="language-python">from booktest.serializers import BookInfoSerializer
data = {&quot;btitle&quot;: &quot;python&quot;}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # False   
serializer.errors
#  {&quot;btitle&quot;: [ErrorDetail(string=&quot;图书不是关于Django的&quot;, code=&quot;invalid&quot;)]}
</code></pre>
<h4 id="2）validate">2）validate</h4>
<p>在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def validate(self, attrs):
        bread = attrs[&quot;bread&quot;]
        bcomment = attrs[&quot;bcomment&quot;]
        if bread &lt; bcomment:
            raise serializers.ValidationError(&quot;阅读量小于评论量&quot;)
        return attrs
</code></pre>
<p>测试</p>
<pre>
<code class="language-python">from booktest.serializers import BookInfoSerializer
data = {&quot;btitle&quot;: &quot;about django&quot;, &quot;bread&quot;: 10, &quot;bcomment&quot;: 20}
s = BookInfoSerializer(data=data)
s.is_valid()  # False
s.errors
#  {&quot;non_field_errors&quot;: [ErrorDetail(string=&quot;阅读量小于评论量&quot;, code=&quot;invalid&quot;)]}
</code></pre>
<h4 id="3）validators">3）validators</h4>
<p>在字段中添加validators选项参数，也可以补充验证行为，如</p>
<pre>
<code class="language-python">def about_django(value):
    if &quot;django&quot; not in value.lower():
        raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)

class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    id = serializers.IntegerField(label=&quot;ID&quot;, read_only=True)
    btitle = serializers.CharField(label=&quot;名称&quot;, max_length=20, validators=[about_django])
    bpub_date = serializers.DateField(label=&quot;发布日期&quot;, required=False)
    bread = serializers.IntegerField(label=&quot;阅读量&quot;, required=False)
    bcomment = serializers.IntegerField(label=&quot;评论量&quot;, required=False)
    image = serializers.ImageField(label=&quot;图片&quot;, required=False)
</code></pre>
<p>测试：</p>
<pre>
<code class="language-python">from booktest.serializers import BookInfoSerializer
data = {&quot;btitle&quot;: &quot;python&quot;}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # False   
serializer.errors
#  {&quot;btitle&quot;: [ErrorDetail(string=&quot;图书不是关于Django的&quot;, code=&quot;invalid&quot;)]}
</code></pre>
<h3 id="2-保存">2. 保存</h3>
<p>如果在验证成功后，想要基于validated_data完成数据对象的创建，可以通过实现create()和update()两个方法来实现。</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def create(self, validated_data):
        &quot;&quot;&quot;新建&quot;&quot;&quot;
        return BookInfo(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;
        instance.btitle = validated_data.get(&quot;btitle&quot;, instance.btitle)
        instance.bpub_date = validated_data.get(&quot;bpub_date&quot;, instance.bpub_date)
        instance.bread = validated_data.get(&quot;bread&quot;, instance.bread)
        instance.bcomment = validated_data.get(&quot;bcomment&quot;, instance.bcomment)
        return instance
</code></pre>
<p>如果需要在返回数据对象的时候，也将数据保存到数据库中，则可以进行如下修改</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.Serializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    ...

    def create(self, validated_data):
        &quot;&quot;&quot;新建&quot;&quot;&quot;
        return BookInfo.objects.create(**validated_data)

    def update(self, instance, validated_data):
        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;
        instance.btitle = validated_data.get(&quot;btitle&quot;, instance.btitle)
        instance.bpub_date = validated_data.get(&quot;bpub_date&quot;, instance.bpub_date)
        instance.bread = validated_data.get(&quot;bread&quot;, instance.bread)
        instance.bcomment = validated_data.get(&quot;bcomment&quot;, instance.bcomment)
        instance.save()
        return instance
</code></pre>
<p>实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了</p>
<pre>
<code class="language-python">book = serializer.save()
</code></pre>
<p>如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。</p>
<pre>
<code class="language-python">from db.serializers import BookInfoSerializer
data = {&quot;btitle&quot;: &quot;封神演义&quot;}
serializer = BookInfoSerializer(data=data)
serializer.is_valid()  # True
serializer.save()  # &lt;BookInfo: 封神演义&gt;

from db.models import BookInfo
book = BookInfo.objects.get(id=2)
data = {&quot;btitle&quot;: &quot;倚天剑&quot;}
serializer = BookInfoSerializer(book, data=data)
serializer.is_valid()  # True
serializer.save()  # &lt;BookInfo: 倚天剑&gt;
book.btitle  # &quot;倚天剑&quot;
</code></pre>
<h4 id="说明：">说明：</h4>
<p>1） 在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到</p>
<pre>
<code class="language-python">serializer.save(owner=request.user)
</code></pre>
<h2 id="34-模型类序列化器modelserializer">3.4 模型类序列化器ModelSerializer</h2>
<p>如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。</p>
<p>ModelSerializer与常规的Serializer相同，但提供了：</p>
<ul>
	<li>基于模型类自动生成一系列字段</li>
	<li>基于模型类自动为Serializer生成validators，比如unique_together</li>
	<li>包含默认的create()和update()的实现</li>
</ul>
<h3 id="1-定义">1. 定义</h3>
<p>比如我们创建一个BookInfoSerializer：</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = &quot;__all__&quot;
</code></pre>
<ul>
	<li>model 指明参照哪个模型类</li>
	<li>fields 指明为模型类的哪些字段生成</li>
</ul>
<p>我们可以在python manage.py shell中查看自动生成的BookInfoSerializer的具体实现</p>
<pre>
<code class="language-python">&gt;&gt;&gt; from booktest.serializers import BookInfoSerializer
&gt;&gt;&gt; serializer = BookInfoSerializer()
&gt;&gt;&gt; serializer
BookInfoSerializer():
    id = IntegerField(label=&quot;ID&quot;, read_only=True)
    btitle = CharField(label=&quot;名称&quot;, max_length=20)
    bpub_date = DateField(allow_null=True, label=&quot;发布日期&quot;, required=False)
    bread = IntegerField(label=&quot;阅读量&quot;, max_value=2147483647, min_value=-2147483648, required=False)
    bcomment = IntegerField(label=&quot;评论量&quot;, max_value=2147483647, min_value=-2147483648, required=False)
    image = ImageField(allow_null=True, label=&quot;图片&quot;, max_length=100, required=False)
</code></pre>
<h3 id="2-指定字段">2. 指定字段</h3>
<pre>
<code class="language-python">&quot;&quot;&quot;
model=对应的模型
fields=(&quot;参与序列化和反序列的字段1&quot;,&quot;参与序列化和反序列的字段2&quot;)
fields=&quot;__all__&quot;    包含所有字段
exclude = (&quot;id&quot;, &quot;is_delete&quot;)    刨除某些字段
read_only_fields    只能读，不能写
跨表自动深度3种方式（展示外键表的所有字段）
    depth = 1         最大10
                                                # required = False  不是必填传值
    category_txt = serializers.CharField(source=&quot;category.name&quot;, required=False)

    x1 = serializers.SerializerMethodField()
    def get_x1(self, obj):
        return obj.category.name

显示：删除和发布文字两种方式 (1, &quot;发布&quot;),(2, &quot;删除&quot;)
serializers.CharField(source=&quot;get_status_display&quot;, required=False)
&quot;&quot;&quot;
</code></pre>
<ol>
	<li>使用<strong>fields</strong>来明确字段，<code>__all__</code>表名包含所有字段，也可以写明具体哪些字段，如</li>
</ol>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = (&quot;id&quot;, &quot;btitle&quot;, &quot;bpub_date&quot;)
</code></pre>
<ol start="2">
	<li>使用<strong>exclude</strong>可以明确排除掉哪些字段</li>
</ol>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        exclude = (&quot;image&quot;,)
</code></pre>
<ol start="3">
	<li>显示指明字段，如：</li>
</ol>
<pre>
<code class="language-python">class HeroInfoSerializer(serializers.ModelSerializer):
    hbook = BookInfoSerializer()

    class Meta:
        model = HeroInfo
        fields = (&quot;id&quot;, &quot;hname&quot;, &quot;hgender&quot;, &quot;hcomment&quot;, &quot;hbook&quot;)
</code></pre>
<ol start="4">
	<li>指明只读字段</li>
</ol>
<p>可以通过<strong>read_only_fields</strong>指明只读字段，即仅用于序列化输出的字段</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = (&quot;id&quot;, &quot;btitle&quot;, &quot;bpub_date&quot;， &quot;bread&quot;, &quot;bcomment&quot;)
        read_only_fields = (&quot;id&quot;, &quot;bread&quot;, &quot;bcomment&quot;)
</code></pre>
<h3 id="3-添加额外参数">3. 添加额外参数</h3>
<p>我们可以使用<strong>extra_kwargs</strong>参数为ModelSerializer添加或修改原有的选项参数</p>
<pre>
<code class="language-python">class BookInfoSerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;
    class Meta:
        model = BookInfo
        fields = (&quot;id&quot;, &quot;btitle&quot;, &quot;bpub_date&quot;, &quot;bread&quot;, &quot;bcomment&quot;)
        extra_kwargs = {
            &quot;bread&quot;: {&quot;min_value&quot;: 0, &quot;required&quot;: True},
            &quot;bcomment&quot;: {&quot;min_value&quot;: 0, &quot;required&quot;: True},
        }

# BookInfoSerializer():
#    id = IntegerField(label=&quot;ID&quot;, read_only=True)
#    btitle = CharField(label=&quot;名称&quot;, max_length=20)
#    bpub_date = DateField(allow_null=True, label=&quot;发布日期&quot;, required=False)
#    bread = IntegerField(label=&quot;阅读量&quot;, max_value=2147483647, min_value=0, required=True)
#    bcomment = IntegerField(label=&quot;评论量&quot;, max_value=2147483647, min_value=0, required=True)
</code></pre>
<h1 id="4-视图">4. 视图</h1>
<h2 id="41-request-与-response">4.1 Request 与 Response</h2>
<h3 id="1-request">1. Request</h3>
<p>REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的<strong>Request</strong>类的对象。</p>
<p>REST framework 提供了<strong>Parser</strong>解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON、表单等）将请求数据进行parse解析，解析为类字典对象保存到<strong>Request</strong>对象中。</p>
<p><strong>Request对象的数据是自动根据前端发送数据的格式进行解析之后的结果。</strong></p>
<p>无论前端发送的哪种格式的数据，我们都可以以统一的方式读取数据。</p>
<h3 id="常用属性">常用属性</h3>
<h4 id="1）data">1）.data</h4>
<p><code>request.data</code> 返回解析之后的请求体数据。类似于Django中标准的<code>request.POST</code>和 <code>request.FILES</code>属性，但提供如下特性：</p>
<ul>
	<li>包含了解析之后的文件和非文件数据</li>
	<li>包含了对POST、PUT、PATCH请求方式解析后的数据</li>
	<li>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</li>
</ul>
<h4 id="2）query_params">2）.query_params</h4>
<p><code>request.query_params</code>与Django标准的<code>request.GET</code>相同，只是更换了更正确的名称而已。</p>
<h3 id="2-response">2. Response</h3>
<pre>
<code>rest_framework.response.Response
</code></pre>
<p>REST framework提供了一个响应类<code>Response</code>，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染）成符合前端需求的类型。</p>
<h3 id="构造方式">构造方式</h3>
<pre>
<code class="language-python">Response(data, status=None, template_name=None, headers=None, content_type=None)
</code></pre>
<p><code>data</code>数据不要是render处理之后的数据，只需传递python的内建类型数据即可，REST framework会使用<code>renderer</code>渲染器处理<code>data</code>。</p>
<p><code>data</code>不能是复杂结构的数据，如Django的模型类对象，对于这样的数据我们可以使用<code>Serializer</code>序列化器序列化处理后（转为了Python字典类型）再传递给<code>data</code>参数。</p>
<p>参数说明:</p>
<ul>
	<li><code>data</code>: 为响应准备的序列化处理后的数据；</li>
	<li><code>status</code>: 状态码，默认200；</li>
	<li><code>template_name</code>: 模板名称，如果使用<code>HTMLRenderer</code> 时需指明；</li>
	<li><code>headers</code>: 用于存放响应头信息的字典；</li>
	<li><code>content_type</code>: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数。</li>
</ul>
<h3 id="3-状态码">3. 状态码</h3>
<p>为了方便设置状态码，REST framewrok在<code>rest_framework.status</code>模块中提供了常用状态码常量。</p>
<h5 id="1）信息告知---1xx">1）信息告知 - 1xx</h5>
<pre>
<code class="language-python">HTTP_100_CONTINUE
HTTP_101_SWITCHING_PROTOCOLS
</code></pre>
<h5 id="2）成功---2xx">2）成功 - 2xx</h5>
<pre>
<code class="language-python">HTTP_200_OK
HTTP_201_CREATED
HTTP_202_ACCEPTED
HTTP_203_NON_AUTHORITATIVE_INFORMATION
HTTP_204_NO_CONTENT
HTTP_205_RESET_CONTENT
HTTP_206_PARTIAL_CONTENT
HTTP_207_MULTI_STATUS
</code></pre>
<h5 id="3）重定向---3xx">3）重定向 - 3xx</h5>
<pre>
<code class="language-python">HTTP_300_MULTIPLE_CHOICES
HTTP_301_MOVED_PERMANENTLY
HTTP_302_FOUND
HTTP_303_SEE_OTHER
HTTP_304_NOT_MODIFIED
HTTP_305_USE_PROXY
HTTP_306_RESERVED
HTTP_307_TEMPORARY_REDIRECT
</code></pre>
<h5 id="4）客户端错误---4xx">4）客户端错误 - 4xx</h5>
<pre>
<code class="language-python">HTTP_400_BAD_REQUEST
HTTP_401_UNAUTHORIZED
HTTP_402_PAYMENT_REQUIRED
HTTP_403_FORBIDDEN
HTTP_404_NOT_FOUND
HTTP_405_METHOD_NOT_ALLOWED
HTTP_406_NOT_ACCEPTABLE
HTTP_407_PROXY_AUTHENTICATION_REQUIRED
HTTP_408_REQUEST_TIMEOUT
HTTP_409_CONFLICT
HTTP_410_GONE
HTTP_411_LENGTH_REQUIRED
HTTP_412_PRECONDITION_FAILED
HTTP_413_REQUEST_ENTITY_TOO_LARGE
HTTP_414_REQUEST_URI_TOO_LONG
HTTP_415_UNSUPPORTED_MEDIA_TYPE
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE
HTTP_417_EXPECTATION_FAILED
HTTP_422_UNPROCESSABLE_ENTITY
HTTP_423_LOCKED
HTTP_424_FAILED_DEPENDENCY
HTTP_428_PRECONDITION_REQUIRED
HTTP_429_TOO_MANY_REQUESTS
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
</code></pre>
<h5 id="5）服务器错误---5xx">5）服务器错误 - 5xx</h5>
<pre>
<code class="language-python">HTTP_500_INTERNAL_SERVER_ERROR
HTTP_501_NOT_IMPLEMENTED
HTTP_502_BAD_GATEWAY
HTTP_503_SERVICE_UNAVAILABLE
HTTP_504_GATEWAY_TIMEOUT
HTTP_505_HTTP_VERSION_NOT_SUPPORTED
HTTP_507_INSUFFICIENT_STORAGE
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
</code></pre>
<h2 id="42-视图概览">4.2 视图概览</h2>
<p>REST framework 提供了众多的通用视图基类与扩展类，以简化视图的编写。</p>
<p>视图的继承关系：</p>
<p><img alt="通用视图继承关系" loading="lazy" src="/d/file/p/20221107/1600214884325377.png" /></p>
<p>视图的方法与属性：</p>
<p><img alt="视图的方法与属性" loading="lazy" src="/d/file/p/20221107/1600214885273686.png" /></p>
<h2 id="43-视图说明">4.3 视图说明</h2>
<h3 id="1-两个基类">1. 两个基类</h3>
<h4 id="1）apiview">1）APIView</h4>
<pre>
<code>rest_framework.views.APIView
</code></pre>
<p><code>APIView</code>是REST framework提供的所有视图的基类，继承自Django的<code>View</code>父类。</p>
<p><code>APIView</code>与<code>View</code>的不同之处在于：</p>
<ul>
	<li>传入到视图方法中的是REST framework的<code>Request</code>对象，而不是Django的<code>HttpRequeset</code>对象；</li>
	<li>视图方法可以返回REST framework的<code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式；</li>
	<li>任何<code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li>
	<li>在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。</li>
</ul>
<h5 id="支持定义的属性：">支持定义的属性：</h5>
<ul>
	<li><strong>authentication_classes</strong> 列表或元祖，身份认证类</li>
	<li><strong>permissoin_classes</strong> 列表或元祖，权限检查类</li>
	<li><strong>throttle_classes</strong> 列表或元祖，流量控制类</li>
</ul>
<p>在<code>APIView</code>中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。</p>
<p>举例：</p>
<pre>
<code class="language-python">from rest_framework.views import APIView
from rest_framework.response import Response

# url(r&quot;^books/$&quot;, views.BookListView.as_view()),
class BookListView(APIView):
    def get(self, request):
        books = BookInfo.objects.all()
        serializer = BookInfoSerializer(books, many=True)
        return Response(serializer.data)
</code></pre>
<h4 id="2）genericapiview">2）GenericAPIView</h4>
<pre>
<code>rest_framework.generics.GenericAPIView
</code></pre>
<p>继承自<code>APIVIew</code>，增加了对于列表视图和详情视图可能用到的通用支持方法。通常使用时，可搭配一个或多个Mixin扩展类。</p>
<h5 id="支持定义的属性：-2">支持定义的属性：</h5>
<ul>
	<li>列表视图与详情视图通用：
	<ul>
		<li><strong>queryset</strong> 列表视图的查询集</li>
		<li><strong>serializer_class</strong> 视图使用的序列化器</li>
	</ul></li>
	<li>列表视图使用：
	<ul>
		<li><strong>pagination_class</strong> 分页控制类</li>
		<li><strong>filter_backends</strong> 过滤控制后端</li>
	</ul></li>
	<li>详情页视图使用：
	<ul>
		<li><strong>lookup_field</strong> 查询单一数据库对象时使用的条件字段，默认为&quot;<code>pk</code>&quot;</li>
		<li><strong>lookup_url_kwarg</strong> 查询单一数据时URL中的参数关键字名称，默认与<strong>look_field</strong>相同</li>
	</ul></li>
</ul>
<h5 id="提供的方法：">提供的方法：</h5>
<ul>
	<li>
	<p>列表视图与详情视图通用：</p>
	<ul>
		<li>
		<p><strong>get_queryset(self)</strong></p>
		<p>返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回<code>queryset</code>属性，可以重写，例如：</p>
		<pre>
<code class="language-python">def get_queryset(self):
    user = self.request.user
    return user.accounts.all()
</code></pre></li>
		<li>
		<p><strong>get_serializer_class(self)</strong></p>
		<p>返回序列化器类，默认返回<code>serializer_class</code>，可以重写，例如：</p>
		<pre>
<code class="language-python">def get_serializer_class(self):
    if self.request.user.is_staff:
        return FullAccountSerializer
    return BasicAccountSerializer
</code></pre></li>
		<li>
		<h5 id="get_serializerself-args-kwargs">get_serializer(self, *args, **kwargs)</h5>
		<p>返回序列化器对象，被其他视图或扩展类使用，如果我们在视图中想要获取序列化器对象，可以直接调用此方法。</p>
		<p><strong>注意，在提供序列化器对象的时候，REST framework会向对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。</strong></p></li>
	</ul></li>
	<li>
	<p>详情视图使用：</p>
	<ul>
		<li>
		<p><strong>get_object(self)</strong> 返回详情视图所需的模型类数据对象，默认使用<code>lookup_field</code>参数来过滤queryset。 在试图中可以调用该方法获取详情信息的模型类对象。</p>
		<p><strong>若详情访问的模型类对象不存在，会返回404。</strong></p>
		<p><strong>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</strong></p></li>
	</ul></li>
</ul>
<p>举例：</p>
<pre>
<code class="language-python"># url(r&quot;^books/(?P&lt;pk&gt;d+)/$&quot;, views.BookDetailView.as_view()),
class BookDetailView(GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request, pk):
        book = self.get_object()
        serializer = self.get_serializer(book)
        return Response(serializer.data)
</code></pre>
<h3 id="2-五个扩展类">2. 五个扩展类</h3>
<h4 id="1）listmodelmixin">1）ListModelMixin</h4>
<p>列表视图扩展类，提供<code>list(request, *args, **kwargs)</code>方法快速实现列表视图，返回200状态码。</p>
<p>该Mixin的list方法会对数据进行过滤和分页。</p>
<p>源代码：</p>
<pre>
<code class="language-python">class ListModelMixin(object):
    &quot;&quot;&quot;
    List a queryset.
    &quot;&quot;&quot;
    def list(self, request, *args, **kwargs):
        # 过滤
        queryset = self.filter_queryset(self.get_queryset())
        # 分页
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        # 序列化
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
</code></pre>
<p>举例：</p>
<pre>
<code class="language-python">from rest_framework.mixins import ListModelMixin

class BookListView(ListModelMixin, GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request):
        return self.list(request)
</code></pre>
<h4 id="2）createmodelmixin">2）CreateModelMixin</h4>
<p>创建视图扩展类，提供<code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p>
<p>如果序列化器对前端发送的数据验证失败，返回400错误。</p>
<p>源代码：</p>
<pre>
<code class="language-python">class CreateModelMixin(object):
    &quot;&quot;&quot;
    Create a model instance.
    &quot;&quot;&quot;
    def create(self, request, *args, **kwargs):
        # 获取序列化器
        serializer = self.get_serializer(data=request.data)
        # 验证
        serializer.is_valid(raise_exception=True)
        # 保存
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

    def get_success_headers(self, data):
        try:
            return {&quot;Location&quot;: str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}
</code></pre>
<h4 id="3）-retrievemodelmixin">3） RetrieveModelMixin</h4>
<p>详情视图扩展类，提供<code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p>
<p>如果存在，返回200， 否则返回404。</p>
<p>源代码：</p>
<pre>
<code class="language-python">class RetrieveModelMixin(object):
    &quot;&quot;&quot;
    Retrieve a model instance.
    &quot;&quot;&quot;
    def retrieve(self, request, *args, **kwargs):
        # 获取对象，会检查对象的权限
        instance = self.get_object()
        # 序列化
        serializer = self.get_serializer(instance)
        return Response(serializer.data)
</code></pre>
<p>举例：</p>
<pre>
<code class="language-python">class BookDetailView(RetrieveModelMixin, GenericAPIView):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    def get(self, request, pk):
        return self.retrieve(request)
</code></pre>
<h4 id="4）updatemodelmixin">4）UpdateModelMixin</h4>
<p>更新视图扩展类，提供<code>update(request, *args, **kwargs)</code>方法，可以快速实现更新一个存在的数据对象。</p>
<p>同时也提供<code>partial_update(request, *args, **kwargs)</code>方法，可以实现局部更新。</p>
<p>成功返回200，序列化器校验数据失败时，返回400错误。</p>
<p>源代码：</p>
<pre>
<code class="language-python">class UpdateModelMixin(object):
    &quot;&quot;&quot;
    Update a model instance.
    &quot;&quot;&quot;
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop(&quot;partial&quot;, False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        if getattr(instance, &quot;_prefetched_objects_cache&quot;, None):
            # If &quot;prefetch_related&quot; has been applied to a queryset, we need to
            # forcibly invalidate the prefetch cache on the instance.
            instance._prefetched_objects_cache = {}

        return Response(serializer.data)

    def perform_update(self, serializer):
        serializer.save()

    def partial_update(self, request, *args, **kwargs):
        kwargs[&quot;partial&quot;] = True
        return self.update(request, *args, **kwargs)
</code></pre>
<h4 id="5）destroymodelmixin">5）DestroyModelMixin</h4>
<p>删除视图扩展类，提供<code>destroy(request, *args, **kwargs)</code>方法，可以快速实现删除一个存在的数据对象。</p>
<p>成功返回204，不存在返回404。</p>
<p>源代码：</p>
<pre>
<code class="language-python">class DestroyModelMixin(object):
    &quot;&quot;&quot;
    Destroy a model instance.
    &quot;&quot;&quot;
    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        self.perform_destroy(instance)
        return Response(status=status.HTTP_204_NO_CONTENT)

    def perform_destroy(self, instance):
        instance.delete()
</code></pre>
<h3 id="3-几个可用子类视图">3. 几个可用子类视图</h3>
<h4 id="1）-createapiview">1） CreateAPIView</h4>
<p>提供 post 方法</p>
<p>继承自： GenericAPIView、CreateModelMixin</p>
<h4 id="2）listapiview">2）ListAPIView</h4>
<p>提供 get 方法</p>
<p>继承自：GenericAPIView、ListModelMixin</p>
<h4 id="3）retireveapiview">3）RetireveAPIView</h4>
<p>提供 get 方法</p>
<p>继承自: GenericAPIView、RetrieveModelMixin</p>
<h4 id="4）destoryapiview">4）DestoryAPIView</h4>
<p>提供 delete 方法</p>
<p>继承自：GenericAPIView、DestoryModelMixin</p>
<h4 id="5）updateapiview">5）UpdateAPIView</h4>
<p>提供 put 和 patch 方法</p>
<p>继承自：GenericAPIView、UpdateModelMixin</p>
<h4 id="6）retrieveupdateapiview">6）RetrieveUpdateAPIView</h4>
<p>提供 get、put、patch方法</p>
<p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p>
<h4 id="7）retrieveupdatedestoryapiview">7）RetrieveUpdateDestoryAPIView</h4>
<p>提供 get、put、patch、delete方法</p>
<p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p>
<h2 id="44-视图集viewset">4.4 视图集ViewSet</h2>
<p>使用视图集ViewSet，可以将一系列逻辑相关的动作放到一个类中：</p>
<ul>
	<li>list() 提供一组数据</li>
	<li>retrieve() 提供单个数据</li>
	<li>create() 创建数据</li>
	<li>update() 保存数据</li>
	<li>destory() 删除数据</li>
</ul>
<p>ViewSet视图集类不再实现get()、post()等方法，而是实现动作 <strong>action</strong> 如 list() 、create() 等。</p>
<p>视图集只在使用as_view()方法的时候，才会将<strong>action</strong>动作与具体请求方式对应上。如：</p>
<pre>
<code class="language-python">class BookInfoViewSet(viewsets.ViewSet):

    def list(self, request):
        ...

    def retrieve(self, request, pk=None):
        ...
</code></pre>
<p>在设置路由时，我们可以如下操作</p>
<pre>
<code class="language-python">urlpatterns = [
    url(r&quot;^books/$&quot;, BookInfoViewSet.as_view({&quot;get&quot;:&quot;list&quot;}),
    url(r&quot;^books/(?P&lt;pk&gt;d+)/$&quot;, BookInfoViewSet.as_view({&quot;get&quot;: &quot;retrieve&quot;})
]
</code></pre>
<h3 id="1-action属性">1. action属性</h3>
<p>在视图集中，我们可以通过action对象属性来获取当前请求视图集时的action动作是哪个。</p>
<p>例如：</p>
<pre>
<code class="language-python">def get_serializer_class(self):
    if self.action == &quot;create&quot;:
        return OrderCommitSerializer
    else:
        return OrderDataSerializer
</code></pre>
<h3 id="2-常用视图集父类">2. 常用视图集父类</h3>
<h4 id="1）-viewset">1） ViewSet</h4>
<p>继承自<code>APIView</code>，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。</p>
<p>在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。</p>
<h4 id="2）genericviewset">2）GenericViewSet</h4>
<p>继承自<code>GenericAPIView</code>，作用也与GenericAPIVIew类似，提供了get_object、get_queryset等方法便于列表视图与详情信息视图的开发。</p>
<h4 id="3）modelviewset">3）ModelViewSet</h4>
<p>继承自<code>GenericAPIVIew</code>，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p>
<h4 id="4）readonlymodelviewset">4）ReadOnlyModelViewSet</h4>
<p>继承自<code>GenericAPIVIew</code>，同时包括了ListModelMixin、RetrieveModelMixin。</p>
<h3 id="3-视图集中定义附加action动作">3. 视图集中定义附加action动作</h3>
<p>在视图集中，除了上述默认的方法动作外，还可以添加自定义动作。</p>
<p>添加自定义动作需要使用<code>rest_framework.decorators.action</code>装饰器。</p>
<p>以action装饰器装饰的方法名会作为action动作名，与list、retrieve等同。</p>
<p>action装饰器可以接收两个参数：</p>
<ul>
	<li>
	<p><strong>methods</strong>: 该action支持的请求方式，列表传递</p></li>
	<li>
	<dl>
		<dt>detail</dt>
		<dd>表示是action中要处理的是否是视图资源的对象（即是否通过url路径获取主键）</dd>
	</dl>
	<ul>
		<li>True 表示使用通过URL获取的主键对应的数据对象</li>
		<li>False 表示不使用URL获取主键</li>
	</ul></li>
</ul>
<p>举例：</p>
<pre>
<code class="language-python">from rest_framework import mixins
from rest_framework.viewsets import GenericViewSet
from rest_framework.decorators import action

class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    # detail为False 表示不需要处理具体的BookInfo对象
    @action(methods=[&quot;get&quot;], detail=False)
    def latest(self, request):
        &quot;&quot;&quot;
        返回最新的图书信息
        &quot;&quot;&quot;
        book = BookInfo.objects.latest(&quot;id&quot;)
        serializer = self.get_serializer(book)
        return Response(serializer.data)

    # detail为True，表示要处理具体与pk主键对应的BookInfo对象
    @action(methods=[&quot;put&quot;], detail=True)
    def read(self, request, pk):
        &quot;&quot;&quot;
        修改图书的阅读量数据
        &quot;&quot;&quot;
        book = self.get_object()
        book.bread = request.data.get(&quot;read&quot;)
        book.save()
        serializer = self.get_serializer(book)
        return Response(serializer.data)
</code></pre>
<p>url的定义</p>
<pre>
<code class="language-python">urlpatterns = [
    url(r&quot;^books/$&quot;, views.BookInfoViewSet.as_view({&quot;get&quot;: &quot;list&quot;})),
    url(r&quot;^books/latest/$&quot;, views.BookInfoViewSet.as_view({&quot;get&quot;: &quot;latest&quot;})),
    url(r&quot;^books/(?P&lt;pk&gt;d+)/$&quot;, views.BookInfoViewSet.as_view({&quot;get&quot;: &quot;retrieve&quot;})),
    url(r&quot;^books/(?P&lt;pk&gt;d+)/read/$&quot;, views.BookInfoViewSet.as_view({&quot;put&quot;: &quot;read&quot;})),
]
</code></pre>
<h3 id="4-视图集的继承关系">4. 视图集的继承关系</h3>
<p><img alt="视图集的继承关系" loading="lazy" src="/d/file/p/20221107/1600214890972278.png" /></p>
<h2 id="45-路由routers">4.5 路由Routers</h2>
<p>对于视图集ViewSet，我们除了可以自己手动指明请求方式与动作action之间的对应关系外，还可以使用Routers来帮助我们快速实现路由信息。</p>
<p>REST framework提供了两个router</p>
<ul>
	<li><strong>SimpleRouter</strong></li>
	<li><strong>DefaultRouter</strong></li>
</ul>
<h3 id="1-使用方法">1. 使用方法</h3>
<p>1） 创建router对象，并注册视图集，例如</p>
<pre>
<code class="language-python">from rest_framework import routers

router = routers.SimpleRouter()
router.register(r&quot;books&quot;, BookInfoViewSet, base_name=&quot;book&quot;)
</code></pre>
<p>register(prefix, viewset, base_name)</p>
<ul>
	<li>prefix 该视图集的路由前缀</li>
	<li>viewset 视图集</li>
	<li>base_name 路由名称的前缀</li>
</ul>
<p>如上述代码会形成的路由如下：</p>
<pre>
<code class="language-python">^books/$    name: book-list
^books/{pk}/$   name: book-detail
</code></pre>
<p>2）添加路由数据</p>
<p>可以有两种方式：</p>
<pre>
<code class="language-python">urlpatterns = [
    ...
]
urlpatterns += router.urls
</code></pre>
<p>或</p>
<pre>
<code class="language-python">urlpatterns = [
    ...
    url(r&quot;^&quot;, include(router.urls))
]
</code></pre>
<h3 id="2-视图集中包含附加action的">2. 视图集中包含附加action的</h3>
<pre>
<code class="language-python">class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    queryset = BookInfo.objects.all()
    serializer_class = BookInfoSerializer

    @action(methods=[&quot;get&quot;], detail=False)
    def latest(self, request):
        ...

    @action(methods=[&quot;put&quot;], detail=True)
    def read(self, request, pk):
        ...
</code></pre>
<p>此视图集会形成的路由：</p>
<pre>
<code class="language-python">^books/latest/$    name: book-latest
^books/{pk}/read/$  name: book-read
</code></pre>
<h3 id="3-路由router形成url的方式">3. 路由router形成URL的方式</h3>
<p>1） SimpleRouter</p>
<p><img alt="SimpleRouter" loading="lazy" src="/d/file/p/20221107/1600214891878939.png" /></p>
<p>2）DefaultRouter</p>
<p><img alt="DefaultRouter" loading="lazy" src="/d/file/p/20221107/1600214892884651.png" /></p>
<p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。</p>
<h1 id="5-其他功能">5. 其他功能</h1>
<h2 id="51-版本">5.1 版本</h2>
<p>可以在配置文件中配置全局默认的版本方案</p>
<pre>
<code class="language-python">REST_FRAMEWORK = {
    # 版本配置
    &quot;DEFAULT_VERSIONING_CLASS&quot;: &quot;rest_framework.versioning.URLPathVersioning&quot;,
    &quot;ALLOWED_VERSIONS&quot;: [&quot;v1&quot;, &quot;v2&quot;],
}
</code></pre>
<p>urls</p>
<pre>
<code class="language-python">from django.conf.urls import url, include
urlpatterns = [
    # 版本管理
    url(r&quot;^api/(?P&lt;version&gt;w+)/&quot;, include(&quot;api.urls&quot;)),
]
</code></pre>
<h2 id="52-认证authentication">5.2 认证Authentication</h2>
<p>可以在配??</p></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/python/biji/289.html'>python 列表操作</a><a>下一篇</a><a href='/python/biji/291.html'>3种Python检测URL状态</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>