<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimal-ui">
    <title>Django笔记：ORM模型_IDC笔记</title>
    <meta name="keywords" content=",Python教程"/>
    <meta name="description" content="Django中操作数据库的方式有两种，一种是使用ORM模型，另一种是直接执行SQL，推荐使用ORM模型的方式来管理数据库，因为当需要执行的数据库操作过多时，第二种方式产生的SQL会非常难于"/>
    <meta content="Responsive admin theme build on top of Bootstrap 4" name="description" />
    <meta content="idcnote.com" name="author"/>
    <link rel="shortcut icon" href="/skin1/images/favicon.ico">
    <!--Morris Chart CSS -->
    <link rel="stylesheet" href="/skin1/css/morris.css">
    <link href="/skin1/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/metismenu.min.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/icons.css" rel="stylesheet" type="text/css">
    <link href="/skin1/css/style.css" rel="stylesheet" type="text/css">
<link href="/SyntaxHighlighter/shCoreDefault.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="/SyntaxHighlighter/shCore.js"></script>
<script type="text/javascript">
 SyntaxHighlighter.all();
</script>
<script>
var paras = document.getElementsByTagName("pre");
for ( var i=0;i<paras.length;i++ ) {
    paras[i].setAttribute("class","brush:php;toolbar:false");     
}
</script>
</head>
<body>
<!-- Begin page -->
		<div id="wrapper">
			<!-- Top Bar Start -->
			<div class="topbar">
				<!-- LOGO -->
				<div class="topbar-left">
					<a href="/" class="logo">
						<span class="logo-light">
                            <i class="mdi mdi-camera-control"></i>IDC笔记
                        </span>
						<span class="logo-sm">
                            <i class="mdi mdi-camera-control"></i>
                        </span>
					</a>
				</div>
				<nav class="navbar-custom">
					<ul class="navbar-right list-inline float-right mb-0">
						<!--<li class="dropdown notification-list list-inline-item d-none d-md-inline-block">
							<a class="nav-link waves-effect" href="#" id="btn-fullscreen">
								<i class="mdi mdi-arrow-expand-all noti-icon"></i>
							</a>
						</li>
						<li class="dropdown notification-list list-inline-item">
							<div class="dropdown notification-list nav-pro-img">
								<a class="dropdown-toggle nav-link arrow-none nav-user" data-toggle="dropdown" href="#" role="button" aria-haspopup="false" aria-expanded="false">
									<img src="/skin1/picture/user-4.jpg" alt="user" class="rounded-circle">
								</a>
								<div class="dropdown-menu dropdown-menu-right profile-dropdown ">
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-account-circle"></i> Profile</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-wallet"></i> Wallet</a>
									<a class="dropdown-item d-block" href="#">
										<span class="badge badge-success float-right">11</span>
										<i class="mdi mdi-settings"></i> Settings</a>
									<a class="dropdown-item" href="#">
										<i class="mdi mdi-lock-open-outline"></i> Lock screen</a>
									<div class="dropdown-divider"></div>
									<a class="dropdown-item text-danger" href="#">
										<i class="mdi mdi-power text-danger"></i> Logout</a>
								</div>
							</div>
						</li>
						-->
					</ul>
					<ul class="list-inline menu-left mb-0">
						<li class="float-left">
							<button class="button-menu-mobile open-left waves-effect">
                            <i class="mdi mdi-menu"></i>
                        </button>
						</li>
						<li class="d-none d-md-inline-block">
							<form role="search" class="app-search">
								<div class="form-group mb-0">
									<input type="text" class="form-control" placeholder="Search..">
									<button type="submit"><i class="fa fa-search"></i></button>
								</div>
							</form>
						</li>
					</ul>
				</nav>
			</div>
<!-- ========== Left Sidebar Start ========== -->
<div class="left side-menu">
    <div class="slimscroll-menu" id="remove-scroll">
    <!--- Sidemenu -->
    <div id="sidebar-menu">
    <!-- Left Menu Start -->
    <ul class="metismenu" id="side-menu">
			<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python入门			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/python/1.html">Python环境搭建</a></li><li><a href="/python/python/2.html">Python解释器及IDLE教程</a></li><li><a href="/python/python/3.html">Pycharm安装及使用教程</a></li><li><a href="/python/python/4.html">学习方向及教程规划</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python基础语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/basic/5.html">第一个Python实例</a></li><li><a href="/python/basic/6.html">Python编码规范</a></li><li><a href="/python/basic/7.html">Python标识符和关键字</a></li><li><a href="/python/basic/9.html">Python基本数据类型介绍</a></li><li><a href="/python/basic/8.html">Python变量</a></li><li><a href="/python/basic/10.html">基本数据类型之字符串</a></li><li><a href="/python/basic/11.html">布尔类型和强制类型转换</a></li><li><a href="/python/basic/12.html">Python的输入和输出方法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python入门语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/syntax/13.html">python算术运算符和关系运算符</a></li><li><a href="/python/syntax/14.html">python算术运算符和关系运算符</a></li><li><a href="/python/syntax/15.html">python位运算符</a></li><li><a href="/python/syntax/16.html">Python控制结构详解</a></li><li><a href="/python/syntax/17.html">python基础ifelse选择结构详解</a></li><li><a href="/python/syntax/18.html">python选择结构的嵌套</a></li><li><a href="/python/syntax/20.html">Python基础for循环语句详解</a></li><li><a href="/python/syntax/19.html">Pyhon基础while循环语句详解</a></li><li><a href="/python/syntax/21.html">python循环嵌套</a></li><li><a href="/python/syntax/24.html">Python序列的加法和乘法操作详解</a></li><li><a href="/python/syntax/23.html">Python序列详解（包括索引和切片）</a></li><li><a href="/python/syntax/22.html">python基础break语句详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python核心语法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/core/25.html">Python序列常用的内置函数详解</a></li><li><a href="/python/core/26.html">Python列表list的基础操作与代码实现</a></li><li><a href="/python/core/27.html">Python列表list操作(遍历查找增加删除修改)实例详解</a></li><li><a href="/python/core/28.html">列表的排序和逆序</a></li><li><a href="/python/core/29.html">列表推导式</a></li><li><a href="/python/core/30.html">python二维列表</a></li><li><a href="/python/core/31.html">python元组的操作详解</a></li><li><a href="/python/core/32.html">python字典及基础操作</a></li><li><a href="/python/core/33.html">python字典常用函数（clear、get、items、keys、values、pop）</a></li><li><a href="/python/core/34.html">字典-混合字典和字典推导式</a></li><li><a href="/python/core/35.html">python集合类型介绍</a></li><li><a href="/python/core/36.html">集合的运算（交集、并集和差集）</a></li><li><a href="/python/core/37.html">Python字符串基础操作</a></li><li><a href="/python/core/38.html">Python字符串常用方法</a></li><li><a href="/python/core/39.html">字符串的测试方法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python函数			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/functions/42.html">python函数的创建和调用</a></li><li><a href="/python/functions/43.html">python函数的参数传递</a></li><li><a href="/python/functions/44.html">python函数的返回值</a></li><li><a href="/python/functions/46.html">python匿名函数</a></li><li><a href="/python/functions/47.html">python三大基础函数</a></li><li><a href="/python/functions/48.html">python递归函数</a></li><li><a href="/python/functions/49.html">python内置函数</a></li><li><a href="/python/functions/45.html">python变量的作用域</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 面向对象编程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/programming/50.html">python面向对象编程</a></li><li><a href="/python/programming/51.html">python类的定义和构造方法及参数传递</a></li><li><a href="/python/programming/52.html">python类方法</a></li><li><a href="/python/programming/53.html">python继承实例讲解</a></li><li><a href="/python/programming/54.html">模块概述</a></li><li><a href="/python/programming/55.html">Python创建和引入模块实例详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python模块			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/modular/56.html">Python引入math模块及库函数大全</a></li><li><a href="/python/modular/57.html">random模块</a></li><li><a href="/python/modular/58.html">datetime模块</a></li><li><a href="/python/modular/59.html">Python如何安装第三方模块？</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 异常处理和程序调试			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/exception/60.html">异常问题和常见异常</a></li><li><a href="/python/exception/61.html">Python异常处理语句try,except实例详解</a></li><li><a href="/python/exception/62.html">Python异常处理语句实例详解二</a></li><li><a href="/python/exception/63.html">Python程序调试图文教程</a></li><li><a href="/python/exception/64.html">使用assert断言对Ptyhon程序调试分析</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 文件及目录操作			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/file/65.html">python文件操作</a></li><li><a href="/python/file/66.html">python读取文件</a></li><li><a href="/python/file/67.html">python中os模块和os.path模块</a></li><li><a href="/python/file/68.html">目录管理</a></li><li><a href="/python/file/69.html">Python项目管理操作</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> GUI编程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/program/70.html">GUI编程</a></li><li><a href="/python/program/71.html">Tkinter模块(1)-简介和Label</a></li><li><a href="/python/program/72.html">Tkinter模块(2)-Frame和Button</a></li><li><a href="/python/program/73.html">Tkinter模块(3)-Entry</a></li><li><a href="/python/program/74.html">Tkinter模块(4)-Radio和Check</a></li><li><a href="/python/program/75.html">Tkinter模块(5)-Canvas</a></li><li><a href="/python/program/76.html">Tkinter模块(6)-练习</a></li><li><a href="/python/program/77.html">wxPython模块(1)-简介和初始化</a></li><li><a href="/python/program/78.html">wxPython模块(2)-文本控件</a></li><li><a href="/python/program/79.html">wxPython模块(3)-按钮和复选框</a></li><li><a href="/python/program/80.html">wxPython(4)-布局</a></li><li><a href="/python/program/81.html">wxPython(5)-事件管理</a></li><li><a href="/python/program/82.html">wxPython(6)-下拉列表和菜单</a></li><li><a href="/python/program/83.html">综合案例</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 进程和线程			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/processes/84.html">Python进程和线程的区别</a></li><li><a href="/python/processes/85.html">Python如何创建线程</a></li><li><a href="/python/processes/87.html">Python临界区与线程安全（线程通信）</a></li><li><a href="/python/processes/86.html">Python线程管理</a></li><li><a href="/python/processes/89.html">Python进程间通信代码详解</a></li><li><a href="/python/processes/88.html">Python创建进程的方式详解</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 数据库管理			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/database/91.html">MySQL下载安装图文教程</a></li><li><a href="/python/database/90.html">数据库概述</a></li><li><a href="/python/database/92.html">Navicat for MySQL管理软件安装使用图文教程</a></li><li><a href="/python/database/93.html">对象和游标</a></li><li><a href="/python/database/95.html">SQlite数据库(2)</a></li><li><a href="/python/database/94.html">SQlite数据库(1)</a></li><li><a href="/python/database/96.html">PyMySQL数据库的使用</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> Python算法			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/algorithm/97.html">python枚举算法</a></li><li><a href="/python/algorithm/98.html">python递归算法</a></li><li><a href="/python/algorithm/99.html">python分治算法</a></li><li><a href="/python/algorithm/101.html">python试探算法</a></li><li><a href="/python/algorithm/100.html">python贪心算法</a></li>		</ul>
	</li>
		<li>
		<a href="javascript:void(0);" class="waves-effect">
			<i class="icon-share"></i>
			<span> 爬虫			<span class="float-right menu-arrow">
			<i class="mdi mdi-chevron-right"></i>
			</span> 
			</span>
		</a>
		<ul class="submenu">
			 <li><a href="/python/reptile/102.html">python爬虫概述</a></li><li><a href="/python/reptile/103.html">python爬虫协议</a></li><li><a href="/python/reptile/104.html">python爬虫技术基础(1)-网络请求</a></li><li><a href="/python/reptile/106.html">python正则表达式(1)</a></li><li><a href="/python/reptile/105.html">python爬虫技术基础(2)header是处理及网络超时</a></li><li><a href="/python/reptile/108.html">BeautifulSoup(1)</a></li><li><a href="/python/reptile/107.html">python正则表达式(2)</a></li><li><a href="/python/reptile/109.html">BeautifulSoup(2)</a></li><li><a href="/python/reptile/110.html">Python爬虫入门抓取天气信息</a></li>		</ul>
	</li>
		<li>
	    <a href="/python/biji" class="waves-effect">
		    <i class="icon-share"></i>
		    <span>Python笔记
		       	<span class="float-right menu-arrow">
		       	<i class="mdi mdi-chevron-right"></i>
		       	</span>
		    </span>
	    </a>
	</li>
	</ul>
</div>
<!-- Sidebar -->
<div class="clearfix"></div>
</div>
<!-- Sidebar -left -->
</div>
<!-- Left Sidebar End -->
<!-- Start right Content here -->
<div class="content-page">
	<div class="content">
		<div class="container-fluid">
			<div class="page-title-box">
				<div class="row align-items-center">
					<div class="col-sm-6">
						<h1 class="page-title">Django笔记：ORM模型</h1>
					</div>
				</div>
				<!-- end row -->
			</div>
			<!-- end page-title -->
			<!-- START ROW -->
			<div class="panel panel-forbid">
				<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>内容摘要</div>
			    <div class="panel-content">
			    <span>Django中操作数据库的方式有两种，一种是使用ORM模型，另一种是直接执行SQL，推荐使用ORM模型的方式来管理数据库，因为当需要执行的数据库操作过多时，第二种方式产生的SQL会非常难于</span>                                     
		    	</div>
			    <div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>文章正文</div>
			    <div class="panel-content">
			    <span><p>Django中操作数据库的方式有两种，一种是使用ORM模型，另一种是直接执行SQL，推荐使用ORM模型的方式来管理数据库，因为当需要执行的数据库操作过多时，第二种方式产生的SQL会非常难于管理和维护，而第一种ORM模型的方式因为是操作的类，并没有和SQL本身直接打交道，而且并没有针对具体的数据库类型，只要是Django支持的数据库，都可以使用已有的ORM模型，所以相比之下会更加方便一点，当然，具体使用哪种方式还是看个人和工作需要了。<br><strong>注：</strong>本文中涉及到数据库实际案例和说明的时候，如具体的SQL描述等，都是使用的MySQL数据库。</p>
<h2 id="一、orm简介">一、ORM简介</h2>
<p>ORM（Object Relational Mapping），即对象关系映射，ORM模型指的就是Django中的模型类，通过ORM模型，我们可以通过操作类的方式去操作数据库，而不用写原生的SQL语句。ORM模型会把类映射为表，把类的一个实例映射为表中的一行数据（即一条记录），把类的属性映射为字段。另外需要说的是，虽然我们操作的是类，但是ORM模型底层还是会把我们的这些操作转换为原生的SQL语句去执行，相当于是简化了我们编程人员的工作，不用我们自己考虑原生SQL相关的问题。<br>
使用ORM的优点：</p>
<ul>
<li>易用性：使用ORM模型做数据库的开发可以有效的减少重复SQL的编写，写出来的模型也更加直观、清晰。</li>
<li>性能损耗小：ORM模型转换为底层数据库操作指令确实存在一些开销，但是这种开销其实很少，而且从实际情况来看，相对于ORM模型带来的好处是远大于它的损耗的。</li>
<li>设计灵活：可以轻松写出复杂的查询。</li>
<li>可移植性：ORM模型并不是针对某种数据库来开发的，它的开发设计是无关于具体的数据库的，Django封装了底层的数据库实现，可以支持多种数据库，包括MySQL、PostgreSQL和SQLite，可以非常轻松的实现数据库的切换。</li>
</ul>
<p><strong>注：</strong>代码中可以通过打印<code>django.db.connection.queries</code>来查看Django最近执行的SQL。在开发中，如果想要了解在执行了某个ORM模型的操作后，Django在底层具体执行了什么样的SQL，就可以通过这个方式来查看。</p>
<h2 id="二、创建和使用orm模型">二、创建和使用ORM模型</h2>
<p>下面的描述中的<code>models</code>都是来自<code>from django.db import models</code>，就不再特别说明了。</p>
<h3 id="1-创建orm模型">1. 创建ORM模型</h3>
<p>通常会使用命令<code>python manage.py startapp [app名称]</code>创建一个子app，在此app文件夹中会默认生成一个<code>models.py</code>文件，一般我们就在这个文件中编写ORM模型类。编写一个ORM模型类有一些基本点：</p>
<ul>
<li>
<strong>模型定义：</strong>ORM模型类必须继承自<code>models.Model</code>或其子类，一个模型类对应于数据库中的一张表。</li>
<li>
<strong>表名：</strong>如果没有指定表名，则以“app名称_类名”的全小写作为数据库中的表名。想要自定义表名，可以定义一个名为<code>Meta</code>的内部类，在类中指定<code>db_table</code>属性作为自定义表名。</li>
<li>
<strong>属性字段定义：</strong>属性字段是直接定义在类中的，而不是定义在<code>__init__()</code>等方法中的，一个属性对应于表中的一个字段，并且每种属性都有其对应<code>Field</code>类，不同的<code>Field</code>类对应于数据库中的不同数据类型。</li>
<li>
<strong>字段名：</strong>如果在属性定义中没有指定字段名，则默认以属性名的全小写作为数据库中的字段名。想要自定义字段名，可以在定义属性字段时，给相应的<code>Field</code>指定<code>db_column</code>参数作为自定义的字段名。</li>
</ul>
<p>示例：在<code>models.py</code>中创建一个Book模型</p>
<pre><code class="language-python">from django.db import models


# ORM模型类必须继承自models.Model或其子类
class Book(models.Model):
    # 如果没有指定表名，则以“app名称_类名”的全小写作为表名
    # 如果在属性定义中没有指定字段名，则默认以属性名的全小写作为字段名

    # 属性（字段）类型都在models中，
    # models.AutoField表示自动增长类型，primary_key参数设置是否为True
    # 如果一个ORM模型类没有定义主键，则会自动创建一个叫id的自动增长类型的主键字段，
    # 即当前这个id属性不定义也是可以的，底层会自动生成
    id = models.AutoField(primary_key=True)
    # models.CharField表示可变长类型，max_length参数设置最大长度，
    # null设置是否允许为空，默认为False
    name = models.CharField(max_length=100, null=False)
    author = models.CharField(max_length=100, null=False)
    # models.FloatField表示浮点类型，default参数设置为空时的默认值
    price = models.FloatField(null=False, default=0)
</code></pre>
<h3 id="2-映射orm模型到数据库">2. 映射ORM模型到数据库</h3>
<p>编写好模型后，就需要将它映射到数据库中，将代码中的类变成数据库中的表。首先需要确保该app在<code>settings.py</code>的<code>INSTALLED_APPS</code>中已配置（将app名称添加到此列表中即可），然后在命令窗口cd到项目根目录（确保已进入对应的Python环境），按顺序执行以下两个命令就可以在数据库中生成对应的表了：</p>
<ol>
<li>
<code>python manage.py makemigrations</code>：根据Python中的模型类生成对应的迁移脚本。执行完此命令会在项目的app目录下的<code>migrations</code>文件夹下生成一些脚本文件，此时还没有映射到数据库。通常执行此命令也够了，不需要指定别的参数，但这里还是介绍下此命令的常用参数选项：
<ul>
<li>
<code>app_label</code>：<code>makemigrations</code>后面可以跟app名称，表示此次只会针对指定的app生成迁移脚本，如果没有指定这个参数，则默认为<code>INSTALLED_APPS</code>中所有的app。</li>
<li>
<code>--name</code>：给此次生成的迁移脚本指定名称，这个参数通常是在默认的名称不能正确表达此次迁移所做的事的时候使用。</li>
<li>
<code>--empty</code>：表示生成一个空的迁移文件，然后自己在里面写迁移脚本。（当你对迁移脚本比较熟的时候可以自己编写，但是也用的较少）</li>
</ul>
</li>
<li>
<code>python manage.py migrate</code>：将迁移脚本映射到数据库中。执行完此命令后数据库中就会生成对应的表了。通常执行此命令也够了，不需要指定别的参数，但这里还是介绍下此命令常用的参数选项：
<ul>
<li>
<code>app_label</code>：<code>migrate</code>可以跟app名称，表示将指定app的迁移脚本映射到数据库中，如果不指定，默认为<code>INSTALLED_APPS</code>中所有的app。</li>
<li>
<code>app_label migrationname</code>：将某个app下指定的迁移文件映射到数据库中，注意，迁移文件不用写后缀名。</li>
<li>
<code>--fake</code>：会将指定的迁移脚本名称添加到数据库中，但是不执行对应的数据库映射操作，默认是全部迁移脚本。每次使用<code>migrate</code>命令时都会把执行过的迁移脚本存储在数据库的<code>django_migrations</code>表（自动生成的表）中，并且执行时会检查已经在数据库中的迁移脚本就不会再去执行了。</li>
<li>
<code>--fake-initial</code>：使用这个参数时，通常需要先手动删除数据库中<code>django_migrations</code>表的所有迁移脚本记录以及对应app下所有迁移脚本文件，然后执行<code>makemigrations</code>命令生成一个迁移脚本文件，再执行此命令时，就会在数据库中将此迁移脚本记录进去，并标记为一个初始状态的迁移脚本，表示以后的迁移脚本都会依赖于此文件，但是不会去执行此迁移脚本对应的数据库映射操作。</li>
</ul>
</li>
</ol>
<h3 id="3-增删改查基础操作">3. 增删改查基础操作</h3>
<p>对数据库的数据进行增删改查操作，通常都是直接通过ORM模型类的<code>objects</code>属性来进行，<code>objects</code>属性中定义了许多和数据库相关的操作，大部分的数据库操作都可以通过<code>objects</code>属性来完成。示例代码如下：<br>
示例：定义一个视图函数，在其中对Book模型进行简单的增删改查操作</p>
<pre><code class="language-python">from django.http import HttpResponse
from .models import Book


def index(request):
    # 增：添加一条数据到数据库中，实例化一个模型类后调用save方法即可
    # book = Book(name="了不起的盖茨比", author="弗朗西斯·斯科特·基·菲茨杰拉德", price=29.8)
    # book.save()

    # 查：查询一条数据
    # 查询方式一：根据主键查找，get方法返回的是一个实例对象
    # 参数pk为primary key的缩写，当然也可以传入具体的主键名称，如get(id=1)
    # book = Book.objects.get(pk=1)
    
    # 查询方式二：根据过滤条件查找，注意filter返回的是一个数据集对象，而不是单一的数据对象
    # book = Book.objects.filter(name="了不起的盖茨比").first()

    # 删：删除一条数据，调用对应的delete方法即可
    # book.delete()

    # 改：修改一条数据，直接修改对象的属性值，最后调用save方法同步到数据库中即可
    book = Book.objects.get(pk=1)
    book.price = 40
    book.save()

    return HttpResponse("书籍删除成功！")
</code></pre>
<h2 id="三、orm模型常用字段field">三、ORM模型常用字段Field</h2>
<h3 id="1-常用字段field">1. 常用字段Field</h3>
<p>模型中一个<code>Field</code>对应于数据库中的一种数据类型，定义模型时根据需要定义相关类型的属性即可，常用的字段<code>Field</code>如下：</p>
<ul>
<li>
<code>AutoField</code>：具有自动增长特性的<code>int</code>类型。实际开发中很少用到这个类型， 如果一个表没有指定主键的话，ORM模型会自动为表创建一个名为<code>id</code>的此类型字段。</li>
<li>
<code>BigAutoField</code>：类似<code>AutoField</code>，为更大范围的64位整型<code>bigint</code>。</li>
<li>
<code>BooleanField</code>：Python代码中接收的是<code>True/False</code>，对应于数据库中的<code>tinyint</code>类型（<code>1/0</code>），注意，此类型是不能指定<code>null</code>参数的，而且是不能为空的，如果想要允许为空，可以使用<code>NullBooleanField</code>字段。</li>
<li>
<code>NullBooleanField</code>：与<code>BooleanField</code>类似，但是允许为空。</li>
<li>
<code>CharField</code>：Python代码中接收的是字符串类型，对应于数据库中的<code>varchar</code>，使用时必须指定<code>max_length</code>参数，不然会报错。而且如果超过了254个字符，那么就不推荐使用这个类型了，建议使用<code>TextField</code>。</li>
<li>
<code>TextField</code>：文本类型，对应于数据库中的<code>longtext</code>类型。</li>
<li>
<code>DateTimeField</code>：在Python中为<code>datetime.datetime</code>类型，可以使用<code>datetime.datetime.now</code>或者<code>django.utils.timezone.now/localtime</code>等方法设置该字段值，对应于数据库中的<code>datetime</code>类型，可以记录年月日和时分秒信息。此类型的字段有两个参数需要注意下：
<ul>
<li>
<code>auto_now_add</code>：如果设置为<code>True</code>，在第一次添加数据时，如果没有传值，则会自动获取当前时间。</li>
<li>
<code>auto_now</code>：如果设置为<code>True</code>，在对象每次修改数据调用<code>save()</code>方法时都会用当前时间更新这个字段。</li>
<li>注：在<code>settings.py</code>中如果配置项<code>USE_TZ</code>设置为True，则<code>django.utils.timezone.now/localtime</code>获取的时间就会根据配置项<code>TIME_ZONE</code>设置的时区来处理，默认为<code>UTC</code>时区，也可以将其更改为<code>Asia/Shanghai</code>（即中国东八区）。</li>
</ul>
</li>
<li>
<code>DateField</code>：在Python中为<code>datetime.date</code>类型，对应于数据库中的<code>date</code>类型，可以记录年月日信息。与<code>DateTimeField</code>字段类似，这个字段也有<code>auto_now_add</code>和<code>auto_now</code>可以使用。</li>
<li>
<code>TimeField</code>：在Python中为<code>datetime.time</code>，对应于数据库中的<code>time</code>类型，可以记录时分秒信息。</li>
<li>
<code>EmailField</code>：类似于<code>CharField</code>，在数据库中也是<code>varchar</code>类型，默认最大长度<code>max_length</code>为254个字符。需要注意的是，这个类型本身只是个普通的字符串类型，并不会进行邮箱格式的验证，其作用是在后续根据ORM模型生成对应表单对象的时候，会根据这个类型对表单中提交的数据进行邮箱格式验证。</li>
<li>
<code>FileField</code>：用于存储文件。</li>
<li>
<code>ImageField</code>：用于存储图片文件。</li>
<li>
<code>FloatField</code>：浮点类型，对应于数据库中的<code>float</code>类型。</li>
<li>
<code>IntegerField</code>：整型。</li>
<li>
<code>BigIntegerField</code>：大整型。</li>
<li>
<code>PositiveIntegerField</code>：正整型。</li>
<li>
<code>SmallIntegerField</code>：小整型。</li>
<li>
<code>PositiveSmallIntegerField</code>：正小整型。</li>
<li>
<code>UUIDField</code>：只能存储<code>uuid</code>格式的字符串，通常用作主键类型。</li>
<li>
<code>URLField</code>：类似于<code>CharField</code>，只能存储url格式的字符串，默认的最大长度<code>max_length</code>为200。</li>
</ul>
<h3 id="2-field常用参数">2. Field常用参数</h3>
<p>不同的<code>Field</code>可能拥有自己特殊的参数，这里就只列举一些大多<code>Field</code>都有的常用参数：</p>
<ul>
<li>
<code>null</code>：设置这个字段在数据库中存储时是否允许为空<code>NULL</code>，默认为False。注意，如果是False，而使用时又没有传递值，则Django会默认传递一个空字符串，如果是True，即允许为空，但是如果也没有传递值，则数据库中存储的值就是<code>NULL</code>，而不是空字符串了。</li>
<li>
<code>blank</code>：设置这个字段在表单验证时是否允许为空，默认为False。这个参数与<code>null</code>的区别在于，<code>null</code>是对应于数据库存储的，而<code>blank</code>是对应于表单验证的。</li>
<li>
<code>db_column</code>：设置字段名，默认为模型类中对应属性名的全小写作为字段名。</li>
<li>
<code>default</code>：设置默认值，可以是一个值或函数，但是不支持<code>lambda</code>表达式。</li>
<li>
<code>primary_key</code>：是否为主键，默认为False。</li>
<li>
<code>unique</code>：设置此字段是否唯一，通常用于设置手机号、邮箱等字段。</li>
</ul>
<h3 id="3-meta内部类">3. Meta内部类</h3>
<p>如果需要定义一些模型（表）级别的配置，可以在模型类中定义一个名叫<code>Meta</code>的内部类，然后在类中配置相关属性即可。常用的属性：</p>
<ul>
<li>
<code>db_table</code>：表名，如果没有指定的话，默认以<code>app名称_模型类名</code>全小写形式作为表名。</li>
<li>
<code>ordering</code>：列表类型，元素为字段名，表示提取数据时会根据指定的字段来进行排序，默认为升序，如果想要降序，则在字段名称前加一个负号<code>-</code>即可。</li>
</ul>
<p>示例：定义一个<code>Author</code>模型，并指定表名为<code>author</code>。</p>
<pre><code class="language-python">"""models.py"""
from django.db import models
from django.utils.timezone import localtime


class Author(models.Model):
    username = models.CharField(max_length=100, null=True)
    age = models.IntegerField(null=True, db_column="author_age")
    create_time = models.DateTimeField(default=localtime)
    
    class Meta:
        # 指定表名
        db_table = "author"
        # 指定查询结果以create_time字段降序排列，然后以age字段升序排列
        ordering = ["-create_time", "age"]
</code></pre>
<h2 id="四、模型中的关联关系">四、模型中的关联关系</h2>
<h3 id="1-一对多">1. 一对多</h3>
<p>在一对多的关系中，需要使用<code>models.ForeignKey</code>在表示“多”的模型中定义一个外键字段，定义时需要指定表示“一”的模型类名。<code>models.ForeignKey</code>常用参数：</p>
<ul>
<li>
<code>to</code>：该属性的第一个参数，表示外键指向的模型类的类名。如果外键指向的模型类在另一个app中，则不用从另一个app中导入该模型类，直接使用<code>app名称.模型类名</code>的格式即可。如果外键指向的模型类为自身（是存在这种情况的），则除了可以使用模型类名外，还可以使用<code>self</code>。</li>
<li>
<code>on_delete</code>：表示外键指向的数据不存在时，本条数据该如何处理。可以指定的处理类型如下：
<ul>
<li>
<code>CASCADE</code>：级联操作，如果外键对应的在另一张表中的数据被删除了，那么本条数据也会被跟着删除。</li>
<li>
<code>PROTECT</code>：外键数据受保护，即只要本条数据还存在，则外键对应的在另一张表中的数据是无法被删除的。</li>
<li>
<code>SET_NULL</code>：删除时设置为空，如果外键对应的在另一张表中的数据被删除了，那么本条数据中的这个外键值就设置为空。</li>
<li>
<code>SET_DEFUALT</code>：设置为默认值，如果外键对应的在另一张表中的数据被删除了，那么本条数据中的这个外键值就设置为指定的默认值，但前提是此字段有指定的默认值。</li>
<li>
<code>SET(obj/func)</code>：设置默认值，如果外键对应的在另一张表中的数据被删除了，那么本条数据中的这个外键值就设置为指定的值<code>obj</code>或者指定函数或方法<code>func</code>的返回值。</li>
<li>
<code>DO_NOTHING</code>：不做任何操作，一切只看数据库本身的约束。</li>
</ul>
</li>
<li>
<code>related_name</code>：使用<code>models.ForeignKey</code>再表示“多”的模型中定义外键后，Django会在表示“一”的模型中自动生成一个<code>表示“多”的模型类名_set</code>属性，如果不想使用这种默认的命名方式，就可以使用此参数指定自己需要的名称了。</li>
</ul>
<p>示例：创建“分类”模型和“文章”模型表示一对多关系，即一个分类下可以有多篇文章，此时就需要在“文章”模型中定义一个外键。</p>
<pre><code class="language-python">"""models.py"""
from django.db import models


class Category(models.Model):
    """此模型用于存储：文章分类的名称"""
    name = models.CharField(max_length=100)
    
    
class Article(models.Model):
    """此模型用于存储：文章信息"""
    title = models.CharField(max_length=100)
    content = models.TextField()
    # 定义一个外键：指向Category模型，采用级联删除（相应分类被删除的话，本文章也会被删除）
    category = models.ForeignKey("Category", on_delete=models.CASCADE)
    # 如果引用的外键在另一个app中，则不用导入相关模型类，直接使用“app名称.模型类名”即可
    author = models.ForeignKey("frontuser.FrontUser", on_delete=models.CASCADE, null=True)
</code></pre>
<pre><code class="language-python">"""views.py"""
from django.http import HttpResponse
from .models import Category, Article


def index(request):
    # ORM模型中不会自动调用save()方法，所有实例化的对象如果还未保存在数据库中，都需要调用一次save()方法。
    category = Category(name="python")
    category.save()
    
    article = Article(title="Python基础", content="列表、元组、字典类型详解……")
    # 可以直接将外键对象赋给对应的外键属性即可
    article.category = category
    article.save()
    
    category = Category.objects.first()
    article = Article.objects.first()
    
    # 如果想要使用外键对象的属性，也可以通过article.category.name的方式直接访问
    print(article.category.name)
    
    # 定义了外键之后，会在外键对应的模型中自动生成一个“模型类名_set”的属性，也可以使用related_name参数进行自定义
    # 例如此处的article_set表示该category下的所有article对象集合
    articles = category.article_set.all()
    
    return HttpResponse("success!")
</code></pre>
<h3 id="2-一对一">2. 一对一</h3>
<p>在其中一个模型中使用<code>models.OneToOneField</code>指定即可，定义方法和参数使用与<code>models.ForeignKey</code>类似（因为<code>models.OneToOneField</code>就是通过<code>models.ForeignKey</code>来实现的，只不过是添加了一个“唯一”的约束），不同之处在于，在另一个外键对应的模型中自动生成的属性为类名的小写形式，当然，你不想用默认生成的属性，也可以通过<code>related_name</code>参数来指定。</p>
<h3 id="3-多对多">3. 多对多</h3>
<p>在其中一个模型中使用<code>models.ManyToManyField</code>指定即可（定义多对多关系时，Django会在数据库中自动生成一个关联两张表的中间表，但是在Django中不用我们自己去定义），同样的，也会在另一个模型中自动生成一个形如<code>类名_set</code>的属性。</p>
<h2 id="五、查询操作">五、查询操作</h2>
<h3 id="1-查询条件表达式">1. 查询条件表达式</h3>
<p>Django中的ORM查询操作，通常使用<code>filter</code>（返回值为<code>QuerySet</code>对象）、<code>exclude</code>和<code>get</code>（返回值为实例对象）等方法来实现，查询时使用形如<code>Field__Condition</code>，用双下划线将查询字段和条件表达式分隔。如果字段<code>Field</code>涉及到其他引用，也是使用双下划线分隔即可，不能使用点号<code>.</code>来表达。查询条件如果有多个，也是使用使用双下划线分隔。见具体示例。<br>
常用的查询条件：</p>
<ul>
<li>
<code>exact</code>：SQL中的等号<code>=</code>，提供精确的查询条件，如果提供的是一个None，则对应于数据库中的<code>null</code>。</li>
</ul>
<pre><code class="language-python">article = Article.objects.get(id__exact=14)
# 等价于
article = Article.objects.get(id=14)  # 这种方式更常用
</code></pre>
<ul>
<li>
<code>iexact</code>：SQL中的<code>LIKE</code>，因为转换为SQL后Django并不会在判断条件中添加通配符，所以大部分情况下其实是和<code>exact</code>是等价的。</li>
</ul>
<pre><code class="language-python">article = Article.objects.filter(title__iexact="hello")
# 转换为SQL后就是：... WHERE "article"."title" LIKE hello 
# 虽然LIKE具有模糊查找的功能，但是因为Django并没有自动添加通配符，
# 所以转换之后的SQL就相当于是精确匹配了，与使用等号是一致的
</code></pre>
<ul>
<li>
<code>contains</code>：SQL中的<code>LIKE BINARY %xxx%</code>，判断某个字符串是否被包含在指定字段中，区分大小写。如<code>articles = Article.objects.filter(title__contains="hello")</code>。</li>
<li>
<code>icontains</code>：与<code>contains</code>用法类似，区别是SQL中少了<code>BINARY</code>，即不区分大小写。</li>
<li>
<code>in</code>：SQL中的<code>in</code>，判断某个字段是否在指定的容器中，这个容器可以是列表、元组或其他可迭代对象，包括<code>QuerySet</code>对象。</li>
</ul>
<pre><code class="language-python">articles = Article.objects.filter(id__in=[1, 2, 3])
# 相当于：SELECT ... WHERE id IN (1, 2, 3)
</code></pre>
<ul>
<li>
<code>gt/gte/lt/lte</code>：大于、大于等于、小于、小于等于。</li>
<li>
<code>startswith</code>：SQL中的<code>... LIKE BINARY xxx%</code>，判断某个字段值是否以指定字符串开头，大小写敏感。</li>
<li>
<code>istartswith</code>：与<code>startswith</code>用法类似，区别是SQL中少了<code>BINARY</code>，即不区分大小写。</li>
<li>
<code>endswith</code>：SQL中的<code>... LIKE BINARY %xxx</code>，判断某个字段值是否以指定字符串结尾，大小写敏感。</li>
<li>
<code>iendswith</code>：与<code>endswith</code>用法类似，区别是SQL中少了<code>BINARY</code>，即不区分大小写。</li>
<li>
<code>range</code>：判断字段是否在指定时间范围之内。</li>
</ul>
<pre><code class="language-python">from datetime import datetime
form django.utils.timezone import make_aware

# make_aware会根据Django中TIME_ZONE设置的时区信息将一个navie类型的时间（不包含时区信息）转换为aware类型的时间（包含时区信息）
start_time = make_aware(datetime(year=2020, month=10, day=12, hour=21, minute=0, second=0))
end_time = make_aware(datetime(year=2020, month=10, day=12, hour=21, minute=0, second=0))
articles = Articles.objects.filter(create_time__range=(start_time, end_time))
</code></pre>
<ul>
<li>
<code>date</code>：根据年月日信息查找数据，可以传入<code>datetime.date</code>类型或<code>datetime.datetime</code>类型的参数。如<code>articles = Article.objects.filter(create_time__date=dateime(year=2020, month=10, day=12))</code>。</li>
<li>
<code>year</code>：根据年份查找数据。</li>
<li>
<code>month</code>：根据月份查找数据。</li>
<li>
<code>day</code>：根据天数查找数据。</li>
<li>
<code>week_day</code>：根据星期查找数据，注意，1表示星期天，7表示星期六。</li>
<li>
<code>time</code>：根据时分秒查找数据，可以传入<code>datetime.time</code>类型的参数，如果要精确到秒最好使用<code>range</code>条件一起判断一个范围，因为数据库中的秒可能有“小数”，即毫秒。</li>
<li>
<code>isnull</code>：根据字段是否为空值进行查找。如<code>articles = Article.objects.filter(create_time__isnull=False)</code>。</li>
<li>
<code>regex和iregex</code>：根据正则表达式查找数据，<code>regex</code>大小写敏感，<code>iregex</code>大小写不敏感。如<code>articles = Article.objects.filter(title__regex=r"^hello")</code>。</li>
</ul>
<h3 id="2-聚合函数">2. 聚合函数</h3>
<p>聚合函数都在<code>django.db.models</code>中，直接导入使用即可。聚合函数的执行必须放在支持聚合函数的方法中执行，如：</p>
<ul>
<li>
<code>objects.aggregate</code>：执行指定的聚合函数，返回值为字典类型，key为<code>字段名__聚合函数名</code>，value为聚合函数的执行结果。如果不想使用默认的key的命名方式，可以将自定义的命名当做关键字参数传入即可，如<code>Book.objects.aggregate(my_price=Avg("price"))</code>，此时key就是<code>my_price</code>了。</li>
<li>
<code>objects.annotate</code>：也是执行聚合函数，但是会先根据外键关系进行分组，再对分组结果执行聚合函数，返回值为<code>QuerySet</code>类型，<code>QuerySet</code>中的元素为对应数据的实例对象，聚合函数的执行结果存储在实例对象的一个新添加的属性当中，这个属性的命名也是可以通过关键字参数来指定。</li>
</ul>
<pre><code class="language-python"># 模型Book表示每一种书的信息，如作者
# 模型BookOrder表示具体每一本书的真实订单信息，如价格
# 模型BookOrder中有一个外键对应于模型Book中的主键，所以可以直接这样查询，表示查询每一种书的平均每本售卖价格
books = Book.objects.annotate(order_avg=Avg("bookorder_price"))
for book in books:
    # order_avg就是新添加的用于存储聚合函数结果的属性
    print(book.name, book.order_avg)
</code></pre>
<ul>
<li>注：这两个方法都可以传入多个聚合函数，如<code>Book.objects.aggregate(max=Max("price"), min=Min("price))</code>。</li>
</ul>
<p>常用的聚合函数：</p>
<ul>
<li>
<code>Avg</code>：求平均值。</li>
</ul>
<pre><code class="language-python">from django.db.models import Avg
# 求book模型中price字段的平均值
result = Book.objects.aggregate(Avg("price"))
</code></pre>
<ul>
<li>
<code>Count</code>：统计个数，可以指定参数<code>distinct</code>为<code>True</code>过滤重复的数据。</li>
</ul>
<pre><code class="language-python">from django.db.models import Count
# 过滤重复数据使用book_nums=Count("id", distinct=True)
result = Book.objects.aggregate(book_nums=Count("id"))
</code></pre>
<ul>
<li>
<code>Max/Min</code>：求指定字段的最大值或最小值。</li>
<li>
<code>Sum</code>：求某个字段的和。</li>
</ul>
<h3 id="3-f表达式和q表达式">3. F表达式和Q表达式</h3>
<p><code>F</code>表达式和<code>Q</code>表达式都在<code>from django.db.models import F, Q</code>中，这两种表达式都是用来优化数据库操作的，即不用这两种表达式也可以完成同样的功能，但是效率会很低。优化原理见具体示例。<br><strong>F表达式</strong><br>
当涉及到的数据过多时，如果不想直接获取模型实例来操作数据库，而是需要直接动态执行SQL的时候，就可以考虑<code>F</code>表达式。通常我们的数据库操作是先获取到对应的模型实例，然后操作模型实例，如果有修改则执行对应的<code>save</code>等方法，相当于是先把数据库中的结果加载到内存中，然后有修改的话再映射回数据库。而<code>F</code>表达式并不会马上去执行对应的数据库操作，而是在触发具体执行的方法的时候再将这个表达式的条件添加上去一起执行。具体见示例：</p>
<pre><code class="language-python">from django.db.models import F

# 下面两个例子如果不使用F表达式，可能需要先使用xxx.objects.all()的方式获取全部实例对象，然后再对每个实例进行相应的修改操作，如此的话，每修改一次实例对象就会执行一次SQL

# 参数price表示要修改的字段，F表达式中的price表示要使用的字段
# 在book模型中给所有数据的price字段增加10，此处就只会执行一次SQL
Book.objects.update(price=F("price")+10)

# 查找出所有用户名和邮箱一样的用户，此处也是只会执行一次SQL
authors = Author.objects.filter(name=F("email"))
</code></pre>
<p><strong>Q表达式</strong><br>
通过<code>objects.filter</code>传入多个条件参数时，多个条件之间默认为“与”的关系，如果想要变成“或”、“非”等其他关系，就可以使用<code>Q</code>表达式。<code>Q</code>表达式可以使用<code>&amp;</code>（<code>AND</code>）、<code>|</code>（<code>OR</code>）、<code>~</code>（<code>NOT</code>）等运算符。</p>
<pre><code class="language-python"># 不使用Q表达式，则默认多个条件之间是“与”的关系
books = Book.objects.filter(price_gte=100, rating_gte=9)

# 使用Q表达式，将多个条件之间使用“或”的关系进行过滤
from django.db.models import Q
books = Book.objects.filter(Q(price_gte=100) | Q(rating_gte=9))
</code></pre>
<h2 id="六、queryset-api">六、QuerySet API</h2>
<p>对于模型类的<code>objects</code>属性，如<code>Book.objects</code>，根据它的源码可以看出，它其实是一个“空壳”类，它的所有方法都拷贝自<code>QuerySet</code>类，所以<code>QuerySet</code>类可以使用的方法，在<code>objects</code>上也可以直接调用。<br>
以下是一些常用的方法：</p>
<ul>
<li>
<code>filter</code>：根据传入的过滤条件查询数据。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
<li>
<code>exclude</code>：排除满足条件的数据。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
<li>
<code>annotate</code>：给<code>QuerySet</code>中的每个对象在执行SQL时添加上一个查询表达式（聚合函数、<code>F</code>表达式、<code>Q</code>表达式、Func表达式等），表达式的查询结果会以新字段的方式添加到结果对象中。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
<li>
<code>order_by</code>：将查询的结果按照指定规则进行排序，默认升序排列，如果要降序排列，在对应字段前添加一个负号<code>-</code>即可，如果传入多个字段参数，则按传入字段的先后顺序进行排序。如果使用了多个<code>order_by</code>方法，则只会根据最后一个<code>order_by</code>方法来进行排序，如<code>objects.order_by(xxx).order_by(xxx)</code>。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
</ul>
<pre><code class="language-python"># 升序排列
articles = Article.objects.order_by("create_time")
# 降序排列
articles = Article.objects.order_by("-create_time")
</code></pre>
<ul>
<li>
<code>values</code>：指定提取哪些字段，如果不传入任何参数，则会返回所有的字段，也可以使用聚合函数形成新的字段名。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是字典。</li>
</ul>
<pre><code class="language-python"># 只提取id和name两个字段
books = Book.objects.values("id", "name")
for book in books:
    print(book)  # 打印结果形如{"id": 1, "name": "xxx"}
    
# 如果想要给提取出来的字段命名，使用关键字参数传入`F`表达式即可，如`values("book_id"=F("id"), "book_name"=F("name"))`，但是自定义的名称不能和模型上已经有的字段名称相同。
# 使用F表达式自定义字段名，以及使用聚合函数形成新的字段
books = Book.objects.values("id", book_name=F("name"), order_nums=Count("bookorder"))
</code></pre>
<ul>
<li>
<code>values_list</code>：类似<code>values</code>。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是字段的值的元组。</li>
<li>
<code>all</code>：返回模型对应的所有数据。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
<li>
<code>select_related</code>：在具有关联关系的模型中，用于<code>多对一</code>和<code>一对一</code>关系的<code>多</code>这一端的模型去关联<code>一</code>这一端的模型，即传入的关联模型只能是本模型中定义的外键模型。可以传入多个关联模型，即一个表中有多个外键。使用这个方法只会产生一次查询，可以优化查询效率。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。示例：</li>
</ul>
<pre><code class="language-python"># 关联关系：一个作者可以有多本书，外键定义在Book模型中
books = Book.objects.all()  # 这里会执行一次SQL查询
for book in books:
    print(book.author.name)  # 打印关联模型Author中的name属性时每次遍历都会执行一次SQL查询
    
# 使用关联查询后，会一次性将Book和Author模型中的字段都查询出来
books = Book.objects.select_related("author")
</code></pre>
<ul>
<li>
<code>prefetch_related</code>：类似<code>select_related</code>，用于<code>多对多</code>和<code>一对多</code>关系中获取<code>多</code>那一端的数据（当然，在使用外键关系关联的模型中，也是可以使用这个方法获取的，但是外键关联关系还是建议使用<code>select_related</code>，因为它只会产生一次查询，而这个方法会产生两次查询）。这个方法会产生两次查询，当然，“两次查询”也是优化查询效率的解决方案。注意，如果对查询结果再进行过滤的话，“两次查询”的优化就没了，还是会执行多次查询，这时候想要将查询和过滤一起执行的话，可以使用<code>Prefetch</code>，并传入<code>queryset</code>过滤调用即可。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。示例：</li>
</ul>
<pre><code class="language-python"># Book模型表示每种书的信息
# BookOrder模型表示每一本书的真实订单信息

# 以下代码还是会执行多次查询
# 查询每一种书的具体订单信息
books = Book.objects.prefetch_related("bookorder_set")
for book in books:
    # 因为这里又使用filter方法过滤price大于等于90的条件，
    # 所以还是会在这里“遍历一次查询一次”
    orders = book.bookorder_set.filter(price_gte=90)
    for order in orders:
        print(order.id)
        
        
# 使用Prefetch后，就只会执行两次查询了
prefetch = Prefetch("bookorder_set", queyset=BookOrder.objects.filter(price_gte=90))
# 只会在这里产生两次查询，之后的遍历都不会产生查询了
books = Book.objects.prefetch_related(prefetch)
for book in books:
    # 注意这里就不能在调用filter了，不然还是会产生多次查询
    orders = book.bookorder_set.all()
    for order in orders:
        print(order.id)
</code></pre>
<ul>
<li>
<code>defer</code>：排除指定字段。如<code>Book.objects.defer("name)</code>提取出来的模型就没有<code>name</code>这个字段了。注意不能排除主键。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
<li>
<code>only</code>：与<code>defer</code>相反，只提取指定字段，同样的，主键是默认提取的。返回值为<code>QuerySet</code>对象，<code>QuerySet</code>中存储的是模型对象。</li>
<li>
<code>get</code>：获取一条数据，注意如果查询到了多条数据就会报错，只能提取一条数据。返回值为模型对象。如<code>Book.objects.get(id=1)</code>是可以的，但是<code>Book.objects.get(id__gte=1)</code>查询<code>id</code>大于等于1的数据不只一条了，这就不可以了。</li>
<li>
<code>create</code>：创建一条数据并存入数据库中，相当于<code>book = Book(title="xxx", ...);book.save()</code>两个语句的合并。</li>
<li>
<code>get_or_create</code>：获取一条数据，如果在数据库中不存在，则会在数据库中创建并返回，返回值为两个元素的元组，第一个元素为模型对象，第二个元素为<code>True/False</code>，如果获取的数据在数据库中存在，则为<code>False</code>，否则创建对应数据存入数据库并返回此值为<code>True</code>。</li>
<li>
<code>bulk_create</code>：一次性创建多条数据，传入一个列表，列表中为需要创建的模型对象。优点在于只会执行一次SQL。</li>
<li>
<code>count</code>：获取提取的数据的条数，底层SQL使用的是<code>slect count(*)</code>的方式来实现的，虽然使用如<code>len(articles)</code>的方式也能获取到数据条数，但是<code>count</code>方法会更高效。</li>
<li>
<code>first</code>：返回<code>QuerySet</code>中的第一条数据。</li>
<li>
<code>last</code>：返回<code>QuerySet</code>中的最后一条数据。</li>
<li>
<code>aggregate</code>：用于执行聚合函数。</li>
<li>
<code>exists</code>：判断某个条件的数据是否存在，如<code>Book.objects.filter(title="xxx").exists()</code>。</li>
<li>
<code>distinct</code>：去除重复的数据。注意，此方法判断的是一条数据的全部字段。</li>
<li>
<code>update</code>：批量更新数据，如<code>Book.objects.update(price=F("price")+10)</code>。</li>
<li>
<code>delete</code>：批量删除满足条件的数据，删除时要注意是否会影响到其他表（使用<code>on_delete</code>参数指定的级联操作关系）。</li>
<li>切片操作：<code>QueySet</code>对象还支持切片操作，如<code>books = Book.objects.all()[1:3]</code>。</li>
</ul>
<p>以下情况Django会将<code>QuerySet</code>对象转换为SQL去执行（某个Python语句执行之后是否触发了SQL的执行，打印<code>connection.queries</code>就可以看到了）：</p>
<ul>
<li>迭代：在遍历<code>QuerySet</code>对象的时候，会先执行这个SQL，再对SQL结果进行遍历。</li>
<li>切片时使用了步长：切片操作本身并不会执行SQL，但是切片时如果提供了步长，就会立即执行SQL。</li>
<li>调用<code>len</code>函数：调用<code>len</code>函数获取<code>QuerySet</code>对象中的数据条数时，也会执行SQL。</li>
<li>调用<code>list</code>：调用<code>list</code>函数将<code>QuerySet</code>对象转换为<code>list</code>对象时，也会执行SQL。</li>
<li>判断：对<code>QuerySet</code>对象进行判断时，也会执行SQL对象。</li>
</ul>
<p><strong>注：</strong>本文为学习笔记，发现错误欢迎指出。</p>

        
                                                                                                        
                                                </div></span>                                     
		    	</div>
		    	<div class="panel-title"><i class="fa fa fa-file-text fa-fw"></i>代码注释</div>
			    <div class="panel-content">
			    <span>[!--zhushi--]</span>                                     
		    	</div>

			</div>

			<!-- END ROW -->
			<div class="newsPage">
				<div class="newsPageTurn">
				    <span><a>上一篇</a><a href='/python/biji/213.html'>函数递归</a><a>下一篇</a><a href='/python/biji/215.html'>SQLAlchemy使用</a></span>
				</div>
			</div>
		</div>


<div id="author-box">
    <h3>作者：喵哥笔记</h3>
        <div class="author-info">
            <div class="author-avatar">
                <img src="/skin1/picture/01.jpg" alt="IDC笔记" class="avatar" width="64" height="64">
            </div>
        <div class="author-description">
            <p>学的不仅是技术，更是梦想！</p>
            <ul class="author-social follows nb">
            	<li>
                    <a target="_blank" href="/" title="IDC笔记">IDC笔记</a>
                </li>
            </ul>
        </div>
        <div class="clear"></div>
    </div>
</div>

<!-- container-fluid -->
	</div>
<!-- content -->
	<footer class="footer">
	© 2020 IDC笔记 <i class="mdi mdi-heart text-danger"></i>. | 备案号：<a href="https://beian.miit.gov.cn/">辽ICP备18000516号</a>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?674585fbbd2294d3faf910f668ea91b4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

	</footer>
</div>

</div>
<!-- END wrapper -->
<!-- jQuery  -->
<script src="/skin1/js/jquery.min.js"></script>
<script src="/skin1/js/bootstrap.bundle.min.js"></script>
<script src="/skin1/js/metismenu.min.js"></script>
<script src="/skin1/js/jquery.slimscroll.js"></script>
<script src="/skin1/js/waves.min.js"></script>
<!--Morris Chart-->
<script src="/skin1/js/morris.min.js"></script>
<script src="/skin1/js/raphael.min.js"></script>
<script src="/skin1/js/dashboard.init.js"></script>
<script src="/skin1/js/app.js"></script>
<script src="/foot.js"></script>
</body>
</html>